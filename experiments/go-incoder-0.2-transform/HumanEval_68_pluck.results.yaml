language: go_test.go
name: HumanEval_68_pluck
results:
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    sort.Ints(arr)\n    var result []int\n    var index int\n    var smalest_value\
    \ int\n    for _, v := range arr {\n        if v%2 == 0 {\n            if smalest_value\
    \ == 0 {\n                smalest_value = v\n                index = -1\n    \
    \        } else {\n                if v < smalest_value {\n                  \
    \  smalest_value = v\n                    index = -1\n                } else {\n\
    \                    if index == -1 {\n                        index = v\n   \
    \                 } else {\n                        if v < index {\n         \
    \                   index = v\n                        }\n                   \
    \ }\n                }\n            }\n        }\n    }\n    if index == -1 {\n\
    \        result = make([]int, 0)\n    } else {\n        result = append(result,\
    \ smalest_value, index)\n    }\n    return result\n}\n`\n\nfunc TestPluck(t *testing.T)\
    \ {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpu_36htyl_test.go:66:1: raw string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074607
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    // write your code here\n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    func TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp9iau7tlr_test.go:289:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074607
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    sort.Ints(arr)\n    smalest_value := arr[0]\n    smalest_index := 0\n\
    \    for _, value := range arr {\n        if value%2 == 0 {\n            if value\
    \ < smalest_value {\n                smalest_value = value\n                smalest_index\
    \ = sort.Search(len(arr), func(i int) bool {\n                    return arr[i]\
    \ < value\n                })\n            }\n        }\n    }\n    return []int{smalest_value,\
    \ smalest_index}\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6cjw7rsb_test.go:34:5: undefined: sort

    /tmp/tmp6cjw7rsb_test.go:41:33: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074608
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    sort.Sort(sort.Reverse(sort.IntSlice(arr)))\n    index := 0\n    smalest_value\
    \ := arr[0]\n    smalest_index := 0\n    for _, value := range arr {\n       \
    \ if value%2 == 0 {\n            if value < smalest_value {\n                smalest_value\
    \ = value\n                smalest_index = index\n            }\n            index++\n\
    \        }\n    }\n    if smalest_index == 0 {\n        return []int{}\n    }\n\
    \    return []int{smalest_value, smalest_index}\n}\n\nfunc TestPluck(t *testing.T)\
    \ {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmplo_hqqhp_test.go:34:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074608
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    arr2 := make([]int, len(arr))\n    arr3 := make([]int, len(arr))\n  \
    \  arr4 := make([]int, len(arr))\n    arr5 := make([]int, len(arr))\n    arr6\
    \ := make([]int, len(arr))\n    arr7 := make([]int, len(arr))\n    arr8 := make([]int,\
    \ len(arr))\n    arr9 := make([]int, len(arr))\n    arr10 := make([]int, len(arr))\n\
    \    arr11 := make([]int, len(arr))\n    arr12 := make([]int, len(arr))\n    arr13\
    \ := make([]int, len(arr))\n    arr14 := make([]int, len(arr))\n    arr15 := make([]int,\
    \ len(arr))\n    arr16 := make([]int, len(arr))\n    arr17 := make([]int, len(arr))\n\
    \    arr18 := make([]int, len(arr))\n    arr19 := make([]int, len(arr))\n    arr20\
    \ := make([]int, len(arr))\n    arr21 := make([]int, len(arr))\n    arr22 := make([]int,\
    \ len(arr))\n    arr23 := make([]int, len(arr))\n    arr24 := make([]int, len(arr))\n\
    \    arr25 := make([]int, len(arr))\n    arr26 := make([]int, len(arr))\n    arr27\
    \ := make([]int, len(arr))\n    arr28 := make([]int, len(arr))\n    arr29 := make([]int,\
    \ len(arr))\n    arr30 := make([]int, len(arr))\n    arr31 := make([]int, len(arr))\n\
    \    arr32 := make([]int, len(arr))\n    arr33 := make([]int, len(arr))\n    arr34\
    \ := make([]int, len(arr))\n    arr35 := make([]int, len(arr))\n    arr36 := make([]int,\
    \ len(arr))\n    arr37 := make([]int, len(arr))\n    arr38 := make([]int, len(arr))\n\
    \    arr39 := make([]int, len(arr))\n    arr40 := make([]int, len(arr))\n    arr41\
    \ := make([]int, len(arr))\n    arr42 := make([]int, len(arr))\n    arr43 := make([]int,\
    \ len(arr))\n    arr\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpn18y7qza_test.go:77:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074607
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    result := make([]int, 0)\n    min := arr[0]\n    index := 0\n    for\
    \ _, v := range arr {\n        if v%2 == 0 {\n            if min > v {\n     \
    \           min = v\n                index = index\n            }\n        } else\
    \ {\n            if min > v {\n                min = v\n                index\
    \ = index\n            }\n        }\n    }\n    result = append(result, min)\n\
    \    result = append(result, index)\n    return result\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\npanic: runtime error: index out of range [0]\
    \ with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with\
    \ length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440, 0xc000014360})\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.pluck(...)\n\t/tmp/tmpcs680i9__test.go:35\n\
    command-line-arguments_test.TestPluck(0x0?)\n\t/tmp/tmpcs680i9__test.go:64 +0x1b0\n\
    testing.tRunner(0xc0001924e0, 0x527d38)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074609
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    result := make([]int, 0)\n    min := arr[0]\n    index := 0\n    for\
    \ _, val := range arr {\n        if val%2 == 0 {\n            if val < min {\n\
    \                min = val\n                index = index\n            }\n   \
    \     } else {\n            if min > val {\n                min = val\n      \
    \          index = index\n            }\n        }\n    }\n    result = append(result,\
    \ min)\n    result = append(result, index)\n    return result\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\npanic: runtime error: index out of range [0]\
    \ with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with\
    \ length 0\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2({0x512440, 0xc000160000})\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x512440,\
    \ 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.pluck(...)\n\t/tmp/tmpshv4416s_test.go:35\n\
    command-line-arguments_test.TestPluck(0x0?)\n\t/tmp/tmpshv4416s_test.go:64 +0x1b0\n\
    testing.tRunner(0xc000103520, 0x527d38)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074609
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    // write your code here\n    arr := arr[:0]\n    arr := append(arr, arr[0])\n\
    \    arr := append(arr, arr[1])\n    arr := append(arr, arr[2])\n    arr := append(arr,\
    \ arr[3])\n    arr := append(arr, arr[4])\n    arr := append(arr, arr[5])\n  \
    \  arr := append(arr, arr[6])\n    arr := append(arr, arr[7])\n    arr := append(arr,\
    \ arr[8])\n    arr := append(arr, arr[9])\n    arr := append(arr, arr[10])\n \
    \   arr := append(arr, arr[11])\n    arr := append(arr, arr[12])\n    arr := append(arr,\
    \ arr[13])\n    arr := append(arr, arr[14])\n    arr := append(arr, arr[15])\n\
    \    arr := append(arr, arr[16])\n    arr := append(arr, arr[17])\n    arr :=\
    \ append(arr, arr[18])\n    arr := append(arr, arr[19])\n    arr := append(arr,\
    \ arr[20])\n    arr := append(arr, arr[21])\n    arr := append(arr, arr[22])\n\
    \    arr := append(arr, arr[23])\n    arr := append(arr, arr[24])\n    arr :=\
    \ append(arr, arr[25])\n    arr := append(arr, arr[26])\n    arr := append(arr,\
    \ arr[27])\n    arr := append(arr, arr[28])\n    arr := append(arr, arr[29])\n\
    \    arr := append(arr, arr[30])\n    arr := append(arr, arr[31])\n    arr :=\
    \ append(arr, arr[32])\n    arr := append(arr, arr[33])\n    arr := append(arr,\
    \ arr[34])\n    arr := append(arr, arr[35])\n    arr := append(arr, arr[36])\n\
    \    arr := append(arr, arr[37])\n    arr := append(arr, arr[38])\n    arr :=\
    \ append(arr, arr[39])\n    arr := append(arr, arr[40])\n    arr := append(arr,\
    \ arr[41])\n    arr := append(arr, arr[42])\n    arr := append(arr, arr[43])\n\
    \    arr := append(arr, arr[44])\n    arr := append(arr, arr[45])\n    arr :=\
    \ append(arr, arr[46])\n    arr := append(arr, arr[47])\n    arr := append(arr,\
    \ arr[48])\n    arr := append(arr, arr[49])\n    arr := \nfunc TestPluck(t *testing.T)\
    \ {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpsz0d0uc3_test.go:87:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074607
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    n := len(arr)\n    result := make([]int, n)\n    min := arr[0]\n    index\
    \ := 0\n    for i := 0; i < n; i++ {\n        if arr[i] < min {\n            min\
    \ = arr[i]\n            index = i\n        }\n    }\n    result[index] = min\n\
    \    return result\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\npanic: runtime error: index out of range [0]\
    \ with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with\
    \ length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440, 0xc000014390})\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x512440,\
    \ 0xc000014390})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.pluck(...)\n\t/tmp/tmpzhouzz99_test.go:36\n\
    command-line-arguments_test.TestPluck(0x0?)\n\t/tmp/tmpzhouzz99_test.go:57 +0x135\n\
    testing.tRunner(0xc0001924e0, 0x527d38)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074609
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    arr2 := make([]int, len(arr))\n    arr3 := make([]int, len(arr))\n  \
    \  arr4 := make([]int, len(arr))\n    arr5 := make([]int, len(arr))\n    arr6\
    \ := make([]int, len(arr))\n    arr7 := make([]int, len(arr))\n    arr8 := make([]int,\
    \ len(arr))\n    arr9 := make([]int, len(arr))\n    arr10 := make([]int, len(arr))\n\
    \    arr11 := make([]int, len(arr))\n    arr12 := make([]int, len(arr))\n    arr13\
    \ := make([]int, len(arr))\n    arr14 := make([]int, len(arr))\n    arr15 := make([]int,\
    \ len(arr))\n    arr16 := make([]int, len(arr))\n    arr17 := make([]int, len(arr))\n\
    \    arr18 := make([]int, len(arr))\n    arr19 := make([]int, len(arr))\n    arr20\
    \ := make([]int, len(arr))\n    arr21 := make([]int, len(arr))\n    arr22 := make([]int,\
    \ len(arr))\n    arr23 := make([]int, len(arr))\n    arr24 := make([]int, len(arr))\n\
    \    arr25 := make([]int, len(arr))\n    arr26 := make([]int, len(arr))\n    arr27\
    \ := make([]int, len(arr))\n    arr28 := make([]int, len(arr))\n    arr29 := make([]int,\
    \ len(arr))\n    arr30 := make([]int, len(arr))\n    arr31 := make([]int, len(arr))\n\
    \    arr32 := make([]int, len(arr))\n    arr33 := make([]int, len(arr))\n    arr34\
    \ := make([]int, len(arr))\n    arr35 := make([]int, len(arr))\n    arr36 := make([]int,\
    \ len(arr))\n    arr37 := make([]int, len(arr))\n    arr38 := make([]int, len(arr))\n\
    \    arr39 := make([]int, len(arr))\n    arr40 := make([]int, len(arr))\n    arr41\
    \ := make([]int, len(arr))\n    arr42 := make([]int, len(arr))\n    arr43 := make([]int,\
    \ len(arr))\n    arr\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpn18y7qza_test.go:77:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074607
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    result := make([]int, 0)\n    min := arr[0]\n    index := 0\n    for\
    \ _, v := range arr {\n        if v%2 == 0 {\n            if min > v {\n     \
    \           min = v\n                index = index\n            }\n        } else\
    \ {\n            if min > v {\n                min = v\n                index\
    \ = index\n            }\n        }\n    }\n    result = append(result, min)\n\
    \    result = append(result, index)\n    return result\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\npanic: runtime error: index out of range [0]\
    \ with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with\
    \ length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440, 0xc000014360})\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.pluck(...)\n\t/tmp/tmpcs680i9__test.go:35\n\
    command-line-arguments_test.TestPluck(0x0?)\n\t/tmp/tmpcs680i9__test.go:64 +0x1b0\n\
    testing.tRunner(0xc0001924e0, 0x527d38)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074609
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var result []int\n    var minVal int\n    var minIndex int\n    for _,\
    \ v := range arr {\n        if v%2 == 0 {\n            if minVal == 0 || v < minVal\
    \ {\n                minVal = v\n                minIndex = -1\n            }\n\
    \        } else {\n            if minVal == 0 || v > minVal {\n              \
    \  minVal = v\n                minIndex = -1\n            }\n        }\n    }\n\
    \    if minVal == 0 {\n        return []int{}\n    }\n    result = append(result,\
    \ minVal)\n    if minIndex == -1 {\n        return result\n    }\n    for i :=\
    \ 0; i < len(arr); i++ {\n        if arr[i] == minVal {\n            result =\
    \ append(result, minIndex)\n        }\n    }\n    return result\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__0 (0.00s)\n\
    \        tmpbmsfzkjd_test.go:85: expected '[%!s(int=2) %!s(int=1)]', got '[%!s(int=3)]'\n\
    \    --- FAIL: TestPluck/test_num__1 (0.00s)\n        tmpbmsfzkjd_test.go:85:\
    \ expected '[%!s(int=2) %!s(int=1)]', got '[%!s(int=3)]'\n    --- FAIL: TestPluck/test_num__3\
    \ (0.00s)\n        tmpbmsfzkjd_test.go:85: expected '[%!s(int=0) %!s(int=1)]',\
    \ got '[%!s(int=2)]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmpbmsfzkjd_test.go:85:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[%!s(int=5)]'\n    --- FAIL: TestPluck/test_num__5\
    \ (0.00s)\n        tmpbmsfzkjd_test.go:85: expected '[%!s(int=4) %!s(int=1)]',\
    \ got '[%!s(int=4)]'\n    --- FAIL: TestPluck/test_num__6 (0.00s)\n        tmpbmsfzkjd_test.go:85:\
    \ expected '[%!s(int=6) %!s(int=1)]', got '[%!s(int=7)]'\n    --- FAIL: TestPluck/test_num__7\
    \ (0.00s)\n        tmpbmsfzkjd_test.go:85: expected '[]', got '[%!s(int=9)]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074609
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    result := make([]int, 0)\n    min := arr[0]\n    index := 0\n    for\
    \ _, v := range arr {\n        if v%2 == 0 {\n            if v < min {\n     \
    \           min = v\n                index = index\n            }\n        } else\
    \ {\n            if min > v {\n                min = v\n                index\
    \ = index\n            }\n        }\n    }\n    result = append(result, min)\n\
    \    result = append(result, index)\n    return result\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\npanic: runtime error: index out of range [0]\
    \ with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with\
    \ length 0\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2({0x512440, 0xc0001c4000})\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x512440,\
    \ 0xc0001c4000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.pluck(...)\n\t/tmp/tmpgiivhosk_test.go:35\n\
    command-line-arguments_test.TestPluck(0x0?)\n\t/tmp/tmpgiivhosk_test.go:64 +0x1b0\n\
    testing.tRunner(0xc0001851e0, 0x527d38)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074609
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    // write your code here\n    sort.Ints(arr)\n    arr2 := make([]int,\
    \ len(arr))\n    i := 0\n    for _, v := range arr {\n        if v%2 == 0 {\n\
    \            arr2[i] = v\n            i++\n        }\n    }\n    return arr2\n\
    }\n`\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpgbq2er2n_test.go:46:1: raw string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074607
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    smalest_value\
    \ := arr[0]\n    smalest_index := 0\n    for i := 1; i < len(arr); i++ {\n   \
    \     if arr[i] < smalest_value {\n            smalest_value = arr[i]\n      \
    \      smalest_index = i\n        }\n    }\n    return []int{smalest_value, smalest_index}\n\
    }\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__1 (0.00s)\n\
    \        tmprjboyjzq_test.go:68: expected '[%!s(int=2) %!s(int=1)]', got '[%!s(int=1)\
    \ %!s(int=0)]'\n    --- FAIL: TestPluck/test_num__6 (0.00s)\n        tmprjboyjzq_test.go:68:\
    \ expected '[%!s(int=6) %!s(int=1)]', got '[%!s(int=1) %!s(int=3)]'\n    --- FAIL:\
    \ TestPluck/test_num__7 (0.00s)\n        tmprjboyjzq_test.go:68: expected '[]',\
    \ got '[%!s(int=1) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074609
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    sort.Ints(arr)\n    index := 0\n    smalest_value := arr[0]\n    smalest_index\
    \ := 0\n    for _, value := range arr {\n        if value%2 == 0 {\n         \
    \   if value < smalest_value {\n                smalest_value = value\n      \
    \          smalest_index = index\n            }\n            index++\n       \
    \ }\n    }\n    return []int{smalest_value, smalest_index}\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4tb_t0mh_test.go:34:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074608
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    arr2 := make([]int, len(arr))\n    min := arr[0]\n    index := 0\n  \
    \  for i := 0; i < len(arr); i++ {\n        if arr[i] < min {\n            min\
    \ = arr[i]\n            index = i\n        }\n    }\n    arr2[index] = min\n \
    \   return arr2\n}\n`\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmplfe9wumk_test.go:46:1: raw string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074607
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    // write your code here\n    arr2 := make([]int, len(arr))\n    arr3\
    \ := make([]int, len(arr))\n    arr4 := make([]int, len(arr))\n    arr5 := make([]int,\
    \ len(arr))\n    arr6 := make([]int, len(arr))\n    arr7 := make([]int, len(arr))\n\
    \    arr8 := make([]int, len(arr))\n    arr9 := make([]int, len(arr))\n    arr10\
    \ := make([]int, len(arr))\n    arr11 := make([]int, len(arr))\n    arr12 := make([]int,\
    \ len(arr))\n    arr13 := make([]int, len(arr))\n    arr14 := make([]int, len(arr))\n\
    \    arr15 := make([]int, len(arr))\n    arr16 := make([]int, len(arr))\n    arr17\
    \ := make([]int, len(arr))\n    arr18 := make([]int, len(arr))\n    arr19 := make([]int,\
    \ len(arr))\n    arr20 := make([]int, len(arr))\n    arr21 := make([]int, len(arr))\n\
    \    arr22 := make([]int, len(arr))\n    arr23 := make([]int, len(arr))\n    arr24\
    \ := make([]int, len(arr))\n    arr25 := make([]int, len(arr))\n    arr26 := make([]int,\
    \ len(arr))\n    arr27 := make([]int, len(arr))\n    arr28 := make([]int, len(arr))\n\
    \    arr29 := make([]int, len(arr))\n    arr30 := make([]int, len(arr))\n    arr31\
    \ := make([]int, len(arr))\n    arr32 := make([]int, len(arr))\n    arr33 := make([]int,\
    \ len(arr))\n    arr34 := make([]int, len(arr))\n    arr35 := make([]int, len(arr))\n\
    \    arr36 := make([]int, len(arr))\n    arr37 := make([]int, len(arr))\n    arr38\
    \ := make([]int, len(arr))\n    arr39 := make([]int, len(arr))\n    arr40 := make([]int,\
    \ len(arr))\n    arr41 := make([]int, len(arr))\n    arr42 := make([]int, len(arr))\n\
    \    arr43 := make([]int, len(\nfunc TestPluck(t *testing.T) {\n  candidate :=\
    \ pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual:\
    \ candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual:\
    \ candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7,\
    \ 6, 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7,\
    \ 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp5dlexyft_test.go:77:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074607
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    result := make([]int, 0)\n    min := arr[0]\n    index := 0\n    for\
    \ _, v := range arr {\n        if v%2 == 0 {\n            if v < min {\n     \
    \           min = v\n                index = index\n            }\n        } else\
    \ {\n            if min == v {\n                index = index\n            }\n\
    \        }\n    }\n    result = append(result, min)\n    result = append(result,\
    \ index)\n    return result\n}\n`\n\nfunc TestPluck(t *testing.T) {\n  candidate\
    \ := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual:\
    \ candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual:\
    \ candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7,\
    \ 6, 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7,\
    \ 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpayk0n9xn_test.go:53:1: raw string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074607
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    sort.Ints(arr)\n    smalest_value := arr[0]\n    smalest_index := 0\n\
    \    for _, value := range arr {\n        if value%2 == 0 {\n            if value\
    \ < smalest_value {\n                smalest_value = value\n                smalest_index\
    \ = sort.Search(len(arr), func(i int) bool {\n                    return arr[i]\
    \ < value\n                })\n            }\n        }\n    }\n    return []int{smalest_value,\
    \ smalest_index}\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6cjw7rsb_test.go:34:5: undefined: sort

    /tmp/tmp6cjw7rsb_test.go:41:33: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074608
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    // write your code here\n    sort.Ints(arr)\n    arr2 := make([]int,\
    \ len(arr))\n    index := 0\n    for _, v := range arr {\n        if v%2 == 0\
    \ {\n            arr2[index] = v\n            index++\n        }\n    }\n    return\
    \ arr2\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n   \
    \  { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmkguyy91_test.go:35:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074608
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    min := arr[0]\n\
    \    index := 0\n    for _, v := range arr {\n        if v%2 == 0 {\n        \
    \    if min > v {\n                min = v\n                index = index\n  \
    \          }\n        } else {\n            if min > v {\n                min\
    \ = v\n                index = index\n            }\n        }\n    }\n    return\
    \ []int{min, index}\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__0 (0.00s)\n\
    \        tmpw1cuerl4_test.go:75: expected '[%!s(int=2) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=0)]'\n    --- FAIL: TestPluck/test_num__1 (0.00s)\n        tmpw1cuerl4_test.go:75:\
    \ expected '[%!s(int=2) %!s(int=1)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL:\
    \ TestPluck/test_num__3 (0.00s)\n        tmpw1cuerl4_test.go:75: expected '[%!s(int=0)\
    \ %!s(int=1)]', got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestPluck/test_num__4\
    \ (0.00s)\n        tmpw1cuerl4_test.go:75: expected '[%!s(int=0) %!s(int=3)]',\
    \ got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestPluck/test_num__5 (0.00s)\n\
    \        tmpw1cuerl4_test.go:75: expected '[%!s(int=4) %!s(int=1)]', got '[%!s(int=4)\
    \ %!s(int=0)]'\n    --- FAIL: TestPluck/test_num__6 (0.00s)\n        tmpw1cuerl4_test.go:75:\
    \ expected '[%!s(int=6) %!s(int=1)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL:\
    \ TestPluck/test_num__7 (0.00s)\n        tmpw1cuerl4_test.go:75: expected '[]',\
    \ got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\n\
    FAIL\n"
  timestamp: 1660074609
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    result := make([]int, 0)\n    min := arr[0]\n    index := 0\n    for\
    \ _, v := range arr {\n        if v%2 == 0 {\n            if min > v {\n     \
    \           min = v\n                index = index\n            }\n        } else\
    \ {\n            if min > v {\n                min = v\n                index\
    \ = index\n            }\n        }\n    }\n    result = append(result, min)\n\
    \    result = append(result, index)\n    return result\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\npanic: runtime error: index out of range [0]\
    \ with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with\
    \ length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440, 0xc000014360})\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.pluck(...)\n\t/tmp/tmpcs680i9__test.go:35\n\
    command-line-arguments_test.TestPluck(0x0?)\n\t/tmp/tmpcs680i9__test.go:64 +0x1b0\n\
    testing.tRunner(0xc0001924e0, 0x527d38)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074609
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    result := make([]int, 0)\n    min := arr[0]\n    index := 0\n    for\
    \ _, value := range arr {\n        if value%2 == 0 {\n            if value < min\
    \ {\n                min = value\n                index = index\n            }\n\
    \        } else {\n            if min == value {\n                index = index\n\
    \            }\n        }\n    }\n    result = append(result, min)\n    result\
    \ = append(result, index)\n    return result\n}\nfunc TestPluck(t *testing.T)\
    \ {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\npanic: runtime error: index out of range [0]\
    \ with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with\
    \ length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440, 0xc000014360})\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.pluck(...)\n\t/tmp/tmpojul8lhc_test.go:35\n\
    command-line-arguments_test.TestPluck(0x0?)\n\t/tmp/tmpojul8lhc_test.go:62 +0x1a5\n\
    testing.tRunner(0xc0001a01a0, 0x527d38)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074609
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    m := make(map[int]int)\n    for _, v := range arr {\n        m[v] = m[v]\
    \ + 1\n    }\n    arr2 := make([]int, 0, len(m))\n    for _, v := range m {\n\
    \        if v%2 == 0 {\n            arr2 = append(arr2, v)\n        }\n    }\n\
    \    if len(arr2) == 0 {\n        return nil\n    }\n    if len(arr2) == 1 {\n\
    \        return arr2\n    }\n    arr3 := make([]int, 0, len(arr2))\n    for _,\
    \ v := range arr2 {\n        if v%2 == 0 {\n            arr3 = append(arr3, v)\n\
    \        }\n    }\n    return arr3\n}\n`\n\nfunc TestPluck(t *testing.T) {\n \
    \ candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4, 2,\
    \ 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n  \
    \   { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n \
    \    { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n\
    \     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n  \
    \   { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     { actual:\
    \ candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmprf42xe81_test.go:58:1: raw string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074607
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    sort.Ints(arr)\n    smalest_value := arr[0]\n    smalest_index := 0\n\
    \    for i := 1; i < len(arr); i++ {\n        if arr[i] < smalest_value {\n  \
    \          smalest_value = arr[i]\n            smalest_index = i\n        }\n\
    \    }\n    return []int{smalest_value, smalest_index}\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpp_pyvtmx_test.go:34:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074608
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    sort.Sort(sort.Reverse(sort.IntSlice(arr)))\n    smalest_value := arr[0]\n\
    \    smalest_index := 0\n    for _, value := range arr {\n        if value % 2\
    \ == 0 {\n            if value < smalest_value {\n                smalest_value\
    \ = value\n                smalest_index = sort.Search(len(arr), func(i int) bool\
    \ {\n                    return arr[i] < value\n                })\n         \
    \   }\n        }\n    }\n    return []int{smalest_value, smalest_index}\n}\n\n\
    func TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxmn0mjju_test.go:34:5: undefined: sort

    /tmp/tmpxmn0mjju_test.go:41:33: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074608
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    sort.Sort(sort.Reverse(sort.IntSlice(arr)))\n    smalest_value := arr[0]\n\
    \    smalest_index := 0\n    for _, value := range arr {\n        if value%2 ==\
    \ 0 {\n            if value < smalest_value {\n                smalest_value =\
    \ value\n                smalest_index = sort.Search(len(arr), func(i int) bool\
    \ {\n                    return arr[i] < value\n                })\n         \
    \   }\n        }\n    }\n    return []int{smalest_value, smalest_index}\n}\n`\n\
    \nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpfof0pndq_test.go:49:1: raw string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074609
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return nil\n    }\n    min := arr[0]\n  \
    \  index := 0\n    for _, v := range arr {\n        if v%2 == 0 {\n          \
    \  if min > v {\n                min = v\n                index = index\n    \
    \        }\n        } else {\n            if min > v {\n                min =\
    \ v\n                index = index\n            }\n        }\n    }\n    return\
    \ []int{min, index}\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__0 (0.00s)\n\
    \        tmp1ttoeo5h_test.go:75: expected '[%!s(int=2) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=0)]'\n    --- FAIL: TestPluck/test_num__1 (0.00s)\n        tmp1ttoeo5h_test.go:75:\
    \ expected '[%!s(int=2) %!s(int=1)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL:\
    \ TestPluck/test_num__3 (0.00s)\n        tmp1ttoeo5h_test.go:75: expected '[%!s(int=0)\
    \ %!s(int=1)]', got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestPluck/test_num__4\
    \ (0.00s)\n        tmp1ttoeo5h_test.go:75: expected '[%!s(int=0) %!s(int=3)]',\
    \ got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestPluck/test_num__5 (0.00s)\n\
    \        tmp1ttoeo5h_test.go:75: expected '[%!s(int=4) %!s(int=1)]', got '[%!s(int=4)\
    \ %!s(int=0)]'\n    --- FAIL: TestPluck/test_num__6 (0.00s)\n        tmp1ttoeo5h_test.go:75:\
    \ expected '[%!s(int=6) %!s(int=1)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL:\
    \ TestPluck/test_num__7 (0.00s)\n        tmp1ttoeo5h_test.go:75: expected '[]',\
    \ got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074610
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    sort.Sort(sort.Reverse(sort.IntSlice(arr)))\n    smalest_value := arr[0]\n\
    \    smalest_index := 0\n    for i := 1; i < len(arr); i++ {\n        if arr[i]\
    \ > smalest_value {\n            smalest_value = arr[i]\n            smalest_index\
    \ = i\n        }\n    }\n    return []int{smalest_value, smalest_index}\n}\n\n\
    func TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpub0fy1le_test.go:34:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074609
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    arr := make([]int, len(arr))\n    arr[0] = arr[0]\n    arr[1] = arr[1]\n\
    \    arr[2] = arr[2]\n    arr[3] = arr[3]\n    arr[4] = arr[4]\n    arr[5] = arr[5]\n\
    \    arr[6] = arr[6]\n    arr[7] = arr[7]\n    arr[8] = arr[8]\n    arr[9] = arr[9]\n\
    \    arr[10] = arr[10]\n    arr[11] = arr[11]\n    arr[12] = arr[12]\n    arr[13]\
    \ = arr[13]\n    arr[14] = arr[14]\n    arr[15] = arr[15]\n    arr[16] = arr[16]\n\
    \    arr[17] = arr[17]\n    arr[18] = arr[18]\n    arr[19] = arr[19]\n    arr[20]\
    \ = arr[20]\n    arr[21] = arr[21]\n    arr[22] = arr[22]\n    arr[23] = arr[23]\n\
    \    arr[24] = arr[24]\n    arr[25] = arr[25]\n    arr[26] = arr[26]\n    arr[27]\
    \ = arr[27]\n    arr[28] = arr[28]\n    arr[29] = arr[29]\n    arr[30] = arr[30]\n\
    \    arr[31] = arr[31]\n    arr[32] = arr[32]\n    arr[33] = arr[33]\n    arr[34]\
    \ = arr[34]\n    arr[35] = arr[35]\n    arr[36] = arr[36]\n    arr[37] = arr[37]\n\
    \    arr[38] = arr[38]\n    arr[39] = arr[39]\n    arr[40] = arr[40]\n    arr[41]\
    \ = arr[41]\n    arr[42] = arr[42]\n    arr[43] = arr[43]\n    arr[44] = arr[44]\n\
    \    arr[45] = arr[45]\n    arr[46] = arr[46]\n    arr[47] = arr[47]\n    arr[48]\
    \ = arr[48]\n    arr[49] = arr[49]\n    arr[50] = arr[50]\n    arr[51] = arr[51]\n\
    \    arr[52] = arr[52]\n    arr[53] = arr[53]\n    arr[54] = arr[54]\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_j09nq20_test.go:91:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074609
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var result []int\n    result := make([]int, 0)\n    min := arr[0]\n \
    \   index := 0\n    for _, value := range arr {\n        if value%2 == 0 {\n \
    \           if value < min {\n                min = value\n                index\
    \ = index\n            }\n        } else {\n            if min > value {\n   \
    \             min = value\n                index = index\n            }\n    \
    \    }\n    }\n    result = append(result, min)\n    result = append(result, index)\n\
    \    return result\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphwu7phcr_test.go:35:12: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074609
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var result []int\n    var index int\n    var smallestEven int\n    var\
    \ smallestIndex int\n    for _, v := range arr {\n        if v%2 == 0 {\n    \
    \        smallestEven = v\n            smallestIndex = index\n        }\n    \
    \    index++\n    }\n    if smallestEven == 0 {\n        return nil\n    }\n \
    \   for _, v := range arr {\n        if v%2 == 0 {\n            if v < smallestEven\
    \ {\n                smallestEven = v\n                smallestIndex = index\n\
    \            }\n            index++\n        }\n    }\n    if smallestEven ==\
    \ 0 {\n        return nil\n    }\n    result = append(result, smallestEven)\n\
    \    result = append(result, smallestIndex)\n    return result\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__3 (0.00s)\n\
    \        tmp07dorlwn_test.go:85: expected '[%!s(int=0) %!s(int=1)]', got '[]'\n\
    \    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmp07dorlwn_test.go:85:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[]'\n    --- FAIL: TestPluck/test_num__5\
    \ (0.00s)\n        tmp07dorlwn_test.go:85: expected '[%!s(int=4) %!s(int=1)]',\
    \ got '[%!s(int=4) %!s(int=5)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074610
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    arr2 := make([]int, len(arr))\n    arr3 := make([]int, len(arr))\n  \
    \  arr4 := make([]int, len(arr))\n    arr5 := make([]int, len(arr))\n    arr6\
    \ := make([]int, len(arr))\n    arr7 := make([]int, len(arr))\n    arr8 := make([]int,\
    \ len(arr))\n    arr9 := make([]int, len(arr))\n    arr10 := make([]int, len(arr))\n\
    \    arr11 := make([]int, len(arr))\n    arr12 := make([]int, len(arr))\n    arr13\
    \ := make([]int, len(arr))\n    arr14 := make([]int, len(arr))\n    arr15 := make([]int,\
    \ len(arr))\n    arr16 := make([]int, len(arr))\n    arr17 := make([]int, len(arr))\n\
    \    arr18 := make([]int, len(arr))\n    arr19 := make([]int, len(arr))\n    arr20\
    \ := make([]int, len(arr))\n    arr21 := make([]int, len(arr))\n    arr22 := make([]int,\
    \ len(arr))\n    arr23 := make([]int, len(arr))\n    arr24 := make([]int, len(arr))\n\
    \    arr25 := make([]int, len(arr))\n    arr26 := make([]int, len(arr))\n    arr27\
    \ := make([]int, len(arr))\n    arr28 := make([]int, len(arr))\n    arr29 := make([]int,\
    \ len(arr))\n    arr30 := make([]int, len(arr))\n    arr31 := make([]int, len(arr))\n\
    \    arr32 := make([]int, len(arr))\n    arr33 := make([]int, len(arr))\n    arr34\
    \ := make([]int, len(arr))\n    arr35 := make([]int, len(arr))\n    arr36 := make([]int,\
    \ len(arr))\n    arr37 := make([]int, len(arr))\n    arr38 := make([]int, len(arr))\n\
    \    arr39 := make([]int, len(arr))\n    arr40 := make([]int, len(arr))\n    arr41\
    \ := make([]int, len(arr))\n    arr42 := make([]int, len(arr))\n    arr43 := make([]int,\
    \ len(arr))\n    arr\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpn18y7qza_test.go:77:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074607
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    m := make(map[int]int)\n    for _, v := range arr {\n        m[v] = m[v]\
    \ + 1\n    }\n    result := make([]int, 0, len(m))\n    for _, v := range m {\n\
    \        if v%2 == 0 {\n            result = append(result, v)\n        }\n  \
    \  }\n    if len(result) == 0 {\n        return []int{}\n    }\n    if len(result)\
    \ == 1 {\n        return result[0]\n    }\n    return result\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpj0q6q7d9_test.go:48:16: cannot use result[0] (variable of type int) as
    type []int in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074609
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    sort.Ints(arr)\n    smalest_value := arr[0]\n    smalest_index := 0\n\
    \    for _, value := range arr {\n        if value%2 == 0 {\n            if value\
    \ < smalest_value {\n                smalest_value = value\n                smalest_index\
    \ = sort.Search(len(arr), func(i int) bool {\n                    return arr[i]\
    \ < value\n                })\n            }\n        }\n    }\n    return []int{smalest_value,\
    \ smalest_index}\n}\n`\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpffu52ry8_test.go:49:1: raw string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074609
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    arr2 := make([]int, len(arr))\n    arr3 := make([]int, len(arr))\n  \
    \  arr4 := make([]int, len(arr))\n    arr5 := make([]int, len(arr))\n    arr6\
    \ := make([]int, len(arr))\n    arr7 := make([]int, len(arr))\n    arr8 := make([]int,\
    \ len(arr))\n    arr9 := make([]int, len(arr))\n    arr10 := make([]int, len(arr))\n\
    \    arr11 := make([]int, len(arr))\n    arr12 := make([]int, len(arr))\n    arr13\
    \ := make([]int, len(arr))\n    arr14 := make([]int, len(arr))\n    arr15 := make([]int,\
    \ len(arr))\n    arr16 := make([]int, len(arr))\n    arr17 := make([]int, len(arr))\n\
    \    arr18 := make([]int, len(arr))\n    arr19 := make([]int, len(arr))\n    arr20\
    \ := make([]int, len(arr))\n    arr21 := make([]int, len(arr))\n    arr22 := make([]int,\
    \ len(arr))\n    arr23 := make([]int, len(arr))\n    arr24 := make([]int, len(arr))\n\
    \    arr25 := make([]int, len(arr))\n    arr26 := make([]int, len(arr))\n    arr27\
    \ := make([]int, len(arr))\n    arr28 := make([]int, len(arr))\n    arr29 := make([]int,\
    \ len(arr))\n    arr30 := make([]int, len(arr))\n    arr31 := make([]int, len(arr))\n\
    \    arr32 := make([]int, len(arr))\n    arr33 := make([]int, len(arr))\n    arr34\
    \ := make([]int, len(arr))\n    arr35 := make([]int, len(arr))\n    arr36 := make([]int,\
    \ len(arr))\n    arr37 := make([]int, len(arr))\n    arr38 := make([]int, len(arr))\n\
    \    arr39 := make([]int, len(arr))\n    arr40 := make([]int, len(arr))\n    arr41\
    \ := make([]int, len(arr))\n    arr42 := make([]int, len(arr))\n    arr43 := make([]int,\
    \ len(arr))\n    arr\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpn18y7qza_test.go:77:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074607
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    arr2 := make([]int,\
    \ len(arr))\n    arr3 := make([]int, len(arr))\n    arr4 := make([]int, len(arr))\n\
    \    arr5 := make([]int, len(arr))\n    arr6 := make([]int, len(arr))\n    arr7\
    \ := make([]int, len(arr))\n    arr8 := make([]int, len(arr))\n    arr9 := make([]int,\
    \ len(arr))\n    arr10 := make([]int, len(arr))\n    arr11 := make([]int, len(arr))\n\
    \    arr12 := make([]int, len(arr))\n    arr13 := make([]int, len(arr))\n    arr14\
    \ := make([]int, len(arr))\n    arr15 := make([]int, len(arr))\n    arr16 := make([]int,\
    \ len(arr))\n    arr17 := make([]int, len(arr))\n    arr18 := make([]int, len(arr))\n\
    \    arr19 := make([]int, len(arr))\n    arr20 := make([]int, len(arr))\n    arr21\
    \ := make([]int, len(arr))\n    arr22 := make([]int, len(arr))\n    arr23 := make([]int,\
    \ len(arr))\n    arr24 := make([]int, len(arr))\n    arr25 := make([]int, len(arr))\n\
    \    arr26 := make([]int, len(arr))\n    arr27 := make([]int, len(arr))\n    arr28\
    \ := make([]int, len(arr))\n    arr29 := make([]int, len(arr))\n    arr30 := make([]int,\
    \ len(arr))\n    arr31 := make([]int, len(arr))\n    arr32 := make([]int, len(arr))\n\
    \    arr33 := make([]int, len(arr))\n    arr34 := make([]int, len(arr))\n    arr35\
    \ := make([]int, len(arr))\n    arr36 := make([]int, len(arr))\n    arr37 := make([]int,\
    \ len(arr))\n    arr38 := make([]int, len(arr))\n    arr39 := make([]int, len(arr))\n\
    \    arr40 := make([]int, len(arr))\n    arr41 := make([]int, len(arr))\n    arr42\
    \ := make([]int, len(arr))\n    arr43 \nfunc TestPluck(t *testing.T) {\n  candidate\
    \ := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual:\
    \ candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual:\
    \ candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7,\
    \ 6, 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7,\
    \ 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmppvcyuvxh_test.go:79:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074609
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    arr2 := make([]int, len(arr))\n    min := arr[0]\n    index := 0\n  \
    \  for _, v := range arr {\n        if v%2 == 0 {\n            arr2[index] = v\n\
    \            min = (min > v) ? min : v\n            index++\n        }\n    }\n\
    \    if index == 0 {\n        return []int{}\n    }\n    return arr2[0:index]\n\
    }\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpo4o_n161_test.go:40:29: illegal character U+003F ''?''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074610
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    m := make(map[int]int)\n    for _, v := range arr {\n        m[v] = m[v]\
    \ + 1\n    }\n    sort.Ints(arr)\n    smalest_value := arr[0]\n    smalest_index\
    \ := 0\n    for _, v := range arr {\n        if v%2 == 0 {\n            if m[smalest_value]\
    \ == m[v] {\n                smalest_value = v\n                smalest_index\
    \ = m[v]\n            }\n        }\n    }\n    return []int{smalest_value, smalest_index}\n\
    }\n`\n    )\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n   \
    \  { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp4p0ttxgz_test.go:51:1: raw string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074610
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    smallest := arr[0]\n\
    \    smallest := arr[0]\n    smallest := 0\n    index := 0\n    for _, value :=\
    \ range arr {\n        if value%2 == 0 {\n            if smallest == 0 {\n   \
    \             smallest = value\n                index = index\n            } else\
    \ {\n                if value < smallest {\n                    smallest = value\n\
    \                    index = index\n                }\n            }\n       \
    \ }\n    }\n    return []int{smallest, index}\n}\n\nfunc TestPluck(t *testing.T)\
    \ {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpsnw3y9x5_test.go:38:14: no new variables on left side of :=

    /tmp/tmpsnw3y9x5_test.go:39:14: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074610
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    sort.Ints(arr)\n    smalest_value := arr[0]\n    smalest_index := 0\n\
    \    for _, value := range arr {\n        if value%2 == 0 {\n            if value\
    \ < smalest_value {\n                smalest_value = value\n                smalest_index\
    \ = sort.Search(len(arr), func(i int) bool {\n                    return arr[i]\
    \ < value\n                })\n            }\n        }\n    }\n    return []int{smalest_value,\
    \ smalest_index}\n}\n`\n)\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpmov8wlk6_test.go:49:1: raw string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074610
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    // write your code here\n    sort.Ints(arr)\n    index := 0\n    smalest\
    \ := 0\n    for _, v := range arr {\n        if v%2 == 0 {\n            if smalest\
    \ == 0 {\n                smalest = v\n                index = index + 1\n   \
    \         } else {\n                if v < smalest {\n                    smalest\
    \ = v\n                    index = index + 1\n                }\n            }\n\
    \        }\n    }\n    if smalest == 0 {\n        return []int{}\n    }\n    return\
    \ []int{smalest, index}\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_f5h1mor_test.go:35:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074610
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    sort.Ints(arr)\n    smalest_value := arr[0]\n    smalest_index := 0\n\
    \    for _, value := range arr {\n        if value%2 == 0 {\n            if value\
    \ < smalest_value {\n                smalest_value = value\n                smalest_index\
    \ = sort.Search(len(arr), func(i int) bool {\n                    return arr[i]\
    \ < value\n                })\n            }\n        }\n    }\n    return []int{smalest_value,\
    \ smalest_index}\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6cjw7rsb_test.go:34:5: undefined: sort

    /tmp/tmp6cjw7rsb_test.go:41:33: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074608
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return nil\n    }\n    smallest := arr[0]\n\
    \    smallest := 0\n    index := 0\n    for _, value := range arr {\n        if\
    \ value%2 == 0 {\n            if smallest > value {\n                smallest\
    \ = value\n                index = index\n            }\n        }\n    }\n  \
    \  return []int{smallest, index}\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate\
    \ := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual:\
    \ candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual:\
    \ candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7,\
    \ 6, 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7,\
    \ 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpoudid4pt_test.go:38:14: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074610
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    result := make([]int, 0)\n    min := arr[0]\n    index := 0\n    for\
    \ _, v := range arr {\n        if v%2 == 0 {\n            if min > v {\n     \
    \           min = v\n                index = index\n            }\n        } else\
    \ {\n            if min > v {\n                min = v\n                index\
    \ = index\n            }\n        }\n    }\n    result = append(result, min)\n\
    \    result = append(result, index)\n    return result\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\npanic: runtime error: index out of range [0]\
    \ with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with\
    \ length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440, 0xc000014360})\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.pluck(...)\n\t/tmp/tmpcs680i9__test.go:35\n\
    command-line-arguments_test.TestPluck(0x0?)\n\t/tmp/tmpcs680i9__test.go:64 +0x1b0\n\
    testing.tRunner(0xc0001924e0, 0x527d38)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074609
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    min := arr[0]\n\
    \    index := 0\n    for _, v := range arr {\n        if v%2 == 0 {\n        \
    \    if min > v {\n                min = v\n                index = index\n  \
    \          }\n        } else {\n            if min > v {\n                min\
    \ = v\n                index = index\n            }\n        }\n    }\n    return\
    \ []int{min, index}\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__0 (0.00s)\n\
    \        tmpw1cuerl4_test.go:75: expected '[%!s(int=2) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=0)]'\n    --- FAIL: TestPluck/test_num__1 (0.00s)\n        tmpw1cuerl4_test.go:75:\
    \ expected '[%!s(int=2) %!s(int=1)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL:\
    \ TestPluck/test_num__3 (0.00s)\n        tmpw1cuerl4_test.go:75: expected '[%!s(int=0)\
    \ %!s(int=1)]', got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestPluck/test_num__4\
    \ (0.00s)\n        tmpw1cuerl4_test.go:75: expected '[%!s(int=0) %!s(int=3)]',\
    \ got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestPluck/test_num__5 (0.00s)\n\
    \        tmpw1cuerl4_test.go:75: expected '[%!s(int=4) %!s(int=1)]', got '[%!s(int=4)\
    \ %!s(int=0)]'\n    --- FAIL: TestPluck/test_num__6 (0.00s)\n        tmpw1cuerl4_test.go:75:\
    \ expected '[%!s(int=6) %!s(int=1)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL:\
    \ TestPluck/test_num__7 (0.00s)\n        tmpw1cuerl4_test.go:75: expected '[]',\
    \ got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\n\
    FAIL\n"
  timestamp: 1660074609
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    m := make(map[int]int)\n    for _, v := range arr {\n        m[v] = m[v]\
    \ + 1\n    }\n    arr2 := make([]int, 0, len(m))\n    for _, v := range m {\n\
    \        if v%2 == 0 {\n            arr2 = append(arr2, v)\n        }\n    }\n\
    \    if len(arr2) == 0 {\n        return nil\n    }\n    if len(arr2) == 1 {\n\
    \        return arr2\n    }\n    arr3 = make([]int, 0, len(arr2))\n    for _,\
    \ v := range arr2 {\n        if arr3[len(arr3)-1] < v {\n            arr3 = append(arr3,\
    \ v)\n        }\n    }\n    return arr3\n}\n\nfunc TestPluck(t *testing.T) {\n\
    \  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4, 2,\
    \ 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n  \
    \   { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n \
    \    { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n\
    \     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n  \
    \   { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     { actual:\
    \ candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprov34bbm_test.go:50:5: undefined: arr3

    /tmp/tmprov34bbm_test.go:52:12: undefined: arr3

    /tmp/tmprov34bbm_test.go:53:27: undefined: arr3

    /tmp/tmprov34bbm_test.go:56:12: undefined: arr3

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074611
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    sort.Sort(sort.Reverse(sort.IntSlice(arr)))\n    result := []int{}\n\
    \    index := 0\n    for _, v := range arr {\n        if v%2 == 0 {\n        \
    \    result = append(result, v)\n            index = index + 1\n        }\n  \
    \  }\n    if index == 0 {\n        return nil\n    }\n    return append(result,\
    \ arr[index-1])\n}\n`\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpkjk9vx62_test.go:48:1: raw string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074610
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    sort.Sort(sort.Reverse(sort.IntSlice(arr)))\n    result := make([]int,\
    \ 0)\n    index := 0\n    for _, v := range arr {\n        if v%2 == 0 {\n   \
    \         result = append(result, v)\n            index = index + 1\n        }\n\
    \    }\n    if index == 0 {\n        return []int{}\n    }\n    return result\n\
    }\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6vn1r509_test.go:34:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074611
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    result := make([]int, 0)\n    min := arr[0]\n    index := 0\n    for\
    \ _, v := range arr {\n        if v%2 == 0 {\n            if min > v {\n     \
    \           min = v\n                index = index\n            }\n        } else\
    \ {\n            if min > v {\n                min = v\n                index\
    \ = index\n            }\n        }\n    }\n    result = append(result, min)\n\
    \    result = append(result, index)\n    return result\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\npanic: runtime error: index out of range [0]\
    \ with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with\
    \ length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440, 0xc000014360})\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.pluck(...)\n\t/tmp/tmpcs680i9__test.go:35\n\
    command-line-arguments_test.TestPluck(0x0?)\n\t/tmp/tmpcs680i9__test.go:64 +0x1b0\n\
    testing.tRunner(0xc0001924e0, 0x527d38)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074609
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    result := make([]int, 0)\n    min := arr[0]\n    index := 0\n    for\
    \ _, v := range arr {\n        if v%2 == 0 {\n            if min > v {\n     \
    \           min = v\n                index = index\n            }\n        } else\
    \ {\n            if min > v {\n                min = v\n                index\
    \ = index\n            }\n        }\n    }\n    result = append(result, min)\n\
    \    result = append(result, index)\n    return result\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\npanic: runtime error: index out of range [0]\
    \ with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with\
    \ length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440, 0xc000014360})\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.pluck(...)\n\t/tmp/tmpcs680i9__test.go:35\n\
    command-line-arguments_test.TestPluck(0x0?)\n\t/tmp/tmpcs680i9__test.go:64 +0x1b0\n\
    testing.tRunner(0xc0001924e0, 0x527d38)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074609
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    min := arr[0]\n\
    \    index := 0\n    for _, v := range arr {\n        if v%2 == 0 {\n        \
    \    if min > v {\n                min = v\n                index = index\n  \
    \          }\n        } else {\n            if min > v {\n                min\
    \ = v\n                index = index\n            }\n        }\n    }\n    return\
    \ []int{min, index}\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__0 (0.00s)\n\
    \        tmpw1cuerl4_test.go:75: expected '[%!s(int=2) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=0)]'\n    --- FAIL: TestPluck/test_num__1 (0.00s)\n        tmpw1cuerl4_test.go:75:\
    \ expected '[%!s(int=2) %!s(int=1)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL:\
    \ TestPluck/test_num__3 (0.00s)\n        tmpw1cuerl4_test.go:75: expected '[%!s(int=0)\
    \ %!s(int=1)]', got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestPluck/test_num__4\
    \ (0.00s)\n        tmpw1cuerl4_test.go:75: expected '[%!s(int=0) %!s(int=3)]',\
    \ got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestPluck/test_num__5 (0.00s)\n\
    \        tmpw1cuerl4_test.go:75: expected '[%!s(int=4) %!s(int=1)]', got '[%!s(int=4)\
    \ %!s(int=0)]'\n    --- FAIL: TestPluck/test_num__6 (0.00s)\n        tmpw1cuerl4_test.go:75:\
    \ expected '[%!s(int=6) %!s(int=1)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL:\
    \ TestPluck/test_num__7 (0.00s)\n        tmpw1cuerl4_test.go:75: expected '[]',\
    \ got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\n\
    FAIL\n"
  timestamp: 1660074609
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var result []int\n    var minVal int\n    var minIndex int\n    for _,\
    \ v := range arr {\n        if v%2 == 0 {\n            if minVal == 0 || minVal\
    \ > v {\n                minVal = v\n                minIndex = arr\n        \
    \    }\n        } else {\n            if minVal == 0 || minVal > v {\n       \
    \         minVal = v\n                minIndex = arr\n            }\n        }\n\
    \    }\n    if minVal == 0 {\n        return []int{}\n    }\n    result = append(result,\
    \ minVal)\n    result = append(result, minIndex)\n    return result\n}\n\nfunc\
    \ TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpwot5f0ei_test.go:41:28: cannot use arr (variable of type []int) as type
    int in assignment

    /tmp/tmpwot5f0ei_test.go:46:28: cannot use arr (variable of type []int) as type
    int in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074611
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    result := make([]int, 0)\n    min := arr[0]\n    index := 0\n    for\
    \ _, value := range arr {\n        if value%2 == 0 {\n            if value < min\
    \ {\n                min = value\n                index = index\n            }\n\
    \        } else {\n            if min > value {\n                min = value\n\
    \                index = index\n            }\n        }\n    }\n    result =\
    \ append(result, min)\n    result = append(result, index)\n    return result\n\
    }\n`\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpoak3dllf_test.go:54:1: raw string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074610
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    min := arr[0]\n\
    \    index := 0\n    for _, v := range arr {\n        if v%2 == 0 {\n        \
    \    if min > v {\n                min = v\n                index = index\n  \
    \          }\n        } else {\n            if min == v {\n                index\
    \ = index\n            }\n        }\n    }\n    return []int{min, index}\n}\n\n\
    func TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__0 (0.00s)\n\
    \        tmp3_hhgwrp_test.go:74: expected '[%!s(int=2) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=0)]'\n    --- FAIL: TestPluck/test_num__1 (0.00s)\n        tmp3_hhgwrp_test.go:74:\
    \ expected '[%!s(int=2) %!s(int=1)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL:\
    \ TestPluck/test_num__3 (0.00s)\n        tmp3_hhgwrp_test.go:74: expected '[%!s(int=0)\
    \ %!s(int=1)]', got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestPluck/test_num__4\
    \ (0.00s)\n        tmp3_hhgwrp_test.go:74: expected '[%!s(int=0) %!s(int=3)]',\
    \ got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestPluck/test_num__5 (0.00s)\n\
    \        tmp3_hhgwrp_test.go:74: expected '[%!s(int=4) %!s(int=1)]', got '[%!s(int=4)\
    \ %!s(int=0)]'\n    --- FAIL: TestPluck/test_num__6 (0.00s)\n        tmp3_hhgwrp_test.go:74:\
    \ expected '[%!s(int=6) %!s(int=1)]', got '[%!s(int=6) %!s(int=0)]'\n    --- FAIL:\
    \ TestPluck/test_num__7 (0.00s)\n        tmp3_hhgwrp_test.go:74: expected '[]',\
    \ got '[%!s(int=7) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074611
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    sort.Ints(arr)\n\
    \    smalest_value := arr[0]\n    smalest_index := 0\n    for _, value := range\
    \ arr {\n        if value%2 == 0 {\n            if value < smalest_value {\n \
    \               smalest_value = value\n                smalest_index = len(arr)\
    \ - 1 - i\n            }\n        }\n    }\n    return []int{smalest_value, smalest_index}\n\
    }\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmt1jkhho_test.go:37:5: undefined: sort

    /tmp/tmpmt1jkhho_test.go:44:48: undefined: i

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074611
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    arr2 := make([]int, len(arr))\n    arr3 := make([]int, len(arr))\n  \
    \  arr4 := make([]int, len(arr))\n    arr5 := make([]int, len(arr))\n    arr6\
    \ := make([]int, len(arr))\n    arr7 := make([]int, len(arr))\n    arr8 := make([]int,\
    \ len(arr))\n    arr9 := make([]int, len(arr))\n    arr10 := make([]int, len(arr))\n\
    \    arr11 := make([]int, len(arr))\n    arr12 := make([]int, len(arr))\n    arr13\
    \ := make([]int, len(arr))\n    arr14 := make([]int, len(arr))\n    arr15 := make([]int,\
    \ len(arr))\n    arr16 := make([]int, len(arr))\n    arr17 := make([]int, len(arr))\n\
    \    arr18 := make([]int, len(arr))\n    arr19 := make([]int, len(arr))\n    arr20\
    \ := make([]int, len(arr))\n    arr21 := make([]int, len(arr))\n    arr22 := make([]int,\
    \ len(arr))\n    arr23 := make([]int, len(arr))\n    arr24 := make([]int, len(arr))\n\
    \    arr25 := make([]int, len(arr))\n    arr26 := make([]int, len(arr))\n    arr27\
    \ := make([]int, len(arr))\n    arr28 := make([]int, len(arr))\n    arr29 := make([]int,\
    \ len(arr))\n    arr30 := make([]int, len(arr))\n    arr31 := make([]int, len(arr))\n\
    \    arr32 := make([]int, len(arr))\n    arr33 := make([]int, len(arr))\n    arr34\
    \ := make([]int, len(arr))\n    arr35 := make([]int, len(arr))\n    arr36 := make([]int,\
    \ len(arr))\n    arr37 := make([]int, len(arr))\n    arr38 := make([]int, len(arr))\n\
    \    arr39 := make([]int, len(arr))\n    arr40 := make([]int, len(arr))\n    arr41\
    \ := make([]int, len(arr))\n    arr42 := make([]int, len(arr))\n    arr43 := make([]int,\
    \ len(arr))\n    arr\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpn18y7qza_test.go:77:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074607
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var minVal int\n    var minIndex int\n    for _, v := range arr {\n \
    \       if v%2 == 0 {\n            if minVal == 0 || v < minVal {\n          \
    \      minVal = v\n                minIndex = v\n            }\n        }\n  \
    \  }\n    return []int{minVal, minIndex}\n}\n\nfunc TestPluck(t *testing.T) {\n\
    \  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4, 2,\
    \ 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n  \
    \   { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n \
    \    { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n\
    \     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n  \
    \   { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     { actual:\
    \ candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__0 (0.00s)\n\
    \        tmp0j52_gqk_test.go:67: expected '[%!s(int=2) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=2)]'\n    --- FAIL: TestPluck/test_num__1 (0.00s)\n        tmp0j52_gqk_test.go:67:\
    \ expected '[%!s(int=2) %!s(int=1)]', got '[%!s(int=2) %!s(int=2)]'\n    --- FAIL:\
    \ TestPluck/test_num__2 (0.00s)\n        tmp0j52_gqk_test.go:67: expected '[]',\
    \ got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestPluck/test_num__3 (0.00s)\n\
    \        tmp0j52_gqk_test.go:67: expected '[%!s(int=0) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=2)]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmp0j52_gqk_test.go:67:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL:\
    \ TestPluck/test_num__5 (0.00s)\n        tmp0j52_gqk_test.go:67: expected '[%!s(int=4)\
    \ %!s(int=1)]', got '[%!s(int=4) %!s(int=4)]'\n    --- FAIL: TestPluck/test_num__6\
    \ (0.00s)\n        tmp0j52_gqk_test.go:67: expected '[%!s(int=6) %!s(int=1)]',\
    \ got '[%!s(int=6) %!s(int=6)]'\n    --- FAIL: TestPluck/test_num__7 (0.00s)\n\
    \        tmp0j52_gqk_test.go:67: expected '[]', got '[%!s(int=0) %!s(int=0)]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074611
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    min := arr[0]\n\
    \    index := 0\n    for _, v := range arr {\n        if v%2 == 0 {\n        \
    \    if min > v {\n                min = v\n                index = index\n  \
    \          }\n        } else {\n            if min > v {\n                min\
    \ = v\n            }\n        }\n    }\n    return []int{min, index}\n}\n\nfunc\
    \ TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__0 (0.00s)\n\
    \        tmprd3310k7_test.go:74: expected '[%!s(int=2) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=0)]'\n    --- FAIL: TestPluck/test_num__1 (0.00s)\n        tmprd3310k7_test.go:74:\
    \ expected '[%!s(int=2) %!s(int=1)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL:\
    \ TestPluck/test_num__3 (0.00s)\n        tmprd3310k7_test.go:74: expected '[%!s(int=0)\
    \ %!s(int=1)]', got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestPluck/test_num__4\
    \ (0.00s)\n        tmprd3310k7_test.go:74: expected '[%!s(int=0) %!s(int=3)]',\
    \ got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestPluck/test_num__5 (0.00s)\n\
    \        tmprd3310k7_test.go:74: expected '[%!s(int=4) %!s(int=1)]', got '[%!s(int=4)\
    \ %!s(int=0)]'\n    --- FAIL: TestPluck/test_num__6 (0.00s)\n        tmprd3310k7_test.go:74:\
    \ expected '[%!s(int=6) %!s(int=1)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL:\
    \ TestPluck/test_num__7 (0.00s)\n        tmprd3310k7_test.go:74: expected '[]',\
    \ got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074611
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    arr2 := make([]int, len(arr))\n    arr3 := make([]int, len(arr))\n  \
    \  arr4 := make([]int, len(arr))\n    arr5 := make([]int, len(arr))\n    arr6\
    \ := make([]int, len(arr))\n    arr7 := make([]int, len(arr))\n    arr8 := make([]int,\
    \ len(arr))\n    arr9 := make([]int, len(arr))\n    arr10 := make([]int, len(arr))\n\
    \    arr11 := make([]int, len(arr))\n    arr12 := make([]int, len(arr))\n    arr13\
    \ := make([]int, len(arr))\n    arr14 := make([]int, len(arr))\n    arr15 := make([]int,\
    \ len(arr))\n    arr16 := make([]int, len(arr))\n    arr17 := make([]int, len(arr))\n\
    \    arr18 := make([]int, len(arr))\n    arr19 := make([]int, len(arr))\n    arr20\
    \ := make([]int, len(arr))\n    arr21 := make([]int, len(arr))\n    arr22 := make([]int,\
    \ len(arr))\n    arr23 := make([]int, len(arr))\n    arr24 := make([]int, len(arr))\n\
    \    arr25 := make([]int, len(arr))\n    arr26 := make([]int, len(arr))\n    arr27\
    \ := make([]int, len(arr))\n    arr28 := make([]int, len(arr))\n    arr29 := make([]int,\
    \ len(arr))\n    arr30 := make([]int, len(arr))\n    arr31 := make([]int, len(arr))\n\
    \    arr32 := make([]int, len(arr))\n    arr33 := make([]int, len(arr))\n    arr34\
    \ := make([]int, len(arr))\n    arr35 := make([]int, len(arr))\n    arr36 := make([]int,\
    \ len(arr))\n    arr37 := make([]int, len(arr))\n    arr38 := make([]int, len(arr))\n\
    \    arr39 := make([]int, len(arr))\n    arr40 := make([]int, len(arr))\n    arr41\
    \ := make([]int, len(arr))\n    arr42 := make([]int, len(arr))\n    arr43 := make([]int,\
    \ len(arr))\n    arr\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpn18y7qza_test.go:77:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074607
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    min := arr[0]\n\
    \    index := 0\n    for _, v := range arr {\n        if v%2 == 0 {\n        \
    \    if v < min {\n                min = v\n                index = index\n  \
    \          }\n        }\n    }\n    return []int{min, index}\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__0 (0.00s)\n\
    \        tmpzxz86ptk_test.go:70: expected '[%!s(int=2) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=0)]'\n    --- FAIL: TestPluck/test_num__1 (0.00s)\n        tmpzxz86ptk_test.go:70:\
    \ expected '[%!s(int=2) %!s(int=1)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL:\
    \ TestPluck/test_num__3 (0.00s)\n        tmpzxz86ptk_test.go:70: expected '[%!s(int=0)\
    \ %!s(int=1)]', got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestPluck/test_num__4\
    \ (0.00s)\n        tmpzxz86ptk_test.go:70: expected '[%!s(int=0) %!s(int=3)]',\
    \ got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestPluck/test_num__5 (0.00s)\n\
    \        tmpzxz86ptk_test.go:70: expected '[%!s(int=4) %!s(int=1)]', got '[%!s(int=4)\
    \ %!s(int=0)]'\n    --- FAIL: TestPluck/test_num__6 (0.00s)\n        tmpzxz86ptk_test.go:70:\
    \ expected '[%!s(int=6) %!s(int=1)]', got '[%!s(int=6) %!s(int=0)]'\n    --- FAIL:\
    \ TestPluck/test_num__7 (0.00s)\n        tmpzxz86ptk_test.go:70: expected '[]',\
    \ got '[%!s(int=7) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074611
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    arr2 := make([]int,\
    \ len(arr))\n    arr3 := make([]int, len(arr))\n    arr4 := make([]int, len(arr))\n\
    \    arr5 := make([]int, len(arr))\n    arr6 := make([]int, len(arr))\n    arr7\
    \ := make([]int, len(arr))\n    arr8 := make([]int, len(arr))\n    arr9 := make([]int,\
    \ len(arr))\n    arr10 := make([]int, len(arr))\n    arr11 := make([]int, len(arr))\n\
    \    arr12 := make([]int, len(arr))\n    arr13 := make([]int, len(arr))\n    arr14\
    \ := make([]int, len(arr))\n    arr15 := make([]int, len(arr))\n    arr16 := make([]int,\
    \ len(arr))\n    arr17 := make([]int, len(arr))\n    arr18 := make([]int, len(arr))\n\
    \    arr19 := make([]int, len(arr))\n    arr20 := make([]int, len(arr))\n    arr21\
    \ := make([]int, len(arr))\n    arr22 := make([]int, len(arr))\n    arr23 := make([]int,\
    \ len(arr))\n    arr24 := make([]int, len(arr))\n    arr25 := make([]int, len(arr))\n\
    \    arr26 := make([]int, len(arr))\n    arr27 := make([]int, len(arr))\n    arr28\
    \ := make([]int, len(arr))\n    arr29 := make([]int, len(arr))\n    arr30 := make([]int,\
    \ len(arr))\n    arr31 := make([]int, len(arr))\n    arr32 := make([]int, len(arr))\n\
    \    arr33 := make([]int, len(arr))\n    arr34 := make([]int, len(arr))\n    arr35\
    \ := make([]int, len(arr))\n    arr36 := make([]int, len(arr))\n    arr37 := make([]int,\
    \ len(arr))\n    arr38 := make([]int, len(arr))\n    arr39 := make([]int, len(arr))\n\
    \    arr40 := make([]int, len(arr))\n    arr41 := make([]int, len(arr))\n    arr42\
    \ := make([]int, len(arr))\n    arr43 \nfunc TestPluck(t *testing.T) {\n  candidate\
    \ := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual:\
    \ candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual:\
    \ candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7,\
    \ 6, 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7,\
    \ 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmppvcyuvxh_test.go:79:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074609
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    m := make(map[int]int)\n    for _, v := range arr {\n        m[v] = m[min(m[v],\
    \ len(m))]\n    }\n    result := make([]int, 0, len(m))\n    for _, v := range\
    \ m {\n        result = append(result, v)\n    }\n    return result\n}\n\nfunc\
    \ TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3f841hb9_test.go:36:18: undefined: min

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074611
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    sort.Sort(sort.Reverse(sort.IntSlice(arr)))\n    smalest_value := arr[0]\n\
    \    smalest_index := 0\n    for _, v := range arr {\n        if v%2 == 0 {\n\
    \            if v < smalest_value {\n                smalest_value = v\n     \
    \           smalest_index = sort.Search(len(arr), func(i int) bool {\n       \
    \             return arr[i] < v\n                })\n            }\n        }\n\
    \    }\n    return []int{smalest_value, smalest_index}\n}\n`\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmplsm808b6_test.go:49:1: raw string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074610
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    sort.Ints(arr)\n    index := 0\n    smalest := arr[0]\n    for _, v :=\
    \ range arr {\n        if v%2 == 0 {\n            if smalest == v {\n        \
    \        index = index + 1\n            } else {\n                smalest = v\n\
    \                index = index\n            }\n        }\n    }\n    if index\
    \ == 0 {\n        return []int{}\n    }\n    return []int{smalest, index}\n}\n\
    \nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmph2n2afv2_test.go:34:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074612
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return nil\n    }\n    min := arr[0]\n  \
    \  index := 0\n    for _, v := range arr {\n        if v%2 == 0 {\n          \
    \  min = v\n            index = index + 1\n        }\n    }\n    return []int{min,\
    \ index}\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n   \
    \  { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__0 (0.00s)\n\
    \        tmplh6ovr38_test.go:68: expected '[%!s(int=2) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=2)]'\n    --- FAIL: TestPluck/test_num__3 (0.00s)\n        tmplh6ovr38_test.go:68:\
    \ expected '[%!s(int=0) %!s(int=1)]', got '[%!s(int=2) %!s(int=4)]'\n    --- FAIL:\
    \ TestPluck/test_num__4 (0.00s)\n        tmplh6ovr38_test.go:68: expected '[%!s(int=0)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=2)]'\n    --- FAIL: TestPluck/test_num__5\
    \ (0.00s)\n        tmplh6ovr38_test.go:68: expected '[%!s(int=4) %!s(int=1)]',\
    \ got '[%!s(int=8) %!s(int=4)]'\n    --- FAIL: TestPluck/test_num__7 (0.00s)\n\
    \        tmplh6ovr38_test.go:68: expected '[]', got '[%!s(int=7) %!s(int=0)]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074612
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    arr2 := make([]int, len(arr))\n    arr3 := make([]int, len(arr))\n  \
    \  arr4 := make([]int, len(arr))\n    arr5 := make([]int, len(arr))\n    arr6\
    \ := make([]int, len(arr))\n    arr7 := make([]int, len(arr))\n    arr8 := make([]int,\
    \ len(arr))\n    arr9 := make([]int, len(arr))\n    arr10 := make([]int, len(arr))\n\
    \    arr11 := make([]int, len(arr))\n    arr12 := make([]int, len(arr))\n    arr13\
    \ := make([]int, len(arr))\n    arr14 := make([]int, len(arr))\n    arr15 := make([]int,\
    \ len(arr))\n    arr16 := make([]int, len(arr))\n    arr17 := make([]int, len(arr))\n\
    \    arr18 := make([]int, len(arr))\n    arr19 := make([]int, len(arr))\n    arr20\
    \ := make([]int, len(arr))\n    arr21 := make([]int, len(arr))\n    arr22 := make([]int,\
    \ len(arr))\n    arr23 := make([]int, len(arr))\n    arr24 := make([]int, len(arr))\n\
    \    arr25 := make([]int, len(arr))\n    arr26 := make([]int, len(arr))\n    arr27\
    \ := make([]int, len(arr))\n    arr28 := make([]int, len(arr))\n    arr29 := make([]int,\
    \ len(arr))\n    arr30 := make([]int, len(arr))\n    arr31 := make([]int, len(arr))\n\
    \    arr32 := make([]int, len(arr))\n    arr33 := make([]int, len(arr))\n    arr34\
    \ := make([]int, len(arr))\n    arr35 := make([]int, len(arr))\n    arr36 := make([]int,\
    \ len(arr))\n    arr37 := make([]int, len(arr))\n    arr38 := make([]int, len(arr))\n\
    \    arr39 := make([]int, len(arr))\n    arr40 := make([]int, len(arr))\n    arr41\
    \ := make([]int, len(arr))\n    arr42 := make([]int, len(arr))\n    arr43 := make([]int,\
    \ len(arr))\n    arr\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpn18y7qza_test.go:77:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074607
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    sort.Sort(sort.Reverse(arr))\n    smalest_value := arr[0]\n    smalest_index\
    \ := 0\n    for _, v := range arr {\n        if v%2 == 0 {\n            if smalest_value%2\
    \ == 0 {\n                smalest_value = v\n                smalest_index = len(arr)\
    \ - 1 - i\n            }\n        }\n    }\n    return []int{smalest_value, smalest_index}\n\
    }\n`\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_qbucv95_test.go:47:1: raw string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074611
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    arr2 := make([]int, len(arr))\n    arr3 := make([]int, len(arr))\n  \
    \  arr4 := make([]int, len(arr))\n    arr5 := make([]int, len(arr))\n    arr6\
    \ := make([]int, len(arr))\n    arr7 := make([]int, len(arr))\n    arr8 := make([]int,\
    \ len(arr))\n    arr9 := make([]int, len(arr))\n    arr10 := make([]int, len(arr))\n\
    \    arr11 := make([]int, len(arr))\n    arr12 := make([]int, len(arr))\n    arr13\
    \ := make([]int, len(arr))\n    arr14 := make([]int, len(arr))\n    arr15 := make([]int,\
    \ len(arr))\n    arr16 := make([]int, len(arr))\n    arr17 := make([]int, len(arr))\n\
    \    arr18 := make([]int, len(arr))\n    arr19 := make([]int, len(arr))\n    arr20\
    \ := make([]int, len(arr))\n    arr21 := make([]int, len(arr))\n    arr22 := make([]int,\
    \ len(arr))\n    arr23 := make([]int, len(arr))\n    arr24 := make([]int, len(arr))\n\
    \    arr25 := make([]int, len(arr))\n    arr26 := make([]int, len(arr))\n    arr27\
    \ := make([]int, len(arr))\n    arr28 := make([]int, len(arr))\n    arr29 := make([]int,\
    \ len(arr))\n    arr30 := make([]int, len(arr))\n    arr31 := make([]int, len(arr))\n\
    \    arr32 := make([]int, len(arr))\n    arr33 := make([]int, len(arr))\n    arr34\
    \ := make([]int, len(arr))\n    arr35 := make([]int, len(arr))\n    arr36 := make([]int,\
    \ len(arr))\n    arr37 := make([]int, len(arr))\n    arr38 := make([]int, len(arr))\n\
    \    arr39 := make([]int, len(arr))\n    arr40 := make([]int, len(arr))\n    arr41\
    \ := make([]int, len(arr))\n    arr42 := make([]int, len(arr))\n    arr43 := make([]int,\
    \ len(arr))\n    arr\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpn18y7qza_test.go:77:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074607
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    arr2 := make([]int, len(arr))\n    arr3 := make([]int, len(arr))\n  \
    \  arr4 := make([]int, len(arr))\n    arr5 := make([]int, len(arr))\n    arr6\
    \ := make([]int, len(arr))\n    arr7 := make([]int, len(arr))\n    arr8 := make([]int,\
    \ len(arr))\n    arr9 := make([]int, len(arr))\n    arr10 := make([]int, len(arr))\n\
    \    arr11 := make([]int, len(arr))\n    arr12 := make([]int, len(arr))\n    arr13\
    \ := make([]int, len(arr))\n    arr14 := make([]int, len(arr))\n    arr15 := make([]int,\
    \ len(arr))\n    arr16 := make([]int, len(arr))\n    arr17 := make([]int, len(arr))\n\
    \    arr18 := make([]int, len(arr))\n    arr19 := make([]int, len(arr))\n    arr20\
    \ := make([]int, len(arr))\n    arr21 := make([]int, len(arr))\n    arr22 := make([]int,\
    \ len(arr))\n    arr23 := make([]int, len(arr))\n    arr24 := make([]int, len(arr))\n\
    \    arr25 := make([]int, len(arr))\n    arr26 := make([]int, len(arr))\n    arr27\
    \ := make([]int, len(arr))\n    arr28 := make([]int, len(arr))\n    arr29 := make([]int,\
    \ len(arr))\n    arr30 := make([]int, len(arr))\n    arr31 := make([]int, len(arr))\n\
    \    arr32 := make([]int, len(arr))\n    arr33 := make([]int, len(arr))\n    arr34\
    \ := make([]int, len(arr))\n    arr35 := make([]int, len(arr))\n    arr36 := make([]int,\
    \ len(arr))\n    arr37 := make([]int, len(arr))\n    arr38 := make([]int, len(arr))\n\
    \    arr39 := make([]int, len(arr))\n    arr40 := make([]int, len(arr))\n    arr41\
    \ := make([]int, len(arr))\n    arr42 := make([]int, len(arr))\n    arr43 := make([]int,\
    \ len(arr))\n    arr\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpn18y7qza_test.go:77:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074607
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    n := len(arr)\n    result := make([]int, n)\n    min := arr[0]\n    index\
    \ := 0\n    for i := 0; i < n; i++ {\n        if arr[i] < min {\n            min\
    \ = arr[i]\n            index = i\n        }\n    }\n    result[index] = min\n\
    \    return result\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\npanic: runtime error: index out of range [0]\
    \ with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with\
    \ length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440, 0xc000014390})\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x512440,\
    \ 0xc000014390})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.pluck(...)\n\t/tmp/tmpzhouzz99_test.go:36\n\
    command-line-arguments_test.TestPluck(0x0?)\n\t/tmp/tmpzhouzz99_test.go:57 +0x135\n\
    testing.tRunner(0xc0001924e0, 0x527d38)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074609
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    // write your code here\n    sort.Ints(arr)\n    var result []int\n \
    \   index := 0\n    for _, v := range arr {\n        if v%2 == 0 {\n         \
    \   result = append(result, v)\n            index = index + 1\n        }\n   \
    \ }\n    if index == 0 {\n        result = append(result, 0)\n    }\n    return\
    \ result\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n   \
    \  { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpcjvqwire_test.go:35:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074612
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    sort.Ints(arr)\n    index := 0\n    smalest := arr[0]\n    for _, v :=\
    \ range arr {\n        if v%2 == 0 {\n            if smalest == v {\n        \
    \        index = index + 1\n            } else {\n                smalest = v\n\
    \                index = index\n            }\n        }\n    }\n    if index\
    \ == 0 {\n        return []int{}\n    }\n    return []int{smalest, index}\n}\n\
    \nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmph2n2afv2_test.go:34:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074612
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    arr2 := make([]int, len(arr))\n    min := 0\n    max := 0\n    index\
    \ := 0\n    for _, val := range arr {\n        if val%2 == 0 {\n            arr2[min]\
    \ = val\n            min++\n        } else {\n            arr2[max] = val\n  \
    \          max++\n        }\n    }\n    if min == 0 {\n        return []int{}\n\
    \    }\n    if min == max {\n        return arr2\n    }\n    arr2[min] = arr2[min]/2\n\
    \    arr2[max] = arr2[max]/2\n    return arr2\n}\n\nfunc TestPluck(t *testing.T)\
    \ {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3rd8cjac_test.go:37:5: index declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074612
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    sort.Ints(arr)\n    smalest_value := arr[0]\n    smalest_index := 0\n\
    \    for _, value := range arr {\n        if value%2 == 0 {\n            if value\
    \ < smalest_value {\n                smalest_value = value\n                smalest_index\
    \ = sort.Search(len(arr), func(i int) bool {\n                    return arr[i]\
    \ < value\n                })\n            }\n        }\n    }\n    return []int{smalest_value,\
    \ smalest_index}\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6cjw7rsb_test.go:34:5: undefined: sort

    /tmp/tmp6cjw7rsb_test.go:41:33: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074608
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    smallest := arr[0]\n\
    \    smallest := arr[0]\n    smallest := 0\n    index := 0\n    for _, val :=\
    \ range arr {\n        if val%2 == 0 {\n            if smallest > val {\n    \
    \            smallest = val\n                index = val\n            }\n    \
    \    } else {\n            if smallest > val {\n                smallest = val\n\
    \                index = val\n            }\n        }\n    }\n    return []int{smallest,\
    \ index}\n}\n`\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n   \
    \  { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpu5y4_poh_test.go:56:1: raw string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074611
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    result := make([]int, 0)\n    index := 0\n    smalest_value := 0\n  \
    \  for _, value := range arr {\n        if value == smalest_value {\n        \
    \    index = index + 1\n        } else {\n            if index > 0 {\n       \
    \         result = append(result, smalest_value)\n            }\n            smalest_value\
    \ = value\n            index = index + 1\n        }\n    }\n    if index > 0 {\n\
    \        result = append(result, smalest_value)\n    }\n    return result\n}\n\
    \nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__0 (0.00s)\n\
    \        tmp23078qza_test.go:74: expected '[%!s(int=2) %!s(int=1)]', got '[%!s(int=4)\
    \ %!s(int=2) %!s(int=3)]'\n    --- FAIL: TestPluck/test_num__1 (0.00s)\n     \
    \   tmp23078qza_test.go:74: expected '[%!s(int=2) %!s(int=1)]', got '[%!s(int=1)\
    \ %!s(int=2) %!s(int=3)]'\n    --- FAIL: TestPluck/test_num__3 (0.00s)\n     \
    \   tmp23078qza_test.go:74: expected '[%!s(int=0) %!s(int=1)]', got '[%!s(int=5)\
    \ %!s(int=0) %!s(int=3) %!s(int=0) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestPluck/test_num__4\
    \ (0.00s)\n        tmp23078qza_test.go:74: expected '[%!s(int=0) %!s(int=3)]',\
    \ got '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=0) %!s(int=5) %!s(int=3)]'\n\
    \    --- FAIL: TestPluck/test_num__5 (0.00s)\n        tmp23078qza_test.go:74:\
    \ expected '[%!s(int=4) %!s(int=1)]', got '[%!s(int=5) %!s(int=4) %!s(int=8) %!s(int=4)\
    \ %!s(int=8)]'\n    --- FAIL: TestPluck/test_num__6 (0.00s)\n        tmp23078qza_test.go:74:\
    \ expected '[%!s(int=6) %!s(int=1)]', got '[%!s(int=7) %!s(int=6) %!s(int=7) %!s(int=1)]'\n\
    \    --- FAIL: TestPluck/test_num__7 (0.00s)\n        tmp23078qza_test.go:74:\
    \ expected '[]', got '[%!s(int=7) %!s(int=9) %!s(int=7) %!s(int=1)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074612
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    sort.Sort(sort.Reverse(arr))\n    index := 0\n    smalest := arr[0]\n\
    \    for _, v := range arr {\n        if v%2 == 0 {\n            if smalest ==\
    \ v {\n                index = index + 1\n            } else {\n             \
    \   smalest = v\n                index = index\n            }\n        }\n   \
    \ }\n    return []int{smalest, index}\n}\n\nfunc TestPluck(t *testing.T) {\n \
    \ candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4, 2,\
    \ 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n  \
    \   { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n \
    \    { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n\
    \     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n  \
    \   { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     { actual:\
    \ candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphxnomxhn_test.go:34:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074612
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    result := make([]int, 0)\n    index := 0\n    smallestEven := arr[0]\n\
    \    smallestIndex := 0\n    for _, v := range arr {\n        if v%2 == 0 {\n\
    \            if smallestEven == v {\n                smallestIndex = index\n \
    \           }\n            smallestEven = v\n            index = index + 1\n \
    \       } else {\n            if smallestEven == v {\n                smallestIndex\
    \ = index\n            }\n        }\n    }\n    if smallestEven == 0 {\n     \
    \   return nil\n    }\n    result = append(result, smallestEven, smallestIndex)\n\
    \    return result\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\npanic: runtime error: index out of range [0]\
    \ with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with\
    \ length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440, 0xc000014360})\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.pluck(...)\n\t/tmp/tmpvofnm9ho_test.go:36\n\
    command-line-arguments_test.TestPluck(0x0?)\n\t/tmp/tmpvofnm9ho_test.go:67 +0x17b\n\
    testing.tRunner(0xc0001a01a0, 0x527d38)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074613
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var result []int\n    var minVal int\n    var minIndex int\n    for _,\
    \ val := range arr {\n        if val%2 == 0 {\n            if minVal == 0 || val\
    \ < minVal {\n                minVal = val\n                minIndex = arr\n \
    \           }\n        } else {\n            if minVal == 0 || val > minVal {\n\
    \                minVal = val\n                minIndex = arr\n            }\n\
    \        }\n    }\n    if minVal == 0 {\n        return []\n    }\n    result\
    \ = append(result, minVal)\n    result = append(result, minIndex)\n    return\
    \ result\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n   \
    \  { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8xqdw7gi_test.go:51:18: expected type, found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074612
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    m := make(map[int]int)\n    for _, v := range arr {\n        m[v] = m[v]\
    \ + 1\n    }\n    var result []int\n    for _, v := range m {\n        if v%2\
    \ == 0 {\n            result = append(result, v)\n        }\n    }\n    if len(result)\
    \ == 0 {\n        return nil\n    }\n    if len(result) == 1 {\n        return\
    \ result[0]\n    }\n    return result\n}\n\nfunc TestPluck(t *testing.T) {\n \
    \ candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4, 2,\
    \ 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n  \
    \   { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n \
    \    { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n\
    \     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n  \
    \   { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     { actual:\
    \ candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpnicgqkne_test.go:48:16: cannot use result[0] (variable of type int) as
    type []int in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074612
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    sort.Sort(sort.Reverse(sort.IntSlice(arr)))\n    var result []int\n \
    \   var minIndex int\n    for _, v := range arr {\n        if v%2 == 0 {\n   \
    \         result = append(result, v)\n            minIndex = sort.Search(len(arr),\
    \ func(i int) bool {\n                return arr[i] < v\n            })\n    \
    \    }\n    }\n    if minIndex == len(arr) {\n        return []int{}\n    }\n\
    \    return append([]int{result[minIndex], minIndex}, result[:minIndex])\n}\n\
    `\n        );\n    }\n}\n\n/**\n * Given an array representing a branch of a tree\
    \ that has non-negative integer nodes\n * your task is to pluck one of the nodes\
    \ and return it.\n * The plucked node should be the node with the smallest even\
    \ value.\n * If multiple nodes with the same smallest even value are found return\
    \ the node that has smallest index.\n * The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n * If there are no even values or the\
    \ given array is empty, return [].\n * Example 1:\n * >>> pluck([]int{4, 2, 3})\n\
    \ * []int{2, 1}\n * Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n * Example 2:\n * >>> pluck([]int{1, 2, 3})\n * []int{2, 1}\n\
    \ * Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \ * Example 3:\n * >>> pluck([]int{})\n * []int{}\n * Example 4:\n * >>> pluck([]int{5,\
    \ 0, 3, 0, 4, 2})\n * []int{0, 1}\n * Explanation: 0 is the smallest value, but\
    \  there are two zeros,\n * so we will choose the first zero, which has the smallest\
    \ index.\n * Constraints:\n * * 1 <= nodes.length <= 10000\n * * 0 <= node.value\n\
    \ */\nclass pluck_test {\n    static function main() {\n        pluck_testCase(\n\
    \            [],\n            [],\n            [],\n            [],\n        \
    \    [],\n            [],\n            [],\n            [],\n            [],\n\
    \            [],\n            [],\n            [],\n            [],\n        \
    \    [],\n            [],\n            [],\n            [],\n            [],\n\
    \            [],\n            [],\n            [],\n            [],\n        \
    \    [],\n            [],\n            [],\n            [],\n            [],\n\
    \            [],\n            [],\n            [],\n            [],\n        \
    \    [],\n            [],\n            [],\n            [],\n            [],\n\
    \            [],\n            [],\n            [],\n            [],\n        \
    \    [],\n            [],\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp7jqxj4s6_test.go:50:1: raw string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074612
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    m := make(map[int]int)\n    for _, v := range arr {\n        m[v] = m[min(v,\
    \ m[v])]\n    }\n    result := make([]int, 0, len(m))\n    for _, v := range m\
    \ {\n        result = append(result, v)\n    }\n    return result\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpef6w__jv_test.go:36:18: undefined: min

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074612
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    arr2 := make([]int, len(arr))\n    arr3 := make([]int, len(arr))\n  \
    \  arr4 := make([]int, len(arr))\n    arr5 := make([]int, len(arr))\n    arr6\
    \ := make([]int, len(arr))\n    arr7 := make([]int, len(arr))\n    arr8 := make([]int,\
    \ len(arr))\n    arr9 := make([]int, len(arr))\n    arr10 := make([]int, len(arr))\n\
    \    arr11 := make([]int, len(arr))\n    arr12 := make([]int, len(arr))\n    arr13\
    \ := make([]int, len(arr))\n    arr14 := make([]int, len(arr))\n    arr15 := make([]int,\
    \ len(arr))\n    arr16 := make([]int, len(arr))\n    arr17 := make([]int, len(arr))\n\
    \    arr18 := make([]int, len(arr))\n    arr19 := make([]int, len(arr))\n    arr20\
    \ := make([]int, len(arr))\n    arr21 := make([]int, len(arr))\n    arr22 := make([]int,\
    \ len(arr))\n    arr23 := make([]int, len(arr))\n    arr24 := make([]int, len(arr))\n\
    \    arr25 := make([]int, len(arr))\n    arr26 := make([]int, len(arr))\n    arr27\
    \ := make([]int, len(arr))\n    arr28 := make([]int, len(arr))\n    arr29 := make([]int,\
    \ len(arr))\n    arr30 := make([]int, len(arr))\n    arr31 := make([]int, len(arr))\n\
    \    arr32 := make([]int, len(arr))\n    arr33 := make([]int, len(arr))\n    arr34\
    \ := make([]int, len(arr))\n    arr35 := make([]int, len(arr))\n    arr36 := make([]int,\
    \ len(arr))\n    arr37 := make([]int, len(arr))\n    arr38 := make([]int, len(arr))\n\
    \    arr39 := make([]int, len(arr))\n    arr40 := make([]int, len(arr))\n    arr41\
    \ := make([]int, len(arr))\n    arr42 := make([]int, len(arr))\n    arr43 := make([]int,\
    \ len(arr))\n    arr\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpn18y7qza_test.go:77:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074607
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    sort.Ints(arr)\n    var result []int\n    var minIndex int\n    var minVal\
    \ int\n    for _, v := range arr {\n        if v%2 == 0 {\n            if minVal\
    \ == 0 || v < minVal {\n                minVal = v\n                minIndex =\
    \ v\n            }\n        } else {\n            if minVal == 0 || v > minVal\
    \ {\n                minVal = v\n                minIndex = v\n            }\n\
    \        }\n    }\n    if minVal == 0 {\n        return []int{}\n    }\n    result\
    \ = append(result, minVal)\n    result = append(result, minIndex)\n    return\
    \ result\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n   \
    \  { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpildmqt3n_test.go:34:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074612
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    m := make(map[int]int)\n    for _, v := range arr {\n        m[v]++\n\
    \    }\n    sort.Ints(arr)\n    index := 0\n    result := make([]int, 0)\n   \
    \ for _, v := range arr {\n        if m[v] % 2 == 0 {\n            result = append(result,\
    \ v)\n        }\n        if m[v] == 1 {\n            index = v\n        }\n  \
    \  }\n    if index == 0 {\n        return nil\n    }\n    return append(result,\
    \ index)\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n   \
    \  { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkqfq6ogi_test.go:38:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074613
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    // write your code here\n    sort.Ints(arr)\n    index := 0\n    smalest\
    \ := 0\n    for _, v := range arr {\n        if v%2 == 0 {\n            if smalest\
    \ == 0 {\n                smalest = v\n                index = index + 1\n   \
    \         } else {\n                if v < smalest {\n                    smalest\
    \ = v\n                    index = index + 1\n                }\n            }\n\
    \        }\n    }\n    return []int{smalest, index}\n}\n`\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpgbmheu4x_test.go:53:1: raw string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074612
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    arr2 := make([]int, len(arr))\n    arr3 := make([]int, len(arr))\n  \
    \  arr4 := make([]int, len(arr))\n    arr5 := make([]int, len(arr))\n    arr6\
    \ := make([]int, len(arr))\n    arr7 := make([]int, len(arr))\n    arr8 := make([]int,\
    \ len(arr))\n    arr9 := make([]int, len(arr))\n    arr10 := make([]int, len(arr))\n\
    \    arr11 := make([]int, len(arr))\n    arr12 := make([]int, len(arr))\n    arr13\
    \ := make([]int, len(arr))\n    arr14 := make([]int, len(arr))\n    arr15 := make([]int,\
    \ len(arr))\n    arr16 := make([]int, len(arr))\n    arr17 := make([]int, len(arr))\n\
    \    arr18 := make([]int, len(arr))\n    arr19 := make([]int, len(arr))\n    arr20\
    \ := make([]int, len(arr))\n    arr21 := make([]int, len(arr))\n    arr22 := make([]int,\
    \ len(arr))\n    arr23 := make([]int, len(arr))\n    arr24 := make([]int, len(arr))\n\
    \    arr25 := make([]int, len(arr))\n    arr26 := make([]int, len(arr))\n    arr27\
    \ := make([]int, len(arr))\n    arr28 := make([]int, len(arr))\n    arr29 := make([]int,\
    \ len(arr))\n    arr30 := make([]int, len(arr))\n    arr31 := make([]int, len(arr))\n\
    \    arr32 := make([]int, len(arr))\n    arr33 := make([]int, len(arr))\n    arr34\
    \ := make([]int, len(arr))\n    arr35 := make([]int, len(arr))\n    arr36 := make([]int,\
    \ len(arr))\n    arr37 := make([]int, len(arr))\n    arr38 := make([]int, len(arr))\n\
    \    arr39 := make([]int, len(arr))\n    arr40 := make([]int, len(arr))\n    arr41\
    \ := make([]int, len(arr))\n    arr42 := make([]int, len(arr))\n    arr43 := make([]int,\
    \ len(arr))\n    arr\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpn18y7qza_test.go:77:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074607
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    m := make(map[int]int)\n    for _, v := range arr {\n        m[v]++\n\
    \    }\n    arr2 := make([]int, 0, len(m))\n    for _, v := range m {\n      \
    \  if v%2 == 0 {\n            arr2 = append(arr2, v)\n        }\n    }\n    if\
    \ len(arr2) == 0 {\n        return nil\n    }\n    return arr2\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__0 (0.00s)\n\
    \        tmpc0_63qxq_test.go:70: expected '[%!s(int=2) %!s(int=1)]', got '[]'\n\
    \    --- FAIL: TestPluck/test_num__1 (0.00s)\n        tmpc0_63qxq_test.go:70:\
    \ expected '[%!s(int=2) %!s(int=1)]', got '[]'\n    --- FAIL: TestPluck/test_num__3\
    \ (0.00s)\n        tmpc0_63qxq_test.go:70: expected '[%!s(int=0) %!s(int=1)]',\
    \ got '[%!s(int=2)]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmpc0_63qxq_test.go:70:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[%!s(int=2)]'\n    --- FAIL: TestPluck/test_num__5\
    \ (0.00s)\n        tmpc0_63qxq_test.go:70: expected '[%!s(int=4) %!s(int=1)]',\
    \ got '[%!s(int=2) %!s(int=2)]'\n    --- FAIL: TestPluck/test_num__6 (0.00s)\n\
    \        tmpc0_63qxq_test.go:70: expected '[%!s(int=6) %!s(int=1)]', got '[%!s(int=2)]'\n\
    \    --- FAIL: TestPluck/test_num__7 (0.00s)\n        tmpc0_63qxq_test.go:70:\
    \ expected '[]', got '[%!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074613
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    min := arr[0]\n\
    \    index := 0\n    for _, val := range arr {\n        if val%2 == 0 {\n    \
    \        if val < min {\n                min = val\n                index = index\n\
    \            }\n        }\n    }\n    return []int{min, index}\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__0 (0.00s)\n\
    \        tmpdo7q5f_7_test.go:70: expected '[%!s(int=2) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=0)]'\n    --- FAIL: TestPluck/test_num__1 (0.00s)\n        tmpdo7q5f_7_test.go:70:\
    \ expected '[%!s(int=2) %!s(int=1)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL:\
    \ TestPluck/test_num__3 (0.00s)\n        tmpdo7q5f_7_test.go:70: expected '[%!s(int=0)\
    \ %!s(int=1)]', got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestPluck/test_num__4\
    \ (0.00s)\n        tmpdo7q5f_7_test.go:70: expected '[%!s(int=0) %!s(int=3)]',\
    \ got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestPluck/test_num__5 (0.00s)\n\
    \        tmpdo7q5f_7_test.go:70: expected '[%!s(int=4) %!s(int=1)]', got '[%!s(int=4)\
    \ %!s(int=0)]'\n    --- FAIL: TestPluck/test_num__6 (0.00s)\n        tmpdo7q5f_7_test.go:70:\
    \ expected '[%!s(int=6) %!s(int=1)]', got '[%!s(int=6) %!s(int=0)]'\n    --- FAIL:\
    \ TestPluck/test_num__7 (0.00s)\n        tmpdo7q5f_7_test.go:70: expected '[]',\
    \ got '[%!s(int=7) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074613
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    // write your code here\n    sort.Ints(arr)\n    var index int\n    var\
    \ smalest_value int\n    for _, value := range arr {\n        if value%2 == 0\
    \ {\n            smalest_value = value\n            index = arr[:].index(value)\n\
    \        }\n    }\n    if smalest_value == 0 {\n        return []int{}\n    }\n\
    \    return []int{smalest_value, index}\n}\n\nfunc TestPluck(t *testing.T) {\n\
    \  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4, 2,\
    \ 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n  \
    \   { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n \
    \    { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n\
    \     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n  \
    \   { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     { actual:\
    \ candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprf6e3cw__test.go:35:5: undefined: sort

    /tmp/tmprf6e3cw__test.go:41:28: arr[:].index undefined (type []int has no field
    or method index)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074613
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    sort.Sort(sort.Reverse(sort.IntSlice(arr)))\n    index := 0\n    smalest_value\
    \ := arr[0]\n    smalest_index := 0\n    for _, value := range arr {\n       \
    \ if value%2 == 0 {\n            if value < smalest_value {\n                smalest_value\
    \ = value\n                smalest_index = index\n            }\n            index++\n\
    \        }\n    }\n    return []int{smalest_value, smalest_index}\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqqzl8l1p_test.go:34:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074613
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    result := make([]int, 0)\n    min := arr[0]\n    index := 0\n    for\
    \ _, v := range arr {\n        if v%2 == 0 {\n            if min > v {\n     \
    \           min = v\n                index = index\n            }\n        } else\
    \ {\n            if min > v {\n                min = v\n                index\
    \ = index\n            }\n        }\n    }\n    result = append(result, min)\n\
    \    result = append(result, index)\n    return result\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\npanic: runtime error: index out of range [0]\
    \ with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with\
    \ length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440, 0xc000014360})\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.pluck(...)\n\t/tmp/tmpcs680i9__test.go:35\n\
    command-line-arguments_test.TestPluck(0x0?)\n\t/tmp/tmpcs680i9__test.go:64 +0x1b0\n\
    testing.tRunner(0xc0001924e0, 0x527d38)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074609
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    sort.Ints(arr)\n    smalest_value := arr[0]\n    smalest_index := 0\n\
    \    for _, value := range arr {\n        if value%2 == 0 {\n            if value\
    \ < smalest_value {\n                smalest_value = value\n                smalest_index\
    \ = sort.Search(len(arr), func(i int) bool {\n                    return arr[i]\
    \ < value\n                })\n            }\n        }\n    }\n    return []int{smalest_value,\
    \ smalest_index}\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6cjw7rsb_test.go:34:5: undefined: sort

    /tmp/tmp6cjw7rsb_test.go:41:33: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074608
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    m := make(map[int]int)\n    for _, v := range arr {\n        m[v] = m[v]\
    \ + 1\n    }\n    arr2 := make([]int, 0, len(m))\n    for _, v := range m {\n\
    \        if v%2 == 0 {\n            arr2 = append(arr2, v)\n        }\n    }\n\
    \    if len(arr2) == 0 {\n        return nil\n    }\n    arr3 := make([]int, 0,\
    \ len(arr2))\n    for _, v := range arr2 {\n        if v%2 == 0 {\n          \
    \  arr3 = append(arr3, v)\n        }\n    }\n    if len(arr3) == 0 {\n       \
    \ return nil\n    }\n    arr4 := make([]int, 0, len(arr3))\n    for _, v := range\
    \ arr3 {\n        if v%2 == 0 {\n            arr4 = append(arr4, v)\n        }\n\
    \    }\n    if len(arr4) == 0 {\n        return nil\n    }\n    arr5 := make([]int,\
    \ 0, len(arr4))\n    for _, v := range arr4 {\n        if v%2 == 0 {\n       \
    \     arr5 = append(arr5, v)\n        }\n    }\n    if len(arr5) == 0 {\n    \
    \    return nil\n    }\n    arr6 := make([]int, 0, len(arr5))\n    for _, v :=\
    \ range arr5 {\n        if v%2 == 0 {\n            arr6 = append(arr6, v)\n  \
    \      }\n    }\n    if len(arr6) == 0 {\n        return nil\n    }\n    arr7\
    \ := make([]int, 0, len(arr6))\n    for _, v := range arr6 {\n        if v%2 ==\
    \ 0 {\n            arr7 = append(arr7, v)\n        }\n    }\n    if len(arr7)\
    \ == 0 {\n        return nil\n    }\n    arr8 := make([]int, 0, len(arr7))\n \
    \   for _, v := range arr7 {\n        if v%2 == 0 {\n            arr8 = append(arr8,\
    \ v)\n        }\n    }\n    if len(arr8) == 0 {\n        return nil\n    }\n \
    \   arr9 := make([]int, 0, len(arr8))\n    for _, v := range arr8 {\n        if\
    \ v%2 == 0 {\n            arr9 = append(arr9, v)\n        }\n    }\n    if len(arr9)\
    \ == 0 {\n        return nil\n    }\n    arr10 := make([]int, 0, len(arr9))\n\
    \    for _, v := range arr9 {\n        if v%2 == 0 {\n            arr10 = append(arr10,\
    \ v)\n        }\n    }\n    if len(arr10) == 0 {\n        return nil\n    }\n\
    \    arr11 := make([]int, 0, len(arr10))\n    for _, v := range arr10 {\n    \
    \    if v%2 == 0 {\n            arr11 = append(arr11, v)\n        }\n    }\nfunc\
    \ TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp23l7rem2_test.go:125:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074612
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    result := make([]int, 0)\n    min := arr[0]\n    index := 0\n    for\
    \ _, v := range arr {\n        if v%2 == 0 {\n            if min > v {\n     \
    \           min = v\n                index = index\n            }\n        } else\
    \ {\n            if min > v {\n                min = v\n                index\
    \ = index\n            }\n        }\n    }\n    result = append(result, min)\n\
    \    result = append(result, index)\n    return result\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\npanic: runtime error: index out of range [0]\
    \ with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with\
    \ length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440, 0xc000014360})\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.pluck(...)\n\t/tmp/tmpcs680i9__test.go:35\n\
    command-line-arguments_test.TestPluck(0x0?)\n\t/tmp/tmpcs680i9__test.go:64 +0x1b0\n\
    testing.tRunner(0xc0001924e0, 0x527d38)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074609
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    sort.Ints(arr)\n    index := 0\n    smalest := arr[0]\n    for _, v :=\
    \ range arr {\n        if v%2 == 0 {\n            if smalest == 0 || v < smalest\
    \ {\n                smalest = v\n                index = index + 1\n        \
    \    }\n        }\n    }\n    return []int{smalest, index}\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0908vq73_test.go:34:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074613
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    min := arr[0]\n\
    \    index := 0\n    for _, v := range arr {\n        if v%2 == 0 {\n        \
    \    if min > v {\n                min = v\n                index = index\n  \
    \          }\n        } else {\n            if min > v {\n                min\
    \ = v\n            }\n        }\n    }\n    return []int{min, index}\n}\n`\n\n\
    func TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp04bseg54_test.go:53:1: raw string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074613
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    arr2 := make([]int, len(arr))\n    arr3 := make([]int, len(arr))\n  \
    \  arr4 := make([]int, len(arr))\n    arr5 := make([]int, len(arr))\n    arr6\
    \ := make([]int, len(arr))\n    arr7 := make([]int, len(arr))\n    arr8 := make([]int,\
    \ len(arr))\n    arr9 := make([]int, len(arr))\n    arr10 := make([]int, len(arr))\n\
    \    arr11 := make([]int, len(arr))\n    arr12 := make([]int, len(arr))\n    arr13\
    \ := make([]int, len(arr))\n    arr14 := make([]int, len(arr))\n    arr15 := make([]int,\
    \ len(arr))\n    arr16 := make([]int, len(arr))\n    arr17 := make([]int, len(arr))\n\
    \    arr18 := make([]int, len(arr))\n    arr19 := make([]int, len(arr))\n    arr20\
    \ := make([]int, len(arr))\n    arr21 := make([]int, len(arr))\n    arr22 := make([]int,\
    \ len(arr))\n    arr23 := make([]int, len(arr))\n    arr24 := make([]int, len(arr))\n\
    \    arr25 := make([]int, len(arr))\n    arr26 := make([]int, len(arr))\n    arr27\
    \ := make([]int, len(arr))\n    arr28 := make([]int, len(arr))\n    arr29 := make([]int,\
    \ len(arr))\n    arr30 := make([]int, len(arr))\n    arr31 := make([]int, len(arr))\n\
    \    arr32 := make([]int, len(arr))\n    arr33 := make([]int, len(arr))\n    arr34\
    \ := make([]int, len(arr))\n    arr35 := make([]int, len(arr))\n    arr36 := make([]int,\
    \ len(arr))\n    arr37 := make([]int, len(arr))\n    arr38 := make([]int, len(arr))\n\
    \    arr39 := make([]int, len(arr))\n    arr40 := make([]int, len(arr))\n    arr41\
    \ := make([]int, len(arr))\n    arr42 := make([]int, len(arr))\n    arr43 := make([]int,\
    \ len(arr))\n    arr\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpn18y7qza_test.go:77:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074607
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    smalest_value\
    \ := arr[0]\n    smalest_index := 0\n    for _, value := range arr {\n       \
    \ if value%2 == 0 {\n            if value < smalest_value {\n                smalest_value\
    \ = value\n                smalest_index = index\n            }\n        }\n \
    \   }\n    return []int{smalest_value, smalest_index}\n}\n\nfunc TestPluck(t *testing.T)\
    \ {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7_ruu2ia_test.go:43:33: undefined: index

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074613
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    arr2 := make([]int, len(arr))\n    arr3 := make([]int, len(arr))\n  \
    \  arr4 := make([]int, len(arr))\n    arr5 := make([]int, len(arr))\n    arr6\
    \ := make([]int, len(arr))\n    arr7 := make([]int, len(arr))\n    arr8 := make([]int,\
    \ len(arr))\n    arr9 := make([]int, len(arr))\n    arr10 := make([]int, len(arr))\n\
    \    arr11 := make([]int, len(arr))\n    arr12 := make([]int, len(arr))\n    arr13\
    \ := make([]int, len(arr))\n    arr14 := make([]int, len(arr))\n    arr15 := make([]int,\
    \ len(arr))\n    arr16 := make([]int, len(arr))\n    arr17 := make([]int, len(arr))\n\
    \    arr18 := make([]int, len(arr))\n    arr19 := make([]int, len(arr))\n    arr20\
    \ := make([]int, len(arr))\n    arr21 := make([]int, len(arr))\n    arr22 := make([]int,\
    \ len(arr))\n    arr23 := make([]int, len(arr))\n    arr24 := make([]int, len(arr))\n\
    \    arr25 := make([]int, len(arr))\n    arr26 := make([]int, len(arr))\n    arr27\
    \ := make([]int, len(arr))\n    arr28 := make([]int, len(arr))\n    arr29 := make([]int,\
    \ len(arr))\n    arr30 := make([]int, len(arr))\n    arr31 := make([]int, len(arr))\n\
    \    arr32 := make([]int, len(arr))\n    arr33 := make([]int, len(arr))\n    arr34\
    \ := make([]int, len(arr))\n    arr35 := make([]int, len(arr))\n    arr36 := make([]int,\
    \ len(arr))\n    arr37 := make([]int, len(arr))\n    arr38 := make([]int, len(arr))\n\
    \    arr39 := make([]int, len(arr))\n    arr40 := make([]int, len(arr))\n    arr41\
    \ := make([]int, len(arr))\n    arr42 := make([]int, len(arr))\n    arr43 := make([]int,\
    \ len(arr))\n    arr\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpn18y7qza_test.go:77:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074607
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    result := make([]int, 0)\n    min := arr[0]\n    index := 0\n    for\
    \ _, v := range arr {\n        if v%2 == 0 {\n            if v < min {\n     \
    \           min = v\n                index = index\n            }\n        } else\
    \ {\n            if min == v {\n                index = index\n            }\n\
    \        }\n    }\n    result = append(result, min)\n    result = append(result,\
    \ index)\n    return result\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate\
    \ := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual:\
    \ candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual:\
    \ candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7,\
    \ 6, 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7,\
    \ 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\npanic: runtime error: index out of range [0]\
    \ with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with\
    \ length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440, 0xc000014360})\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.pluck(...)\n\t/tmp/tmpp3mql4a7_test.go:35\n\
    command-line-arguments_test.TestPluck(0x0?)\n\t/tmp/tmpp3mql4a7_test.go:63 +0x1a5\n\
    testing.tRunner(0xc0001924e0, 0x527d38)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074614
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var result []int\n    var minVal int\n    var minIndex int\n    for _,\
    \ v := range arr {\n        if v%2 == 0 {\n            if minVal == 0 || minVal\
    \ > v {\n                minVal = v\n                minIndex = v\n          \
    \  }\n        } else {\n            if minVal == 0 || minVal > v {\n         \
    \       minVal = v\n                minIndex = v\n            }\n        }\n \
    \   }\n    result = append(result, minVal)\n    result = append(result, minIndex)\n\
    \    return result\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__0 (0.00s)\n\
    \        tmpd_k908mp_test.go:75: expected '[%!s(int=2) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=2)]'\n    --- FAIL: TestPluck/test_num__1 (0.00s)\n        tmpd_k908mp_test.go:75:\
    \ expected '[%!s(int=2) %!s(int=1)]', got '[%!s(int=1) %!s(int=1)]'\n    --- FAIL:\
    \ TestPluck/test_num__2 (0.00s)\n        tmpd_k908mp_test.go:75: expected '[]',\
    \ got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestPluck/test_num__3 (0.00s)\n\
    \        tmpd_k908mp_test.go:75: expected '[%!s(int=0) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=2)]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmpd_k908mp_test.go:75:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[%!s(int=3) %!s(int=3)]'\n    --- FAIL:\
    \ TestPluck/test_num__5 (0.00s)\n        tmpd_k908mp_test.go:75: expected '[%!s(int=4)\
    \ %!s(int=1)]', got '[%!s(int=4) %!s(int=4)]'\n    --- FAIL: TestPluck/test_num__6\
    \ (0.00s)\n        tmpd_k908mp_test.go:75: expected '[%!s(int=6) %!s(int=1)]',\
    \ got '[%!s(int=1) %!s(int=1)]'\n    --- FAIL: TestPluck/test_num__7 (0.00s)\n\
    \        tmpd_k908mp_test.go:75: expected '[]', got '[%!s(int=1) %!s(int=1)]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074614
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    sort.Ints(arr)\n    smalest_value := arr[0]\n    smalest_index := 0\n\
    \    for _, value := range arr {\n        if value%2 == 0 {\n            if value\
    \ < smalest_value {\n                smalest_value = value\n                smalest_index\
    \ = sort.Search(len(arr), func(i int) bool {\n                    return arr[i]\
    \ < value\n                })\n            }\n        }\n    }\n    return []int{smalest_value,\
    \ smalest_index}\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6cjw7rsb_test.go:34:5: undefined: sort

    /tmp/tmp6cjw7rsb_test.go:41:33: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074608
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    result := make([]int, 0)\n    min := arr[0]\n    index := 0\n    for\
    \ _, v := range arr {\n        if v%2 == 0 {\n            if min > v {\n     \
    \           min = v\n                index = index\n            }\n        } else\
    \ {\n            if min > v {\n                min = v\n                index\
    \ = index\n            }\n        }\n    }\n    result = append(result, min)\n\
    \    result = append(result, index)\n    return result\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\npanic: runtime error: index out of range [0]\
    \ with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with\
    \ length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440, 0xc000014360})\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.pluck(...)\n\t/tmp/tmpcs680i9__test.go:35\n\
    command-line-arguments_test.TestPluck(0x0?)\n\t/tmp/tmpcs680i9__test.go:64 +0x1b0\n\
    testing.tRunner(0xc0001924e0, 0x527d38)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074609
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    min := arr[0]\n\
    \    index := 0\n    for _, v := range arr {\n        if v%2 == 0 {\n        \
    \    min = v\n            index = index + 1\n        }\n    }\n    return []int{min,\
    \ index}\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n   \
    \  { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__0 (0.00s)\n\
    \        tmptefn8i4x_test.go:68: expected '[%!s(int=2) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=2)]'\n    --- FAIL: TestPluck/test_num__3 (0.00s)\n        tmptefn8i4x_test.go:68:\
    \ expected '[%!s(int=0) %!s(int=1)]', got '[%!s(int=2) %!s(int=4)]'\n    --- FAIL:\
    \ TestPluck/test_num__4 (0.00s)\n        tmptefn8i4x_test.go:68: expected '[%!s(int=0)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=2)]'\n    --- FAIL: TestPluck/test_num__5\
    \ (0.00s)\n        tmptefn8i4x_test.go:68: expected '[%!s(int=4) %!s(int=1)]',\
    \ got '[%!s(int=8) %!s(int=4)]'\n    --- FAIL: TestPluck/test_num__7 (0.00s)\n\
    \        tmptefn8i4x_test.go:68: expected '[]', got '[%!s(int=7) %!s(int=0)]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074614
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    // write your code here\n    arr2 := make([]int, len(arr))\n    arr3\
    \ := make([]int, len(arr))\n    arr4 := make([]int, len(arr))\n    arr5 := make([]int,\
    \ len(arr))\n    arr6 := make([]int, len(arr))\n    arr7 := make([]int, len(arr))\n\
    \    arr8 := make([]int, len(arr))\n    arr9 := make([]int, len(arr))\n    arr10\
    \ := make([]int, len(arr))\n    arr11 := make([]int, len(arr))\n    arr12 := make([]int,\
    \ len(arr))\n    arr13 := make([]int, len(arr))\n    arr14 := make([]int, len(arr))\n\
    \    arr15 := make([]int, len(arr))\n    arr16 := make([]int, len(arr))\n    arr17\
    \ := make([]int, len(arr))\n    arr18 := make([]int, len(arr))\n    arr19 := make([]int,\
    \ len(arr))\n    arr20 := make([]int, len(arr))\n    arr21 := make([]int, len(arr))\n\
    \    arr22 := make([]int, len(arr))\n    arr23 := make([]int, len(arr))\n    arr24\
    \ := make([]int, len(arr))\n    arr25 := make([]int, len(arr))\n    arr26 := make([]int,\
    \ len(arr))\n    arr27 := make([]int, len(arr))\n    arr28 := make([]int, len(arr))\n\
    \    arr29 := make([]int, len(arr))\n    arr30 := make([]int, len(arr))\n    arr31\
    \ := make([]int, len(arr))\n    arr32 := make([]int, len(arr))\n    arr33 := make([]int,\
    \ len(arr))\n    arr34 := make([]int, len(arr))\n    arr35 := make([]int, len(arr))\n\
    \    arr36 := make([]int, len(arr))\n    arr37 := make([]int, len(arr))\n    arr38\
    \ := make([]int, len(arr))\n    arr39 := make([]int, len(arr))\n    arr40 := make([]int,\
    \ len(arr))\n    arr41 := make([]int, len(arr))\n    arr42 := make([]int, len(arr))\n\
    \    arr43 := make([]int, len(\nfunc TestPluck(t *testing.T) {\n  candidate :=\
    \ pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual:\
    \ candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual:\
    \ candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7,\
    \ 6, 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7,\
    \ 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp5dlexyft_test.go:77:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074607
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    n := len(arr)\n    result := make([]int, n)\n    min := arr[0]\n    index\
    \ := 0\n    for i := 0; i < n; i++ {\n        if arr[i] < min {\n            min\
    \ = arr[i]\n            index = i\n        }\n    }\n    result[index] = min\n\
    \    return result\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\npanic: runtime error: index out of range [0]\
    \ with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with\
    \ length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440, 0xc000014390})\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x512440,\
    \ 0xc000014390})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.pluck(...)\n\t/tmp/tmpzhouzz99_test.go:36\n\
    command-line-arguments_test.TestPluck(0x0?)\n\t/tmp/tmpzhouzz99_test.go:57 +0x135\n\
    testing.tRunner(0xc0001924e0, 0x527d38)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074609
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    sort.Sort(sort.Reverse(sort.IntSlice(arr)))\n    smalest_value := arr[0]\n\
    \    smalest_index := 0\n    for i := 1; i < len(arr); i++ {\n        if arr[i]\
    \ < smalest_value {\n            smalest_value = arr[i]\n            smalest_index\
    \ = i\n        }\n    }\n    return []int{smalest_value, smalest_index}\n}\n\n\
    func TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpeac4ren7_test.go:34:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074614
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    result := make([]int, 0)\n    min := arr[0]\n    index := 0\n    for\
    \ _, value := range arr {\n        if value%2 == 0 {\n            if value < min\
    \ {\n                min = value\n                index = index\n            }\n\
    \        } else {\n            if min > value {\n                min = value\n\
    \                index = index\n            }\n        }\n    }\n    result =\
    \ append(result, min)\n    result = append(result, index)\n    return result\n\
    }\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\npanic: runtime error: index out of range [0]\
    \ with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with\
    \ length 0\n\ngoroutine 34 [running]:\ntesting.tRunner.func1.2({0x512440, 0xc0001d6000})\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x512440,\
    \ 0xc0001d6000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.pluck(...)\n\t/tmp/tmps3fulh75_test.go:35\n\
    command-line-arguments_test.TestPluck(0x0?)\n\t/tmp/tmps3fulh75_test.go:64 +0x1b0\n\
    testing.tRunner(0xc000199040, 0x527d38)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074614
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var result []int\n    var minVal int\n    var minIndex int\n    for _,\
    \ v := range arr {\n        if v%2 == 0 {\n            if minVal == 0 || v < minVal\
    \ {\n                minVal = v\n                minIndex = arr[v]\n         \
    \   }\n        } else {\n            if minVal == 0 || v < minVal {\n        \
    \        minVal = v\n                minIndex = arr[v]\n            }\n      \
    \  }\n    }\n    result = append(result, minVal)\n    result = append(result,\
    \ minIndex)\n    return result\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate\
    \ := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual:\
    \ candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual:\
    \ candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7,\
    \ 6, 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7,\
    \ 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\npanic: runtime error: index out of range [4]\
    \ with length 3 [recovered]\n\tpanic: runtime error: index out of range [4] with\
    \ length 3\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513680, 0xc000014360})\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x513680,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.pluck(...)\n\t/tmp/tmpiuax06rb_test.go:41\n\
    command-line-arguments_test.TestPluck(0x0?)\n\t/tmp/tmpiuax06rb_test.go:62 +0xeff\n\
    testing.tRunner(0xc0001a0340, 0x528f98)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074614
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    // write your code here\n    \n    arrSorted := make([]int, len(arr))\n\
    \    for i := 0; i < len(arr); i++ {\n        arrSorted[i] = arr[i]\n    }\n \
    \   arrSorted = append(arrSorted, 0)\n    arrSorted = append(arrSorted, 0)\n \
    \   \n    smallestEven := 0\n    smallestIndex := 0\n    \n    for i := 1; i <\
    \ len(arr); i++ {\n        if arrSorted[i-1]%2 == 0 {\n            smallestEven\
    \ = arrSorted[i-1]\n            smallestIndex = i\n        }\n    }\n    \n  \
    \  if smallestEven == 0 {\n        return []int{}\n    }\n    \n    arrSorted\
    \ = append(arrSorted, smallestEven)\n    arrSorted = append(arrSorted, smallestIndex)\n\
    \    \n    return arrSorted\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate\
    \ := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual:\
    \ candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual:\
    \ candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7,\
    \ 6, 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7,\
    \ 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__0 (0.00s)\n\
    \        tmpieewkd00_test.go:83: expected '[%!s(int=2) %!s(int=1)]', got '[%!s(int=4)\
    \ %!s(int=2) %!s(int=3) %!s(int=0) %!s(int=0) %!s(int=2) %!s(int=2)]'\n    ---\
    \ FAIL: TestPluck/test_num__1 (0.00s)\n        tmpieewkd00_test.go:83: expected\
    \ '[%!s(int=2) %!s(int=1)]', got '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=0)\
    \ %!s(int=0) %!s(int=2) %!s(int=2)]'\n    --- FAIL: TestPluck/test_num__3 (0.00s)\n\
    \        tmpieewkd00_test.go:83: expected '[%!s(int=0) %!s(int=1)]', got '[%!s(int=5)\
    \ %!s(int=0) %!s(int=3) %!s(int=0) %!s(int=4) %!s(int=2) %!s(int=0) %!s(int=0)\
    \ %!s(int=4) %!s(int=5)]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n     \
    \   tmpieewkd00_test.go:83: expected '[%!s(int=0) %!s(int=3)]', got '[]'\n   \
    \ --- FAIL: TestPluck/test_num__5 (0.00s)\n        tmpieewkd00_test.go:83: expected\
    \ '[%!s(int=4) %!s(int=1)]', got '[%!s(int=5) %!s(int=4) %!s(int=8) %!s(int=4)\
    \ %!s(int=8) %!s(int=0) %!s(int=0) %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestPluck/test_num__6\
    \ (0.00s)\n        tmpieewkd00_test.go:83: expected '[%!s(int=6) %!s(int=1)]',\
    \ got '[%!s(int=7) %!s(int=6) %!s(int=7) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=6)\
    \ %!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074614
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    sort.Ints(arr)\n    smalest_value := arr[0]\n    smalest_index := 0\n\
    \    for _, value := range arr {\n        if value%2 == 0 {\n            if value\
    \ < smalest_value {\n                smalest_value = value\n                smalest_index\
    \ = sort.Search(len(arr), func(i int) bool {\n                    return arr[i]\
    \ < value\n                })\n            }\n        }\n    }\n    return []int{smalest_value,\
    \ smalest_index}\n}\n`\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpffu52ry8_test.go:49:1: raw string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074609
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var result []int\n    var minVal int\n    var minIndex int\n    for _,\
    \ v := range arr {\n        if v%2 == 0 {\n            if minVal == 0 || v < minVal\
    \ {\n                minVal = v\n                minIndex = v\n            }\n\
    \        } else {\n            if minVal == 0 || v < minVal {\n              \
    \  minVal = v\n                minIndex = v\n            }\n        }\n    }\n\
    \    result = append(result, minVal)\n    result = append(result, minIndex)\n\
    \    return result\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__0 (0.00s)\n\
    \        tmph_j4x92q_test.go:75: expected '[%!s(int=2) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=2)]'\n    --- FAIL: TestPluck/test_num__1 (0.00s)\n        tmph_j4x92q_test.go:75:\
    \ expected '[%!s(int=2) %!s(int=1)]', got '[%!s(int=1) %!s(int=1)]'\n    --- FAIL:\
    \ TestPluck/test_num__2 (0.00s)\n        tmph_j4x92q_test.go:75: expected '[]',\
    \ got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestPluck/test_num__3 (0.00s)\n\
    \        tmph_j4x92q_test.go:75: expected '[%!s(int=0) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=2)]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmph_j4x92q_test.go:75:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[%!s(int=3) %!s(int=3)]'\n    --- FAIL:\
    \ TestPluck/test_num__5 (0.00s)\n        tmph_j4x92q_test.go:75: expected '[%!s(int=4)\
    \ %!s(int=1)]', got '[%!s(int=4) %!s(int=4)]'\n    --- FAIL: TestPluck/test_num__6\
    \ (0.00s)\n        tmph_j4x92q_test.go:75: expected '[%!s(int=6) %!s(int=1)]',\
    \ got '[%!s(int=1) %!s(int=1)]'\n    --- FAIL: TestPluck/test_num__7 (0.00s)\n\
    \        tmph_j4x92q_test.go:75: expected '[]', got '[%!s(int=1) %!s(int=1)]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074614
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    sort.Ints(arr)\n    index := 0\n    smalest_value := arr[0]\n    smalest_index\
    \ := 0\n    for _, value := range arr {\n        if value%2 == 0 {\n         \
    \   if value < smalest_value {\n                smalest_value = value\n      \
    \          smalest_index = index\n            }\n            index++\n       \
    \ }\n    }\n    return []int{smalest_value, smalest_index}\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4tb_t0mh_test.go:34:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074608
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    result := make([]int, 0)\n    min := arr[0]\n    index := 0\n    for\
    \ _, v := range arr {\n        if v%2 == 0 {\n            if min > v {\n     \
    \           min = v\n                index = index\n            }\n        } else\
    \ {\n            if min > v {\n                min = v\n                index\
    \ = index\n            }\n        }\n    }\n    result = append(result, min)\n\
    \    result = append(result, index)\n    return result\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\npanic: runtime error: index out of range [0]\
    \ with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with\
    \ length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440, 0xc000014360})\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.pluck(...)\n\t/tmp/tmpcs680i9__test.go:35\n\
    command-line-arguments_test.TestPluck(0x0?)\n\t/tmp/tmpcs680i9__test.go:64 +0x1b0\n\
    testing.tRunner(0xc0001924e0, 0x527d38)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074609
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    result := make([]int, 0)\n    min := arr[0]\n    index := 0\n    for\
    \ _, v := range arr {\n        if v%2 == 0 {\n            if min > v {\n     \
    \           min = v\n                index = index\n            }\n        } else\
    \ {\n            if min > v {\n                min = v\n            }\n      \
    \  }\n    }\n    result = append(result, min)\n    result = append(result, index)\n\
    \    return result\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\npanic: runtime error: index out of range [0]\
    \ with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with\
    \ length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440, 0xc000014360})\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.pluck(...)\n\t/tmp/tmprzcozqhs_test.go:35\n\
    command-line-arguments_test.TestPluck(0x0?)\n\t/tmp/tmprzcozqhs_test.go:63 +0x1b0\n\
    testing.tRunner(0xc0001924e0, 0x527d38)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074614
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    m := make(map[int]int)\n    for _, v := range arr {\n        m[v]++\n\
    \    }\n    arr2 := make([]int, 0, len(m))\n    for k, v := range m {\n      \
    \  if v == 0 {\n            continue\n        }\n        if v%2 == 0 {\n     \
    \       arr2 = append(arr2, k)\n        }\n    }\n    if len(arr2) == 0 {\n  \
    \      return nil\n    }\n    arr3 := make([]int, 0, len(arr2))\n    for _, v\
    \ := range arr2 {\n        arr3 = append(arr3, v)\n    }\n    return arr3\n}\n\
    \nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__0 (0.00s)\n\
    \        tmp_4f3tr37_test.go:77: expected '[%!s(int=2) %!s(int=1)]', got '[]'\n\
    \    --- FAIL: TestPluck/test_num__1 (0.00s)\n        tmp_4f3tr37_test.go:77:\
    \ expected '[%!s(int=2) %!s(int=1)]', got '[]'\n    --- FAIL: TestPluck/test_num__3\
    \ (0.00s)\n        tmp_4f3tr37_test.go:77: expected '[%!s(int=0) %!s(int=1)]',\
    \ got '[%!s(int=0)]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmp_4f3tr37_test.go:77:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[%!s(int=3)]'\n    --- FAIL: TestPluck/test_num__5\
    \ (0.00s)\n        tmp_4f3tr37_test.go:77: expected '[%!s(int=4) %!s(int=1)]',\
    \ got '[%!s(int=4) %!s(int=8)]'\n    --- FAIL: TestPluck/test_num__6 (0.00s)\n\
    \        tmp_4f3tr37_test.go:77: expected '[%!s(int=6) %!s(int=1)]', got '[%!s(int=7)]'\n\
    \    --- FAIL: TestPluck/test_num__7 (0.00s)\n        tmp_4f3tr37_test.go:77:\
    \ expected '[]', got '[%!s(int=7)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074614
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    sort.Sort(sort.Reverse(sort.IntSlice(arr)))\n    result := make([]int,\
    \ 0)\n    index := 0\n    for _, v := range arr {\n        if v%2 == 0 {\n   \
    \         result = append(result, v)\n            index = index + 1\n        }\n\
    \    }\n    if index == 0 {\n        return nil\n    }\n    return result\n}\n\
    \nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpseyy4_ym_test.go:34:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074614
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    // write your code here\n    arr2 := make([]int, len(arr))\n    min :=\
    \ 0\n    max := 0\n    index := 0\n    for i := 0; i < len(arr); i++ {\n     \
    \   if arr[i] > max {\n            max = arr[i]\n        }\n        if arr[i]\
    \ < min {\n            min = arr[i]\n        }\n    }\n    for i := 0; i < len(arr);\
    \ i++ {\n        if arr[i] == min {\n            arr2[index] = arr[i]\n      \
    \      index++\n        }\n    }\n    if index == 0 {\n        return nil\n  \
    \  }\n    return arr2\n}\n`\n\nfunc TestPluck(t *testing.T) {\n  candidate :=\
    \ pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual:\
    \ candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual:\
    \ candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7,\
    \ 6, 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7,\
    \ 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpsz311hfd_test.go:58:1: raw string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074614
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    sort.Ints(arr)\n    smalest_value := arr[0]\n    smalest_index := 0\n\
    \    for _, value := range arr {\n        if value%2 == 0 {\n            if value\
    \ < smalest_value {\n                smalest_value = value\n                smalest_index\
    \ = sort.Search(len(arr), func(i int) bool {\n                    return arr[i]\
    \ < value\n                })\n            }\n        }\n    }\n    return []int{smalest_value,\
    \ smalest_index}\n}\n`\n)\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpmov8wlk6_test.go:49:1: raw string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074610
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var result []int\n    var minVal int\n    var minIndex int\n    for _,\
    \ val := range arr {\n        if val%2 == 0 {\n            if minVal == 0 || val\
    \ < minVal {\n                minVal = val\n                minIndex = arr\n \
    \           }\n        } else {\n            if minVal == 0 || val > minVal {\n\
    \                minVal = val\n                minIndex = arr\n            }\n\
    \        }\n    }\n    if minVal == 0 {\n        return []int{}\n    }\n    result\
    \ = append(result, minVal)\n    result = append(result, minIndex)\n    return\
    \ result\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n   \
    \  { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpok83161j_test.go:41:28: cannot use arr (variable of type []int) as type
    int in assignment

    /tmp/tmpok83161j_test.go:46:28: cannot use arr (variable of type []int) as type
    int in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074614
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var result []int\n    var index int\n    var smallestEven int\n    for\
    \ _, v := range arr {\n        if v%2 == 0 {\n            smallestEven = v\n \
    \       }\n    }\n    for _, v := range arr {\n        if v%2 == 0 {\n       \
    \     if smallestEven == v {\n                index = v\n            } else {\n\
    \                index = smallestEven\n            }\n        }\n    }\n    result\
    \ = append(result, smallestEven)\n    result = append(result, index)\n    return\
    \ result\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n   \
    \  { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__0 (0.00s)\n\
    \        tmp77qk1g43_test.go:76: expected '[%!s(int=2) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=2)]'\n    --- FAIL: TestPluck/test_num__1 (0.00s)\n        tmp77qk1g43_test.go:76:\
    \ expected '[%!s(int=2) %!s(int=1)]', got '[%!s(int=2) %!s(int=2)]'\n    --- FAIL:\
    \ TestPluck/test_num__2 (0.00s)\n        tmp77qk1g43_test.go:76: expected '[]',\
    \ got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestPluck/test_num__3 (0.00s)\n\
    \        tmp77qk1g43_test.go:76: expected '[%!s(int=0) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=2)]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmp77qk1g43_test.go:76:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL:\
    \ TestPluck/test_num__5 (0.00s)\n        tmp77qk1g43_test.go:76: expected '[%!s(int=4)\
    \ %!s(int=1)]', got '[%!s(int=8) %!s(int=8)]'\n    --- FAIL: TestPluck/test_num__6\
    \ (0.00s)\n        tmp77qk1g43_test.go:76: expected '[%!s(int=6) %!s(int=1)]',\
    \ got '[%!s(int=6) %!s(int=6)]'\n    --- FAIL: TestPluck/test_num__7 (0.00s)\n\
    \        tmp77qk1g43_test.go:76: expected '[]', got '[%!s(int=0) %!s(int=0)]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074615
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    arr2 := make([]int, len(arr))\n    arr3 := make([]int, len(arr))\n  \
    \  arr4 := make([]int, len(arr))\n    arr5 := make([]int, len(arr))\n    arr6\
    \ := make([]int, len(arr))\n    arr7 := make([]int, len(arr))\n    arr8 := make([]int,\
    \ len(arr))\n    arr9 := make([]int, len(arr))\n    arr10 := make([]int, len(arr))\n\
    \    arr11 := make([]int, len(arr))\n    arr12 := make([]int, len(arr))\n    arr13\
    \ := make([]int, len(arr))\n    arr14 := make([]int, len(arr))\n    arr15 := make([]int,\
    \ len(arr))\n    arr16 := make([]int, len(arr))\n    arr17 := make([]int, len(arr))\n\
    \    arr18 := make([]int, len(arr))\n    arr19 := make([]int, len(arr))\n    arr20\
    \ := make([]int, len(arr))\n    arr21 := make([]int, len(arr))\n    arr22 := make([]int,\
    \ len(arr))\n    arr23 := make([]int, len(arr))\n    arr24 := make([]int, len(arr))\n\
    \    arr25 := make([]int, len(arr))\n    arr26 := make([]int, len(arr))\n    arr27\
    \ := make([]int, len(arr))\n    arr28 := make([]int, len(arr))\n    arr29 := make([]int,\
    \ len(arr))\n    arr30 := make([]int, len(arr))\n    arr31 := make([]int, len(arr))\n\
    \    arr32 := make([]int, len(arr))\n    arr33 := make([]int, len(arr))\n    arr34\
    \ := make([]int, len(arr))\n    arr35 := make([]int, len(arr))\n    arr36 := make([]int,\
    \ len(arr))\n    arr37 := make([]int, len(arr))\n    arr38 := make([]int, len(arr))\n\
    \    arr39 := make([]int, len(arr))\n    arr40 := make([]int, len(arr))\n    arr41\
    \ := make([]int, len(arr))\n    arr42 := make([]int, len(arr))\n    arr43 := make([]int,\
    \ len(arr))\n    arr\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpn18y7qza_test.go:77:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074607
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    // write your code here\n    arr2 := make([]int, len(arr))\n    arr3\
    \ := make([]int, len(arr))\n    arr4 := make([]int, len(arr))\n    arr5 := make([]int,\
    \ len(arr))\n    arr6 := make([]int, len(arr))\n    arr7 := make([]int, len(arr))\n\
    \    arr8 := make([]int, len(arr))\n    arr9 := make([]int, len(arr))\n    arr10\
    \ := make([]int, len(arr))\n    arr11 := make([]int, len(arr))\n    arr12 := make([]int,\
    \ len(arr))\n    arr13 := make([]int, len(arr))\n    arr14 := make([]int, len(arr))\n\
    \    arr15 := make([]int, len(arr))\n    arr16 := make([]int, len(arr))\n    arr17\
    \ := make([]int, len(arr))\n    arr18 := make([]int, len(arr))\n    arr19 := make([]int,\
    \ len(arr))\n    arr20 := make([]int, len(arr))\n    arr21 := make([]int, len(arr))\n\
    \    arr22 := make([]int, len(arr))\n    arr23 := make([]int, len(arr))\n    arr24\
    \ := make([]int, len(arr))\n    arr25 := make([]int, len(arr))\n    arr26 := make([]int,\
    \ len(arr))\n    arr27 := make([]int, len(arr))\n    arr28 := make([]int, len(arr))\n\
    \    arr29 := make([]int, len(arr))\n    arr30 := make([]int, len(arr))\n    arr31\
    \ := make([]int, len(arr))\n    arr32 := make([]int, len(arr))\n    arr33 := make([]int,\
    \ len(arr))\n    arr34 := make([]int, len(arr))\n    arr35 := make([]int, len(arr))\n\
    \    arr36 := make([]int, len(arr))\n    arr37 := make([]int, len(arr))\n    arr38\
    \ := make([]int, len(arr))\n    arr39 := make([]int, len(arr))\n    arr40 := make([]int,\
    \ len(arr))\n    arr41 := make([]int, len(arr))\n    arr42 := make([]int, len(arr))\n\
    \    arr43 := make([]int, len(\nfunc TestPluck(t *testing.T) {\n  candidate :=\
    \ pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual:\
    \ candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual:\
    \ candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7,\
    \ 6, 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7,\
    \ 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp5dlexyft_test.go:77:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074607
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    m := make(map[int]int)\n    for _, v := range arr {\n        m[v]++\n\
    \    }\n    arr2 := make([]int, 0, len(m))\n    for k, v := range m {\n      \
    \  if v%2 == 0 {\n            arr2 = append(arr2, k)\n        }\n    }\n    if\
    \ len(arr2) == 0 {\n        return nil\n    }\n    if len(arr2) == 1 {\n     \
    \   return arr2\n    }\n    arr3 := make([]int, 0, len(arr2))\n    for _, v :=\
    \ range arr2 {\n        arr3 = append(arr3, v)\n    }\n    return arr3\n}\n\n\
    func TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__0 (0.00s)\n\
    \        tmp99k3r4_p_test.go:77: expected '[%!s(int=2) %!s(int=1)]', got '[]'\n\
    \    --- FAIL: TestPluck/test_num__1 (0.00s)\n        tmp99k3r4_p_test.go:77:\
    \ expected '[%!s(int=2) %!s(int=1)]', got '[]'\n    --- FAIL: TestPluck/test_num__3\
    \ (0.00s)\n        tmp99k3r4_p_test.go:77: expected '[%!s(int=0) %!s(int=1)]',\
    \ got '[%!s(int=0)]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmp99k3r4_p_test.go:77:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[%!s(int=3)]'\n    --- FAIL: TestPluck/test_num__5\
    \ (0.00s)\n        tmp99k3r4_p_test.go:77: expected '[%!s(int=4) %!s(int=1)]',\
    \ got '[%!s(int=4) %!s(int=8)]'\n    --- FAIL: TestPluck/test_num__6 (0.00s)\n\
    \        tmp99k3r4_p_test.go:77: expected '[%!s(int=6) %!s(int=1)]', got '[%!s(int=7)]'\n\
    \    --- FAIL: TestPluck/test_num__7 (0.00s)\n        tmp99k3r4_p_test.go:77:\
    \ expected '[]', got '[%!s(int=7)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074615
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    result := make([]int, 0)\n    min := arr[0]\n    index := 0\n    for\
    \ _, v := range arr {\n        if v%2 == 0 {\n            if v < min {\n     \
    \           min = v\n                index = index\n            }\n        } else\
    \ {\n            if min > v {\n                min = v\n                index\
    \ = index\n            }\n        }\n    }\n    result = append(result, min)\n\
    \    result = append(result, index)\n    return result\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\npanic: runtime error: index out of range [0]\
    \ with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with\
    \ length 0\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2({0x512440, 0xc0001c4000})\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x512440,\
    \ 0xc0001c4000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.pluck(...)\n\t/tmp/tmpgiivhosk_test.go:35\n\
    command-line-arguments_test.TestPluck(0x0?)\n\t/tmp/tmpgiivhosk_test.go:64 +0x1b0\n\
    testing.tRunner(0xc0001851e0, 0x527d38)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074609
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    sort.Sort(sort.Reverse(sort.IntSlice(arr)))\n    index := 0\n    smalest\
    \ := arr[0]\n    smalest_index := 0\n    for _, v := range arr {\n        if v%2\
    \ == 0 {\n            if smalest == v {\n                smalest_index = index\n\
    \            }\n            smalest = v\n            index = index + 1\n     \
    \   }\n    }\n    if smalest_index == 0 {\n        return []int{}\n    }\n   \
    \ return []int{smalest, smalest_index}\n}\n\nfunc TestPluck(t *testing.T) {\n\
    \  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4, 2,\
    \ 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n  \
    \   { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n \
    \    { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n\
    \     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n  \
    \   { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     { actual:\
    \ candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpy50rfx9j_test.go:34:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074615
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    result := make([]int, 0)\n    min := arr[0]\n    index := 0\n    for\
    \ _, v := range arr {\n        if v%2 == 0 {\n            if min > v {\n     \
    \           min = v\n                index = index\n            }\n        } else\
    \ {\n            if min > v {\n                min = v\n            }\n      \
    \  }\n    }\n    result = append(result, min)\n    result = append(result, index)\n\
    \    return result\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\npanic: runtime error: index out of range [0]\
    \ with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with\
    \ length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440, 0xc000014360})\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.pluck(...)\n\t/tmp/tmprzcozqhs_test.go:35\n\
    command-line-arguments_test.TestPluck(0x0?)\n\t/tmp/tmprzcozqhs_test.go:63 +0x1b0\n\
    testing.tRunner(0xc0001924e0, 0x527d38)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074614
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    sort.Ints(arr)\n    result := make([]int, 0)\n    index := 0\n    for\
    \ _, v := range arr {\n        if v%2 == 0 {\n            result = append(result,\
    \ v)\n            index = index + 1\n        }\n    }\n    if index == 0 {\n \
    \       return []int{}\n    }\n    return result\n}\n\nfunc TestPluck(t *testing.T)\
    \ {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_r1m7kg7_test.go:34:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074615
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    arr2 := make([]int, len(arr))\n    arr3 := make([]int, len(arr))\n  \
    \  arr4 := make([]int, len(arr))\n    arr5 := make([]int, len(arr))\n    arr6\
    \ := make([]int, len(arr))\n    arr7 := make([]int, len(arr))\n    arr8 := make([]int,\
    \ len(arr))\n    arr9 := make([]int, len(arr))\n    arr10 := make([]int, len(arr))\n\
    \    arr11 := make([]int, len(arr))\n    arr12 := make([]int, len(arr))\n    arr13\
    \ := make([]int, len(arr))\n    arr14 := make([]int, len(arr))\n    arr15 := make([]int,\
    \ len(arr))\n    arr16 := make([]int, len(arr))\n    arr17 := make([]int, len(arr))\n\
    \    arr18 := make([]int, len(arr))\n    arr19 := make([]int, len(arr))\n    arr20\
    \ := make([]int, len(arr))\n    arr21 := make([]int, len(arr))\n    arr22 := make([]int,\
    \ len(arr))\n    arr23 := make([]int, len(arr))\n    arr24 := make([]int, len(arr))\n\
    \    arr25 := make([]int, len(arr))\n    arr26 := make([]int, len(arr))\n    arr27\
    \ := make([]int, len(arr))\n    arr28 := make([]int, len(arr))\n    arr29 := make([]int,\
    \ len(arr))\n    arr30 := make([]int, len(arr))\n    arr31 := make([]int, len(arr))\n\
    \    arr32 := make([]int, len(arr))\n    arr33 := make([]int, len(arr))\n    arr34\
    \ := make([]int, len(arr))\n    arr35 := make([]int, len(arr))\n    arr36 := make([]int,\
    \ len(arr))\n    arr37 := make([]int, len(arr))\n    arr38 := make([]int, len(arr))\n\
    \    arr39 := make([]int, len(arr))\n    arr40 := make([]int, len(arr))\n    arr41\
    \ := make([]int, len(arr))\n    arr42 := make([]int, len(arr))\n    arr43 := make([]int,\
    \ len(arr))\n    arr\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpn18y7qza_test.go:77:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074607
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    result := make([]int, 0)\n    min := arr[0]\n    index := 0\n    for\
    \ _, value := range arr {\n        if value%2 == 0 {\n            if value < min\
    \ {\n                min = value\n                index = index\n            }\n\
    \        } else {\n            if min > value {\n                min = value\n\
    \                index = index\n            }\n        }\n    }\n    result =\
    \ append(result, min)\n    result = append(result, index)\n    return result\n\
    }\n`\n        );\n    }\n\n    public function testPluck()\n    {\n        $this->assertEquals(\n\
    \            array('pluck'),\n            pluck(array(1, 2, 3))\n        );\n\
    \        $this->assertEquals(\n            array('pluck'),\n            pluck(array())\n\
    \        );\n        $this->assertEquals(\n            array('pluck'),\n     \
    \       pluck(array(5, 0))\n        );\n        $this->assertEquals(\n       \
    \     array('pluck'),\n            pluck(array(5, 0, 3, 0, 4, 2))\n        );\n\
    \    }\n\n    public function testPluckWithIndex()\n    {\n        $this->assertEquals(\n\
    \            array('pluck', 'pluck'),\n            pluck(array(1, 2, 3), true)\n\
    \        );\n        $this->assertEquals(\n            array('pluck', 'pluck'),\n\
    \            pluck(array(), true)\n        );\n        $this->assertEquals(\n\
    \            array('pluck', 'pluck'),\n            pluck(array(5, 0), true)\n\
    \        );\n        $this->assertEquals(\n            array('pluck', 'pluck'),\n\
    \            pluck(array(5, 0, 3, 0, 4, 2), true)\n        );\n    }\n\n    public\
    \ function testPluckWithIndexAndValue()\n    {\n        $this->assertEquals(\n\
    \            array('pluck', 'pluck'),\n            pluck(array(1, 2, 3), false)\n\
    \        );\n        $this->assertEquals(\n            array('pluck', 'pluck'),\n\
    \            pluck(array(), false)\n        );\n        $this->assertEquals(\n\
    \            array('pluck', 'pluck'),\n            pluck(array(5, 0), false)\n\
    \        );\n        $this->assertEquals(\n            array('pluck', 'pluck'),\n\
    \            pluck(array(5, 0, 3, 0, 4, 2), false)\n        );\n    }\n\n    public\
    \ function testPluckWithIndexAndValueAndMin()\n    {\n        $this->assertEquals(\n\
    \            array('pluck', 'pluck'),\n            pluck(array(1, 2, 3), true,\
    \ 1)\n        );\n        $this->assertEquals(\n            array('pluck', 'pluck'),\n\
    \            pluck(array(), true, 0)\n        );\n        $this->assertEquals(\n\
    \            array('pluck', 'pluck'),\n            pluck(array(5, 0), true, 0)\n\
    \        );\n        $this->assertEquals(\n            array('pluck', 'pluck'),\n\
    \            pluck(array(5, 0, 3, 0, 4, 2), \nfunc TestPluck(t *testing.T) {\n\
    \  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4, 2,\
    \ 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n  \
    \   { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n \
    \    { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n\
    \     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n  \
    \   { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     { actual:\
    \ candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpu0fzv00u_test.go:54:1: raw string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074614
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    arr2 := make([]int, len(arr))\n    arr3 := make([]int, len(arr))\n  \
    \  arr4 := make([]int, len(arr))\n    arr5 := make([]int, len(arr))\n    arr6\
    \ := make([]int, len(arr))\n    arr7 := make([]int, len(arr))\n    arr8 := make([]int,\
    \ len(arr))\n    arr9 := make([]int, len(arr))\n    arr10 := make([]int, len(arr))\n\
    \    arr11 := make([]int, len(arr))\n    arr12 := make([]int, len(arr))\n    arr13\
    \ := make([]int, len(arr))\n    arr14 := make([]int, len(arr))\n    arr15 := make([]int,\
    \ len(arr))\n    arr16 := make([]int, len(arr))\n    arr17 := make([]int, len(arr))\n\
    \    arr18 := make([]int, len(arr))\n    arr19 := make([]int, len(arr))\n    arr20\
    \ := make([]int, len(arr))\n    arr21 := make([]int, len(arr))\n    arr22 := make([]int,\
    \ len(arr))\n    arr23 := make([]int, len(arr))\n    arr24 := make([]int, len(arr))\n\
    \    arr25 := make([]int, len(arr))\n    arr26 := make([]int, len(arr))\n    arr27\
    \ := make([]int, len(arr))\n    arr28 := make([]int, len(arr))\n    arr29 := make([]int,\
    \ len(arr))\n    arr30 := make([]int, len(arr))\n    arr31 := make([]int, len(arr))\n\
    \    arr32 := make([]int, len(arr))\n    arr33 := make([]int, len(arr))\n    arr34\
    \ := make([]int, len(arr))\n    arr35 := make([]int, len(arr))\n    arr36 := make([]int,\
    \ len(arr))\n    arr37 := make([]int, len(arr))\n    arr38 := make([]int, len(arr))\n\
    \    arr39 := make([]int, len(arr))\n    arr40 := make([]int, len(arr))\n    arr41\
    \ := make([]int, len(arr))\n    arr42 := make([]int, len(arr))\n    arr43 := make([]int,\
    \ len(arr))\n    arr\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpn18y7qza_test.go:77:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074607
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    min := arr[0]\n\
    \    index := 0\n    for _, v := range arr {\n        if v%2 == 0 {\n        \
    \    if v < min {\n                min = v\n                index = index\n  \
    \          }\n        } else {\n            if v == min {\n                index++\n\
    \            }\n        }\n    }\n    return []int{min, index}\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__0 (0.00s)\n\
    \        tmpi_v7u1kq_test.go:74: expected '[%!s(int=2) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=0)]'\n    --- FAIL: TestPluck/test_num__1 (0.00s)\n        tmpi_v7u1kq_test.go:74:\
    \ expected '[%!s(int=2) %!s(int=1)]', got '[%!s(int=1) %!s(int=1)]'\n    --- FAIL:\
    \ TestPluck/test_num__4 (0.00s)\n        tmpi_v7u1kq_test.go:74: expected '[%!s(int=0)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=1)]'\n    --- FAIL: TestPluck/test_num__7\
    \ (0.00s)\n        tmpi_v7u1kq_test.go:74: expected '[]', got '[%!s(int=7) %!s(int=2)]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074615
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    result := make([]int, 0)\n    min := arr[0]\n    index := 0\n    for\
    \ _, v := range arr {\n        if v%2 == 0 {\n            if min > v {\n     \
    \           min = v\n                index = index\n            }\n        } else\
    \ {\n            if min > v {\n                min = v\n                index\
    \ = index\n            }\n        }\n    }\n    result = append(result, min)\n\
    \    result = append(result, index)\n    return result\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\npanic: runtime error: index out of range [0]\
    \ with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with\
    \ length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440, 0xc000014360})\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.pluck(...)\n\t/tmp/tmpcs680i9__test.go:35\n\
    command-line-arguments_test.TestPluck(0x0?)\n\t/tmp/tmpcs680i9__test.go:64 +0x1b0\n\
    testing.tRunner(0xc0001924e0, 0x527d38)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074609
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    m := make(map[int]int)\n    for _, v := range arr {\n        m[v] = m[v]\
    \ + 1\n    }\n    result := make([]int, 0, len(m))\n    for _, v := range m {\n\
    \        if v%2 == 0 {\n            result = append(result, v)\n        }\n  \
    \  }\n    if len(result) == 0 {\n        return []int{}\n    }\n    if len(result)\
    \ == 1 {\n        return result[0]\n    }\n    return result\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpj0q6q7d9_test.go:48:16: cannot use result[0] (variable of type int) as
    type []int in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074609
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    arr2 := make([]int, len(arr))\n    arr3 := make([]int, len(arr))\n  \
    \  arr4 := make([]int, len(arr))\n    arr5 := make([]int, len(arr))\n    arr6\
    \ := make([]int, len(arr))\n    arr7 := make([]int, len(arr))\n    arr8 := make([]int,\
    \ len(arr))\n    arr9 := make([]int, len(arr))\n    arr10 := make([]int, len(arr))\n\
    \    arr11 := make([]int, len(arr))\n    arr12 := make([]int, len(arr))\n    arr13\
    \ := make([]int, len(arr))\n    arr14 := make([]int, len(arr))\n    arr15 := make([]int,\
    \ len(arr))\n    arr16 := make([]int, len(arr))\n    arr17 := make([]int, len(arr))\n\
    \    arr18 := make([]int, len(arr))\n    arr19 := make([]int, len(arr))\n    arr20\
    \ := make([]int, len(arr))\n    arr21 := make([]int, len(arr))\n    arr22 := make([]int,\
    \ len(arr))\n    arr23 := make([]int, len(arr))\n    arr24 := make([]int, len(arr))\n\
    \    arr25 := make([]int, len(arr))\n    arr26 := make([]int, len(arr))\n    arr27\
    \ := make([]int, len(arr))\n    arr28 := make([]int, len(arr))\n    arr29 := make([]int,\
    \ len(arr))\n    arr30 := make([]int, len(arr))\n    arr31 := make([]int, len(arr))\n\
    \    arr32 := make([]int, len(arr))\n    arr33 := make([]int, len(arr))\n    arr34\
    \ := make([]int, len(arr))\n    arr35 := make([]int, len(arr))\n    arr36 := make([]int,\
    \ len(arr))\n    arr37 := make([]int, len(arr))\n    arr38 := make([]int, len(arr))\n\
    \    arr39 := make([]int, len(arr))\n    arr40 := make([]int, len(arr))\n    arr41\
    \ := make([]int, len(arr))\n    arr42 := make([]int, len(arr))\n    arr43 := make([]int,\
    \ len(arr))\n    arr\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpn18y7qza_test.go:77:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074607
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var result []int\n    var minIndex int\n    var minVal int\n    var i\
    \ int\n    for i = 0; i < len(arr); i++ {\n        if arr[i] % 2 == 0 {\n    \
    \        if minVal == 0 || arr[i] < minVal {\n                minVal = arr[i]\n\
    \                minIndex = i\n            }\n        } else {\n            if\
    \ minVal == 0 || arr[i] > minVal {\n                minVal = arr[i]\n        \
    \        minIndex = i\n            }\n        }\n    }\n    if minVal == 0 {\n\
    \        result = make([]int, 0)\n    } else {\n        result = append(result,\
    \ minVal)\n        result = append(result, minIndex)\n    }\n    return result\n\
    }\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__0 (0.00s)\n\
    \        tmp7zf6fxwa_test.go:80: expected '[%!s(int=2) %!s(int=1)]', got '[%!s(int=3)\
    \ %!s(int=2)]'\n    --- FAIL: TestPluck/test_num__1 (0.00s)\n        tmp7zf6fxwa_test.go:80:\
    \ expected '[%!s(int=2) %!s(int=1)]', got '[%!s(int=3) %!s(int=2)]'\n    --- FAIL:\
    \ TestPluck/test_num__3 (0.00s)\n        tmp7zf6fxwa_test.go:80: expected '[%!s(int=0)\
    \ %!s(int=1)]', got '[%!s(int=2) %!s(int=5)]'\n    --- FAIL: TestPluck/test_num__4\
    \ (0.00s)\n        tmp7zf6fxwa_test.go:80: expected '[%!s(int=0) %!s(int=3)]',\
    \ got '[%!s(int=5) %!s(int=4)]'\n    --- FAIL: TestPluck/test_num__6 (0.00s)\n\
    \        tmp7zf6fxwa_test.go:80: expected '[%!s(int=6) %!s(int=1)]', got '[%!s(int=7)\
    \ %!s(int=2)]'\n    --- FAIL: TestPluck/test_num__7 (0.00s)\n        tmp7zf6fxwa_test.go:80:\
    \ expected '[]', got '[%!s(int=9) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660074616
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    result := make([]int, 0)\n    min := arr[0]\n    index := 0\n    for\
    \ _, v := range arr {\n        if v%2 == 0 {\n            if min > v {\n     \
    \           min = v\n                index = index\n            }\n        } else\
    \ {\n            if min == v {\n                index = index\n            }\n\
    \        }\n    }\n    result = append(result, min)\n    result = append(result,\
    \ index)\n    return result\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate\
    \ := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual:\
    \ candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual:\
    \ candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7,\
    \ 6, 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7,\
    \ 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\npanic: runtime error: index out of range [0]\
    \ with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with\
    \ length 0\n\ngoroutine 34 [running]:\ntesting.tRunner.func1.2({0x512440, 0xc0001d6000})\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x512440,\
    \ 0xc0001d6000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.pluck(...)\n\t/tmp/tmp_qckbawd_test.go:35\n\
    command-line-arguments_test.TestPluck(0x0?)\n\t/tmp/tmp_qckbawd_test.go:63 +0x1a5\n\
    testing.tRunner(0xc000198ea0, 0x527d38)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074616
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    arr2 := make([]int, len(arr))\n    arr3 := make([]int, len(arr))\n  \
    \  arr4 := make([]int, len(arr))\n    arr5 := make([]int, len(arr))\n    arr6\
    \ := make([]int, len(arr))\n    arr7 := make([]int, len(arr))\n    arr8 := make([]int,\
    \ len(arr))\n    arr9 := make([]int, len(arr))\n    arr10 := make([]int, len(arr))\n\
    \    arr11 := make([]int, len(arr))\n    arr12 := make([]int, len(arr))\n    arr13\
    \ := make([]int, len(arr))\n    arr14 := make([]int, len(arr))\n    arr15 := make([]int,\
    \ len(arr))\n    arr16 := make([]int, len(arr))\n    arr17 := make([]int, len(arr))\n\
    \    arr18 := make([]int, len(arr))\n    arr19 := make([]int, len(arr))\n    arr20\
    \ := make([]int, len(arr))\n    arr21 := make([]int, len(arr))\n    arr22 := make([]int,\
    \ len(arr))\n    arr23 := make([]int, len(arr))\n    arr24 := make([]int, len(arr))\n\
    \    arr25 := make([]int, len(arr))\n    arr26 := make([]int, len(arr))\n    arr27\
    \ := make([]int, len(arr))\n    arr28 := make([]int, len(arr))\n    arr29 := make([]int,\
    \ len(arr))\n    arr30 := make([]int, len(arr))\n    arr31 := make([]int, len(arr))\n\
    \    arr32 := make([]int, len(arr))\n    arr33 := make([]int, len(arr))\n    arr34\
    \ := make([]int, len(arr))\n    arr35 := make([]int, len(arr))\n    arr36 := make([]int,\
    \ len(arr))\n    arr37 := make([]int, len(arr))\n    arr38 := make([]int, len(arr))\n\
    \    arr39 := make([]int, len(arr))\n    arr40 := make([]int, len(arr))\n    arr41\
    \ := make([]int, len(arr))\n    arr42 := make([]int, len(arr))\n    arr43 := make([]int,\
    \ len(arr))\n    arr\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpn18y7qza_test.go:77:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074607
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    sort.Ints(arr)\n\
    \    var result []int\n    var index int\n    for _, v := range arr {\n      \
    \  if v%2 == 0 {\n            result = append(result, v)\n            index =\
    \ len(result)-1\n        }\n    }\n    if index == -1 {\n        return []int{}\n\
    \    }\n    return result\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate :=\
    \ pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual:\
    \ candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual:\
    \ candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7,\
    \ 6, 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7,\
    \ 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmppoce9nja_test.go:37:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074615
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    // write your code here\n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    func TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp9iau7tlr_test.go:289:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074607
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    sort.Ints(arr)\n    smalest_value := arr[0]\n    smalest_index := 0\n\
    \    for i := 1; i < len(arr); i++ {\n        if arr[i] < smalest_value {\n  \
    \          smalest_value = arr[i]\n            smalest_index = i\n        }\n\
    \    }\n    return []int{smalest_value, smalest_index}\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpp_pyvtmx_test.go:34:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074608
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    m := make(map[int]int)\n    for _, v := range arr {\n        m[v] = m[v]\
    \ + 1\n    }\n    arr2 := make([]int, 0, len(m))\n    for _, v := range m {\n\
    \        if v%2 == 0 {\n            arr2 = append(arr2, v)\n        }\n    }\n\
    \    if len(arr2) == 0 {\n        return nil\n    }\n    if len(arr2) == 1 {\n\
    \        return arr2\n    }\n    arr3 := make([]int, 0, len(arr2))\n    for _,\
    \ v := range arr2 {\n        if v%2 == 0 {\n            arr3 = append(arr3, v)\n\
    \        }\n    }\n    if len(arr3) == 0 {\n        return nil\n    }\n    if\
    \ len(arr3) == 1 {\n        return arr3\n    }\n    arr4 := make([]int, 0, len(arr3))\n\
    \    for _, v := range arr3 {\n        if v%2 == 0 {\n            arr4 = append(arr4,\
    \ v)\n        }\n    }\n    if len(arr4) == 0 {\n        return nil\n    }\n \
    \   if len(arr4) == 1 {\n        return arr4\n    }\n    arr5 := make([]int, 0,\
    \ len(arr4))\n    for _, v := range arr4 {\n        if v%2 == 0 {\n          \
    \  arr5 = append(arr5, v)\n        }\n    }\n    if len(arr5) == 0 {\n       \
    \ return nil\n    }\n    if len(arr5) == 1 {\n        return arr5\n    }\n   \
    \ arr6 := make([]int, 0, len(arr5))\n    for _, v := range arr5 {\n        if\
    \ v%2 == 0 {\n            arr6 = append(arr6, v)\n        }\n    }\n    if len(arr6)\
    \ == 0 {\n        return nil\n    }\n    if len(arr6) == 1 {\n        return arr6\n\
    \    }\n    arr7 := make([]int, 0, len(arr6))\n    for _, v := range arr6 {\n\
    \        if v%2 == 0 {\n            arr7 = append(arr7, v)\n        }\n    }\n\
    \    if len(arr7) == 0 {\n        return nil\n    }\n    if len(arr7) == 1 {\n\
    \        return arr7\n    }\n    arr8 := make([]int, 0, len(arr7))\n    for _,\
    \ v := range arr7 {\n        if v%2 == 0 {\n            arr8 = append(arr8, v)\n\
    \        }\n    }\n    if len(arr8) == 0 {\n        return nil\n    }\n    if\
    \ len(arr8) == 1 {\n        return arr8\n    }\n    arr9 := make([]int, 0, len(arr8))\n\
    \    for _, v := range arr8 {\n        if v%2 == 0 {\n            arr9 = append(arr9,\
    \ v)\n        }\n    }\n    if len(arr9) == 0 {\n        return nil\n    }\n \
    \   if len(arr9) == 1 {\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpmz82a6hp_test.go:132:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074615
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    result := make([]int, 0)\n    min := arr[0]\n    index := 0\n    for\
    \ _, v := range arr {\n        if v%2 == 0 {\n            if min > v {\n     \
    \           min = v\n                index = index\n            }\n        } else\
    \ {\n            if min == v {\n                index = index\n            }\n\
    \        }\n    }\n    result = append(result, min)\n    result = append(result,\
    \ index)\n    return result\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate\
    \ := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual:\
    \ candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual:\
    \ candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7,\
    \ 6, 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7,\
    \ 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\npanic: runtime error: index out of range [0]\
    \ with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with\
    \ length 0\n\ngoroutine 34 [running]:\ntesting.tRunner.func1.2({0x512440, 0xc0001d6000})\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x512440,\
    \ 0xc0001d6000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.pluck(...)\n\t/tmp/tmp_qckbawd_test.go:35\n\
    command-line-arguments_test.TestPluck(0x0?)\n\t/tmp/tmp_qckbawd_test.go:63 +0x1a5\n\
    testing.tRunner(0xc000198ea0, 0x527d38)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074616
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    arr2 := make([]int, len(arr))\n    arr3 := make([]int, len(arr))\n  \
    \  arr4 := make([]int, len(arr))\n    arr5 := make([]int, len(arr))\n    arr6\
    \ := make([]int, len(arr))\n    arr7 := make([]int, len(arr))\n    arr8 := make([]int,\
    \ len(arr))\n    arr9 := make([]int, len(arr))\n    arr10 := make([]int, len(arr))\n\
    \    arr11 := make([]int, len(arr))\n    arr12 := make([]int, len(arr))\n    arr13\
    \ := make([]int, len(arr))\n    arr14 := make([]int, len(arr))\n    arr15 := make([]int,\
    \ len(arr))\n    arr16 := make([]int, len(arr))\n    arr17 := make([]int, len(arr))\n\
    \    arr18 := make([]int, len(arr))\n    arr19 := make([]int, len(arr))\n    arr20\
    \ := make([]int, len(arr))\n    arr21 := make([]int, len(arr))\n    arr22 := make([]int,\
    \ len(arr))\n    arr23 := make([]int, len(arr))\n    arr24 := make([]int, len(arr))\n\
    \    arr25 := make([]int, len(arr))\n    arr26 := make([]int, len(arr))\n    arr27\
    \ := make([]int, len(arr))\n    arr28 := make([]int, len(arr))\n    arr29 := make([]int,\
    \ len(arr))\n    arr30 := make([]int, len(arr))\n    arr31 := make([]int, len(arr))\n\
    \    arr32 := make([]int, len(arr))\n    arr33 := make([]int, len(arr))\n    arr34\
    \ := make([]int, len(arr))\n    arr35 := make([]int, len(arr))\n    arr36 := make([]int,\
    \ len(arr))\n    arr37 := make([]int, len(arr))\n    arr38 := make([]int, len(arr))\n\
    \    arr39 := make([]int, len(arr))\n    arr40 := make([]int, len(arr))\n    arr41\
    \ := make([]int, len(arr))\n    arr42 := make([]int, len(arr))\n    arr43 := make([]int,\
    \ len(arr))\n    arr\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpn18y7qza_test.go:77:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074607
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    m := make(map[int]int)\n    for _, v := range arr {\n        m[v] = m[min(v,\
    \ m[v])]\n    }\n    result := make([]int, 0, len(m))\n    for _, v := range m\
    \ {\n        result = append(result, v)\n    }\n    return result\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpef6w__jv_test.go:36:18: undefined: min

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074612
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    sort.Ints(arr)\n    var result []int\n    var index int\n    for _, v\
    \ := range arr {\n        if v%2 == 0 {\n            result = append(result, v)\n\
    \            index = len(result)\n        }\n    }\n    if index == 0 {\n    \
    \    return []int{}\n    }\n    return result\n}\n`\n\nvar pluckTests = `package\
    \ pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpbc3_rugf_test.go:48:1: expected declaration, found `


    var pluckTests = `

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074615
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    arr2 := make([]int, len(arr))\n    arr3 := make([]int, len(arr))\n  \
    \  arr4 := make([]int, len(arr))\n    arr5 := make([]int, len(arr))\n    arr6\
    \ := make([]int, len(arr))\n    arr7 := make([]int, len(arr))\n    arr8 := make([]int,\
    \ len(arr))\n    arr9 := make([]int, len(arr))\n    arr10 := make([]int, len(arr))\n\
    \    arr11 := make([]int, len(arr))\n    arr12 := make([]int, len(arr))\n    arr13\
    \ := make([]int, len(arr))\n    arr14 := make([]int, len(arr))\n    arr15 := make([]int,\
    \ len(arr))\n    arr16 := make([]int, len(arr))\n    arr17 := make([]int, len(arr))\n\
    \    arr18 := make([]int, len(arr))\n    arr19 := make([]int, len(arr))\n    arr20\
    \ := make([]int, len(arr))\n    arr21 := make([]int, len(arr))\n    arr22 := make([]int,\
    \ len(arr))\n    arr23 := make([]int, len(arr))\n    arr24 := make([]int, len(arr))\n\
    \    arr25 := make([]int, len(arr))\n    arr26 := make([]int, len(arr))\n    arr27\
    \ := make([]int, len(arr))\n    arr28 := make([]int, len(arr))\n    arr29 := make([]int,\
    \ len(arr))\n    arr30 := make([]int, len(arr))\n    arr31 := make([]int, len(arr))\n\
    \    arr32 := make([]int, len(arr))\n    arr33 := make([]int, len(arr))\n    arr34\
    \ := make([]int, len(arr))\n    arr35 := make([]int, len(arr))\n    arr36 := make([]int,\
    \ len(arr))\n    arr37 := make([]int, len(arr))\n    arr38 := make([]int, len(arr))\n\
    \    arr39 := make([]int, len(arr))\n    arr40 := make([]int, len(arr))\n    arr41\
    \ := make([]int, len(arr))\n    arr42 := make([]int, len(arr))\n    arr43 := make([]int,\
    \ len(arr))\n    arr\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpn18y7qza_test.go:77:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074607
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    sort.Sort(sort.Reverse(sort.IntSlice(arr)))\n    index := 0\n    smalest_value\
    \ := arr[0]\n    smalest_index := 0\n    for _, value := range arr {\n       \
    \ if value%2 == 0 {\n            if value < smalest_value {\n                smalest_value\
    \ = value\n                smalest_index = index\n            }\n            index++\n\
    \        }\n    }\n    return []int{smalest_value, smalest_index}\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqqzl8l1p_test.go:34:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074613
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    arr2 := make([]int, len(arr))\n    arr3 := make([]int, len(arr))\n  \
    \  arr4 := make([]int, len(arr))\n    arr5 := make([]int, len(arr))\n    arr6\
    \ := make([]int, len(arr))\n    arr7 := make([]int, len(arr))\n    arr8 := make([]int,\
    \ len(arr))\n    arr9 := make([]int, len(arr))\n    arr10 := make([]int, len(arr))\n\
    \    arr11 := make([]int, len(arr))\n    arr12 := make([]int, len(arr))\n    arr13\
    \ := make([]int, len(arr))\n    arr14 := make([]int, len(arr))\n    arr15 := make([]int,\
    \ len(arr))\n    arr16 := make([]int, len(arr))\n    arr17 := make([]int, len(arr))\n\
    \    arr18 := make([]int, len(arr))\n    arr19 := make([]int, len(arr))\n    arr20\
    \ := make([]int, len(arr))\n    arr21 := make([]int, len(arr))\n    arr22 := make([]int,\
    \ len(arr))\n    arr23 := make([]int, len(arr))\n    arr24 := make([]int, len(arr))\n\
    \    arr25 := make([]int, len(arr))\n    arr26 := make([]int, len(arr))\n    arr27\
    \ := make([]int, len(arr))\n    arr28 := make([]int, len(arr))\n    arr29 := make([]int,\
    \ len(arr))\n    arr30 := make([]int, len(arr))\n    arr31 := make([]int, len(arr))\n\
    \    arr32 := make([]int, len(arr))\n    arr33 := make([]int, len(arr))\n    arr34\
    \ := make([]int, len(arr))\n    arr35 := make([]int, len(arr))\n    arr36 := make([]int,\
    \ len(arr))\n    arr37 := make([]int, len(arr))\n    arr38 := make([]int, len(arr))\n\
    \    arr39 := make([]int, len(arr))\n    arr40 := make([]int, len(arr))\n    arr41\
    \ := make([]int, len(arr))\n    arr42 := make([]int, len(arr))\n    arr43 := make([]int,\
    \ len(arr))\n    arr\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpn18y7qza_test.go:77:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074607
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    arr2 := make([]int, len(arr))\n    min := arr[0]\n    index := 0\n  \
    \  for _, v := range arr {\n        if v%2 == 0 {\n            arr2[index] = v\n\
    \            index++\n            if v < min {\n                min = v\n    \
    \        }\n        }\n    }\n    if index == 0 {\n        return []int{}\n  \
    \  }\n    return arr2[0:index]\n}\n`\n    )\n}\n\nfunc TestPluck(t *testing.T)\
    \ {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp0lw9cw4y_test.go:51:1: raw string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074615
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    smalest_value\
    \ := arr[0]\n    smalest_index := 0\n    for _, value := range arr {\n       \
    \ if value%2 == 0 {\n            if value < smalest_value {\n                smalest_value\
    \ = value\n                smalest_index = index\n            }\n        }\n \
    \       index++\n    }\n    return []int{smalest_value, smalest_index}\n}\n\n\
    func TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6_fkxdo6_test.go:43:33: undefined: index

    /tmp/tmp6_fkxdo6_test.go:46:9: undefined: index

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074616
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    m := make(map[int]int)\n    for _, v := range arr {\n        m[v] = m[v]\
    \ + 1\n    }\n    sort.Ints(arr)\n    arr2 := make([]int, 0)\n    for _, v :=\
    \ range arr {\n        if m[v] % 2 == 0 {\n            arr2 = append(arr2, v)\n\
    \        }\n    }\n    if len(arr2) == 0 {\n        return nil\n    }\n    return\
    \ arr2\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n   \
    \  { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4xkrhswe_test.go:38:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074616
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    arr2 := make([]int, len(arr))\n    arr3 := make([]int, len(arr))\n  \
    \  arr4 := make([]int, len(arr))\n    arr5 := make([]int, len(arr))\n    arr6\
    \ := make([]int, len(arr))\n    arr7 := make([]int, len(arr))\n    arr8 := make([]int,\
    \ len(arr))\n    arr9 := make([]int, len(arr))\n    arr10 := make([]int, len(arr))\n\
    \    arr11 := make([]int, len(arr))\n    arr12 := make([]int, len(arr))\n    arr13\
    \ := make([]int, len(arr))\n    arr14 := make([]int, len(arr))\n    arr15 := make([]int,\
    \ len(arr))\n    arr16 := make([]int, len(arr))\n    arr17 := make([]int, len(arr))\n\
    \    arr18 := make([]int, len(arr))\n    arr19 := make([]int, len(arr))\n    arr20\
    \ := make([]int, len(arr))\n    arr21 := make([]int, len(arr))\n    arr22 := make([]int,\
    \ len(arr))\n    arr23 := make([]int, len(arr))\n    arr24 := make([]int, len(arr))\n\
    \    arr25 := make([]int, len(arr))\n    arr26 := make([]int, len(arr))\n    arr27\
    \ := make([]int, len(arr))\n    arr28 := make([]int, len(arr))\n    arr29 := make([]int,\
    \ len(arr))\n    arr30 := make([]int, len(arr))\n    arr31 := make([]int, len(arr))\n\
    \    arr32 := make([]int, len(arr))\n    arr33 := make([]int, len(arr))\n    arr34\
    \ := make([]int, len(arr))\n    arr35 := make([]int, len(arr))\n    arr36 := make([]int,\
    \ len(arr))\n    arr37 := make([]int, len(arr))\n    arr38 := make([]int, len(arr))\n\
    \    arr39 := make([]int, len(arr))\n    arr40 := make([]int, len(arr))\n    arr41\
    \ := make([]int, len(arr))\n    arr42 := make([]int, len(arr))\n    arr43 := make([]int,\
    \ len(arr))\n    arr\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpn18y7qza_test.go:77:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074607
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    min := arr[0]\n\
    \    index := 0\n    for _, v := range arr {\n        if v%2 == 0 {\n        \
    \    if min > v {\n                min = v\n                index = index + 1\n\
    \            }\n        } else {\n            if min > v {\n                min\
    \ = v\n            }\n        }\n    }\n    return []int{min, index}\n}\n\nfunc\
    \ TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__1 (0.00s)\n\
    \        tmpwr9ljr_1_test.go:74: expected '[%!s(int=2) %!s(int=1)]', got '[%!s(int=1)\
    \ %!s(int=0)]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmpwr9ljr_1_test.go:74:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[%!s(int=0) %!s(int=1)]'\n    --- FAIL:\
    \ TestPluck/test_num__6 (0.00s)\n        tmpwr9ljr_1_test.go:74: expected '[%!s(int=6)\
    \ %!s(int=1)]', got '[%!s(int=1) %!s(int=1)]'\n    --- FAIL: TestPluck/test_num__7\
    \ (0.00s)\n        tmpwr9ljr_1_test.go:74: expected '[]', got '[%!s(int=1) %!s(int=0)]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074616
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var minVal int\n    var minIndex int\n    var minVal int\n    var minIndex\
    \ int\n    for _, val := range arr {\n        if val%2 == 0 {\n            if\
    \ minVal == 0 || val < minVal {\n                minVal = val\n              \
    \  minIndex = val\n            }\n        } else {\n            if minVal == 0\
    \ || val < minVal {\n                minVal = val\n                minIndex =\
    \ val\n            }\n        }\n    }\n    if minVal == 0 {\n        return []int{}\n\
    \    }\n    return []int{minVal, minIndex}\n}\n`\n\nfunc TestPluck(t *testing.T)\
    \ {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpp3wcdj86_test.go:56:1: raw string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074615
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    min := arr[0]\n\
    \    index := 0\n    for _, v := range arr {\n        if v%2 == 0 {\n        \
    \    if min > v {\n                min = v\n                index = index\n  \
    \          }\n        } else {\n            if min > v {\n                min\
    \ = v\n                index = index\n            }\n        }\n    }\n    return\
    \ []int{min, index}\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__0 (0.00s)\n\
    \        tmpw1cuerl4_test.go:75: expected '[%!s(int=2) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=0)]'\n    --- FAIL: TestPluck/test_num__1 (0.00s)\n        tmpw1cuerl4_test.go:75:\
    \ expected '[%!s(int=2) %!s(int=1)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL:\
    \ TestPluck/test_num__3 (0.00s)\n        tmpw1cuerl4_test.go:75: expected '[%!s(int=0)\
    \ %!s(int=1)]', got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestPluck/test_num__4\
    \ (0.00s)\n        tmpw1cuerl4_test.go:75: expected '[%!s(int=0) %!s(int=3)]',\
    \ got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestPluck/test_num__5 (0.00s)\n\
    \        tmpw1cuerl4_test.go:75: expected '[%!s(int=4) %!s(int=1)]', got '[%!s(int=4)\
    \ %!s(int=0)]'\n    --- FAIL: TestPluck/test_num__6 (0.00s)\n        tmpw1cuerl4_test.go:75:\
    \ expected '[%!s(int=6) %!s(int=1)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL:\
    \ TestPluck/test_num__7 (0.00s)\n        tmpw1cuerl4_test.go:75: expected '[]',\
    \ got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\n\
    FAIL\n"
  timestamp: 1660074609
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    sort.Ints(arr)\n    var result []int\n    var index int\n    for _, v\
    \ := range arr {\n        if v%2 == 0 {\n            result = append(result, v)\n\
    \            index = len(result)-1\n        }\n    }\n    if index == -1 {\n \
    \       return []int{}\n    }\n    return result\n}\n\nfunc TestPluck(t *testing.T)\
    \ {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpotovrh6g_test.go:34:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074616
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    min := arr[0]\n\
    \    index := 0\n    for _, val := range arr {\n        if val%2 == 0 {\n    \
    \        if val < min {\n                min = val\n                index = index\n\
    \            }\n        } else {\n            if val == min {\n              \
    \  index = index\n            }\n        }\n    }\n    return []int{min, index}\n\
    }\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__0 (0.00s)\n\
    \        tmpjl79sf3e_test.go:74: expected '[%!s(int=2) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=0)]'\n    --- FAIL: TestPluck/test_num__1 (0.00s)\n        tmpjl79sf3e_test.go:74:\
    \ expected '[%!s(int=2) %!s(int=1)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL:\
    \ TestPluck/test_num__3 (0.00s)\n        tmpjl79sf3e_test.go:74: expected '[%!s(int=0)\
    \ %!s(int=1)]', got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestPluck/test_num__4\
    \ (0.00s)\n        tmpjl79sf3e_test.go:74: expected '[%!s(int=0) %!s(int=3)]',\
    \ got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestPluck/test_num__5 (0.00s)\n\
    \        tmpjl79sf3e_test.go:74: expected '[%!s(int=4) %!s(int=1)]', got '[%!s(int=4)\
    \ %!s(int=0)]'\n    --- FAIL: TestPluck/test_num__6 (0.00s)\n        tmpjl79sf3e_test.go:74:\
    \ expected '[%!s(int=6) %!s(int=1)]', got '[%!s(int=6) %!s(int=0)]'\n    --- FAIL:\
    \ TestPluck/test_num__7 (0.00s)\n        tmpjl79sf3e_test.go:74: expected '[]',\
    \ got '[%!s(int=7) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074616
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    sort.Ints(arr)\n    evens := make([]int, 0, len(arr))\n    index := 0\n\
    \    for _, v := range arr {\n        if v%2 == 0 {\n            evens = append(evens,\
    \ v)\n            index++\n        }\n    }\n    if len(evens) == 0 {\n      \
    \  return []int{}\n    }\n    if evens[0]%2 == 0 {\n        return evens\n   \
    \ }\n    return evens[:1]\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate :=\
    \ pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual:\
    \ candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual:\
    \ candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7,\
    \ 6, 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7,\
    \ 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp14w03717_test.go:34:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074616
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var minVal int\n    var minIndex int\n    var minVal int\n    var minIndex\
    \ int\n    var minVal int\n    var minIndex int\n    var minVal int\n    var minIndex\
    \ int\n    var minVal int\n    var minIndex int\n    var minVal int\n    var minIndex\
    \ int\n    var minVal int\n    var minIndex int\n    var minVal int\n    var minIndex\
    \ int\n    var minVal int\n    var minIndex int\n    var minVal int\n    var minIndex\
    \ int\n    var minVal int\n    var minIndex int\n    var minVal int\n    var minIndex\
    \ int\n    var minVal int\n    var minIndex int\n    var minVal int\n    var minIndex\
    \ int\n    var minVal int\n    var minIndex int\n    var minVal int\n    var minIndex\
    \ int\n    var minVal int\n    var minIndex int\n    var minVal int\n    var minIndex\
    \ int\n    var minVal int\n    var minIndex int\n    var minVal int\n    var minIndex\
    \ int\n    var minVal int\n    var minIndex int\n    var minVal int\n    var minIndex\
    \ int\n    var minVal int\n    var minIndex int\n    var minVal int\n    var minIndex\
    \ int\n    var minVal int\n    var minIndex int\n    var minVal int\n    var minIndex\
    \ int\n    var minVal int\n    var minIndex int\n    var minVal int\n    var minIndex\
    \ int\n    var minVal int\n    var minIndex int\n    var minVal int\n    var minIndex\
    \ int\n    var minVal int\n    var minIndex int\n    var minVal int\n    var minIndex\
    \ int\n    var minVal int\n    var minIndex int\n    var minVal int\n    var minIndex\
    \ int\n    var minVal int\n    var minIndex int\n    var minVal int\n    var minIndex\
    \ int\n    var minVal int\n    var minIndex int\n    var minVal int\n    var minIndex\
    \ int\n    var minVal int\n    var minIndex int\n    var minVal int\n    var minIndex\
    \ int\n    var minVal int\n    var minIndex int\n    var minVal int\n    var minIndex\
    \ int\n    var minVal int\n    var minIndex int\n    var minVal int\n    var minIndex\
    \ int\n    var minVal int\n    var minIndex int\n    var minVal int\n    var minIndex\
    \ int\n    var minVal int\n    var minIndex int\n    var minVal int\n    var minIndex\
    \ int\n    var minVal int\n    var minIndex int\n    var minVal int\n    var minIndex\
    \ int\n    var minVal int\n    var minIndex int\n    var min\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpl57ff_0k_test.go:136:9: missing variable type or initialization

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074616
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    sort.Ints(arr)\n\
    \    smalest_value := arr[0]\n    smalest_index := 0\n    for i := 1; i < len(arr);\
    \ i++ {\n        if arr[i] > arr[i-1] {\n            smalest_value = arr[i]\n\
    \            smalest_index = i\n        }\n    }\n    return []int{smalest_value,\
    \ smalest_index}\n}\n`\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6s_yevue_test.go:48:1: raw string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074616
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    sort.Sort(sort.Reverse(sort.IntSlice(arr)))\n    smalest_value := arr[0]\n\
    \    smalest_index := 0\n    for _, value := range arr {\n        if value%2 ==\
    \ 0 {\n            if value < smalest_value {\n                smalest_value =\
    \ value\n                smalest_index = sort.Search(len(arr), func(i int) bool\
    \ {\n                    return arr[i] < value\n                })\n         \
    \   }\n        }\n    }\n    return []int{smalest_value, smalest_index}\n}\n\n\
    func TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpr13wbtv2_test.go:34:5: undefined: sort

    /tmp/tmpr13wbtv2_test.go:41:33: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074616
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    sort.Sort(sort.Reverse(sort.IntSlice(arr)))\n    var index int\n    var\
    \ smalest_value int\n    for _, value := range arr {\n        if value % 2 ==\
    \ 0 {\n            smalest_value = value\n            index = len(arr) - sort.Search(len(arr),\
    \ func(i int) bool {\n                return arr[i] > smalest_value\n        \
    \    })\n            break\n        }\n    }\n    if index == len(arr) {\n   \
    \     return []int{}\n    }\n    return []int{smalest_value, index}\n}\n`\n  \
    \  )\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpl4h8eq92_test.go:51:1: raw string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074616
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    min := arr[0]\n\
    \    index := 0\n    for _, v := range arr {\n        if v%2 == 0 {\n        \
    \    if min > v {\n                min = v\n                index = index\n  \
    \          }\n        } else {\n            if min > v {\n                min\
    \ = v\n                index = index\n            }\n        }\n    }\n    return\
    \ []int{min, index}\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__0 (0.00s)\n\
    \        tmpw1cuerl4_test.go:75: expected '[%!s(int=2) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=0)]'\n    --- FAIL: TestPluck/test_num__1 (0.00s)\n        tmpw1cuerl4_test.go:75:\
    \ expected '[%!s(int=2) %!s(int=1)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL:\
    \ TestPluck/test_num__3 (0.00s)\n        tmpw1cuerl4_test.go:75: expected '[%!s(int=0)\
    \ %!s(int=1)]', got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestPluck/test_num__4\
    \ (0.00s)\n        tmpw1cuerl4_test.go:75: expected '[%!s(int=0) %!s(int=3)]',\
    \ got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestPluck/test_num__5 (0.00s)\n\
    \        tmpw1cuerl4_test.go:75: expected '[%!s(int=4) %!s(int=1)]', got '[%!s(int=4)\
    \ %!s(int=0)]'\n    --- FAIL: TestPluck/test_num__6 (0.00s)\n        tmpw1cuerl4_test.go:75:\
    \ expected '[%!s(int=6) %!s(int=1)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL:\
    \ TestPluck/test_num__7 (0.00s)\n        tmpw1cuerl4_test.go:75: expected '[]',\
    \ got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\n\
    FAIL\n"
  timestamp: 1660074609
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    arr2 := make([]int, len(arr))\n    arr3 := make([]int, len(arr))\n  \
    \  arr4 := make([]int, len(arr))\n    arr5 := make([]int, len(arr))\n    arr6\
    \ := make([]int, len(arr))\n    arr7 := make([]int, len(arr))\n    arr8 := make([]int,\
    \ len(arr))\n    arr9 := make([]int, len(arr))\n    arr10 := make([]int, len(arr))\n\
    \    arr11 := make([]int, len(arr))\n    arr12 := make([]int, len(arr))\n    arr13\
    \ := make([]int, len(arr))\n    arr14 := make([]int, len(arr))\n    arr15 := make([]int,\
    \ len(arr))\n    arr16 := make([]int, len(arr))\n    arr17 := make([]int, len(arr))\n\
    \    arr18 := make([]int, len(arr))\n    arr19 := make([]int, len(arr))\n    arr20\
    \ := make([]int, len(arr))\n    arr21 := make([]int, len(arr))\n    arr22 := make([]int,\
    \ len(arr))\n    arr23 := make([]int, len(arr))\n    arr24 := make([]int, len(arr))\n\
    \    arr25 := make([]int, len(arr))\n    arr26 := make([]int, len(arr))\n    arr27\
    \ := make([]int, len(arr))\n    arr28 := make([]int, len(arr))\n    arr29 := make([]int,\
    \ len(arr))\n    arr30 := make([]int, len(arr))\n    arr31 := make([]int, len(arr))\n\
    \    arr32 := make([]int, len(arr))\n    arr33 := make([]int, len(arr))\n    arr34\
    \ := make([]int, len(arr))\n    arr35 := make([]int, len(arr))\n    arr36 := make([]int,\
    \ len(arr))\n    arr37 := make([]int, len(arr))\n    arr38 := make([]int, len(arr))\n\
    \    arr39 := make([]int, len(arr))\n    arr40 := make([]int, len(arr))\n    arr41\
    \ := make([]int, len(arr))\n    arr42 := make([]int, len(arr))\n    arr43 := make([]int,\
    \ len(arr))\n    arr\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpn18y7qza_test.go:77:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074607
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    arr2 := make([]int, len(arr))\n    min := 0\n    max := 0\n    for i\
    \ := 0; i < len(arr); i++ {\n        if arr[i] > max {\n            max = arr[i]\n\
    \        }\n        if arr[i] < min {\n            min = arr[i]\n        }\n \
    \   }\n    for i := 0; i < len(arr); i++ {\n        if arr[i] > max {\n      \
    \      max = arr[i]\n        }\n        if arr[i] < min {\n            min = arr[i]\n\
    \        }\n        if arr[i] % 2 == 0 {\n            arr2[i] = arr[i]\n     \
    \   }\n    }\n    if len(arr2) == 0 {\n        return []int{}\n    }\n    for\
    \ i := 0; i < len(arr2); i++ {\n        if arr2[i] > max {\n            max =\
    \ arr2[i]\n        }\n        if arr2[i] < min {\n            min = arr2[i]\n\
    \        }\n    }\n    arr3 := make([]int, len(arr2))\n    for i := 0; i < len(arr2);\
    \ i++ {\n        if arr2[i] > max {\n            arr3[i] = arr2[i]\n        }\n\
    \        if arr2[i] < min {\n            arr3[i] = arr2[i]\n        }\n      \
    \  if arr2[i] % 2 == 0 {\n            arr3[i] = arr2[i]\n        }\n    }\n  \
    \  if len(arr3) == 0 {\n        return []int{}\n    }\n    for i := 0; i < len(arr3);\
    \ i++ {\n        if arr3[i] > max {\n            arr3[i] = arr2[i]\n        }\n\
    \        if arr3[i] < min {\n            arr3[i] = arr2[i]\n        }\n      \
    \  if arr3[i] % 2 == 0 {\n            arr3[i] = arr2[i]\n        }\n    }\n  \
    \  return arr3\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__0 (0.00s)\n\
    \        tmpttlzkl2m_test.go:116: expected '[%!s(int=2) %!s(int=1)]', got '[%!s(int=4)\
    \ %!s(int=2) %!s(int=0)]'\n    --- FAIL: TestPluck/test_num__1 (0.00s)\n     \
    \   tmpttlzkl2m_test.go:116: expected '[%!s(int=2) %!s(int=1)]', got '[%!s(int=0)\
    \ %!s(int=2) %!s(int=0)]'\n    --- FAIL: TestPluck/test_num__3 (0.00s)\n     \
    \   tmpttlzkl2m_test.go:116: expected '[%!s(int=0) %!s(int=1)]', got '[%!s(int=0)\
    \ %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestPluck/test_num__4\
    \ (0.00s)\n        tmpttlzkl2m_test.go:116: expected '[%!s(int=0) %!s(int=3)]',\
    \ got '[%!s(int=0) %!s(int=2) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\n\
    \    --- FAIL: TestPluck/test_num__5 (0.00s)\n        tmpttlzkl2m_test.go:116:\
    \ expected '[%!s(int=4) %!s(int=1)]', got '[%!s(int=0) %!s(int=4) %!s(int=8) %!s(int=4)\
    \ %!s(int=8)]'\n    --- FAIL: TestPluck/test_num__6 (0.00s)\n        tmpttlzkl2m_test.go:116:\
    \ expected '[%!s(int=6) %!s(int=1)]', got '[%!s(int=0) %!s(int=6) %!s(int=0) %!s(int=0)]'\n\
    \    --- FAIL: TestPluck/test_num__7 (0.00s)\n        tmpttlzkl2m_test.go:116:\
    \ expected '[]', got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074617
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return nil\n    }\n    smalest_value := arr[0]\n\
    \    smalest_index := 0\n    for i := 1; i < len(arr); i++ {\n        if arr[i]\
    \ < smalest_value {\n            smalest_value = arr[i]\n            smalest_index\
    \ = i\n        }\n    }\n    return []int{smalest_value, smalest_index}\n}\n\n\
    func TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__1 (0.00s)\n\
    \        tmpld_btnou_test.go:68: expected '[%!s(int=2) %!s(int=1)]', got '[%!s(int=1)\
    \ %!s(int=0)]'\n    --- FAIL: TestPluck/test_num__6 (0.00s)\n        tmpld_btnou_test.go:68:\
    \ expected '[%!s(int=6) %!s(int=1)]', got '[%!s(int=1) %!s(int=3)]'\n    --- FAIL:\
    \ TestPluck/test_num__7 (0.00s)\n        tmpld_btnou_test.go:68: expected '[]',\
    \ got '[%!s(int=1) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074617
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    result := make([]int, 0)\n    min := arr[0]\n    index := 0\n    for\
    \ _, value := range arr {\n        if value%2 == 0 {\n            if value < min\
    \ {\n                min = value\n                index = index\n            }\n\
    \        } else {\n            if min > value {\n                min = value\n\
    \                index = index\n            }\n        }\n    }\n    result =\
    \ append(result, min)\n    result = append(result, index)\n    return result\n\
    }\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\npanic: runtime error: index out of range [0]\
    \ with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with\
    \ length 0\n\ngoroutine 34 [running]:\ntesting.tRunner.func1.2({0x512440, 0xc0001d6000})\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x512440,\
    \ 0xc0001d6000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.pluck(...)\n\t/tmp/tmps3fulh75_test.go:35\n\
    command-line-arguments_test.TestPluck(0x0?)\n\t/tmp/tmps3fulh75_test.go:64 +0x1b0\n\
    testing.tRunner(0xc000199040, 0x527d38)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074614
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    result := make([]int, 0)\n    index := 0\n    for _, value := range arr\
    \ {\n        if value%2 == 0 {\n            result = append(result, value)\n \
    \           index = index + 1\n        }\n    }\n    if index == 0 {\n       \
    \ return nil\n    }\n    return append(result, arr[index-1], index)\n}\n\nfunc\
    \ TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__0 (0.00s)\n\
    \        tmpzpg9zdh8_test.go:68: expected '[%!s(int=2) %!s(int=1)]', got '[%!s(int=4)\
    \ %!s(int=2) %!s(int=2) %!s(int=2)]'\n    --- FAIL: TestPluck/test_num__1 (0.00s)\n\
    \        tmpzpg9zdh8_test.go:68: expected '[%!s(int=2) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=1) %!s(int=1)]'\n    --- FAIL: TestPluck/test_num__3 (0.00s)\n     \
    \   tmpzpg9zdh8_test.go:68: expected '[%!s(int=0) %!s(int=1)]', got '[%!s(int=0)\
    \ %!s(int=0) %!s(int=4) %!s(int=2) %!s(int=0) %!s(int=4)]'\n    --- FAIL: TestPluck/test_num__4\
    \ (0.00s)\n        tmpzpg9zdh8_test.go:68: expected '[%!s(int=0) %!s(int=3)]',\
    \ got '[%!s(int=2) %!s(int=0) %!s(int=2) %!s(int=2)]'\n    --- FAIL: TestPluck/test_num__5\
    \ (0.00s)\n        tmpzpg9zdh8_test.go:68: expected '[%!s(int=4) %!s(int=1)]',\
    \ got '[%!s(int=4) %!s(int=8) %!s(int=4) %!s(int=8) %!s(int=4) %!s(int=4)]'\n\
    \    --- FAIL: TestPluck/test_num__6 (0.00s)\n        tmpzpg9zdh8_test.go:68:\
    \ expected '[%!s(int=6) %!s(int=1)]', got '[%!s(int=6) %!s(int=7) %!s(int=1)]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074617
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    result := make([]int, 0)\n    min := arr[0]\n    index := 0\n    for\
    \ _, v := range arr {\n        if v%2 == 0 {\n            if min > v {\n     \
    \           min = v\n                index = index\n            }\n        } else\
    \ {\n            if min > v {\n                min = v\n                index\
    \ = index\n            }\n        }\n    }\n    result = append(result, min)\n\
    \    result = append(result, index)\n    return result\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\npanic: runtime error: index out of range [0]\
    \ with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with\
    \ length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440, 0xc000014360})\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.pluck(...)\n\t/tmp/tmpcs680i9__test.go:35\n\
    command-line-arguments_test.TestPluck(0x0?)\n\t/tmp/tmpcs680i9__test.go:64 +0x1b0\n\
    testing.tRunner(0xc0001924e0, 0x527d38)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074609
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    // write your code here\n    sort.Ints(arr)\n    var result []int\n \
    \   var index int\n    for _, v := range arr {\n        if v%2 == 0 {\n      \
    \      result = append(result, v)\n            index = len(result)\n        }\n\
    \    }\n    if index == 0 {\n        return []\n    }\n    return result\n}\n\n\
    func TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpdl0bum1b_test.go:45:18: expected type, found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074616
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    arr2 := make([]int, len(arr))\n    arr3 := make([]int, len(arr))\n  \
    \  arr4 := make([]int, len(arr))\n    arr5 := make([]int, len(arr))\n    arr6\
    \ := make([]int, len(arr))\n    arr7 := make([]int, len(arr))\n    arr8 := make([]int,\
    \ len(arr))\n    arr9 := make([]int, len(arr))\n    arr10 := make([]int, len(arr))\n\
    \    arr11 := make([]int, len(arr))\n    arr12 := make([]int, len(arr))\n    arr13\
    \ := make([]int, len(arr))\n    arr14 := make([]int, len(arr))\n    arr15 := make([]int,\
    \ len(arr))\n    arr16 := make([]int, len(arr))\n    arr17 := make([]int, len(arr))\n\
    \    arr18 := make([]int, len(arr))\n    arr19 := make([]int, len(arr))\n    arr20\
    \ := make([]int, len(arr))\n    arr21 := make([]int, len(arr))\n    arr22 := make([]int,\
    \ len(arr))\n    arr23 := make([]int, len(arr))\n    arr24 := make([]int, len(arr))\n\
    \    arr25 := make([]int, len(arr))\n    arr26 := make([]int, len(arr))\n    arr27\
    \ := make([]int, len(arr))\n    arr28 := make([]int, len(arr))\n    arr29 := make([]int,\
    \ len(arr))\n    arr30 := make([]int, len(arr))\n    arr31 := make([]int, len(arr))\n\
    \    arr32 := make([]int, len(arr))\n    arr33 := make([]int, len(arr))\n    arr34\
    \ := make([]int, len(arr))\n    arr35 := make([]int, len(arr))\n    arr36 := make([]int,\
    \ len(arr))\n    arr37 := make([]int, len(arr))\n    arr38 := make([]int, len(arr))\n\
    \    arr39 := make([]int, len(arr))\n    arr40 := make([]int, len(arr))\n    arr41\
    \ := make([]int, len(arr))\n    arr42 := make([]int, len(arr))\n    arr43 := make([]int,\
    \ len(arr))\n    arr\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpn18y7qza_test.go:77:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074607
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    sort.Ints(arr)\n    var result []int\n    var index int\n    for _, v\
    \ := range arr {\n        if v%2 == 0 {\n            result = append(result, v)\n\
    \            index = len(result)-1\n        }\n    }\n    if index == -1 {\n \
    \       return []int{}\n    }\n    return result\n}\n\nfunc TestPluck(t *testing.T)\
    \ {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpotovrh6g_test.go:34:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074616
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    m := make(map[int]int)\n    for _, v := range arr {\n        m[v]++\n\
    \    }\n    result := make([]int, 0, len(m))\n    for _, v := range m {\n    \
    \    if v%2 == 0 {\n            result = append(result, v)\n        }\n    }\n\
    \    if len(result) == 0 {\n        return []int{}\n    }\n    if len(result)\
    \ == 1 {\n        return result[0]\n    }\n    return result\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp30th4kte_test.go:48:16: cannot use result[0] (variable of type int) as
    type []int in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074616
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    arr2 := make([]int, len(arr))\n    arr3 := make([]int, len(arr))\n  \
    \  arr4 := make([]int, len(arr))\n    arr5 := make([]int, len(arr))\n    arr6\
    \ := make([]int, len(arr))\n    arr7 := make([]int, len(arr))\n    arr8 := make([]int,\
    \ len(arr))\n    arr9 := make([]int, len(arr))\n    arr10 := make([]int, len(arr))\n\
    \    arr11 := make([]int, len(arr))\n    arr12 := make([]int, len(arr))\n    arr13\
    \ := make([]int, len(arr))\n    arr14 := make([]int, len(arr))\n    arr15 := make([]int,\
    \ len(arr))\n    arr16 := make([]int, len(arr))\n    arr17 := make([]int, len(arr))\n\
    \    arr18 := make([]int, len(arr))\n    arr19 := make([]int, len(arr))\n    arr20\
    \ := make([]int, len(arr))\n    arr21 := make([]int, len(arr))\n    arr22 := make([]int,\
    \ len(arr))\n    arr23 := make([]int, len(arr))\n    arr24 := make([]int, len(arr))\n\
    \    arr25 := make([]int, len(arr))\n    arr26 := make([]int, len(arr))\n    arr27\
    \ := make([]int, len(arr))\n    arr28 := make([]int, len(arr))\n    arr29 := make([]int,\
    \ len(arr))\n    arr30 := make([]int, len(arr))\n    arr31 := make([]int, len(arr))\n\
    \    arr32 := make([]int, len(arr))\n    arr33 := make([]int, len(arr))\n    arr34\
    \ := make([]int, len(arr))\n    arr35 := make([]int, len(arr))\n    arr36 := make([]int,\
    \ len(arr))\n    arr37 := make([]int, len(arr))\n    arr38 := make([]int, len(arr))\n\
    \    arr39 := make([]int, len(arr))\n    arr40 := make([]int, len(arr))\n    arr41\
    \ := make([]int, len(arr))\n    arr42 := make([]int, len(arr))\n    arr43 := make([]int,\
    \ len(arr))\n    arr\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpn18y7qza_test.go:77:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074607
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    m := make(map[int]int)\n    for _, v := range arr {\n        m[v] = m[v]\
    \ + 1\n    }\n    arr2 := make([]int, 0, len(m))\n    for v, cnt := range m {\n\
    \        if cnt > 1 {\n            arr2 = append(arr2, v)\n        }\n    }\n\
    \    if len(arr2) == 0 {\n        return nil\n    }\n    if len(arr2) == 1 {\n\
    \        return arr2\n    }\n    arr3 = make([]int, 0, len(arr2))\n    for _,\
    \ v := range arr2 {\n        if v%2 == 0 {\n            arr3 = append(arr3, v)\n\
    \        }\n    }\n    if len(arr3) == 0 {\n        return nil\n    }\n    if\
    \ len(arr3) == 1 {\n        return arr3\n    }\n    arr4 = make([]int, 0, len(arr3))\n\
    \    for _, v := range arr3 {\n        if v%2 == 1 {\n            arr4 = append(arr4,\
    \ v)\n        }\n    }\n    if len(arr4) == 0 {\n        return nil\n    }\n \
    \   if len(arr4) == 1 {\n        return arr4\n    }\n    arr5 = make([]int, 0,\
    \ len(arr4))\n    for _, v := range arr4 {\n        if v%2 == 2 {\n          \
    \  arr5 = append(arr5, v)\n        }\n    }\n    if len(arr5) == 0 {\n       \
    \ return nil\n    }\n    if len(arr5) == 1 {\n        return arr5\n    }\n   \
    \ arr6 = make([]int, 0, len(arr5))\n    for _, v := range arr5 {\n        if v%2\
    \ == 3 {\n            arr6 = append(arr6, v)\n        }\n    }\n    if len(arr6)\
    \ == 0 {\n        return nil\n    }\n    if len(arr6) == 1 {\n        return arr6\n\
    \    }\n    arr7 = make([]int, 0, len(arr6))\n    for _, v := range arr6 {\n \
    \       if v%2 == 4 {\n            arr7 = append(arr7, v)\n        }\n    }\n\
    \    if len(arr7) == 0 {\n        return nil\n    }\n    if len(arr7) == 1 {\n\
    \        return arr7\n    }\n    arr8 = make([]int, 0, len(arr7))\n    for _,\
    \ v := range arr7 {\n        if v%2 == 5 {\n            arr8 = append(arr8, v)\n\
    \        }\n    }\n    if len(arr8) == 0 {\n        return nil\n    }\n    if\
    \ len(arr8) == 1 {\n        return arr8\n    }\n    arr9 = make([]int, 0, len(arr8))\n\
    \    for _, v := range arr8 {\n        if v%2 == 6 {\n            arr9 = append(arr9,\
    \ v)\n        }\n    }\n    if len(arr9) == 0 {\n        return nil\n    }\n \
    \   if len(arr9) == 1 {\n        return arr9\n    }\nfunc TestPluck(t *testing.T)\
    \ {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp9wjr8ils_test.go:134:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074616
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    arr2 := make([]int, len(arr))\n    min := arr[0]\n    index := 0\n  \
    \  for i := 0; i < len(arr); i++ {\n        if arr[i] < min {\n            min\
    \ = arr[i]\n            index = i\n        }\n    }\n    arr2[index] = min\n \
    \   return arr2\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\npanic: runtime error: index out of range [0]\
    \ with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with\
    \ length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440, 0xc000014390})\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x512440,\
    \ 0xc000014390})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.pluck(...)\n\t/tmp/tmp1200_9mi_test.go:35\n\
    command-line-arguments_test.TestPluck(0x0?)\n\t/tmp/tmp1200_9mi_test.go:56 +0x135\n\
    testing.tRunner(0xc0001a0340, 0x527d38)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074617
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    result := make([]int, 0)\n    min := arr[0]\n    index := 0\n    for\
    \ _, value := range arr {\n        if value%2 == 0 {\n            if value < min\
    \ {\n                min = value\n                index = index\n            }\n\
    \        } else {\n            if min > value {\n                min = value\n\
    \                index = index\n            }\n        }\n    }\n    result =\
    \ append(result, min)\n    result = append(result, index)\n    return result\n\
    }\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\npanic: runtime error: index out of range [0]\
    \ with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with\
    \ length 0\n\ngoroutine 34 [running]:\ntesting.tRunner.func1.2({0x512440, 0xc0001d6000})\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x512440,\
    \ 0xc0001d6000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.pluck(...)\n\t/tmp/tmps3fulh75_test.go:35\n\
    command-line-arguments_test.TestPluck(0x0?)\n\t/tmp/tmps3fulh75_test.go:64 +0x1b0\n\
    testing.tRunner(0xc000199040, 0x527d38)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074614
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    sort.Sort(sort.Reverse(sort.IntSlice(arr)))\n    var result []int\n \
    \   var index int\n    for _, v := range arr {\n        if v%2 == 0 {\n      \
    \      result = append(result, v)\n            index = len(result)-1\n       \
    \ }\n    }\n    if index == -1 {\n        return nil\n    }\n    return append([]int{result[index],\
    \ index}, result[:index]...)\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate\
    \ := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual:\
    \ candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual:\
    \ candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7,\
    \ 6, 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7,\
    \ 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjt3nlzn5_test.go:34:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074616
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    arr := make([]int, len(arr))\n    min := 0\n    max := 0\n    index :=\
    \ 0\n    for i := 0; i < len(arr); i++ {\n        if arr[i] > max {\n        \
    \    max = arr[i]\n            index = i\n        }\n        if arr[i] < min {\n\
    \            min = arr[i]\n        }\n    }\n    if min % 2 == 0 {\n        arr[index]\
    \ = min\n        return arr\n    }\n    arr[index] = min\n    return arr\n}\n\n\
    func TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmph5cr7_4t_test.go:34:9: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074617
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    result := make([]int, 0)\n    min := arr[0]\n    index := 0\n    for\
    \ _, value := range arr {\n        if value%2 == 0 {\n            if value < min\
    \ {\n                min = value\n                index = index\n            }\n\
    \        } else {\n            if min > value {\n                min = value\n\
    \                index = index\n            }\n        }\n    }\n    result =\
    \ append(result, min)\n    result = append(result, index)\n    return result\n\
    }\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\npanic: runtime error: index out of range [0]\
    \ with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with\
    \ length 0\n\ngoroutine 34 [running]:\ntesting.tRunner.func1.2({0x512440, 0xc0001d6000})\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x512440,\
    \ 0xc0001d6000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.pluck(...)\n\t/tmp/tmps3fulh75_test.go:35\n\
    command-line-arguments_test.TestPluck(0x0?)\n\t/tmp/tmps3fulh75_test.go:64 +0x1b0\n\
    testing.tRunner(0xc000199040, 0x527d38)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074614
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    // write your code here\n    arr := make([]int, len(arr))\n    arr[0]\
    \ = arr[0]\n    arr[len(arr)-1] = arr[len(arr)-1]\n    i := 0\n    for i < len(arr)\
    \ {\n        if arr[i] % 2 == 0 {\n            arr[i] = arr[i]\n            i++\n\
    \        } else {\n            arr[i] = arr[i] + 1\n            i++\n        }\n\
    \    }\n    sort.Ints(arr)\n    result := make([]int, 0)\n    for _, v := range\
    \ arr {\n        if v%2 == 0 {\n            result = append(result, v)\n     \
    \   }\n    }\n    return result\n}\n`\n\nfunc TestPluck(t *testing.T) {\n  candidate\
    \ := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual:\
    \ candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual:\
    \ candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7,\
    \ 6, 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7,\
    \ 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp0minj6vw_test.go:57:1: raw string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074616
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    sort.Ints(arr)\n    var result []int\n    var index int\n    for _, v\
    \ := range arr {\n        if v%2 == 0 {\n            result = append(result, v)\n\
    \            index = len(result)\n        }\n    }\n    if index == 0 {\n    \
    \    return []int{}\n    }\n    return result\n}\n\nfunc TestPluck(t *testing.T)\
    \ {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpv1cntyoh_test.go:34:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074617
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    // write your code here\n    sort.Ints(arr)\n    index := 0\n    smalest_value\
    \ := arr[0]\n    for _, value := range arr {\n        if value%2 == 0 {\n    \
    \        if value < smalest_value {\n                smalest_value = value\n \
    \               index = index + 1\n            }\n        } else {\n         \
    \   if value < smalest_value {\n                smalest_value = value\n      \
    \          index = index + 1\n            }\n        }\n    }\n    if index ==\
    \ 0 {\n        return []int{}\n    }\n    return []int{smalest_value, index}\n\
    }\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvme1q1cz_test.go:35:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074617
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    sort.Ints(arr)\n    smalest_value := arr[0]\n    smalest_index := 0\n\
    \    for _, value := range arr {\n        if value%2 == 0 {\n            if value\
    \ < smalest_value {\n                smalest_value = value\n                smalest_index\
    \ = sort.Search(len(arr), func(i int) bool {\n                    return arr[i]\
    \ < value\n                })\n            }\n        }\n    }\n    return []int{smalest_value,\
    \ smalest_index}\n}\n`\n)\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpmov8wlk6_test.go:49:1: raw string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074610
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    result := make([]int, 0)\n    min := arr[0]\n    index := 0\n    for\
    \ _, v := range arr {\n        if v%2 == 0 {\n            if min > v {\n     \
    \           min = v\n                index = index\n            }\n        } else\
    \ {\n            if min > v {\n                min = v\n                index\
    \ = index\n            }\n        }\n    }\n    result = append(result, min)\n\
    \    result = append(result, index)\n    return result\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\npanic: runtime error: index out of range [0]\
    \ with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with\
    \ length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440, 0xc000014360})\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.pluck(...)\n\t/tmp/tmpcs680i9__test.go:35\n\
    command-line-arguments_test.TestPluck(0x0?)\n\t/tmp/tmpcs680i9__test.go:64 +0x1b0\n\
    testing.tRunner(0xc0001924e0, 0x527d38)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074609
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    sort.Ints(arr)\n\
    \    smalest_value := arr[0]\n    smalest_index := 0\n    for _, value := range\
    \ arr {\n        if value%2 == 0 {\n            if value < smalest_value {\n \
    \               smalest_value = value\n                smalest_index = sort.Search(len(arr),\
    \ func(i int) bool {\n                    return arr[i] < value\n            \
    \    })\n            }\n        }\n    }\n    return []int{smalest_value, smalest_index}\n\
    }\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmptpm5467i_test.go:37:5: undefined: sort

    /tmp/tmptpm5467i_test.go:44:33: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074617
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    arr2 := make([]int, len(arr))\n    arr3 := make([]int, len(arr))\n  \
    \  arr4 := make([]int, len(arr))\n    arr5 := make([]int, len(arr))\n    arr6\
    \ := make([]int, len(arr))\n    arr7 := make([]int, len(arr))\n    arr8 := make([]int,\
    \ len(arr))\n    arr9 := make([]int, len(arr))\n    arr10 := make([]int, len(arr))\n\
    \    arr11 := make([]int, len(arr))\n    arr12 := make([]int, len(arr))\n    arr13\
    \ := make([]int, len(arr))\n    arr14 := make([]int, len(arr))\n    arr15 := make([]int,\
    \ len(arr))\n    arr16 := make([]int, len(arr))\n    arr17 := make([]int, len(arr))\n\
    \    arr18 := make([]int, len(arr))\n    arr19 := make([]int, len(arr))\n    arr20\
    \ := make([]int, len(arr))\n    arr21 := make([]int, len(arr))\n    arr22 := make([]int,\
    \ len(arr))\n    arr23 := make([]int, len(arr))\n    arr24 := make([]int, len(arr))\n\
    \    arr25 := make([]int, len(arr))\n    arr26 := make([]int, len(arr))\n    arr27\
    \ := make([]int, len(arr))\n    arr28 := make([]int, len(arr))\n    arr29 := make([]int,\
    \ len(arr))\n    arr30 := make([]int, len(arr))\n    arr31 := make([]int, len(arr))\n\
    \    arr32 := make([]int, len(arr))\n    arr33 := make([]int, len(arr))\n    arr34\
    \ := make([]int, len(arr))\n    arr35 := make([]int, len(arr))\n    arr36 := make([]int,\
    \ len(arr))\n    arr37 := make([]int, len(arr))\n    arr38 := make([]int, len(arr))\n\
    \    arr39 := make([]int, len(arr))\n    arr40 := make([]int, len(arr))\n    arr41\
    \ := make([]int, len(arr))\n    arr42 := make([]int, len(arr))\n    arr43 := make([]int,\
    \ len(arr))\n    arr\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpn18y7qza_test.go:77:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074607
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var result []int\n    var smallestValue int\n    var smallestIndex int\n\
    \    for _, node := range arr {\n        if smallestValue == 0 || smallestValue\
    \ > node {\n            smallestValue = node\n            smallestIndex = 0\n\
    \        }\n        if smallestValue == node {\n            smallestIndex++\n\
    \        }\n    }\n    if smallestValue != 0 {\n        result = append(result,\
    \ smallestValue)\n    }\n    if smallestIndex != 0 {\n        result = append(result,\
    \ smallestIndex)\n    }\n    return result\n}\n\nfunc TestPluck(t *testing.T)\
    \ {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__1 (0.00s)\n\
    \        tmpxm8n02a__test.go:75: expected '[%!s(int=2) %!s(int=1)]', got '[%!s(int=1)\
    \ %!s(int=1)]'\n    --- FAIL: TestPluck/test_num__3 (0.00s)\n        tmpxm8n02a__test.go:75:\
    \ expected '[%!s(int=0) %!s(int=1)]', got '[%!s(int=2) %!s(int=1)]'\n    --- FAIL:\
    \ TestPluck/test_num__4 (0.00s)\n        tmpxm8n02a__test.go:75: expected '[%!s(int=0)\
    \ %!s(int=3)]', got '[%!s(int=3) %!s(int=1)]'\n    --- FAIL: TestPluck/test_num__5\
    \ (0.00s)\n        tmpxm8n02a__test.go:75: expected '[%!s(int=4) %!s(int=1)]',\
    \ got '[%!s(int=4) %!s(int=2)]'\n    --- FAIL: TestPluck/test_num__6 (0.00s)\n\
    \        tmpxm8n02a__test.go:75: expected '[%!s(int=6) %!s(int=1)]', got '[%!s(int=1)\
    \ %!s(int=1)]'\n    --- FAIL: TestPluck/test_num__7 (0.00s)\n        tmpxm8n02a__test.go:75:\
    \ expected '[]', got '[%!s(int=1) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660074617
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    arr2 := make([]int, len(arr))\n    arr3 := make([]int, len(arr))\n  \
    \  arr4 := make([]int, len(arr))\n    arr5 := make([]int, len(arr))\n    arr6\
    \ := make([]int, len(arr))\n    arr7 := make([]int, len(arr))\n    arr8 := make([]int,\
    \ len(arr))\n    arr9 := make([]int, len(arr))\n    arr10 := make([]int, len(arr))\n\
    \    arr11 := make([]int, len(arr))\n    arr12 := make([]int, len(arr))\n    arr13\
    \ := make([]int, len(arr))\n    arr14 := make([]int, len(arr))\n    arr15 := make([]int,\
    \ len(arr))\n    arr16 := make([]int, len(arr))\n    arr17 := make([]int, len(arr))\n\
    \    arr18 := make([]int, len(arr))\n    arr19 := make([]int, len(arr))\n    arr20\
    \ := make([]int, len(arr))\n    arr21 := make([]int, len(arr))\n    arr22 := make([]int,\
    \ len(arr))\n    arr23 := make([]int, len(arr))\n    arr24 := make([]int, len(arr))\n\
    \    arr25 := make([]int, len(arr))\n    arr26 := make([]int, len(arr))\n    arr27\
    \ := make([]int, len(arr))\n    arr28 := make([]int, len(arr))\n    arr29 := make([]int,\
    \ len(arr))\n    arr30 := make([]int, len(arr))\n    arr31 := make([]int, len(arr))\n\
    \    arr32 := make([]int, len(arr))\n    arr33 := make([]int, len(arr))\n    arr34\
    \ := make([]int, len(arr))\n    arr35 := make([]int, len(arr))\n    arr36 := make([]int,\
    \ len(arr))\n    arr37 := make([]int, len(arr))\n    arr38 := make([]int, len(arr))\n\
    \    arr39 := make([]int, len(arr))\n    arr40 := make([]int, len(arr))\n    arr41\
    \ := make([]int, len(arr))\n    arr42 := make([]int, len(arr))\n    arr43 := make([]int,\
    \ len(arr))\n    arr\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpn18y7qza_test.go:77:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074607
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    arr2 := make([]int, len(arr))\n    arr3 := make([]int, len(arr))\n  \
    \  arr4 := make([]int, len(arr))\n    arr5 := make([]int, len(arr))\n    arr6\
    \ := make([]int, len(arr))\n    arr7 := make([]int, len(arr))\n    arr8 := make([]int,\
    \ len(arr))\n    arr9 := make([]int, len(arr))\n    arr10 := make([]int, len(arr))\n\
    \    arr11 := make([]int, len(arr))\n    arr12 := make([]int, len(arr))\n    arr13\
    \ := make([]int, len(arr))\n    arr14 := make([]int, len(arr))\n    arr15 := make([]int,\
    \ len(arr))\n    arr16 := make([]int, len(arr))\n    arr17 := make([]int, len(arr))\n\
    \    arr18 := make([]int, len(arr))\n    arr19 := make([]int, len(arr))\n    arr20\
    \ := make([]int, len(arr))\n    arr21 := make([]int, len(arr))\n    arr22 := make([]int,\
    \ len(arr))\n    arr23 := make([]int, len(arr))\n    arr24 := make([]int, len(arr))\n\
    \    arr25 := make([]int, len(arr))\n    arr26 := make([]int, len(arr))\n    arr27\
    \ := make([]int, len(arr))\n    arr28 := make([]int, len(arr))\n    arr29 := make([]int,\
    \ len(arr))\n    arr30 := make([]int, len(arr))\n    arr31 := make([]int, len(arr))\n\
    \    arr32 := make([]int, len(arr))\n    arr33 := make([]int, len(arr))\n    arr34\
    \ := make([]int, len(arr))\n    arr35 := make([]int, len(arr))\n    arr36 := make([]int,\
    \ len(arr))\n    arr37 := make([]int, len(arr))\n    arr38 := make([]int, len(arr))\n\
    \    arr39 := make([]int, len(arr))\n    arr40 := make([]int, len(arr))\n    arr41\
    \ := make([]int, len(arr))\n    arr42 := make([]int, len(arr))\n    arr43 := make([]int,\
    \ len(arr))\n    arr\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpn18y7qza_test.go:77:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074607
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    sort.Ints(arr)\n    smalest_value := arr[0]\n    smalest_index := 0\n\
    \    for i := 1; i < len(arr); i++ {\n        if arr[i] < smalest_value {\n  \
    \          smalest_value = arr[i]\n            smalest_index = i\n        }\n\
    \    }\n    return []int{smalest_value, smalest_index}\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpp_pyvtmx_test.go:34:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074608
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    sort.Sort(sort.Reverse(arr))\n    evens := make([]int, 0)\n    index\
    \ := 0\n    for _, v := range arr {\n        if v%2 == 0 {\n            evens\
    \ = append(evens, v)\n        }\n        if v == 0 {\n            index = len(evens)\n\
    \        }\n    }\n    if index == 0 {\n        return []int{}\n    }\n    return\
    \ evens\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n   \
    \  { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpv6i63ycx_test.go:34:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074617
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    result := make([]int, 0)\n    min := arr[0]\n    index := 0\n    for\
    \ _, val := range arr {\n        if val%2 == 0 {\n            if val < min {\n\
    \                min = val\n                index = index\n            }\n   \
    \     } else {\n            if val == min {\n                index = index + 1\n\
    \            }\n        }\n    }\n    result = append(result, min)\n    result\
    \ = append(result, index)\n    return result\n}\n\nfunc TestPluck(t *testing.T)\
    \ {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\npanic: runtime error: index out of range [0]\
    \ with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with\
    \ length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440, 0xc000014360})\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.pluck(...)\n\t/tmp/tmpn91mkimw_test.go:35\n\
    command-line-arguments_test.TestPluck(0x0?)\n\t/tmp/tmpn91mkimw_test.go:63 +0x1e5\n\
    testing.tRunner(0xc0001a0340, 0x527d38)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074617
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    arr2 := make([]int, len(arr))\n    arr3 := make([]int, len(arr))\n  \
    \  arr4 := make([]int, len(arr))\n    arr5 := make([]int, len(arr))\n    arr6\
    \ := make([]int, len(arr))\n    arr7 := make([]int, len(arr))\n    arr8 := make([]int,\
    \ len(arr))\n    arr9 := make([]int, len(arr))\n    arr10 := make([]int, len(arr))\n\
    \    arr11 := make([]int, len(arr))\n    arr12 := make([]int, len(arr))\n    arr13\
    \ := make([]int, len(arr))\n    arr14 := make([]int, len(arr))\n    arr15 := make([]int,\
    \ len(arr))\n    arr16 := make([]int, len(arr))\n    arr17 := make([]int, len(arr))\n\
    \    arr18 := make([]int, len(arr))\n    arr19 := make([]int, len(arr))\n    arr20\
    \ := make([]int, len(arr))\n    arr21 := make([]int, len(arr))\n    arr22 := make([]int,\
    \ len(arr))\n    arr23 := make([]int, len(arr))\n    arr24 := make([]int, len(arr))\n\
    \    arr25 := make([]int, len(arr))\n    arr26 := make([]int, len(arr))\n    arr27\
    \ := make([]int, len(arr))\n    arr28 := make([]int, len(arr))\n    arr29 := make([]int,\
    \ len(arr))\n    arr30 := make([]int, len(arr))\n    arr31 := make([]int, len(arr))\n\
    \    arr32 := make([]int, len(arr))\n    arr33 := make([]int, len(arr))\n    arr34\
    \ := make([]int, len(arr))\n    arr35 := make([]int, len(arr))\n    arr36 := make([]int,\
    \ len(arr))\n    arr37 := make([]int, len(arr))\n    arr38 := make([]int, len(arr))\n\
    \    arr39 := make([]int, len(arr))\n    arr40 := make([]int, len(arr))\n    arr41\
    \ := make([]int, len(arr))\n    arr42 := make([]int, len(arr))\n    arr43 := make([]int,\
    \ len(arr))\n    arr\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpn18y7qza_test.go:77:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074607
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    sort.Sort(sort.Reverse(sort.IntSlice(arr)))\n    index := 0\n    smalest_value\
    \ := arr[0]\n    for _, value := range arr {\n        if value%2 == 0 {\n    \
    \        if value < smalest_value {\n                smalest_value = value\n \
    \               index = index + 1\n            }\n        }\n    }\n    return\
    \ []int{smalest_value, index}\n}\n`\n\nfunc TestPluck(t *testing.T) {\n  candidate\
    \ := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual:\
    \ candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual:\
    \ candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7,\
    \ 6, 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7,\
    \ 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpbubfueyf_test.go:47:1: raw string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074617
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given an array representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given array is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // []int{}\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    result := make([]int, 0)\n    min := arr[0]\n    index := 0\n    for\
    \ _, value := range arr {\n        if value%2 == 0 {\n            if value < min\
    \ {\n                min = value\n                index = index\n            }\n\
    \        } else {\n            if min > value {\n                min = value\n\
    \                index = index\n            }\n        }\n    }\n    result =\
    \ append(result, min)\n    result = append(result, index)\n    return result\n\
    }\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\npanic: runtime error: index out of range [0]\
    \ with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with\
    \ length 0\n\ngoroutine 34 [running]:\ntesting.tRunner.func1.2({0x512440, 0xc0001d6000})\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x512440,\
    \ 0xc0001d6000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.pluck(...)\n\t/tmp/tmps3fulh75_test.go:35\n\
    command-line-arguments_test.TestPluck(0x0?)\n\t/tmp/tmps3fulh75_test.go:64 +0x1b0\n\
    testing.tRunner(0xc000199040, 0x527d38)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074614
