language: go_test.go
name: HumanEval_78_hex_key
results:
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    n\
    \ := 0\n    for _, r := range num {\n        n += int(r) - int('A') + int('0')\n\
    \    }\n    return n\n}\n\nfunc TestHex_Key(t *testing.T) {\n  candidate := hex_key\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"AB\"), expected: 1 },\n     {\
    \ actual: candidate(\"1077E\"), expected: 2 },\n     { actual: candidate(\"ABED1A33\"\
    ), expected: 4 },\n     { actual: candidate(\"2020\"), expected: 2 },\n     {\
    \ actual: candidate(\"123456789ABCDEF0\"), expected: 6 },\n     { actual: candidate(\"\
    112233445566778899AABBCCDDEEFF00\"), expected: 12 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestHex_Key (0.00s)\n    --- FAIL: TestHex_Key/test_num__0 (0.00s)\n\
    \        tmpc3262wjc_test.go:55: expected '%!s(int=1)', got '%!s(int=97)'\n  \
    \  --- FAIL: TestHex_Key/test_num__1 (0.00s)\n        tmpc3262wjc_test.go:55:\
    \ expected '%!s(int=2)', got '%!s(int=191)'\n    --- FAIL: TestHex_Key/test_num__2\
    \ (0.00s)\n        tmpc3262wjc_test.go:55: expected '%!s(int=4)', got '%!s(int=348)'\n\
    \    --- FAIL: TestHex_Key/test_num__3 (0.00s)\n        tmpc3262wjc_test.go:55:\
    \ expected '%!s(int=2)', got '%!s(int=128)'\n    --- FAIL: TestHex_Key/test_num__4\
    \ (0.00s)\n        tmpc3262wjc_test.go:55: expected '%!s(int=6)', got '%!s(int=658)'\n\
    \    --- FAIL: TestHex_Key/test_num__5 (0.00s)\n        tmpc3262wjc_test.go:55:\
    \ expected '%!s(int=12)', got '%!s(int=1316)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660074585
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    n\
    \ := 0\n    i := 0\n    for ; i < len(num); i++ {\n        n += int(num[i]) -\
    \ 'A'\n    }\n    if n == 0 {\n        return 0\n    }\n    n /= 2\n    for ;\
    \ i < len(num); i++ {\n        n += int(num[i]) - 'A'\n        if n % 2 == 0 {\n\
    \            n /= 2\n        }\n    }\n    return n\n}\n\nfunc TestHex_Key(t *testing.T)\
    \ {\n  candidate := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AB\"), expected: 1 },\n     { actual: candidate(\"1077E\"), expected: 2 },\n \
    \    { actual: candidate(\"ABED1A33\"), expected: 4 },\n     { actual: candidate(\"\
    2020\"), expected: 2 },\n     { actual: candidate(\"123456789ABCDEF0\"), expected:\
    \ 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"), expected:\
    \ 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestHex_Key (0.00s)\n    --- FAIL: TestHex_Key/test_num__0 (0.00s)\n\
    \        tmpx1s56uet_test.go:66: expected '%!s(int=1)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestHex_Key/test_num__1 (0.00s)\n        tmpx1s56uet_test.go:66: expected\
    \ '%!s(int=2)', got '%!s(int=-24)'\n    --- FAIL: TestHex_Key/test_num__2 (0.00s)\n\
    \        tmpx1s56uet_test.go:66: expected '%!s(int=4)', got '%!s(int=-18)'\n \
    \   --- FAIL: TestHex_Key/test_num__3 (0.00s)\n        tmpx1s56uet_test.go:66:\
    \ expected '%!s(int=2)', got '%!s(int=-32)'\n    --- FAIL: TestHex_Key/test_num__4\
    \ (0.00s)\n        tmpx1s56uet_test.go:66: expected '%!s(int=6)', got '%!s(int=-55)'\n\
    \    --- FAIL: TestHex_Key/test_num__5 (0.00s)\n        tmpx1s56uet_test.go:66:\
    \ expected '%!s(int=12)', got '%!s(int=-110)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074685
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    //\
    \ Your code here\n    \n    return 0\n}\n\nfunc TestHex_Key(t *testing.T) {\n\
    \  candidate := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AB\"\
    ), expected: 1 },\n     { actual: candidate(\"1077E\"), expected: 2 },\n     {\
    \ actual: candidate(\"ABED1A33\"), expected: 4 },\n     { actual: candidate(\"\
    2020\"), expected: 2 },\n     { actual: candidate(\"123456789ABCDEF0\"), expected:\
    \ 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"), expected:\
    \ 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestHex_Key (0.00s)\n    --- FAIL: TestHex_Key/test_num__0 (0.00s)\n\
    \        tmpcshf94km_test.go:53: expected '%!s(int=1)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestHex_Key/test_num__1 (0.00s)\n        tmpcshf94km_test.go:53: expected\
    \ '%!s(int=2)', got '%!s(int=0)'\n    --- FAIL: TestHex_Key/test_num__2 (0.00s)\n\
    \        tmpcshf94km_test.go:53: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestHex_Key/test_num__3 (0.00s)\n        tmpcshf94km_test.go:53: expected\
    \ '%!s(int=2)', got '%!s(int=0)'\n    --- FAIL: TestHex_Key/test_num__4 (0.00s)\n\
    \        tmpcshf94km_test.go:53: expected '%!s(int=6)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestHex_Key/test_num__5 (0.00s)\n        tmpcshf94km_test.go:53: expected\
    \ '%!s(int=12)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074578
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    n\
    \ := 0\n    for _, r := range num {\n        n += int(rune(r) - 'A') + 1\n   \
    \ }\n    return n\n}\n\nfunc TestHex_Key(t *testing.T) {\n  candidate := hex_key\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"AB\"), expected: 1 },\n     {\
    \ actual: candidate(\"1077E\"), expected: 2 },\n     { actual: candidate(\"ABED1A33\"\
    ), expected: 4 },\n     { actual: candidate(\"2020\"), expected: 2 },\n     {\
    \ actual: candidate(\"123456789ABCDEF0\"), expected: 6 },\n     { actual: candidate(\"\
    112233445566778899AABBCCDDEEFF00\"), expected: 12 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestHex_Key (0.00s)\n    --- FAIL: TestHex_Key/test_num__0 (0.00s)\n\
    \        tmpzmosy36c_test.go:55: expected '%!s(int=1)', got '%!s(int=3)'\n   \
    \ --- FAIL: TestHex_Key/test_num__1 (0.00s)\n        tmpzmosy36c_test.go:55: expected\
    \ '%!s(int=2)', got '%!s(int=-44)'\n    --- FAIL: TestHex_Key/test_num__2 (0.00s)\n\
    \        tmpzmosy36c_test.go:55: expected '%!s(int=4)', got '%!s(int=-28)'\n \
    \   --- FAIL: TestHex_Key/test_num__3 (0.00s)\n        tmpzmosy36c_test.go:55:\
    \ expected '%!s(int=2)', got '%!s(int=-60)'\n    --- FAIL: TestHex_Key/test_num__4\
    \ (0.00s)\n        tmpzmosy36c_test.go:55: expected '%!s(int=6)', got '%!s(int=-94)'\n\
    \    --- FAIL: TestHex_Key/test_num__5 (0.00s)\n        tmpzmosy36c_test.go:55:\
    \ expected '%!s(int=12)', got '%!s(int=-188)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074581
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    //\
    \ Your code here\n    \n    return 0\n}\n\nfunc TestHex_Key(t *testing.T) {\n\
    \  candidate := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AB\"\
    ), expected: 1 },\n     { actual: candidate(\"1077E\"), expected: 2 },\n     {\
    \ actual: candidate(\"ABED1A33\"), expected: 4 },\n     { actual: candidate(\"\
    2020\"), expected: 2 },\n     { actual: candidate(\"123456789ABCDEF0\"), expected:\
    \ 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"), expected:\
    \ 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestHex_Key (0.00s)\n    --- FAIL: TestHex_Key/test_num__0 (0.00s)\n\
    \        tmpcshf94km_test.go:53: expected '%!s(int=1)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestHex_Key/test_num__1 (0.00s)\n        tmpcshf94km_test.go:53: expected\
    \ '%!s(int=2)', got '%!s(int=0)'\n    --- FAIL: TestHex_Key/test_num__2 (0.00s)\n\
    \        tmpcshf94km_test.go:53: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestHex_Key/test_num__3 (0.00s)\n        tmpcshf94km_test.go:53: expected\
    \ '%!s(int=2)', got '%!s(int=0)'\n    --- FAIL: TestHex_Key/test_num__4 (0.00s)\n\
    \        tmpcshf94km_test.go:53: expected '%!s(int=6)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestHex_Key/test_num__5 (0.00s)\n        tmpcshf94km_test.go:53: expected\
    \ '%!s(int=12)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074578
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    n\
    \ := len(num)\n    count := 0\n    i := 0\n    for ; i < n; i++ {\n        digit\
    \ := int(num[i])\n        if digit > 9 {\n            digit = digit - 10\n   \
    \     }\n        if digit == 0 || digit == 1 {\n            continue\n       \
    \ }\n        count += digit\n    }\n    return count\n}\n\nfunc TestHex_Key(t\
    \ *testing.T) {\n  candidate := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AB\"), expected: 1 },\n     { actual: candidate(\"1077E\"), expected: 2 },\n \
    \    { actual: candidate(\"ABED1A33\"), expected: 4 },\n     { actual: candidate(\"\
    2020\"), expected: 2 },\n     { actual: candidate(\"123456789ABCDEF0\"), expected:\
    \ 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"), expected:\
    \ 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestHex_Key (0.00s)\n    --- FAIL: TestHex_Key/test_num__0 (0.00s)\n\
    \        tmp09fipgw2_test.go:64: expected '%!s(int=1)', got '%!s(int=111)'\n \
    \   --- FAIL: TestHex_Key/test_num__1 (0.00s)\n        tmp09fipgw2_test.go:64:\
    \ expected '%!s(int=2)', got '%!s(int=226)'\n    --- FAIL: TestHex_Key/test_num__2\
    \ (0.00s)\n        tmp09fipgw2_test.go:64: expected '%!s(int=4)', got '%!s(int=404)'\n\
    \    --- FAIL: TestHex_Key/test_num__3 (0.00s)\n        tmp09fipgw2_test.go:64:\
    \ expected '%!s(int=2)', got '%!s(int=156)'\n    --- FAIL: TestHex_Key/test_num__4\
    \ (0.00s)\n        tmp09fipgw2_test.go:64: expected '%!s(int=6)', got '%!s(int=770)'\n\
    \    --- FAIL: TestHex_Key/test_num__5 (0.00s)\n        tmp09fipgw2_test.go:64:\
    \ expected '%!s(int=12)', got '%!s(int=1540)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074685
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    var\
    \ count int = 0\n    for _, r := range num {\n        if r == 'A' || r == 'B'\
    \ || r == 'C' || r == 'D' || r == 'E' || r == 'F' {\n            count++\n   \
    \     }\n    }\n    return count\n}\n\nfunc TestHex_Key(t *testing.T) {\n  candidate\
    \ := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AB\"), expected: 1 },\n \
    \    { actual: candidate(\"1077E\"), expected: 2 },\n     { actual: candidate(\"\
    ABED1A33\"), expected: 4 },\n     { actual: candidate(\"2020\"), expected: 2 },\n\
    \     { actual: candidate(\"123456789ABCDEF0\"), expected: 6 },\n     { actual:\
    \ candidate(\"112233445566778899AABBCCDDEEFF00\"), expected: 12 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestHex_Key (0.00s)\n    --- FAIL: TestHex_Key/test_num__0 (0.00s)\n\
    \        tmpon0xm6jg_test.go:57: expected '%!s(int=1)', got '%!s(int=2)'\n   \
    \ --- FAIL: TestHex_Key/test_num__1 (0.00s)\n        tmpon0xm6jg_test.go:57: expected\
    \ '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestHex_Key/test_num__2 (0.00s)\n\
    \        tmpon0xm6jg_test.go:57: expected '%!s(int=4)', got '%!s(int=5)'\n   \
    \ --- FAIL: TestHex_Key/test_num__3 (0.00s)\n        tmpon0xm6jg_test.go:57: expected\
    \ '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074582
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    num\
    \ := strings.ToUpper(num)\n    num := strings.Replace(num, \"A\", \"1\", -1)\n\
    \    num := strings.Replace(num, \"B\", \"2\", -1)\n    num := strings.Replace(num,\
    \ \"C\", \"3\", -1)\n    num := strings.Replace(num, \"D\", \"4\", -1)\n    num\
    \ := strings.Replace(num, \"E\", \"5\", -1)\n    num := strings.Replace(num, \"\
    F\", \"6\", -1)\n    num := strings.Replace(num, \"0\", \"7\", -1)\n    num :=\
    \ strings.Replace(num, \"1\", \"8\", -1)\n    num := strings.Replace(num, \"2\"\
    , \"9\", -1)\n    num := strings.Replace(num, \"3\", \"A\", -1)\n    num := strings.Replace(num,\
    \ \"4\", \"B\", -1)\n    num := strings.Replace(num, \"5\", \"C\", -1)\n    num\
    \ := strings.Replace(num, \"6\", \"D\", -1)\n    num := strings.Replace(num, \"\
    7\", \"E\", -1)\n    num := strings.Replace(num, \"8\", \"F\", -1)\n    num :=\
    \ strings.Replace(num, \"9\", \"0\", -1)\n    num := strings.Replace(num, \"+\"\
    , \"-\", -1)\n    num := strings.Replace(num, \"/\", \"*\", -1)\n    num := strings.Replace(num,\
    \ \"=\", \"+\", -1)\n    num := strings.Replace(num, \"*\", \"/\", -1)\n    num\
    \ := strings.Replace(num, \"-\", \"+\", -1)\n    num := strings.Replace(num, \"\
    (\", \"\", -1)\n    num := strings.Replace(num, \")\", \"\", -1)\n    num := strings.Replace(num,\
    \ \"/\", \"\", -1)\n    num := strings.Replace(num, \"*\", \"\", -1)\n    num\
    \ := strings.Replace(num, \"+\", \"\", -1)\n    num := strings.Replace(num, \"\
    -\", \"\", -1)\n    num := strings.Replace(num, \"=\", \"\", -1)\n    num := strings.Replace(num,\
    \ \".\", \"\", -1)\n    num := strings.Replace(num, \"-\", \"\", -1)\n    num\
    \ := strings.Replace(num, \"+\", \"\", -1)\n    num := strings.Replace(num, \"\
    *\", \"\", -1)\n    num := strings.Replace(num, \"/\", \"\", -1)\n    num := strings.Replace(num,\
    \ \"=\", \"\", -1)\n    num := strings.Replace(num, \".\", \"\", -1)\n    num\
    \ := strings.Replace(num, \"-\", \"\", -1)\n    num := strings.Replace(num, \"\
    +\", \"\", -1)\n    num := strings.Replace(num, \"*\", \"\", -1)\n    num := strings.Replace(num,\
    \ \"/\", \"\", -1)\n    num := strings.Replace(num, \"=\", \"\", -1)\n    num\
    \ := strings.Replace(num, \".\", \"\", -1)\n\nfunc TestHex_Key(t *testing.T) {\n\
    \  candidate := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AB\"\
    ), expected: 1 },\n     { actual: candidate(\"1077E\"), expected: 2 },\n     {\
    \ actual: candidate(\"ABED1A33\"), expected: 4 },\n     { actual: candidate(\"\
    2020\"), expected: 2 },\n     { actual: candidate(\"123456789ABCDEF0\"), expected:\
    \ 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"), expected:\
    \ 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpyc5d4znm_test.go:73:6: expected ''('', found TestHex_Key

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074683
- exit_code: 2
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    num\
    \ := strings.ToUpper(num)\n    n := len(num)\n    prime := 0\n    i := 0\n   \
    \ for ; i < n; i++ {\n        digit := num[i]\n        if digit == 'A' || digit\
    \ == 'B' || digit == 'C' || digit == 'D' || digit == 'E' || digit == 'F' {\n \
    \           prime++\n        }\n    }\n    return prime\n}\n\nfunc TestHex_Key(t\
    \ *testing.T) {\n  candidate := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AB\"), expected: 1 },\n     { actual: candidate(\"1077E\"), expected: 2 },\n \
    \    { actual: candidate(\"ABED1A33\"), expected: 4 },\n     { actual: candidate(\"\
    2020\"), expected: 2 },\n     { actual: candidate(\"123456789ABCDEF0\"), expected:\
    \ 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"), expected:\
    \ 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpp4rd_lu9_test.go:30:9: no new variables on left side of :=

    /tmp/tmpp4rd_lu9_test.go:30:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074684
- exit_code: 2
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    n\
    \ := 0\n    for _, r := range num {\n        if r == 'A' || r == 'B' || r == 'C'\
    \ || r == 'D' || r == 'E' || r == 'F' {\n            n += 2\n        } else {\n\
    \            n += r - '0'\n        }\n    }\n    return n\n}\n\nfunc TestHex_Key(t\
    \ *testing.T) {\n  candidate := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AB\"), expected: 1 },\n     { actual: candidate(\"1077E\"), expected: 2 },\n \
    \    { actual: candidate(\"ABED1A33\"), expected: 4 },\n     { actual: candidate(\"\
    2020\"), expected: 2 },\n     { actual: candidate(\"123456789ABCDEF0\"), expected:\
    \ 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"), expected:\
    \ 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp12s76byh_test.go:35:13: invalid operation: n += r - ''0'' (mismatched
    types int and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074684
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    num\
    \ := strings.ToUpper(num)\n    num := strings.Replace(num, \"A\", \"1\", -1)\n\
    \    num := strings.Replace(num, \"B\", \"2\", -1)\n    num := strings.Replace(num,\
    \ \"C\", \"3\", -1)\n    num := strings.Replace(num, \"D\", \"4\", -1)\n    num\
    \ := strings.Replace(num, \"E\", \"5\", -1)\n    num := strings.Replace(num, \"\
    F\", \"6\", -1)\n    num := strings.Replace(num, \"0\", \"0\", -1)\n    num :=\
    \ strings.Replace(num, \"1\", \"1\", -1)\n    num := strings.Replace(num, \"2\"\
    , \"2\", -1)\n    num := strings.Replace(num, \"3\", \"3\", -1)\n    num := strings.Replace(num,\
    \ \"4\", \"4\", -1)\n    num := strings.Replace(num, \"5\", \"5\", -1)\n    num\
    \ := strings.Replace(num, \"6\", \"6\", -1)\n    num := strings.Replace(num, \"\
    7\", \"7\", -1)\n    num := strings.Replace(num, \"8\", \"8\", -1)\n    num :=\
    \ strings.Replace(num, \"9\", \"9\", -1)\n    num := strings.Replace(num, \"+\"\
    , \"-\", -1)\n    num := strings.Replace(num, \"-\", \"+\", -1)\n    num := strings.Replace(num,\
    \ \".\", \"0\", -1)\n    num := strings.Replace(num, \"/\", \"0\", -1)\n    num\
    \ := strings.Replace(num, \"0\", \"0\", -1)\n    num := strings.Replace(num, \"\
    1\", \"1\", -1)\n    num := strings.Replace(num, \"2\", \"2\", -1)\n    num :=\
    \ strings.Replace(num, \"3\", \"3\", -1)\n    num := strings.Replace(num, \"4\"\
    , \"4\", -1)\n    num := strings.Replace(num, \"5\", \"5\", -1)\n    num := strings.Replace(num,\
    \ \"6\", \"6\", -1)\n    num := strings.Replace(num, \"7\", \"7\", -1)\n    num\
    \ := strings.Replace(num, \"8\", \"8\", -1)\n    num := strings.Replace(num, \"\
    9\", \"9\", -1)\n    num := strings.Replace(num, \"-\", \"+\", -1)\n    num :=\
    \ strings.Replace(num, \"+\", \"-\", -1)\n    num := strings.Replace(num, \".\"\
    , \"0\", -1)\n    num := strings.Replace(num, \"/\", \"0\", -1)\n    num := strings.Replace(num,\
    \ \"0\", \"0\", -1)\n    num := strings.Replace(num, \"1\", \"1\", -1)\n    num\
    \ := strings.Replace(num, \"2\", \"2\", -1)\n    num := strings.Replace(num, \"\
    3\", \"3\", -1)\n    num := strings.Replace(num, \"4\", \"4\", -1)\n    num :=\
    \ strings.Replace(num, \"5\", \"5\", -1)\n    num := strings.Replace(num, \"6\"\
    , \"6\nfunc TestHex_Key(t *testing.T) {\n  candidate := hex_key\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AB\"), expected: 1 },\n     { actual: candidate(\"\
    1077E\"), expected: 2 },\n     { actual: candidate(\"ABED1A33\"), expected: 4\
    \ },\n     { actual: candidate(\"2020\"), expected: 2 },\n     { actual: candidate(\"\
    123456789ABCDEF0\"), expected: 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"\
    ), expected: 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp9til3zju_test.go:71:38: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074582
- exit_code: 2
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    num\
    \ := strings.ToUpper(num)\n    \n    var count int = 0\n    for _, v := range\
    \ num {\n        if v == 'A' || v == 'B' || v == 'C' || v == 'D' || v == 'E' ||\
    \ v == 'F' {\n            count++\n        }\n    }\n    \n    return count\n\
    }\n\nfunc TestHex_Key(t *testing.T) {\n  candidate := hex_key\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AB\"), expected: 1 },\n     { actual: candidate(\"\
    1077E\"), expected: 2 },\n     { actual: candidate(\"ABED1A33\"), expected: 4\
    \ },\n     { actual: candidate(\"2020\"), expected: 2 },\n     { actual: candidate(\"\
    123456789ABCDEF0\"), expected: 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"\
    ), expected: 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp35riqdoh_test.go:30:9: no new variables on left side of :=

    /tmp/tmp35riqdoh_test.go:30:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074684
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    n\
    \ := 0\n    for _, r := range num {\n        if r == 'A' || r == 'B' || r == 'C'\
    \ || r == 'D' || r == 'E' || r == 'F' {\n            n = n + 1\n        }\n  \
    \  }\n    return n\n}\n\nfunc TestHex_Key(t *testing.T) {\n  candidate := hex_key\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"AB\"), expected: 1 },\n     {\
    \ actual: candidate(\"1077E\"), expected: 2 },\n     { actual: candidate(\"ABED1A33\"\
    ), expected: 4 },\n     { actual: candidate(\"2020\"), expected: 2 },\n     {\
    \ actual: candidate(\"123456789ABCDEF0\"), expected: 6 },\n     { actual: candidate(\"\
    112233445566778899AABBCCDDEEFF00\"), expected: 12 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestHex_Key (0.00s)\n    --- FAIL: TestHex_Key/test_num__0 (0.00s)\n\
    \        tmpo9w9bgib_test.go:57: expected '%!s(int=1)', got '%!s(int=2)'\n   \
    \ --- FAIL: TestHex_Key/test_num__1 (0.00s)\n        tmpo9w9bgib_test.go:57: expected\
    \ '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestHex_Key/test_num__2 (0.00s)\n\
    \        tmpo9w9bgib_test.go:57: expected '%!s(int=4)', got '%!s(int=5)'\n   \
    \ --- FAIL: TestHex_Key/test_num__3 (0.00s)\n        tmpo9w9bgib_test.go:57: expected\
    \ '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074579
- exit_code: 2
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    num\
    \ := strings.ToUpper(num)\n    count := 0\n    for _, v := range num {\n     \
    \   if v == 'A' || v == 'B' || v == 'C' || v == 'D' || v == 'E' || v == 'F' {\n\
    \            count++\n        }\n    }\n    return count\n}\n\nfunc TestHex_Key(t\
    \ *testing.T) {\n  candidate := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AB\"), expected: 1 },\n     { actual: candidate(\"1077E\"), expected: 2 },\n \
    \    { actual: candidate(\"ABED1A33\"), expected: 4 },\n     { actual: candidate(\"\
    2020\"), expected: 2 },\n     { actual: candidate(\"123456789ABCDEF0\"), expected:\
    \ 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"), expected:\
    \ 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp88q38rvw_test.go:30:9: no new variables on left side of :=

    /tmp/tmp88q38rvw_test.go:30:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074577
- exit_code: 2
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    num\
    \ := strings.ToUpper(num)\n    count := 0\n    for _, v := range num {\n     \
    \   if v == 'A' || v == 'B' || v == 'C' || v == 'D' || v == 'E' || v == 'F' {\n\
    \            count++\n        }\n    }\n    return count\n}\n\nfunc TestHex_Key(t\
    \ *testing.T) {\n  candidate := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AB\"), expected: 1 },\n     { actual: candidate(\"1077E\"), expected: 2 },\n \
    \    { actual: candidate(\"ABED1A33\"), expected: 4 },\n     { actual: candidate(\"\
    2020\"), expected: 2 },\n     { actual: candidate(\"123456789ABCDEF0\"), expected:\
    \ 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"), expected:\
    \ 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp88q38rvw_test.go:30:9: no new variables on left side of :=

    /tmp/tmp88q38rvw_test.go:30:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074577
- exit_code: 2
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    num\
    \ := strings.ToUpper(num)\n    count := 0\n    for _, v := range num {\n     \
    \   if v == 'A' || v == 'B' || v == 'C' || v == 'D' || v == 'E' || v == 'F' {\n\
    \            continue\n        }\n        count += int(v)\n    }\n    return count\n\
    }\n\nfunc TestHex_Key(t *testing.T) {\n  candidate := hex_key\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AB\"), expected: 1 },\n     { actual: candidate(\"\
    1077E\"), expected: 2 },\n     { actual: candidate(\"ABED1A33\"), expected: 4\
    \ },\n     { actual: candidate(\"2020\"), expected: 2 },\n     { actual: candidate(\"\
    123456789ABCDEF0\"), expected: 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"\
    ), expected: 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp16c7kfeh_test.go:30:9: no new variables on left side of :=

    /tmp/tmp16c7kfeh_test.go:30:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074579
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    n\
    \ := 0\n    for _, r := range num {\n        if r == 'A' || r == 'B' || r == 'C'\
    \ || r == 'D' || r == 'E' || r == 'F' {\n            n += 2\n        } else {\n\
    \            n += 1\n        }\n    }\n    return n\n}\n\nfunc TestHex_Key(t *testing.T)\
    \ {\n  candidate := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AB\"), expected: 1 },\n     { actual: candidate(\"1077E\"), expected: 2 },\n \
    \    { actual: candidate(\"ABED1A33\"), expected: 4 },\n     { actual: candidate(\"\
    2020\"), expected: 2 },\n     { actual: candidate(\"123456789ABCDEF0\"), expected:\
    \ 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"), expected:\
    \ 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestHex_Key (0.00s)\n    --- FAIL: TestHex_Key/test_num__0 (0.00s)\n\
    \        tmpzr1nui6s_test.go:59: expected '%!s(int=1)', got '%!s(int=4)'\n   \
    \ --- FAIL: TestHex_Key/test_num__1 (0.00s)\n        tmpzr1nui6s_test.go:59: expected\
    \ '%!s(int=2)', got '%!s(int=6)'\n    --- FAIL: TestHex_Key/test_num__2 (0.00s)\n\
    \        tmpzr1nui6s_test.go:59: expected '%!s(int=4)', got '%!s(int=13)'\n  \
    \  --- FAIL: TestHex_Key/test_num__3 (0.00s)\n        tmpzr1nui6s_test.go:59:\
    \ expected '%!s(int=2)', got '%!s(int=4)'\n    --- FAIL: TestHex_Key/test_num__4\
    \ (0.00s)\n        tmpzr1nui6s_test.go:59: expected '%!s(int=6)', got '%!s(int=22)'\n\
    \    --- FAIL: TestHex_Key/test_num__5 (0.00s)\n        tmpzr1nui6s_test.go:59:\
    \ expected '%!s(int=12)', got '%!s(int=44)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074583
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    count\
    \ := 0\n    for _, v := range num {\n        if v == 'A' || v == 'B' || v == 'C'\
    \ || v == 'D' || v == 'E' || v == 'F' {\n            count++\n        }\n    }\n\
    \    return count\n}\n\nfunc TestHex_Key(t *testing.T) {\n  candidate := hex_key\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"AB\"), expected: 1 },\n     {\
    \ actual: candidate(\"1077E\"), expected: 2 },\n     { actual: candidate(\"ABED1A33\"\
    ), expected: 4 },\n     { actual: candidate(\"2020\"), expected: 2 },\n     {\
    \ actual: candidate(\"123456789ABCDEF0\"), expected: 6 },\n     { actual: candidate(\"\
    112233445566778899AABBCCDDEEFF00\"), expected: 12 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestHex_Key (0.00s)\n    --- FAIL: TestHex_Key/test_num__0 (0.00s)\n\
    \        tmpi9ufeu_p_test.go:57: expected '%!s(int=1)', got '%!s(int=2)'\n   \
    \ --- FAIL: TestHex_Key/test_num__1 (0.00s)\n        tmpi9ufeu_p_test.go:57: expected\
    \ '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestHex_Key/test_num__2 (0.00s)\n\
    \        tmpi9ufeu_p_test.go:57: expected '%!s(int=4)', got '%!s(int=5)'\n   \
    \ --- FAIL: TestHex_Key/test_num__3 (0.00s)\n        tmpi9ufeu_p_test.go:57: expected\
    \ '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074685
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    var\
    \ count int = 0\n    for _, c := range num {\n        if c >= '0' && c <= '9'\
    \ {\n            count++\n        }\n    }\n    return count\n}\n\nfunc TestHex_Key(t\
    \ *testing.T) {\n  candidate := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AB\"), expected: 1 },\n     { actual: candidate(\"1077E\"), expected: 2 },\n \
    \    { actual: candidate(\"ABED1A33\"), expected: 4 },\n     { actual: candidate(\"\
    2020\"), expected: 2 },\n     { actual: candidate(\"123456789ABCDEF0\"), expected:\
    \ 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"), expected:\
    \ 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestHex_Key (0.00s)\n    --- FAIL: TestHex_Key/test_num__0 (0.00s)\n\
    \        tmpk61m3u86_test.go:57: expected '%!s(int=1)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestHex_Key/test_num__1 (0.00s)\n        tmpk61m3u86_test.go:57: expected\
    \ '%!s(int=2)', got '%!s(int=4)'\n    --- FAIL: TestHex_Key/test_num__2 (0.00s)\n\
    \        tmpk61m3u86_test.go:57: expected '%!s(int=4)', got '%!s(int=3)'\n   \
    \ --- FAIL: TestHex_Key/test_num__3 (0.00s)\n        tmpk61m3u86_test.go:57: expected\
    \ '%!s(int=2)', got '%!s(int=4)'\n    --- FAIL: TestHex_Key/test_num__4 (0.00s)\n\
    \        tmpk61m3u86_test.go:57: expected '%!s(int=6)', got '%!s(int=10)'\n  \
    \  --- FAIL: TestHex_Key/test_num__5 (0.00s)\n        tmpk61m3u86_test.go:57:\
    \ expected '%!s(int=12)', got '%!s(int=20)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074583
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    num\
    \ := strings.ToUpper(num)\n    n := len(num)\n    prime := make([]int, n)\n  \
    \  prime := append(prime, 2)\n    prime := append(prime, 3)\n    prime := append(prime,\
    \ 5)\n    prime := append(prime, 7)\n    prime := append(prime, 11)\n    prime\
    \ := append(prime, 13)\n    prime := append(prime, 17)\n    prime := append(prime,\
    \ 19)\n    prime := append(prime, 23)\n    prime := append(prime, 29)\n    prime\
    \ := append(prime, 31)\n    prime := append(prime, 37)\n    prime := append(prime,\
    \ 43)\n    prime := append(prime, 59)\n    prime := append(prime, 61)\n    prime\
    \ := append(prime, 67)\n    prime := append(prime, 73)\n    prime := append(prime,\
    \ 79)\n    prime := append(prime, 83)\n    prime := append(prime, 89)\n    prime\
    \ := append(prime, 97)\n    prime := append(prime, 101)\n    prime := append(prime,\
    \ 103)\n    prime := append(prime, 107)\n    prime := append(prime, 109)\n   \
    \ prime := append(prime, 113)\n    prime := append(prime, 127)\n    prime := append(prime,\
    \ 131)\n    prime := append(prime, 137)\n    prime := append(prime, 139)\n   \
    \ prime := append(prime, 149)\n    prime := append(prime, 151)\n    prime := append(prime,\
    \ 157)\n    prime := append(prime, 163)\n    prime := append(prime, 167)\n   \
    \ prime := append(prime, 173)\n    prime := append(prime, 179)\n    prime := append(prime,\
    \ 181)\n    prime := append(prime, 191)\n    prime := append(prime, 193)\n   \
    \ prime := append(prime, 197)\n    prime := append(prime, 199)\n    prime := append(prime,\
    \ 211)\n    prime := append(prime, 223)\n    prime := append(prime, 227)\n   \
    \ prime := append(prime, 229)\n    prime := append(prime, 233)\n    prime := append(prime,\
    \ 239)\n    prime := append(prime, 241)\n    prime := append(prime, 243)\n   \
    \ prime := append(prime, 247)\n    prime := append(prime, 251)\n    prime := append(prime,\
    \ 257)\n    prime := append(prime, 263)\n    prime := append(prime, 269)\n   \
    \ \nfunc TestHex_Key(t *testing.T) {\n  candidate := hex_key\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AB\"), expected: 1 },\n     { actual: candidate(\"\
    1077E\"), expected: 2 },\n     { actual: candidate(\"ABED1A33\"), expected: 4\
    \ },\n     { actual: candidate(\"2020\"), expected: 2 },\n     { actual: candidate(\"\
    123456789ABCDEF0\"), expected: 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"\
    ), expected: 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpdiairc5n_test.go:89:6: expected ''('', found TestHex_Key

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074683
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    //\
    \ Your code here\n    num := strings.ToUpper(num)\n    num := strings.Replace(num,\
    \ \"A\", \"1\", -1)\n    num := strings.Replace(num, \"B\", \"2\", -1)\n    num\
    \ := strings.Replace(num, \"C\", \"3\", -1)\n    num := strings.Replace(num, \"\
    D\", \"4\", -1)\n    num := strings.Replace(num, \"E\", \"5\", -1)\n    num :=\
    \ strings.Replace(num, \"F\", \"6\", -1)\n    num := strings.Replace(num, \"1\"\
    , \"2\", -1)\n    num := strings.Replace(num, \"2\", \"3\", -1)\n    num := strings.Replace(num,\
    \ \"3\", \"4\", -1)\n    num := strings.Replace(num, \"4\", \"5\", -1)\n    num\
    \ := strings.Replace(num, \"5\", \"6\", -1)\n    num := strings.Replace(num, \"\
    6\", \"7\", -1)\n    num := strings.Replace(num, \"7\", \"8\", -1)\n    num :=\
    \ strings.Replace(num, \"8\", \"9\", -1)\n    num := strings.Replace(num, \"9\"\
    , \"10\", -1)\n    num := strings.Replace(num, \"10\", \"11\", -1)\n    num :=\
    \ strings.Replace(num, \"11\", \"12\", -1)\n    num := strings.Replace(num, \"\
    12\", \"13\", -1)\n    num := strings.Replace(num, \"13\", \"14\", -1)\n    num\
    \ := strings.Replace(num, \"14\", \"15\", -1)\n    num := strings.Replace(num,\
    \ \"15\", \"16\", -1)\n    num := strings.Replace(num, \"16\", \"17\", -1)\n \
    \   num := strings.Replace(num, \"17\", \"18\", -1)\n    num := strings.Replace(num,\
    \ \"18\", \"19\", -1)\n    num := strings.Replace(num, \"19\", \"20\", -1)\n \
    \   num := strings.Replace(num, \"20\", \"21\", -1)\n    num := strings.Replace(num,\
    \ \"21\", \"22\", -1)\n    num := strings.Replace(num, \"22\", \"23\", -1)\n \
    \   num := strings.Replace(num, \"23\", \"24\", -1)\n    num := strings.Replace(num,\
    \ \"24\", \"25\", -1)\n    num := strings.Replace(num, \"25\", \"26\", -1)\n \
    \   num := strings.Replace(num, \"26\", \"27\", -1)\n    num := strings.Replace(num,\
    \ \"27\", \"28\", -1)\n    num := strings.Replace(num, \"28\", \"29\", -1)\n \
    \   num := strings.Replace(num, \"29\", \"30\", -1)\n    num := strings.Replace(num,\
    \ \"30\", \"31\", -1)\n    num := strings.Replace(num, \"31\", \"32\", -1)\n \
    \   num := strings.Replace(num, \"32\", \"33\", -1)\n    num := strings.Replace(num,\
    \ \"33\", \"34\", -1)\n\nfunc TestHex_Key(t *testing.T) {\n  candidate := hex_key\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"AB\"), expected: 1 },\n     {\
    \ actual: candidate(\"1077E\"), expected: 2 },\n     { actual: candidate(\"ABED1A33\"\
    ), expected: 4 },\n     { actual: candidate(\"2020\"), expected: 2 },\n     {\
    \ actual: candidate(\"123456789ABCDEF0\"), expected: 6 },\n     { actual: candidate(\"\
    112233445566778899AABBCCDDEEFF00\"), expected: 12 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp3gi8vbh0_test.go:72:6: expected ''('', found TestHex_Key

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074683
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    n\
    \ := 0\n    base := 0\n    i := 0\n    for ; i < len(num); i++ {\n        c :=\
    \ num[i]\n        if c >= '0' && c <= '9' {\n            n = n*10 + int(c-'0')\n\
    \        } else if c >= 'A' && c <= 'F' {\n            n = n*10 + int(c-'A') +\
    \ 10\n        } else if c >= 'a' && c <= 'f' {\n            n = n*10 + int(c-'a')\
    \ + 10\n        } else {\n            fmt.Println(\"invalid input\")\n       \
    \     return -1\n        }\n    }\n    for ; i < len(num); i++ {\n        c :=\
    \ num[i]\n        if c >= '0' && c <= '9' {\n            n = n*10 + int(c-'0')\n\
    \        } else if c >= 'A' && c <= 'F' {\n            n = n*10 + int(c-'A') +\
    \ 10\n        } else if c >= 'a' && c <= 'f' {\n            n = n*10 + int(c-'a')\
    \ + 10\n        } else {\n            fmt.Println(\"invalid input\")\n       \
    \     return -1\n        }\n    }\n    for ; i < len(num); i++ {\n        c :=\
    \ num[i]\n        if c >= '0' && c <= '9' {\n            n = n*10 + int(c-'0')\n\
    \        } else if c >= 'A' && c <= 'F' {\n            n = n*10 + int(c-'A') +\
    \ 10\n        } else if c >= 'a' && c <= 'f' {\n            n = n*10 + int(c-'a')\
    \ + 10\n        } else {\n            fmt.Println(\"invalid input\")\n       \
    \     return -1\n        }\n    }\n    for ; i < len(num); i++ {\n        c :=\
    \ num[i]\n        if c >= '0' && c <= '9' {\n            n = n*10 + int(c-'0')\n\
    \        } else if c >= 'A' && c <= 'F' {\n            n = n*10 + int(c-'A') +\
    \ 10\n        } else if c >= 'a' && c <= 'f' {\n            n = n*10 + int(c-'a')\
    \ + 10\n        } else {\n            fmt.Println(\"invalid input\")\n       \
    \     return -1\n        }\n    }\n    for ; i < len(num); i++ {\n        c :=\
    \ num[i]\n        if c >= '0' && c <= '9' {\n            n = n*10 + int(c-'0')\n\
    \        } else if c >= 'A' && c <= 'F' {\n            n = n*10 + int(c-'A') +\
    \ 10\n        \nfunc TestHex_Key(t *testing.T) {\n  candidate := hex_key\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"AB\"), expected: 1 },\n     { actual:\
    \ candidate(\"1077E\"), expected: 2 },\n     { actual: candidate(\"ABED1A33\"\
    ), expected: 4 },\n     { actual: candidate(\"2020\"), expected: 2 },\n     {\
    \ actual: candidate(\"123456789ABCDEF0\"), expected: 6 },\n     { actual: candidate(\"\
    112233445566778899AABBCCDDEEFF00\"), expected: 12 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpzi3uhad2_test.go:92:6: expected ''('', found TestHex_Key

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074683
- exit_code: 2
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    num\
    \ := strings.ToUpper(num)\n    count := 0\n    for _, char := range num {\n  \
    \      if char == 'A' || char == 'B' || char == 'C' || char == 'D' || char ==\
    \ 'E' || char == 'F' {\n            count++\n        }\n    }\n    return count\n\
    }\n\nfunc TestHex_Key(t *testing.T) {\n  candidate := hex_key\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AB\"), expected: 1 },\n     { actual: candidate(\"\
    1077E\"), expected: 2 },\n     { actual: candidate(\"ABED1A33\"), expected: 4\
    \ },\n     { actual: candidate(\"2020\"), expected: 2 },\n     { actual: candidate(\"\
    123456789ABCDEF0\"), expected: 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"\
    ), expected: 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpp_8j83d0_test.go:30:9: no new variables on left side of :=

    /tmp/tmpp_8j83d0_test.go:30:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074582
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    //\
    \ Your code here\n    num := strings.ToUpper(num)\n    num := strings.Replace(num,\
    \ \"A\", \"1\", -1)\n    num := strings.Replace(num, \"B\", \"2\", -1)\n    num\
    \ := strings.Replace(num, \"C\", \"3\", -1)\n    num := strings.Replace(num, \"\
    D\", \"4\", -1)\n    num := strings.Replace(num, \"E\", \"5\", -1)\n    num :=\
    \ strings.Replace(num, \"F\", \"6\", -1)\n    num := strings.Replace(num, \"0\"\
    , \"0\", -1)\n    num := strings.Replace(num, \"1\", \"1\", -1)\n    num := strings.Replace(num,\
    \ \"2\", \"2\", -1)\n    num := strings.Replace(num, \"3\", \"3\", -1)\n    num\
    \ := strings.Replace(num, \"4\", \"4\", -1)\n    num := strings.Replace(num, \"\
    5\", \"5\", -1)\n    num := strings.Replace(num, \"6\", \"6\", -1)\n    num :=\
    \ strings.Replace(num, \"7\", \"7\", -1)\n    num := strings.Replace(num, \"8\"\
    , \"8\", -1)\n    num := strings.Replace(num, \"9\", \"9\", -1)\n    num := strings.Replace(num,\
    \ \"+\", \"-\", -1)\n    num := strings.Replace(num, \"-\", \"+\", -1)\n    num\
    \ := strings.Replace(num, \".\", \"0\", -1)\n    num := strings.Replace(num, \"\
    /\", \"0\", -1)\n    num := strings.Replace(num, \"=\", \"0\", -1)\n    num :=\
    \ strings.Replace(num, \"?\", \"0\", -1)\n    num := strings.Replace(num, \"!\"\
    , \"0\", -1)\n    num := strings.Replace(num, \"(\", \"0\", -1)\n    num := strings.Replace(num,\
    \ \"[\", \"0\", -1)\n    num := strings.Replace(num, \"{\", \"0\", -1)\n    num\
    \ := strings.Replace(num, \"}\", \"0\", -1)\n    num := strings.Replace(num, \"\
    ]\", \"0\", -1)\n    num := strings.Replace(num, \";\", \"0\", -1)\n    num :=\
    \ strings.Replace(num, \"<\", \"0\", -1)\n    num := strings.Replace(num, \">\"\
    , \"0\", -1)\n    num := strings.Replace(num, \"!\", \"0\", -1)\n    num := strings.Replace(num,\
    \ \"@\", \"0\", -1)\n    num := strings.Replace(num, \"#\", \"0\", -1)\n    num\
    \ := strings.Replace(num, \"$\", \"0\", -1)\n    num := strings.Replace(num, \"\
    %\", \"0\", -1)\n    num := strings.Replace(num, \"^\", \"0\", -1)\n    num :=\
    \ strings.Replace(num, \"&\", \"0\", -1)\n    num := strings.Replace(num, \"*\"\
    , \"0\", -1)\n    num := \nfunc TestHex_Key(t *testing.T) {\n  candidate := hex_key\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"AB\"), expected: 1 },\n     {\
    \ actual: candidate(\"1077E\"), expected: 2 },\n     { actual: candidate(\"ABED1A33\"\
    ), expected: 4 },\n     { actual: candidate(\"2020\"), expected: 2 },\n     {\
    \ actual: candidate(\"123456789ABCDEF0\"), expected: 6 },\n     { actual: candidate(\"\
    112233445566778899AABBCCDDEEFF00\"), expected: 12 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp2p8_pthd_test.go:72:6: expected ''('', found TestHex_Key

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074683
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    num\
    \ := strings.ToUpper(num)\n    num := strings.Replace(num, \"A\", \"10\", -1)\n\
    \    num := strings.Replace(num, \"B\", \"11\", -1)\n    num := strings.Replace(num,\
    \ \"C\", \"12\", -1)\n    num := strings.Replace(num, \"D\", \"13\", -1)\n   \
    \ num := strings.Replace(num, \"E\", \"14\", -1)\n    num := strings.Replace(num,\
    \ \"F\", \"15\", -1)\n    num := strings.Replace(num, \"0\", \"10\", -1)\n   \
    \ num := strings.Replace(num, \"1\", \"11\", -1)\n    num := strings.Replace(num,\
    \ \"2\", \"12\", -1)\n    num := strings.Replace(num, \"3\", \"13\", -1)\n   \
    \ num := strings.Replace(num, \"4\", \"14\", -1)\n    num := strings.Replace(num,\
    \ \"5\", \"15\", -1)\n    num := strings.Replace(num, \"6\", \"16\", -1)\n   \
    \ num := strings.Replace(num, \"7\", \"17\", -1)\n    num := strings.Replace(num,\
    \ \"8\", \"18\", -1)\n    num := strings.Replace(num, \"9\", \"19\", -1)\n   \
    \ num := strings.Replace(num, \"+\", \"-\", -1)\n    num := strings.Replace(num,\
    \ \"/\", \"*\", -1)\n    num := strings.Replace(num, \"=\", \"+\", -1)\n    num\
    \ := strings.Replace(num, \"-\", \"*\", -1)\n    num := strings.Replace(num, \"\
    *\", \"/\", -1)\n    num := strings.Replace(num, \"(\", \"-\", -1)\n    num :=\
    \ strings.Replace(num, \")\", \"-\", -1)\n    num := strings.Replace(num, \"[\"\
    , \"+\", -1)\n    num := strings.Replace(num, \"]\", \"-\", -1)\n    num := strings.Replace(num,\
    \ \"{\", \"+\", -1)\n    num := strings.Replace(num, \"}\", \"-\", -1)\n    num\
    \ := strings.Replace(num, \"!\", \"*\", -1)\n    num := strings.Replace(num, \"\
    @\", \"*\", -1)\n    num := strings.Replace(num, \"#\", \"*\", -1)\n    num :=\
    \ strings.Replace(num, \"$\", \"*\", -1)\n    num := strings.Replace(num, \"%\"\
    , \"*\", -1)\n    num := strings.Replace(num, \"^\", \"*\", -1)\n    num := strings.Replace(num,\
    \ \"&\", \"*\", -1)\n    num := strings.Replace(num, \"*\", \"^\", -1)\n    num\
    \ := strings.Replace(num, \"(\", \"-\", -1)\n    num := strings.Replace(num, \"\
    -\", \"(\", -1)\n    num := strings.Replace(num, \"+\", \"(\", -1)\n    num :=\
    \ strings.Replace(num, \")\", \"-\", -1)\n    num := strings.Replace(num, \"\n\
    func TestHex_Key(t *testing.T) {\n  candidate := hex_key\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AB\"), expected: 1 },\n     { actual: candidate(\"\
    1077E\"), expected: 2 },\n     { actual: candidate(\"ABED1A33\"), expected: 4\
    \ },\n     { actual: candidate(\"2020\"), expected: 2 },\n     { actual: candidate(\"\
    123456789ABCDEF0\"), expected: 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"\
    ), expected: 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp0g9nsfya_test.go:70:33: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074683
- exit_code: 2
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    num\
    \ := strings.ToUpper(num)\n    n := len(num)\n    count := 0\n    for i := 0;\
    \ i < n; i++ {\n        c := num[i]\n        if c >= '0' && c <= '9' {\n     \
    \       count += int(c - '0')\n        } else {\n            count += int(c -\
    \ 'A' + 10)\n        }\n    }\n    return count\n}\n\nfunc TestHex_Key(t *testing.T)\
    \ {\n  candidate := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AB\"), expected: 1 },\n     { actual: candidate(\"1077E\"), expected: 2 },\n \
    \    { actual: candidate(\"ABED1A33\"), expected: 4 },\n     { actual: candidate(\"\
    2020\"), expected: 2 },\n     { actual: candidate(\"123456789ABCDEF0\"), expected:\
    \ 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"), expected:\
    \ 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvwdu20in_test.go:30:9: no new variables on left side of :=

    /tmp/tmpvwdu20in_test.go:30:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074684
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    num\
    \ := strings.ToUpper(num)\n    n := len(num)\n    prime := make([]int, n)\n  \
    \  prime[0] = 2\n    prime[1] = 3\n    prime[2] = 5\n    prime[3] = 7\n    prime[4]\
    \ = 11\n    prime[5] = 13\n    prime[6] = 17\n    prime[7] = 19\n    prime[8]\
    \ = 23\n    prime[9] = 29\n    prime[10] = 31\n    prime[11] = 31\n    prime[12]\
    \ = 37\n    prime[13] = 41\n    prime[14] = 43\n    prime[15] = 47\n    prime[16]\
    \ = 53\n    prime[17] = 59\n    prime[18] = 61\n    prime[19] = 67\n    prime[20]\
    \ = 71\n    prime[21] = 73\n    prime[22] = 79\n    prime[23] = 83\n    prime[24]\
    \ = 89\n    prime[25] = 97\n    prime[26] = 101\n    prime[27] = 103\n    prime[28]\
    \ = 107\n    prime[29] = 109\n    prime[30] = 112\n    prime[31] = 116\n    prime[32]\
    \ = 113\n    prime[33] = 119\n    prime[34] = 121\n    prime[35] = 123\n    prime[36]\
    \ = 127\n    prime[37] = 131\n    prime[38] = 137\n    prime[39] = 139\n    prime[40]\
    \ = 142\n    prime[41] = 147\n    prime[42] = 151\n    prime[43] = 157\n    prime[44]\
    \ = 163\n    prime[45] = 167\n    prime[46] = 173\n    prime[47] = 179\n    prime[48]\
    \ = 181\n    prime[49] = 191\n    prime[50] = 193\n    prime[51] = 193\n    prime[52]\
    \ = 197\n    prime[53] = 199\n    prime[54] = 211\n    prime[55] = 223\n    prime[56]\
    \ = 229\n    prime[57] = 233\n    prime[58] = 239\n    prime[59] = 241\n    prime[60]\
    \ = 243\n    prime[61] = 247\n    prime[62] = 251\n    prime[63] = 253\n    prime[64]\
    \ = 257\n    prime[65] = 263\n    prime[66] = 269\n    prime[67] = 271\n    prime[68]\
    \ = 277\n    prime[69] = 281\n    \nfunc TestHex_Key(t *testing.T) {\n  candidate\
    \ := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AB\"), expected: 1 },\n \
    \    { actual: candidate(\"1077E\"), expected: 2 },\n     { actual: candidate(\"\
    ABED1A33\"), expected: 4 },\n     { actual: candidate(\"2020\"), expected: 2 },\n\
    \     { actual: candidate(\"123456789ABCDEF0\"), expected: 6 },\n     { actual:\
    \ candidate(\"112233445566778899AABBCCDDEEFF00\"), expected: 12 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpgzxtn9iw_test.go:104:6: expected ''('', found TestHex_Key

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074683
- exit_code: 2
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    num\
    \ := strings.ToUpper(num)\n    count := 0\n    i := 0\n    for ; i < len(num);\
    \ i++ {\n        switch {\n        case num[i] == 'A':\n            count++\n\
    \        case num[i] == 'B':\n            count++\n        case num[i] == 'C':\n\
    \            count++\n        case num[i] == 'D':\n            count++\n     \
    \   case num[i] == 'E':\n            count++\n        case num[i] == 'F':\n  \
    \          count++\n        default:\n            count++\n        }\n    }\n\
    \    return count\n}\n\nfunc TestHex_Key(t *testing.T) {\n  candidate := hex_key\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"AB\"), expected: 1 },\n     {\
    \ actual: candidate(\"1077E\"), expected: 2 },\n     { actual: candidate(\"ABED1A33\"\
    ), expected: 4 },\n     { actual: candidate(\"2020\"), expected: 2 },\n     {\
    \ actual: candidate(\"123456789ABCDEF0\"), expected: 6 },\n     { actual: candidate(\"\
    112233445566778899AABBCCDDEEFF00\"), expected: 12 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpw67du7bm_test.go:30:9: no new variables on left side of :=

    /tmp/tmpw67du7bm_test.go:30:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074684
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    n\
    \ := len(num)\n    prime := make([]bool, len(num))\n    prime[0]=true\n    prime[1]=true\n\
    \    prime[2]=true\n    prime[3]=true\n    prime[4]=true\n    prime[5]=true\n\
    \    prime[6]=true\n    prime[7]=true\n    prime[8]=true\n    prime[9]=true\n\
    \    prime[10]=true\n    prime[11]=true\n    prime[12]=true\n    prime[13]=true\n\
    \    prime[14]=true\n    prime[15]=true\n    prime[16]=true\n    prime[17]=true\n\
    \    prime[18]=true\n    prime[19]=true\n    prime[20]=true\n    prime[21]=true\n\
    \    prime[22]=true\n    prime[23]=true\n    prime[24]=true\n    prime[25]=true\n\
    \    prime[26]=true\n    prime[27]=true\n    prime[28]=true\n    prime[29]=true\n\
    \    prime[30]=true\n    prime[31]=true\n    prime[32]=true\n    prime[33]=true\n\
    \    prime[34]=true\n    prime[35]=true\n    prime[36]=true\n    prime[37]=true\n\
    \    prime[38]=true\n    prime[39]=true\n    prime[40]=true\n    prime[41]=true\n\
    \    prime[42]=true\n    prime[43]=true\n    prime[44]=true\n    prime[45]=true\n\
    \    prime[46]=true\n    prime[47]=true\n    prime[48]=true\n    prime[49]=true\n\
    \    prime[50]=true\n    prime[51]=true\n    prime[52]=true\n    prime[53]=true\n\
    \    prime[54]=true\n    prime[55]=true\n    prime[56]=true\n    prime[57]=true\n\
    \    prime[58]=true\n    prime[59]=true\n    prime[60]=true\n    prime[61]=true\n\
    \    prime[62]=true\n    prime[63]=true\n    prime[64]=true\n    prime[65]=true\n\
    \    prime[66]=true\n    prime[67]=true\n    prime[68]=true\n    prime[69]=true\n\
    \    prime[70]=true\n    prime[71]=true\n    prime[7\nfunc TestHex_Key(t *testing.T)\
    \ {\n  candidate := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AB\"), expected: 1 },\n     { actual: candidate(\"1077E\"), expected: 2 },\n \
    \    { actual: candidate(\"ABED1A33\"), expected: 4 },\n     { actual: candidate(\"\
    2020\"), expected: 2 },\n     { actual: candidate(\"123456789ABCDEF0\"), expected:\
    \ 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"), expected:\
    \ 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp5fx3e834_test.go:104:12: expected '']'', found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074683
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    //\
    \ Your code here\n    \n    return 0\n}\n\nfunc TestHex_Key(t *testing.T) {\n\
    \  candidate := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AB\"\
    ), expected: 1 },\n     { actual: candidate(\"1077E\"), expected: 2 },\n     {\
    \ actual: candidate(\"ABED1A33\"), expected: 4 },\n     { actual: candidate(\"\
    2020\"), expected: 2 },\n     { actual: candidate(\"123456789ABCDEF0\"), expected:\
    \ 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"), expected:\
    \ 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestHex_Key (0.00s)\n    --- FAIL: TestHex_Key/test_num__0 (0.00s)\n\
    \        tmpcshf94km_test.go:53: expected '%!s(int=1)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestHex_Key/test_num__1 (0.00s)\n        tmpcshf94km_test.go:53: expected\
    \ '%!s(int=2)', got '%!s(int=0)'\n    --- FAIL: TestHex_Key/test_num__2 (0.00s)\n\
    \        tmpcshf94km_test.go:53: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestHex_Key/test_num__3 (0.00s)\n        tmpcshf94km_test.go:53: expected\
    \ '%!s(int=2)', got '%!s(int=0)'\n    --- FAIL: TestHex_Key/test_num__4 (0.00s)\n\
    \        tmpcshf94km_test.go:53: expected '%!s(int=6)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestHex_Key/test_num__5 (0.00s)\n        tmpcshf94km_test.go:53: expected\
    \ '%!s(int=12)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074578
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    n\
    \ := 0\n    for _, r := range num {\n        if r == 'A' || r == 'B' || r == 'C'\
    \ || r == 'D' || r == 'E' || r == 'F' {\n            n += 2\n        } else {\n\
    \            n += 1\n        }\n    }\n    return n\n}\n\nfunc TestHex_Key(t *testing.T)\
    \ {\n  candidate := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AB\"), expected: 1 },\n     { actual: candidate(\"1077E\"), expected: 2 },\n \
    \    { actual: candidate(\"ABED1A33\"), expected: 4 },\n     { actual: candidate(\"\
    2020\"), expected: 2 },\n     { actual: candidate(\"123456789ABCDEF0\"), expected:\
    \ 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"), expected:\
    \ 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestHex_Key (0.00s)\n    --- FAIL: TestHex_Key/test_num__0 (0.00s)\n\
    \        tmpzr1nui6s_test.go:59: expected '%!s(int=1)', got '%!s(int=4)'\n   \
    \ --- FAIL: TestHex_Key/test_num__1 (0.00s)\n        tmpzr1nui6s_test.go:59: expected\
    \ '%!s(int=2)', got '%!s(int=6)'\n    --- FAIL: TestHex_Key/test_num__2 (0.00s)\n\
    \        tmpzr1nui6s_test.go:59: expected '%!s(int=4)', got '%!s(int=13)'\n  \
    \  --- FAIL: TestHex_Key/test_num__3 (0.00s)\n        tmpzr1nui6s_test.go:59:\
    \ expected '%!s(int=2)', got '%!s(int=4)'\n    --- FAIL: TestHex_Key/test_num__4\
    \ (0.00s)\n        tmpzr1nui6s_test.go:59: expected '%!s(int=6)', got '%!s(int=22)'\n\
    \    --- FAIL: TestHex_Key/test_num__5 (0.00s)\n        tmpzr1nui6s_test.go:59:\
    \ expected '%!s(int=12)', got '%!s(int=44)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074583
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    n\
    \ := len(num)\n    result := 0\n    for i := 0; i < n; i++ {\n        digit :=\
    \ int(num[i])\n        if digit < '0' || digit > '9' {\n            continue\n\
    \        }\n        result += 1\n    }\n    return result\n}\n\nfunc TestHex_Key(t\
    \ *testing.T) {\n  candidate := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AB\"), expected: 1 },\n     { actual: candidate(\"1077E\"), expected: 2 },\n \
    \    { actual: candidate(\"ABED1A33\"), expected: 4 },\n     { actual: candidate(\"\
    2020\"), expected: 2 },\n     { actual: candidate(\"123456789ABCDEF0\"), expected:\
    \ 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"), expected:\
    \ 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestHex_Key (0.00s)\n    --- FAIL: TestHex_Key/test_num__0 (0.00s)\n\
    \        tmpoymlbxhc_test.go:60: expected '%!s(int=1)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestHex_Key/test_num__1 (0.00s)\n        tmpoymlbxhc_test.go:60: expected\
    \ '%!s(int=2)', got '%!s(int=4)'\n    --- FAIL: TestHex_Key/test_num__2 (0.00s)\n\
    \        tmpoymlbxhc_test.go:60: expected '%!s(int=4)', got '%!s(int=3)'\n   \
    \ --- FAIL: TestHex_Key/test_num__3 (0.00s)\n        tmpoymlbxhc_test.go:60: expected\
    \ '%!s(int=2)', got '%!s(int=4)'\n    --- FAIL: TestHex_Key/test_num__4 (0.00s)\n\
    \        tmpoymlbxhc_test.go:60: expected '%!s(int=6)', got '%!s(int=10)'\n  \
    \  --- FAIL: TestHex_Key/test_num__5 (0.00s)\n        tmpoymlbxhc_test.go:60:\
    \ expected '%!s(int=12)', got '%!s(int=20)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074685
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    num\
    \ := strings.ToUpper(num)\n    num := strings.TrimSpace(num)\n    num := strings.Replace(num,\
    \ \"A\", \"1\", -1)\n    num := strings.Replace(num, \"B\", \"2\", -1)\n    num\
    \ := strings.Replace(num, \"C\", \"3\", -1)\n    num := strings.Replace(num, \"\
    D\", \"4\", -1)\n    num := strings.Replace(num, \"E\", \"5\", -1)\n    num :=\
    \ strings.Replace(num, \"F\", \"6\", -1)\n    num := strings.Replace(num, \"0\"\
    , \"0\", -1)\n    num := strings.Replace(num, \"1\", \"1\", -1)\n    num := strings.Replace(num,\
    \ \"2\", \"2\", -1)\n    num := strings.Replace(num, \"3\", \"3\", -1)\n    num\
    \ := strings.Replace(num, \"4\", \"4\", -1)\n    num := strings.Replace(num, \"\
    5\", \"5\", -1)\n    num := strings.Replace(num, \"6\", \"6\", -1)\n    num :=\
    \ strings.Replace(num, \"7\", \"7\", -1)\n    num := strings.Replace(num, \"8\"\
    , \"8\", -1)\n    num := strings.Replace(num, \"9\", \"9\", -1)\n    num := strings.Replace(num,\
    \ \"+\", \"-\", -1)\n    num := strings.Replace(num, \"-\", \"+\", -1)\n    num\
    \ := strings.Replace(num, \".\", \"0\", -1)\n    num := strings.Replace(num, \"\
    /\", \"0\", -1)\n    num := strings.Replace(num, \"0\", \"0\", -1)\n    num :=\
    \ strings.Replace(num, \"1\", \"1\", -1)\n    num := strings.Replace(num, \"2\"\
    , \"2\", -1)\n    num := strings.Replace(num, \"3\", \"3\", -1)\n    num := strings.Replace(num,\
    \ \"4\", \"4\", -1)\n    num := strings.Replace(num, \"5\", \"5\", -1)\n    num\
    \ := strings.Replace(num, \"6\", \"6\", -1)\n    num := strings.Replace(num, \"\
    7\", \"7\", -1)\n    num := strings.Replace(num, \"8\", \"8\", -1)\n    num :=\
    \ strings.Replace(num, \"9\", \"9\", -1)\n    num := strings.Replace(num, \"*\"\
    , \"0\", -1)\n    num := strings.Replace(num, \"/\", \"0\", -1)\n    num := strings.Replace(num,\
    \ \"0\", \"0\", -1)\n    num := strings.Replace(num, \"1\", \"1\", -1)\n    num\
    \ := strings.Replace(num, \"2\", \"2\", -1)\n    num := strings.Replace(num, \"\
    3\", \"3\", -1)\n    num := strings.Replace(num, \"4\", \"4\", -1)\n    num :=\
    \ strings.Replace(num, \"5\", \"5\", -1)\n    num := strings.Replace(num, \"6\"\
    , \"6\", -1)\n    num := strings.Replace(num, \"7\", \"7\", -1)\nfunc TestHex_Key(t\
    \ *testing.T) {\n  candidate := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AB\"), expected: 1 },\n     { actual: candidate(\"1077E\"), expected: 2 },\n \
    \    { actual: candidate(\"ABED1A33\"), expected: 4 },\n     { actual: candidate(\"\
    2020\"), expected: 2 },\n     { actual: candidate(\"123456789ABCDEF0\"), expected:\
    \ 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"), expected:\
    \ 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpcd950lua_test.go:72:6: expected ''('', found TestHex_Key

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074683
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    num\
    \ := strings.ToUpper(num)\n    n := len(num)\n    prime := make([]int, n)\n  \
    \  prime[0] = 1\n    prime[1] = 2\n    prime[2] = 2\n    prime[3] = 2\n    prime[4]\
    \ = 2\n    prime[5] = 2\n    prime[6] = 2\n    prime[7] = 2\n    prime[8] = 2\n\
    \    prime[9] = 2\n    prime[10] = 2\n    prime[11] = 2\n    prime[12] = 2\n \
    \   prime[13] = 2\n    prime[14] = 2\n    prime[15] = 2\n    prime[16] = 2\n \
    \   prime[17] = 2\n    prime[18] = 2\n    prime[19] = 2\n    prime[20] = 2\n \
    \   prime[21] = 2\n    prime[22] = 2\n    prime[23] = 2\n    prime[24] = 2\n \
    \   prime[25] = 2\n    prime[26] = 2\n    prime[27] = 2\n    prime[28] = 2\n \
    \   prime[29] = 2\n    prime[30] = 2\n    prime[31] = 2\n    prime[32] = 2\n \
    \   prime[33] = 2\n    prime[34] = 2\n    prime[35] = 2\n    prime[36] = 2\n \
    \   prime[37] = 2\n    prime[38] = 2\n    prime[39] = 2\n    prime[40] = 2\n \
    \   prime[41] = 2\n    prime[42] = 2\n    prime[43] = 2\n    prime[44] = 2\n \
    \   prime[45] = 2\n    prime[46] = 2\n    prime[47] = 2\n    prime[48] = 2\n \
    \   prime[49] = 2\n    prime[50] = 2\n    prime[51] = 2\n    prime[52] = 2\n \
    \   prime[53] = 2\n    prime[54] = 2\n    prime[55] = 2\n    prime[56] = 2\n \
    \   prime[57] = 2\n    prime[58] = 2\n    prime[59] = 2\n    prime[60] = 2\n \
    \   prime[61] = 2\n    prime[62] = 2\n    prime[63] = 2\n    prime[64] = 2\n \
    \   prime[65] = 2\n    prime[66] = 2\n    prime[67] = 2\n    prime[68] = 2\n \
    \   prime[69] = 2\n    prime[70] = 2\n    prime[71] = 2\n    prime[72] = 2\n \
    \   prime[73\nfunc TestHex_Key(t *testing.T) {\n  candidate := hex_key\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"AB\"), expected: 1 },\n     { actual:\
    \ candidate(\"1077E\"), expected: 2 },\n     { actual: candidate(\"ABED1A33\"\
    ), expected: 4 },\n     { actual: candidate(\"2020\"), expected: 2 },\n     {\
    \ actual: candidate(\"123456789ABCDEF0\"), expected: 6 },\n     { actual: candidate(\"\
    112233445566778899AABBCCDDEEFF00\"), expected: 12 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpnw4j5qmi_test.go:106:13: expected '']'', found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074683
- exit_code: 2
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    num\
    \ := strings.ToUpper(num)\n    count := 0\n    for _, r := range num {\n     \
    \   count += int(unicode.ToLower(r) - 'A') + 1\n    }\n    return count\n}\n\n\
    func TestHex_Key(t *testing.T) {\n  candidate := hex_key\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AB\"), expected: 1 },\n     { actual: candidate(\"\
    1077E\"), expected: 2 },\n     { actual: candidate(\"ABED1A33\"), expected: 4\
    \ },\n     { actual: candidate(\"2020\"), expected: 2 },\n     { actual: candidate(\"\
    123456789ABCDEF0\"), expected: 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"\
    ), expected: 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_1_iz6v8_test.go:30:9: no new variables on left side of :=

    /tmp/tmp_1_iz6v8_test.go:30:12: undefined: strings

    /tmp/tmp_1_iz6v8_test.go:33:22: undefined: unicode

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074684
- exit_code: 2
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    num\
    \ := strings.ToUpper(num)\n    count := 0\n    for _, v := range num {\n     \
    \   if v == 'A' || v == 'B' || v == 'C' || v == 'D' || v == 'E' || v == 'F' {\n\
    \            count++\n        }\n    }\n    return count\n}\n\nfunc TestHex_Key(t\
    \ *testing.T) {\n  candidate := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AB\"), expected: 1 },\n     { actual: candidate(\"1077E\"), expected: 2 },\n \
    \    { actual: candidate(\"ABED1A33\"), expected: 4 },\n     { actual: candidate(\"\
    2020\"), expected: 2 },\n     { actual: candidate(\"123456789ABCDEF0\"), expected:\
    \ 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"), expected:\
    \ 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp88q38rvw_test.go:30:9: no new variables on left side of :=

    /tmp/tmp88q38rvw_test.go:30:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074577
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    //\
    \ Your code here\n    \n    return 0\n}\n\nfunc TestHex_Key(t *testing.T) {\n\
    \  candidate := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AB\"\
    ), expected: 1 },\n     { actual: candidate(\"1077E\"), expected: 2 },\n     {\
    \ actual: candidate(\"ABED1A33\"), expected: 4 },\n     { actual: candidate(\"\
    2020\"), expected: 2 },\n     { actual: candidate(\"123456789ABCDEF0\"), expected:\
    \ 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"), expected:\
    \ 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestHex_Key (0.00s)\n    --- FAIL: TestHex_Key/test_num__0 (0.00s)\n\
    \        tmpcshf94km_test.go:53: expected '%!s(int=1)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestHex_Key/test_num__1 (0.00s)\n        tmpcshf94km_test.go:53: expected\
    \ '%!s(int=2)', got '%!s(int=0)'\n    --- FAIL: TestHex_Key/test_num__2 (0.00s)\n\
    \        tmpcshf94km_test.go:53: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestHex_Key/test_num__3 (0.00s)\n        tmpcshf94km_test.go:53: expected\
    \ '%!s(int=2)', got '%!s(int=0)'\n    --- FAIL: TestHex_Key/test_num__4 (0.00s)\n\
    \        tmpcshf94km_test.go:53: expected '%!s(int=6)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestHex_Key/test_num__5 (0.00s)\n        tmpcshf94km_test.go:53: expected\
    \ '%!s(int=12)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074578
- exit_code: 2
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    num\
    \ := strings.ToUpper(num)\n    count := 0\n    for _, v := range num {\n     \
    \   if v == 'A' || v == 'B' || v == 'C' || v == 'D' || v == 'E' || v == 'F' {\n\
    \            count++\n        }\n    }\n    return count\n}\n\nfunc TestHex_Key(t\
    \ *testing.T) {\n  candidate := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AB\"), expected: 1 },\n     { actual: candidate(\"1077E\"), expected: 2 },\n \
    \    { actual: candidate(\"ABED1A33\"), expected: 4 },\n     { actual: candidate(\"\
    2020\"), expected: 2 },\n     { actual: candidate(\"123456789ABCDEF0\"), expected:\
    \ 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"), expected:\
    \ 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp88q38rvw_test.go:30:9: no new variables on left side of :=

    /tmp/tmp88q38rvw_test.go:30:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074577
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    //\
    \ Your code here\n    \n    \n    return 0\n}\nfunc TestHex_Key(t *testing.T)\
    \ {\n  candidate := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AB\"), expected: 1 },\n     { actual: candidate(\"1077E\"), expected: 2 },\n \
    \    { actual: candidate(\"ABED1A33\"), expected: 4 },\n     { actual: candidate(\"\
    2020\"), expected: 2 },\n     { actual: candidate(\"123456789ABCDEF0\"), expected:\
    \ 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"), expected:\
    \ 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestHex_Key (0.00s)\n    --- FAIL: TestHex_Key/test_num__0 (0.00s)\n\
    \        tmp_ynmxke8_test.go:53: expected '%!s(int=1)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestHex_Key/test_num__1 (0.00s)\n        tmp_ynmxke8_test.go:53: expected\
    \ '%!s(int=2)', got '%!s(int=0)'\n    --- FAIL: TestHex_Key/test_num__2 (0.00s)\n\
    \        tmp_ynmxke8_test.go:53: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestHex_Key/test_num__3 (0.00s)\n        tmp_ynmxke8_test.go:53: expected\
    \ '%!s(int=2)', got '%!s(int=0)'\n    --- FAIL: TestHex_Key/test_num__4 (0.00s)\n\
    \        tmp_ynmxke8_test.go:53: expected '%!s(int=6)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestHex_Key/test_num__5 (0.00s)\n        tmp_ynmxke8_test.go:53: expected\
    \ '%!s(int=12)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\n\
    FAIL\n"
  timestamp: 1660074685
- exit_code: 2
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    n\
    \ := len(num)\n    count := 0\n    i := 0\n    for i < n {\n        c := num[i]\n\
    \        if c >= '0' && c <= '9' {\n            count++\n        }\n        i++\n\
    \    }\n    if count == 0 {\n        return 0\n    }\n    i := 0\n    for i <\
    \ n {\n        c := num[i]\n        if c >= 'A' && c <= 'F' {\n            count++\n\
    \        }\n        i++\n    }\n    return count\n}\n\nfunc TestHex_Key(t *testing.T)\
    \ {\n  candidate := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AB\"), expected: 1 },\n     { actual: candidate(\"1077E\"), expected: 2 },\n \
    \    { actual: candidate(\"ABED1A33\"), expected: 4 },\n     { actual: candidate(\"\
    2020\"), expected: 2 },\n     { actual: candidate(\"123456789ABCDEF0\"), expected:\
    \ 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"), expected:\
    \ 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp04o8zek7_test.go:43:7: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074684
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    num\
    \ := strings.ToUpper(num)\n    num := strings.Replace(num, \"A\", \"1\", -1)\n\
    \    num := strings.Replace(num, \"B\", \"2\", -1)\n    num := strings.Replace(num,\
    \ \"C\", \"3\", -1)\n    num := strings.Replace(num, \"D\", \"4\", -1)\n    num\
    \ := strings.Replace(num, \"E\", \"5\", -1)\n    num := strings.Replace(num, \"\
    F\", \"6\", -1)\n    num := strings.Replace(num, \"0\", \"7\", -1)\n    num :=\
    \ strings.Replace(num, \"1\", \"8\", -1)\n    num := strings.Replace(num, \"2\"\
    , \"9\", -1)\n    num := strings.Replace(num, \"3\", \"A\", -1)\n    num := strings.Replace(num,\
    \ \"4\", \"B\", -1)\n    num := strings.Replace(num, \"5\", \"C\", -1)\n    num\
    \ := strings.Replace(num, \"6\", \"D\", -1)\n    num := strings.Replace(num, \"\
    7\", \"E\", -1)\n    num := strings.Replace(num, \"8\", \"F\", -1)\n    num :=\
    \ strings.Replace(num, \"9\", \"0\", -1)\n    num := strings.Replace(num, \"+\"\
    , \"0\", -1)\n    num := strings.Replace(num, \"-\", \"0\", -1)\n    num := strings.Replace(num,\
    \ \".\", \"0\", -1)\n    num := strings.Replace(num, \"/\", \"0\", -1)\n    num\
    \ := strings.Replace(num, \"=\", \"0\", -1)\n    num := strings.Replace(num, \"\
    ?\", \"0\", -1)\n    num := strings.Replace(num, \"!\", \"0\", -1)\n    num :=\
    \ strings.Replace(num, \"*\", \"0\", -1)\n    num := strings.Replace(num, \"(\"\
    , \"0\", -1)\n    num := strings.Replace(num, \"[\", \"0\", -1)\n    num := strings.Replace(num,\
    \ \"]\", \"0\", -1)\n    num := strings.Replace(num, \"{\", \"0\", -1)\n    num\
    \ := strings.Replace(num, \"}\", \"0\", -1)\n    num := strings.Replace(num, \"\
    <\", \"0\", -1)\n    num := strings.Replace(num, \">\", \"0\", -1)\n    num :=\
    \ strings.Replace(num, \"|\", \"0\", -1)\n    num := strings.Replace(num, \"~\"\
    , \"0\", -1)\n    num := strings.Replace(num, \"!\", \"0\", -1)\n    num := strings.Replace(num,\
    \ \"@\", \"0\", -1)\n    num := strings.Replace(num, \"#\", \"0\", -1)\n    num\
    \ := strings.Replace(num, \"$\", \"0\", -1)\n    num := strings.Replace(num, \"\
    %\", \"0\", -1)\n    num := strings.Replace(num, \"^\", \"0\", -1)\n    num :=\
    \ strings.\nfunc TestHex_Key(t *testing.T) {\n  candidate := hex_key\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"AB\"), expected: 1 },\n     { actual:\
    \ candidate(\"1077E\"), expected: 2 },\n     { actual: candidate(\"ABED1A33\"\
    ), expected: 4 },\n     { actual: candidate(\"2020\"), expected: 2 },\n     {\
    \ actual: candidate(\"123456789ABCDEF0\"), expected: 6 },\n     { actual: candidate(\"\
    112233445566778899AABBCCDDEEFF00\"), expected: 12 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpnp4udrxc_test.go:71:1: expected selector or type assertion, found ''func''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074683
- exit_code: 2
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    num\
    \ := strings.ToUpper(num)\n    count := 0\n    for _, v := range num {\n     \
    \   if v == 'A' || v == 'B' || v == 'C' || v == 'D' || v == 'E' || v == 'F' {\n\
    \            count++\n        }\n    }\n    return count\n}\n\nfunc TestHex_Key(t\
    \ *testing.T) {\n  candidate := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AB\"), expected: 1 },\n     { actual: candidate(\"1077E\"), expected: 2 },\n \
    \    { actual: candidate(\"ABED1A33\"), expected: 4 },\n     { actual: candidate(\"\
    2020\"), expected: 2 },\n     { actual: candidate(\"123456789ABCDEF0\"), expected:\
    \ 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"), expected:\
    \ 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp88q38rvw_test.go:30:9: no new variables on left side of :=

    /tmp/tmp88q38rvw_test.go:30:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074577
- exit_code: 2
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    n\
    \ := 0\n    base := \"0123456789ABCDEF\"\n    for _, c := range num {\n      \
    \  if c >= '0' && c <= '9' {\n            n = n*10 + int(c-'0')\n        } else\
    \ if c >= 'A' && c <= 'F' {\n            n = n*10 + int(c-'A') + 10\n        }\
    \ else if c >= 'a' && c <= 'f' {\n            n = n*10 + int(c-'a') + 10\n   \
    \     } else {\n            fmt.Println(\"invalid input\")\n        }\n    }\n\
    \    \n    for i := 2; i < n; i++ {\n        if n%i == 0 {\n            return\
    \ i\n        }\n    }\n    return n\n}\n\nfunc TestHex_Key(t *testing.T) {\n \
    \ candidate := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AB\"), expected:\
    \ 1 },\n     { actual: candidate(\"1077E\"), expected: 2 },\n     { actual: candidate(\"\
    ABED1A33\"), expected: 4 },\n     { actual: candidate(\"2020\"), expected: 2 },\n\
    \     { actual: candidate(\"123456789ABCDEF0\"), expected: 6 },\n     { actual:\
    \ candidate(\"112233445566778899AABBCCDDEEFF00\"), expected: 12 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprx0ga2j6_test.go:31:5: base declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074685
- exit_code: 2
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    num\
    \ := strings.ToUpper(num)\n    count := 0\n    for _, char := range num {\n  \
    \      if char == 'A' || char == 'B' || char == 'C' || char == 'D' || char ==\
    \ 'E' || char == 'F' {\n            count++\n        }\n    }\n    return count\n\
    }\n\nfunc TestHex_Key(t *testing.T) {\n  candidate := hex_key\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AB\"), expected: 1 },\n     { actual: candidate(\"\
    1077E\"), expected: 2 },\n     { actual: candidate(\"ABED1A33\"), expected: 4\
    \ },\n     { actual: candidate(\"2020\"), expected: 2 },\n     { actual: candidate(\"\
    123456789ABCDEF0\"), expected: 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"\
    ), expected: 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpp_8j83d0_test.go:30:9: no new variables on left side of :=

    /tmp/tmpp_8j83d0_test.go:30:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074582
- exit_code: 2
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    num\
    \ := strings.ToUpper(num)\n    n := len(num)\n    count := 0\n    i := 0\n   \
    \ for ; i < n; i++ {\n        digit := num[i]\n        if digit == \"A\" || digit\
    \ == \"B\" || digit == \"C\" || digit == \"D\" || digit == \"E\" || digit == \"\
    F\" {\n            count++\n        }\n    }\n    return count\n}\n\nfunc TestHex_Key(t\
    \ *testing.T) {\n  candidate := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AB\"), expected: 1 },\n     { actual: candidate(\"1077E\"), expected: 2 },\n \
    \    { actual: candidate(\"ABED1A33\"), expected: 4 },\n     { actual: candidate(\"\
    2020\"), expected: 2 },\n     { actual: candidate(\"123456789ABCDEF0\"), expected:\
    \ 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"), expected:\
    \ 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdlhpphap_test.go:30:9: no new variables on left side of :=

    /tmp/tmpdlhpphap_test.go:30:12: undefined: strings

    /tmp/tmpdlhpphap_test.go:36:21: invalid operation: digit == "A" (mismatched types
    byte and untyped string)

    /tmp/tmpdlhpphap_test.go:36:37: invalid operation: digit == "B" (mismatched types
    byte and untyped string)

    /tmp/tmpdlhpphap_test.go:36:53: invalid operation: digit == "C" (mismatched types
    byte and untyped string)

    /tmp/tmpdlhpphap_test.go:36:69: invalid operation: digit == "D" (mismatched types
    byte and untyped string)

    /tmp/tmpdlhpphap_test.go:36:85: invalid operation: digit == "E" (mismatched types
    byte and untyped string)

    /tmp/tmpdlhpphap_test.go:36:101: invalid operation: digit == "F" (mismatched types
    byte and untyped string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074579
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    var\
    \ count int = 0\n    for _, char := range num {\n        if char == 'A' || char\
    \ == 'B' || char == 'C' || char == 'D' || char == 'E' || char == 'F' {\n     \
    \       count++\n        }\n    }\n    return count\n}\n\nfunc TestHex_Key(t *testing.T)\
    \ {\n  candidate := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AB\"), expected: 1 },\n     { actual: candidate(\"1077E\"), expected: 2 },\n \
    \    { actual: candidate(\"ABED1A33\"), expected: 4 },\n     { actual: candidate(\"\
    2020\"), expected: 2 },\n     { actual: candidate(\"123456789ABCDEF0\"), expected:\
    \ 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"), expected:\
    \ 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestHex_Key (0.00s)\n    --- FAIL: TestHex_Key/test_num__0 (0.00s)\n\
    \        tmpidh0uqan_test.go:57: expected '%!s(int=1)', got '%!s(int=2)'\n   \
    \ --- FAIL: TestHex_Key/test_num__1 (0.00s)\n        tmpidh0uqan_test.go:57: expected\
    \ '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestHex_Key/test_num__2 (0.00s)\n\
    \        tmpidh0uqan_test.go:57: expected '%!s(int=4)', got '%!s(int=5)'\n   \
    \ --- FAIL: TestHex_Key/test_num__3 (0.00s)\n        tmpidh0uqan_test.go:57: expected\
    \ '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074582
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    //\
    \ Your code here\n    \n    return 0\n}\n\nfunc TestHex_Key(t *testing.T) {\n\
    \  candidate := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AB\"\
    ), expected: 1 },\n     { actual: candidate(\"1077E\"), expected: 2 },\n     {\
    \ actual: candidate(\"ABED1A33\"), expected: 4 },\n     { actual: candidate(\"\
    2020\"), expected: 2 },\n     { actual: candidate(\"123456789ABCDEF0\"), expected:\
    \ 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"), expected:\
    \ 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestHex_Key (0.00s)\n    --- FAIL: TestHex_Key/test_num__0 (0.00s)\n\
    \        tmpcshf94km_test.go:53: expected '%!s(int=1)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestHex_Key/test_num__1 (0.00s)\n        tmpcshf94km_test.go:53: expected\
    \ '%!s(int=2)', got '%!s(int=0)'\n    --- FAIL: TestHex_Key/test_num__2 (0.00s)\n\
    \        tmpcshf94km_test.go:53: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestHex_Key/test_num__3 (0.00s)\n        tmpcshf94km_test.go:53: expected\
    \ '%!s(int=2)', got '%!s(int=0)'\n    --- FAIL: TestHex_Key/test_num__4 (0.00s)\n\
    \        tmpcshf94km_test.go:53: expected '%!s(int=6)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestHex_Key/test_num__5 (0.00s)\n        tmpcshf94km_test.go:53: expected\
    \ '%!s(int=12)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074578
- exit_code: 2
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    //\
    \ Your code here\n    num := strings.ToUpper(num)\n    count := 0\n    for _,\
    \ v := range num {\n        if v == 'A' || v == 'B' || v == 'C' || v == 'D' ||\
    \ v == 'E' || v == 'F' {\n            count++\n        }\n    }\n    return count\n\
    }\n\nfunc TestHex_Key(t *testing.T) {\n  candidate := hex_key\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AB\"), expected: 1 },\n     { actual: candidate(\"\
    1077E\"), expected: 2 },\n     { actual: candidate(\"ABED1A33\"), expected: 4\
    \ },\n     { actual: candidate(\"2020\"), expected: 2 },\n     { actual: candidate(\"\
    123456789ABCDEF0\"), expected: 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"\
    ), expected: 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpa80bxlmd_test.go:31:9: no new variables on left side of :=

    /tmp/tmpa80bxlmd_test.go:31:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074583
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    var\
    \ count int = 0\n    for _, r := range num {\n        if r == 'A' || r == 'B'\
    \ || r == 'C' || r == 'D' || r == 'E' || r == 'F' {\n            count++\n   \
    \     }\n    }\n    return count\n}\n\nfunc TestHex_Key(t *testing.T) {\n  candidate\
    \ := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AB\"), expected: 1 },\n \
    \    { actual: candidate(\"1077E\"), expected: 2 },\n     { actual: candidate(\"\
    ABED1A33\"), expected: 4 },\n     { actual: candidate(\"2020\"), expected: 2 },\n\
    \     { actual: candidate(\"123456789ABCDEF0\"), expected: 6 },\n     { actual:\
    \ candidate(\"112233445566778899AABBCCDDEEFF00\"), expected: 12 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestHex_Key (0.00s)\n    --- FAIL: TestHex_Key/test_num__0 (0.00s)\n\
    \        tmpon0xm6jg_test.go:57: expected '%!s(int=1)', got '%!s(int=2)'\n   \
    \ --- FAIL: TestHex_Key/test_num__1 (0.00s)\n        tmpon0xm6jg_test.go:57: expected\
    \ '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestHex_Key/test_num__2 (0.00s)\n\
    \        tmpon0xm6jg_test.go:57: expected '%!s(int=4)', got '%!s(int=5)'\n   \
    \ --- FAIL: TestHex_Key/test_num__3 (0.00s)\n        tmpon0xm6jg_test.go:57: expected\
    \ '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074582
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    //\
    \ Your code here\n    \n    return 0\n}\n</code>\n<|/ q dscore=0 |>\n<| c |>\n\
    What have you tried so far? Where are you stuck? Please show us your attempt.\n\
    <|/ c |>\n<| c |>\nI tried to write some code but i got stuck. i don't know how\
    \ to count the numbers of prime numbers in a string. i tried to use for loop but\
    \ i couldn't do it.\n<|/ c |>\n<| c |>\nPlease show us your attempt.\n<|/ c |>\n\
    <| c |>\ni edited the question\n<|/ c |>\n<| c |>\nPlease show us your attempt.\n\
    <|/ c |>\n<| a dscore=1 |>\n<code>\npackage main\n\nimport (\n    \"fmt\"\n  \
    \  \"math\"\n)\n\nfunc TestHex_Key(t *testing.T) {\n  candidate := hex_key\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"AB\"), expected: 1 },\n     {\
    \ actual: candidate(\"1077E\"), expected: 2 },\n     { actual: candidate(\"ABED1A33\"\
    ), expected: 4 },\n     { actual: candidate(\"2020\"), expected: 2 },\n     {\
    \ actual: candidate(\"123456789ABCDEF0\"), expected: 6 },\n     { actual: candidate(\"\
    112233445566778899AABBCCDDEEFF00\"), expected: 12 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpzfv12ge5_test.go:34:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074685
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    n\
    \ := 0\n    for _, r := range num {\n        n += int(rune(r) - '0')\n    }\n\
    \    return n\n}\n\nfunc TestHex_Key(t *testing.T) {\n  candidate := hex_key\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"AB\"), expected: 1 },\n     {\
    \ actual: candidate(\"1077E\"), expected: 2 },\n     { actual: candidate(\"ABED1A33\"\
    ), expected: 4 },\n     { actual: candidate(\"2020\"), expected: 2 },\n     {\
    \ actual: candidate(\"123456789ABCDEF0\"), expected: 6 },\n     { actual: candidate(\"\
    112233445566778899AABBCCDDEEFF00\"), expected: 12 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestHex_Key (0.00s)\n    --- FAIL: TestHex_Key/test_num__0 (0.00s)\n\
    \        tmpsucyn_gd_test.go:55: expected '%!s(int=1)', got '%!s(int=35)'\n  \
    \  --- FAIL: TestHex_Key/test_num__1 (0.00s)\n        tmpsucyn_gd_test.go:55:\
    \ expected '%!s(int=2)', got '%!s(int=36)'\n    --- FAIL: TestHex_Key/test_num__2\
    \ (0.00s)\n        tmpsucyn_gd_test.go:55: expected '%!s(int=4)', got '%!s(int=100)'\n\
    \    --- FAIL: TestHex_Key/test_num__3 (0.00s)\n        tmpsucyn_gd_test.go:55:\
    \ expected '%!s(int=2)', got '%!s(int=4)'\n    --- FAIL: TestHex_Key/test_num__4\
    \ (0.00s)\n        tmpsucyn_gd_test.go:55: expected '%!s(int=6)', got '%!s(int=162)'\n\
    \    --- FAIL: TestHex_Key/test_num__5 (0.00s)\n        tmpsucyn_gd_test.go:55:\
    \ expected '%!s(int=12)', got '%!s(int=324)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074582
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    //\
    \ Your code here\n    \n    return 0\n}\n\nfunc TestHex_Key(t *testing.T) {\n\
    \  candidate := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AB\"\
    ), expected: 1 },\n     { actual: candidate(\"1077E\"), expected: 2 },\n     {\
    \ actual: candidate(\"ABED1A33\"), expected: 4 },\n     { actual: candidate(\"\
    2020\"), expected: 2 },\n     { actual: candidate(\"123456789ABCDEF0\"), expected:\
    \ 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"), expected:\
    \ 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestHex_Key (0.00s)\n    --- FAIL: TestHex_Key/test_num__0 (0.00s)\n\
    \        tmpcshf94km_test.go:53: expected '%!s(int=1)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestHex_Key/test_num__1 (0.00s)\n        tmpcshf94km_test.go:53: expected\
    \ '%!s(int=2)', got '%!s(int=0)'\n    --- FAIL: TestHex_Key/test_num__2 (0.00s)\n\
    \        tmpcshf94km_test.go:53: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestHex_Key/test_num__3 (0.00s)\n        tmpcshf94km_test.go:53: expected\
    \ '%!s(int=2)', got '%!s(int=0)'\n    --- FAIL: TestHex_Key/test_num__4 (0.00s)\n\
    \        tmpcshf94km_test.go:53: expected '%!s(int=6)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestHex_Key/test_num__5 (0.00s)\n        tmpcshf94km_test.go:53: expected\
    \ '%!s(int=12)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074578
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    //\
    \ Your code here\n    \n    return 0\n}\n\nfunc TestHex_Key(t *testing.T) {\n\
    \  candidate := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AB\"\
    ), expected: 1 },\n     { actual: candidate(\"1077E\"), expected: 2 },\n     {\
    \ actual: candidate(\"ABED1A33\"), expected: 4 },\n     { actual: candidate(\"\
    2020\"), expected: 2 },\n     { actual: candidate(\"123456789ABCDEF0\"), expected:\
    \ 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"), expected:\
    \ 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestHex_Key (0.00s)\n    --- FAIL: TestHex_Key/test_num__0 (0.00s)\n\
    \        tmpcshf94km_test.go:53: expected '%!s(int=1)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestHex_Key/test_num__1 (0.00s)\n        tmpcshf94km_test.go:53: expected\
    \ '%!s(int=2)', got '%!s(int=0)'\n    --- FAIL: TestHex_Key/test_num__2 (0.00s)\n\
    \        tmpcshf94km_test.go:53: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestHex_Key/test_num__3 (0.00s)\n        tmpcshf94km_test.go:53: expected\
    \ '%!s(int=2)', got '%!s(int=0)'\n    --- FAIL: TestHex_Key/test_num__4 (0.00s)\n\
    \        tmpcshf94km_test.go:53: expected '%!s(int=6)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestHex_Key/test_num__5 (0.00s)\n        tmpcshf94km_test.go:53: expected\
    \ '%!s(int=12)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074578
- exit_code: 2
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    num\
    \ := strings.ToUpper(num)\n    count := 0\n    for _, r := range num {\n     \
    \   if r == 'A' || r == 'B' || r == 'C' || r == 'D' || r == 'E' || r == 'F' {\n\
    \            count++\n        }\n    }\n    return count\n}\n\nfunc TestHex_Key(t\
    \ *testing.T) {\n  candidate := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AB\"), expected: 1 },\n     { actual: candidate(\"1077E\"), expected: 2 },\n \
    \    { actual: candidate(\"ABED1A33\"), expected: 4 },\n     { actual: candidate(\"\
    2020\"), expected: 2 },\n     { actual: candidate(\"123456789ABCDEF0\"), expected:\
    \ 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"), expected:\
    \ 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4qeoci93_test.go:30:9: no new variables on left side of :=

    /tmp/tmp4qeoci93_test.go:30:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074579
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    n\
    \ := len(num)\n    k := 0\n    i := 0\n    prime := true\n    for i < n {\n  \
    \      digit := int(num[i])\n        if digit > 9 {\n            digit = digit\
    \ - 10\n        }\n        if prime {\n            k += digit\n            i +=\
    \ 2\n            prime = false\n        } else {\n            k += digit * digit\n\
    \            i += 3\n            prime = true\n        }\n    }\n    return k\n\
    }\n\nfunc TestHex_Key(t *testing.T) {\n  candidate := hex_key\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AB\"), expected: 1 },\n     { actual: candidate(\"\
    1077E\"), expected: 2 },\n     { actual: candidate(\"ABED1A33\"), expected: 4\
    \ },\n     { actual: candidate(\"2020\"), expected: 2 },\n     { actual: candidate(\"\
    123456789ABCDEF0\"), expected: 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"\
    ), expected: 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestHex_Key (0.00s)\n    --- FAIL: TestHex_Key/test_num__0 (0.00s)\n\
    \        tmpkgtg953i_test.go:70: expected '%!s(int=1)', got '%!s(int=55)'\n  \
    \  --- FAIL: TestHex_Key/test_num__1 (0.00s)\n        tmpkgtg953i_test.go:70:\
    \ expected '%!s(int=2)', got '%!s(int=2064)'\n    --- FAIL: TestHex_Key/test_num__2\
    \ (0.00s)\n        tmpkgtg953i_test.go:70: expected '%!s(int=4)', got '%!s(int=5272)'\n\
    \    --- FAIL: TestHex_Key/test_num__3 (0.00s)\n        tmpkgtg953i_test.go:70:\
    \ expected '%!s(int=2)', got '%!s(int=1640)'\n    --- FAIL: TestHex_Key/test_num__4\
    \ (0.00s)\n        tmpkgtg953i_test.go:70: expected '%!s(int=6)', got '%!s(int=7338)'\n\
    \    --- FAIL: TestHex_Key/test_num__5 (0.00s)\n        tmpkgtg953i_test.go:70:\
    \ expected '%!s(int=12)', got '%!s(int=14650)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074686
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    num\
    \ := strings.ToUpper(num)\n    n := len(num)\n    prime := make([]int, n)\n  \
    \  for i := 0; i < n; i++ {\n        prime[i] = 0\n    }\n    for i := 0; i <\
    \ n; i++ {\n        if num[i] == 'A' || num[i] == 'B' || num[i] == 'C' || num[i]\
    \ == 'D' || num[i] == 'E' || num[i] == 'F' {\n            prime[i] = 1\n     \
    \   }\n    }\n    for i := 0; i < n; i++ {\n        for j := i + 1; j < n; j++\
    \ {\n            if prime[i]*prime[j] == 1 {\n                prime[j] = 1\n \
    \           }\n        }\n    }\n    return len(prime)\n}\n</code>\n<|/ a tags=go,primes\
    \ |>\n<| c |>\nThis is not the fastest solution, but it's very elegant. Thanks!\n\
    <|/ c |>\n<| c |>\nThis is not the fastest solution, but it's very elegant. Thanks!\n\
    <|/ c |>\n<| c |>\nThis is not the fastest solution, but it's very elegant. Thanks!\n\
    <|/ c |>\n<| c |>\nThis is not the fastest solution, but it's very elegant. Thanks!\n\
    <|/ c |>\n<| c |>\nThis is not the fastest solution, but it's very elegant. Thanks!\n\
    <|/ c |>\n<| a tags=go,primes |>\n<code>\npackage main\n\nimport (\n    \"fmt\"\
    \n    \"math\"\n)\n\nfunc TestHex_Key(t *testing.T) {\n  candidate := hex_key\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"AB\"), expected: 1 },\n     {\
    \ actual: candidate(\"1077E\"), expected: 2 },\n     { actual: candidate(\"ABED1A33\"\
    ), expected: 4 },\n     { actual: candidate(\"2020\"), expected: 2 },\n     {\
    \ actual: candidate(\"123456789ABCDEF0\"), expected: 6 },\n     { actual: candidate(\"\
    112233445566778899AABBCCDDEEFF00\"), expected: 12 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpyvro36x3_test.go:50:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074685
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    n\
    \ := 0\n    for _, r := range num {\n        n += int(rune(r) - '0')\n    }\n\
    \    return n\n}\n\nfunc TestHex_Key(t *testing.T) {\n  candidate := hex_key\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"AB\"), expected: 1 },\n     {\
    \ actual: candidate(\"1077E\"), expected: 2 },\n     { actual: candidate(\"ABED1A33\"\
    ), expected: 4 },\n     { actual: candidate(\"2020\"), expected: 2 },\n     {\
    \ actual: candidate(\"123456789ABCDEF0\"), expected: 6 },\n     { actual: candidate(\"\
    112233445566778899AABBCCDDEEFF00\"), expected: 12 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestHex_Key (0.00s)\n    --- FAIL: TestHex_Key/test_num__0 (0.00s)\n\
    \        tmpsucyn_gd_test.go:55: expected '%!s(int=1)', got '%!s(int=35)'\n  \
    \  --- FAIL: TestHex_Key/test_num__1 (0.00s)\n        tmpsucyn_gd_test.go:55:\
    \ expected '%!s(int=2)', got '%!s(int=36)'\n    --- FAIL: TestHex_Key/test_num__2\
    \ (0.00s)\n        tmpsucyn_gd_test.go:55: expected '%!s(int=4)', got '%!s(int=100)'\n\
    \    --- FAIL: TestHex_Key/test_num__3 (0.00s)\n        tmpsucyn_gd_test.go:55:\
    \ expected '%!s(int=2)', got '%!s(int=4)'\n    --- FAIL: TestHex_Key/test_num__4\
    \ (0.00s)\n        tmpsucyn_gd_test.go:55: expected '%!s(int=6)', got '%!s(int=162)'\n\
    \    --- FAIL: TestHex_Key/test_num__5 (0.00s)\n        tmpsucyn_gd_test.go:55:\
    \ expected '%!s(int=12)', got '%!s(int=324)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074582
- exit_code: 2
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    num\
    \ := strings.ToUpper(num)\n    count := 0\n    for _, v := range num {\n     \
    \   if v == 'A' || v == 'B' || v == 'C' || v == 'D' || v == 'E' || v == 'F' {\n\
    \            count++\n        }\n    }\n    return count\n}\n\nfunc TestHex_Key(t\
    \ *testing.T) {\n  candidate := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AB\"), expected: 1 },\n     { actual: candidate(\"1077E\"), expected: 2 },\n \
    \    { actual: candidate(\"ABED1A33\"), expected: 4 },\n     { actual: candidate(\"\
    2020\"), expected: 2 },\n     { actual: candidate(\"123456789ABCDEF0\"), expected:\
    \ 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"), expected:\
    \ 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp88q38rvw_test.go:30:9: no new variables on left side of :=

    /tmp/tmp88q38rvw_test.go:30:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074577
- exit_code: 2
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    num\
    \ := strings.ToUpper(num)\n    count := 0\n    for _, c := range num {\n     \
    \   if c >= '0' && c <= '9' {\n            count++\n        }\n    }\n    return\
    \ count\n}\n\nfunc TestHex_Key(t *testing.T) {\n  candidate := hex_key\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"AB\"), expected: 1 },\n     { actual:\
    \ candidate(\"1077E\"), expected: 2 },\n     { actual: candidate(\"ABED1A33\"\
    ), expected: 4 },\n     { actual: candidate(\"2020\"), expected: 2 },\n     {\
    \ actual: candidate(\"123456789ABCDEF0\"), expected: 6 },\n     { actual: candidate(\"\
    112233445566778899AABBCCDDEEFF00\"), expected: 12 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp44qev7nj_test.go:30:9: no new variables on left side of :=

    /tmp/tmp44qev7nj_test.go:30:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074577
- exit_code: 2
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    n\
    \ := 0\n    base := 0\n    for _, r := range num {\n        n += (r - 'A') * base\n\
    \        base *= 16\n    }\n    if n < 2 {\n        return n\n    }\n    for i\
    \ := 2; i < n; i++ {\n        if n%i == 0 {\n            return i\n        }\n\
    \    }\n    return n\n}\n\nfunc TestHex_Key(t *testing.T) {\n  candidate := hex_key\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"AB\"), expected: 1 },\n     {\
    \ actual: candidate(\"1077E\"), expected: 2 },\n     { actual: candidate(\"ABED1A33\"\
    ), expected: 4 },\n     { actual: candidate(\"2020\"), expected: 2 },\n     {\
    \ actual: candidate(\"123456789ABCDEF0\"), expected: 6 },\n     { actual: candidate(\"\
    112233445566778899AABBCCDDEEFF00\"), expected: 12 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0t60ptad_test.go:33:14: invalid operation: (r - ''A'') * base (mismatched
    types rune and int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074685
- exit_code: 2
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    num\
    \ := strings.ToUpper(num)\n    count := 0\n    for _, v := range num {\n     \
    \   if v == 'A' || v == 'B' || v == 'C' || v == 'D' || v == 'E' || v == 'F' {\n\
    \            count++\n        }\n    }\n    return count\n}\n\nfunc TestHex_Key(t\
    \ *testing.T) {\n  candidate := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AB\"), expected: 1 },\n     { actual: candidate(\"1077E\"), expected: 2 },\n \
    \    { actual: candidate(\"ABED1A33\"), expected: 4 },\n     { actual: candidate(\"\
    2020\"), expected: 2 },\n     { actual: candidate(\"123456789ABCDEF0\"), expected:\
    \ 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"), expected:\
    \ 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp88q38rvw_test.go:30:9: no new variables on left side of :=

    /tmp/tmp88q38rvw_test.go:30:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074577
- exit_code: 2
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    n\
    \ := 0\n    for _, r := range num {\n        n += (r - 'A') * 16\n    }\n    return\
    \ n\n}\n\nfunc TestHex_Key(t *testing.T) {\n  candidate := hex_key\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"AB\"), expected: 1 },\n     { actual:\
    \ candidate(\"1077E\"), expected: 2 },\n     { actual: candidate(\"ABED1A33\"\
    ), expected: 4 },\n     { actual: candidate(\"2020\"), expected: 2 },\n     {\
    \ actual: candidate(\"123456789ABCDEF0\"), expected: 6 },\n     { actual: candidate(\"\
    112233445566778899AABBCCDDEEFF00\"), expected: 12 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpksqd9hfl_test.go:32:9: invalid operation: n += (r - ''A'') * 16 (mismatched
    types int and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074580
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    n\
    \ := 0\n    i := 0\n    for ; i < len(num); i++ {\n        if num[i] >= '0' &&\
    \ num[i] <= '9' {\n            n = n*16 + int(num[i]) - '0'\n        } else {\n\
    \            n = n*16 + int(num[i]) - 'A' + 10\n        }\n    }\n    return n\n\
    }\n\nfunc TestHex_Key(t *testing.T) {\n  candidate := hex_key\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AB\"), expected: 1 },\n     { actual: candidate(\"\
    1077E\"), expected: 2 },\n     { actual: candidate(\"ABED1A33\"), expected: 4\
    \ },\n     { actual: candidate(\"2020\"), expected: 2 },\n     { actual: candidate(\"\
    123456789ABCDEF0\"), expected: 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"\
    ), expected: 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestHex_Key (0.00s)\n    --- FAIL: TestHex_Key/test_num__0 (0.00s)\n\
    \        tmp340aa_hi_test.go:60: expected '%!s(int=1)', got '%!s(int=171)'\n \
    \   --- FAIL: TestHex_Key/test_num__1 (0.00s)\n        tmp340aa_hi_test.go:60:\
    \ expected '%!s(int=2)', got '%!s(int=67454)'\n    --- FAIL: TestHex_Key/test_num__2\
    \ (0.00s)\n        tmp340aa_hi_test.go:60: expected '%!s(int=4)', got '%!s(int=2884442675)'\n\
    \    --- FAIL: TestHex_Key/test_num__3 (0.00s)\n        tmp340aa_hi_test.go:60:\
    \ expected '%!s(int=2)', got '%!s(int=8224)'\n    --- FAIL: TestHex_Key/test_num__4\
    \ (0.00s)\n        tmp340aa_hi_test.go:60: expected '%!s(int=6)', got '%!s(int=1311768467463790320)'\n\
    \    --- FAIL: TestHex_Key/test_num__5 (0.00s)\n        tmp340aa_hi_test.go:60:\
    \ expected '%!s(int=12)', got '%!s(int=-7373874951294615808)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074686
- exit_code: 2
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    n\
    \ := 0\n    for _, r := range num {\n        n += int(unicode.ToLower(r) - 'a')\n\
    \    }\n    return n\n}\n\nfunc TestHex_Key(t *testing.T) {\n  candidate := hex_key\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"AB\"), expected: 1 },\n     {\
    \ actual: candidate(\"1077E\"), expected: 2 },\n     { actual: candidate(\"ABED1A33\"\
    ), expected: 4 },\n     { actual: candidate(\"2020\"), expected: 2 },\n     {\
    \ actual: candidate(\"123456789ABCDEF0\"), expected: 6 },\n     { actual: candidate(\"\
    112233445566778899AABBCCDDEEFF00\"), expected: 12 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpd8oyde4w_test.go:32:18: undefined: unicode

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074577
- exit_code: 2
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    num\
    \ := strings.ToUpper(num)\n    count := 0\n    for _, v := range num {\n     \
    \   if v == 'A' || v == 'B' || v == 'C' || v == 'D' || v == 'E' || v == 'F' {\n\
    \            count++\n        }\n    }\n    return count\n}\n\nfunc TestHex_Key(t\
    \ *testing.T) {\n  candidate := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AB\"), expected: 1 },\n     { actual: candidate(\"1077E\"), expected: 2 },\n \
    \    { actual: candidate(\"ABED1A33\"), expected: 4 },\n     { actual: candidate(\"\
    2020\"), expected: 2 },\n     { actual: candidate(\"123456789ABCDEF0\"), expected:\
    \ 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"), expected:\
    \ 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp88q38rvw_test.go:30:9: no new variables on left side of :=

    /tmp/tmp88q38rvw_test.go:30:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074577
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    n\
    \ := len(num)\n    prime := make([]int, n)\n    prime[0] = 2\n    prime[1] = 3\n\
    \    prime[2] = 5\n    prime[3] = 7\n    prime[4] = 11\n    prime[5] = 13\n  \
    \  prime[6] = 17\n    prime[7] = 19\n    prime[8] = 23\n    prime[9] = 29\n  \
    \  prime[10] = 31\n    prime[11] = 31\n    prime[12] = 31\n    prime[13] = 31\n\
    \    prime[14] = 31\n    prime[15] = 31\n    prime[16] = 31\n    prime[17] = 31\n\
    \    prime[18] = 31\n    prime[19] = 31\n    prime[20] = 31\n    prime[21] = 31\n\
    \    prime[22] = 31\n    prime[23] = 31\n    prime[24] = 31\n    prime[25] = 31\n\
    \    prime[26] = 31\n    prime[27] = 31\n    prime[28] = 31\n    prime[29] = 31\n\
    \    prime[30] = 31\n    prime[31] = 31\n    prime[32] = 31\n    prime[33] = 31\n\
    \    prime[34] = 31\n    prime[35] = 31\n    prime[36] = 31\n    prime[37] = 31\n\
    \    prime[38] = 31\n    prime[39] = 31\n    prime[40] = 31\n    prime[41] = 31\n\
    \    prime[42] = 31\n    prime[43] = 31\n    prime[44] = 31\n    prime[45] = 31\n\
    \    prime[46] = 31\n    prime[47] = 31\n    prime[48] = 31\n    prime[49] = 31\n\
    \    prime[50] = 31\n    prime[51] = 31\n    prime[52] = 31\n    prime[53] = 31\n\
    \    prime[54] = 31\n    prime[55] = 31\n    prime[56] = 31\n    prime[57] = 31\n\
    \    prime[58] = 31\n    prime[59] = 31\n    prime[60] = 31\n    prime[61] = 31\n\
    \    prime[62] = 31\n    prime[63] = 31\n    prime[64] = 31\n    prime[65] = 31\n\
    \    prime[66] = 31\n\nfunc TestHex_Key(t *testing.T) {\n  candidate := hex_key\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"AB\"), expected: 1 },\n     {\
    \ actual: candidate(\"1077E\"), expected: 2 },\n     { actual: candidate(\"ABED1A33\"\
    ), expected: 4 },\n     { actual: candidate(\"2020\"), expected: 2 },\n     {\
    \ actual: candidate(\"123456789ABCDEF0\"), expected: 6 },\n     { actual: candidate(\"\
    112233445566778899AABBCCDDEEFF00\"), expected: 12 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpn113atsk_test.go:100:6: expected ''('', found TestHex_Key

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074576
- exit_code: 2
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    //\
    \ Your code here\n    num := strings.ToUpper(num)\n    count := 0\n    for _,\
    \ v := range num {\n        if v == 'A' || v == 'B' || v == 'C' || v == 'D' ||\
    \ v == 'E' || v == 'F' {\n            count++\n        }\n    }\n    return count\n\
    }\n\nfunc TestHex_Key(t *testing.T) {\n  candidate := hex_key\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AB\"), expected: 1 },\n     { actual: candidate(\"\
    1077E\"), expected: 2 },\n     { actual: candidate(\"ABED1A33\"), expected: 4\
    \ },\n     { actual: candidate(\"2020\"), expected: 2 },\n     { actual: candidate(\"\
    123456789ABCDEF0\"), expected: 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"\
    ), expected: 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpa80bxlmd_test.go:31:9: no new variables on left side of :=

    /tmp/tmpa80bxlmd_test.go:31:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074583
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    num\
    \ := strings.ToUpper(num)\n    num := strings.TrimSpace(num)\n    num := strings.Replace(num,\
    \ \"A\", \"10\", -1)\n    num := strings.Replace(num, \"B\", \"11\", -1)\n   \
    \ num := strings.Replace(num, \"C\", \"12\", -1)\n    num := strings.Replace(num,\
    \ \"D\", \"13\", -1)\n    num := strings.Replace(num, \"E\", \"14\", -1)\n   \
    \ num := strings.Replace(num, \"F\", \"15\", -1)\n    num := strings.Replace(num,\
    \ \"0\", \"1\", -1)\n    num := strings.Replace(num, \"1\", \"2\", -1)\n    num\
    \ := strings.Replace(num, \"2\", \"3\", -1)\n    num := strings.Replace(num, \"\
    3\", \"4\", -1)\n    num := strings.Replace(num, \"4\", \"5\", -1)\n    num :=\
    \ strings.Replace(num, \"5\", \"6\", -1)\n    num := strings.Replace(num, \"6\"\
    , \"7\", -1)\n    num := strings.Replace(num, \"7\", \"8\", -1)\n    num := strings.Replace(num,\
    \ \"8\", \"9\", -1)\n    num := strings.Replace(num, \"9\", \"10\", -1)\n    num\
    \ := strings.Replace(num, \"10\", \"11\", -1)\n    num := strings.Replace(num,\
    \ \"11\", \"12\", -1)\n    num := strings.Replace(num, \"12\", \"13\", -1)\n \
    \   num := strings.Replace(num, \"13\", \"14\", -1)\n    num := strings.Replace(num,\
    \ \"14\", \"15\", -1)\n    num := strings.Replace(num, \"15\", \"16\", -1)\n \
    \   num := strings.Replace(num, \"16\", \"17\", -1)\n    num := strings.Replace(num,\
    \ \"17\", \"18\", -1)\n    num := strings.Replace(num, \"18\", \"19\", -1)\n \
    \   num := strings.Replace(num, \"19\", \"20\", -1)\n    num := strings.Replace(num,\
    \ \"20\", \"21\", -1)\n    num := strings.Replace(num, \"21\", \"22\", -1)\n \
    \   num := strings.Replace(num, \"22\", \"23\", -1)\n    num := strings.Replace(num,\
    \ \"23\", \"24\", -1)\n    num := strings.Replace(num, \"24\", \"25\", -1)\n \
    \   num := strings.Replace(num, \"25\", \"26\", -1)\n    num := strings.Replace(num,\
    \ \"26\", \"27\", -1)\n    num := strings.Replace(num, \"27\", \"28\", -1)\n \
    \   num := strings.Replace(num, \"28\", \"29\", -1)\n    num := strings.Replace(num,\
    \ \"29\", \"30\", -1)\n    num := strings.Replace(num, \"30\", \"31\", -1)\n \
    \   num := strings.Replace(num, \"31\", \"32\", -1)\n    num := strings.Replace(num,\
    \ \"\nfunc TestHex_Key(t *testing.T) {\n  candidate := hex_key\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AB\"), expected: 1 },\n     { actual: candidate(\"\
    1077E\"), expected: 2 },\n     { actual: candidate(\"ABED1A33\"), expected: 4\
    \ },\n     { actual: candidate(\"2020\"), expected: 2 },\n     { actual: candidate(\"\
    123456789ABCDEF0\"), expected: 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"\
    ), expected: 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvzdlk0w4_test.go:70:33: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074580
- exit_code: 2
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    num\
    \ := strings.ToUpper(num)\n    \n    count := 0\n    for _, v := range num {\n\
    \        if v == 'A' || v == 'B' || v == 'C' || v == 'D' || v == 'E' || v == 'F'\
    \ {\n            count++\n        }\n    }\n    \n    return count\n}\n\nfunc\
    \ TestHex_Key(t *testing.T) {\n  candidate := hex_key\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"AB\"), expected: 1 },\n     { actual: candidate(\"\
    1077E\"), expected: 2 },\n     { actual: candidate(\"ABED1A33\"), expected: 4\
    \ },\n     { actual: candidate(\"2020\"), expected: 2 },\n     { actual: candidate(\"\
    123456789ABCDEF0\"), expected: 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"\
    ), expected: 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpzu7zmc5m_test.go:30:9: no new variables on left side of :=

    /tmp/tmpzu7zmc5m_test.go:30:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074685
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    num\
    \ := strings.ToUpper(num)\n    num := strings.Replace(num, \"A\", \"10\", -1)\n\
    \    num := strings.Replace(num, \"B\", \"11\", -1)\n    num := strings.Replace(num,\
    \ \"C\", \"12\", -1)\n    num := strings.Replace(num, \"D\", \"13\", -1)\n   \
    \ num := strings.Replace(num, \"E\", \"14\", -1)\n    num := strings.Replace(num,\
    \ \"F\", \"15\", -1)\n    num := strings.Replace(num, \"0\", \"10\", -1)\n   \
    \ num := strings.Replace(num, \"1\", \"11\", -1)\n    num := strings.Replace(num,\
    \ \"2\", \"12\", -1)\n    num := strings.Replace(num, \"3\", \"13\", -1)\n   \
    \ num := strings.Replace(num, \"4\", \"14\", -1)\n    num := strings.Replace(num,\
    \ \"5\", \"15\", -1)\n    num := strings.Replace(num, \"6\", \"16\", -1)\n   \
    \ num := strings.Replace(num, \"7\", \"17\", -1)\n    num := strings.Replace(num,\
    \ \"8\", \"18\", -1)\n    num := strings.Replace(num, \"9\", \"19\", -1)\n   \
    \ num := strings.Replace(num, \"+\", \"-\", -1)\n    num := strings.Replace(num,\
    \ \"/\", \"*\", -1)\n    num := strings.Replace(num, \"=\", \"*\", -1)\n    num\
    \ := strings.Replace(num, \"-\", \"+\", -1)\n    num := strings.Replace(num, \"\
    *\", \"/\", -1)\n    num := strings.Replace(num, \"(\", \"-\", -1)\n    num :=\
    \ strings.Replace(num, \")\", \"-\", -1)\n    num := strings.Replace(num, \".\"\
    , \"*\", -1)\n    num := strings.Replace(num, \"-\", \"+\", -1)\n    num := strings.Replace(num,\
    \ \"+\", \"*\", -1)\n    num := strings.Replace(num, \"*\", \"/\", -1)\n    num\
    \ := strings.Replace(num, \"/\", \"*\", -1)\n    num := strings.Replace(num, \"\
    *\", \"*\", -1)\n    num := strings.Replace(num, \"*\", \"*\", -1)\n    num :=\
    \ strings.Replace(num, \"*\", \"*\", -1)\n    num := strings.Replace(num, \"*\"\
    , \"*\", -1)\n    num := strings.Replace(num, \"*\", \"*\", -1)\n    num := strings.Replace(num,\
    \ \"*\", \"*\", -1)\n    num := strings.Replace(num, \"*\", \"*\", -1)\n    num\
    \ := strings.Replace(num, \"*\", \"*\", -1)\n    num := strings.Replace(num, \"\
    *\", \"*\", -1)\n    num := strings.Replace(num, \"*\", \"*\", -1)\n    num :=\
    \ strings.Replace(num, \"*\", \"*\", -1)\n    num := strings.Replace\nfunc TestHex_Key(t\
    \ *testing.T) {\n  candidate := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AB\"), expected: 1 },\n     { actual: candidate(\"1077E\"), expected: 2 },\n \
    \    { actual: candidate(\"ABED1A33\"), expected: 4 },\n     { actual: candidate(\"\
    2020\"), expected: 2 },\n     { actual: candidate(\"123456789ABCDEF0\"), expected:\
    \ 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"), expected:\
    \ 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpwlx61il1_test.go:71:6: expected ''('', found TestHex_Key

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074685
- exit_code: 2
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    num\
    \ := strings.ToUpper(num)\n    n := len(num)\n    count := 0\n    i := 0\n   \
    \ for ; i < n; i++ {\n        c := num[i]\n        if c >= '0' && c <= '9' {\n\
    \            count++\n        }\n    }\n    return count\n}\n\nfunc TestHex_Key(t\
    \ *testing.T) {\n  candidate := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AB\"), expected: 1 },\n     { actual: candidate(\"1077E\"), expected: 2 },\n \
    \    { actual: candidate(\"ABED1A33\"), expected: 4 },\n     { actual: candidate(\"\
    2020\"), expected: 2 },\n     { actual: candidate(\"123456789ABCDEF0\"), expected:\
    \ 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"), expected:\
    \ 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpeu3troc9_test.go:30:9: no new variables on left side of :=

    /tmp/tmpeu3troc9_test.go:30:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074685
- exit_code: 2
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    num\
    \ := strings.ToUpper(num)\n    count := 0\n    for _, v := range num {\n     \
    \   if v == 'A' || v == 'B' || v == 'C' || v == 'D' || v == 'E' || v == 'F' {\n\
    \            continue\n        }\n        count += int(v)\n    }\n    return count\n\
    }\n\nfunc TestHex_Key(t *testing.T) {\n  candidate := hex_key\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AB\"), expected: 1 },\n     { actual: candidate(\"\
    1077E\"), expected: 2 },\n     { actual: candidate(\"ABED1A33\"), expected: 4\
    \ },\n     { actual: candidate(\"2020\"), expected: 2 },\n     { actual: candidate(\"\
    123456789ABCDEF0\"), expected: 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"\
    ), expected: 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp16c7kfeh_test.go:30:9: no new variables on left side of :=

    /tmp/tmp16c7kfeh_test.go:30:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074579
- exit_code: 2
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    n\
    \ := 0\n    for _, r := range num {\n        n += (r - 'A') * 16\n    }\n    return\
    \ n\n}\n\nfunc TestHex_Key(t *testing.T) {\n  candidate := hex_key\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"AB\"), expected: 1 },\n     { actual:\
    \ candidate(\"1077E\"), expected: 2 },\n     { actual: candidate(\"ABED1A33\"\
    ), expected: 4 },\n     { actual: candidate(\"2020\"), expected: 2 },\n     {\
    \ actual: candidate(\"123456789ABCDEF0\"), expected: 6 },\n     { actual: candidate(\"\
    112233445566778899AABBCCDDEEFF00\"), expected: 12 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpksqd9hfl_test.go:32:9: invalid operation: n += (r - ''A'') * 16 (mismatched
    types int and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074580
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    n\
    \ := len(num)\n    if n < 2 {\n        return -1\n    }\n    digits := make([]int,\
    \ n)\n    for i := 0; i < n; i++ {\n        digits[i] = int(num[i])\n    }\n \
    \   result := 0\n    for _, d := range digits {\n        if d >= 2 && d <= 9 {\n\
    \            continue\n        }\n        result += 1\n    }\n    return result\n\
    }\n\nfunc TestHex_Key(t *testing.T) {\n  candidate := hex_key\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AB\"), expected: 1 },\n     { actual: candidate(\"\
    1077E\"), expected: 2 },\n     { actual: candidate(\"ABED1A33\"), expected: 4\
    \ },\n     { actual: candidate(\"2020\"), expected: 2 },\n     { actual: candidate(\"\
    123456789ABCDEF0\"), expected: 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"\
    ), expected: 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestHex_Key (0.00s)\n    --- FAIL: TestHex_Key/test_num__0 (0.00s)\n\
    \        tmpal7803uz_test.go:66: expected '%!s(int=1)', got '%!s(int=2)'\n   \
    \ --- FAIL: TestHex_Key/test_num__1 (0.00s)\n        tmpal7803uz_test.go:66: expected\
    \ '%!s(int=2)', got '%!s(int=5)'\n    --- FAIL: TestHex_Key/test_num__2 (0.00s)\n\
    \        tmpal7803uz_test.go:66: expected '%!s(int=4)', got '%!s(int=8)'\n   \
    \ --- FAIL: TestHex_Key/test_num__3 (0.00s)\n        tmpal7803uz_test.go:66: expected\
    \ '%!s(int=2)', got '%!s(int=4)'\n    --- FAIL: TestHex_Key/test_num__4 (0.00s)\n\
    \        tmpal7803uz_test.go:66: expected '%!s(int=6)', got '%!s(int=16)'\n  \
    \  --- FAIL: TestHex_Key/test_num__5 (0.00s)\n        tmpal7803uz_test.go:66:\
    \ expected '%!s(int=12)', got '%!s(int=32)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074686
- exit_code: 2
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    num\
    \ := strings.ToUpper(num)\n    count := 0\n    for _, v := range num {\n     \
    \   if v == 'A' || v == 'B' || v == 'C' || v == 'D' || v == 'E' || v == 'F' {\n\
    \            count++\n        }\n    }\n    return count\n}\n\nfunc TestHex_Key(t\
    \ *testing.T) {\n  candidate := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AB\"), expected: 1 },\n     { actual: candidate(\"1077E\"), expected: 2 },\n \
    \    { actual: candidate(\"ABED1A33\"), expected: 4 },\n     { actual: candidate(\"\
    2020\"), expected: 2 },\n     { actual: candidate(\"123456789ABCDEF0\"), expected:\
    \ 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"), expected:\
    \ 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp88q38rvw_test.go:30:9: no new variables on left side of :=

    /tmp/tmp88q38rvw_test.go:30:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074577
- exit_code: 2
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    num\
    \ := strings.ToUpper(num)\n    count := 0\n    for _, v := range num {\n     \
    \   if v == 'A' || v == 'B' || v == 'C' || v == 'D' || v == 'E' || v == 'F' {\n\
    \            count++\n        }\n    }\n    return count\n}\n\nfunc TestHex_Key(t\
    \ *testing.T) {\n  candidate := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AB\"), expected: 1 },\n     { actual: candidate(\"1077E\"), expected: 2 },\n \
    \    { actual: candidate(\"ABED1A33\"), expected: 4 },\n     { actual: candidate(\"\
    2020\"), expected: 2 },\n     { actual: candidate(\"123456789ABCDEF0\"), expected:\
    \ 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"), expected:\
    \ 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp88q38rvw_test.go:30:9: no new variables on left side of :=

    /tmp/tmp88q38rvw_test.go:30:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074577
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    n\
    \ := 0\n    base := len(num)\n    for i := 0; i < base; i++ {\n        n += int(num[i])\
    \ - 'A' + 1\n    }\n    return n\n}\n\nfunc TestHex_Key(t *testing.T) {\n  candidate\
    \ := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AB\"), expected: 1 },\n \
    \    { actual: candidate(\"1077E\"), expected: 2 },\n     { actual: candidate(\"\
    ABED1A33\"), expected: 4 },\n     { actual: candidate(\"2020\"), expected: 2 },\n\
    \     { actual: candidate(\"123456789ABCDEF0\"), expected: 6 },\n     { actual:\
    \ candidate(\"112233445566778899AABBCCDDEEFF00\"), expected: 12 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestHex_Key (0.00s)\n    --- FAIL: TestHex_Key/test_num__0 (0.00s)\n\
    \        tmp1rz_zjq4_test.go:56: expected '%!s(int=1)', got '%!s(int=3)'\n   \
    \ --- FAIL: TestHex_Key/test_num__1 (0.00s)\n        tmp1rz_zjq4_test.go:56: expected\
    \ '%!s(int=2)', got '%!s(int=-44)'\n    --- FAIL: TestHex_Key/test_num__2 (0.00s)\n\
    \        tmp1rz_zjq4_test.go:56: expected '%!s(int=4)', got '%!s(int=-28)'\n \
    \   --- FAIL: TestHex_Key/test_num__3 (0.00s)\n        tmp1rz_zjq4_test.go:56:\
    \ expected '%!s(int=2)', got '%!s(int=-60)'\n    --- FAIL: TestHex_Key/test_num__4\
    \ (0.00s)\n        tmp1rz_zjq4_test.go:56: expected '%!s(int=6)', got '%!s(int=-94)'\n\
    \    --- FAIL: TestHex_Key/test_num__5 (0.00s)\n        tmp1rz_zjq4_test.go:56:\
    \ expected '%!s(int=12)', got '%!s(int=-188)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074686
- exit_code: 2
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    //\
    \ Your code here\n    num := strings.ToUpper(num)\n    count := 0\n    for _,\
    \ v := range num {\n        if v == 'A' || v == 'B' || v == 'C' || v == 'D' ||\
    \ v == 'E' || v == 'F' {\n            count++\n        }\n    }\n    return count\n\
    }\n\nfunc TestHex_Key(t *testing.T) {\n  candidate := hex_key\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AB\"), expected: 1 },\n     { actual: candidate(\"\
    1077E\"), expected: 2 },\n     { actual: candidate(\"ABED1A33\"), expected: 4\
    \ },\n     { actual: candidate(\"2020\"), expected: 2 },\n     { actual: candidate(\"\
    123456789ABCDEF0\"), expected: 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"\
    ), expected: 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpa80bxlmd_test.go:31:9: no new variables on left side of :=

    /tmp/tmpa80bxlmd_test.go:31:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074583
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    num\
    \ := strings.ToUpper(num)\n    num := strings.Replace(num, \"A\", \"10\", -1)\n\
    \    num := strings.Replace(num, \"B\", \"11\", -1)\n    num := strings.Replace(num,\
    \ \"C\", \"12\", -1)\n    num := strings.Replace(num, \"D\", \"13\", -1)\n   \
    \ num := strings.Replace(num, \"E\", \"14\", -1)\n    num := strings.Replace(num,\
    \ \"F\", \"15\", -1)\n    num := strings.Replace(num, \"0\", \"10\", -1)\n   \
    \ num := strings.Replace(num, \"1\", \"11\", -1)\n    num := strings.Replace(num,\
    \ \"2\", \"12\", -1)\n    num := strings.Replace(num, \"3\", \"13\", -1)\n   \
    \ num := strings.Replace(num, \"4\", \"14\", -1)\n    num := strings.Replace(num,\
    \ \"5\", \"15\", -1)\n    num := strings.Replace(num, \"6\", \"16\", -1)\n   \
    \ num := strings.Replace(num, \"7\", \"17\", -1)\n    num := strings.Replace(num,\
    \ \"8\", \"18\", -1)\n    num := strings.Replace(num, \"9\", \"19\", -1)\n   \
    \ num := strings.Replace(num, \"+\", \"-\", -1)\n    num := strings.Replace(num,\
    \ \"-\", \"+\", -1)\n    num := strings.Replace(num, \".\", \"0\", -1)\n    num\
    \ := strings.Replace(num, \"/\", \"0\", -1)\n    num := strings.Replace(num, \"\
    *\", \"0\", -1)\n    num := strings.Replace(num, \"=\", \"0\", -1)\n    num :=\
    \ strings.Replace(num, \"(\", \"0\", -1)\n    num := strings.Replace(num, \"[\"\
    , \"0\", -1)\n    num := strings.Replace(num, \"]\", \"0\", -1)\n    num := strings.Replace(num,\
    \ \"{\", \"0\", -1)\n    num := strings.Replace(num, \"}\", \"0\", -1)\n    num\
    \ := strings.Replace(num, \"!\", \"0\", -1)\n    num := strings.Replace(num, \"\
    @\", \"0\", -1)\n    num := strings.Replace(num, \"#\", \"0\", -1)\n    num :=\
    \ strings.Replace(num, \"$\", \"0\", -1)\n    num := strings.Replace(num, \"%\"\
    , \"0\", -1)\n    num := strings.Replace(num, \"^\", \"0\", -1)\n    num := strings.Replace(num,\
    \ \"&\", \"0\", -1)\n    num := strings.Replace(num, \"*\", \"0\", -1)\n    num\
    \ := strings.Replace(num, \"(\", \"0\", -1)\n    num := strings.Replace(num, \"\
    [\", \"0\", -1)\n    num := strings.Replace(num, \"]\", \"0\", -1)\n    num :=\
    \ strings.Replace(num, \"{\", \"0\", -1)\n    num \nfunc TestHex_Key(t *testing.T)\
    \ {\n  candidate := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AB\"), expected: 1 },\n     { actual: candidate(\"1077E\"), expected: 2 },\n \
    \    { actual: candidate(\"ABED1A33\"), expected: 4 },\n     { actual: candidate(\"\
    2020\"), expected: 2 },\n     { actual: candidate(\"123456789ABCDEF0\"), expected:\
    \ 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"), expected:\
    \ 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp5vj0pc6l_test.go:71:6: expected ''('', found TestHex_Key

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074686
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    //\
    \ Your code here\n    num := strings.ToUpper(num)\n    num := strings.Replace(num,\
    \ \"A\", \"1\", -1)\n    num := strings.Replace(num, \"B\", \"2\", -1)\n    num\
    \ := strings.Replace(num, \"C\", \"3\", -1)\n    num := strings.Replace(num, \"\
    D\", \"4\", -1)\n    num := strings.Replace(num, \"E\", \"5\", -1)\n    num :=\
    \ strings.Replace(num, \"F\", \"6\", -1)\n    num := strings.Replace(num, \"0\"\
    , \"7\", -1)\n    num := strings.Replace(num, \"1\", \"8\", -1)\n    num := strings.Replace(num,\
    \ \"2\", \"9\", -1)\n    num := strings.Replace(num, \"3\", \"A\", -1)\n    num\
    \ := strings.Replace(num, \"4\", \"B\", -1)\n    num := strings.Replace(num, \"\
    5\", \"C\", -1)\n    num := strings.Replace(num, \"6\", \"D\", -1)\n    num :=\
    \ strings.Replace(num, \"7\", \"E\", -1)\n    num := strings.Replace(num, \"8\"\
    , \"F\", -1)\n    num := strings.Replace(num, \"9\", \"0\", -1)\n    num := strings.Replace(num,\
    \ \"+\", \"-\", -1)\n    num := strings.Replace(num, \"/\", \"*\", -1)\n    num\
    \ := strings.Replace(num, \"=\", \"+\", -1)\n    num := strings.Replace(num, \"\
    -\", \"*\", -1)\n    num := strings.Replace(num, \"*\", \"*\", -1)\n    num :=\
    \ strings.Replace(num, \"/\", \"*\", -1)\n    num := strings.Replace(num, \"-\"\
    , \"*\", -1)\n    num := strings.Replace(num, \"+\", \"*\", -1)\n    num := strings.Replace(num,\
    \ \"*\", \"*\", -1)\n    num := strings.Replace(num, \"=\", \"+\", -1)\n    num\
    \ := strings.Replace(num, \"+\", \"*\", -1)\n    num := strings.Replace(num, \"\
    -\", \"*\", -1)\n    num := strings.Replace(num, \"*\", \"*\", -1)\n    num :=\
    \ strings.Replace(num, \"/\", \"*\", -1)\n    num := strings.Replace(num, \"-\"\
    , \"*\", -1)\n    num := strings.Replace(num, \"+\", \"*\", -1)\n    num := strings.Replace(num,\
    \ \"*\", \"*\", -1)\n    num := strings.Replace(num, \"=\", \"+\", -1)\n    num\
    \ := strings.Replace(num, \"+\", \"*\", -1)\n    num := strings.Replace(num, \"\
    -\", \"*\", -1)\n    num := strings.Replace(num, \"*\", \"*\", -1)\n    num :=\
    \ strings.Replace(num, \"/\", \"*\", -1)\n    num := strings.Replace(num, \"-\"\
    , \"*\", -1)\n\nfunc TestHex_Key(t *testing.T) {\n  candidate := hex_key\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"AB\"), expected: 1 },\n     { actual:\
    \ candidate(\"1077E\"), expected: 2 },\n     { actual: candidate(\"ABED1A33\"\
    ), expected: 4 },\n     { actual: candidate(\"2020\"), expected: 2 },\n     {\
    \ actual: candidate(\"123456789ABCDEF0\"), expected: 6 },\n     { actual: candidate(\"\
    112233445566778899AABBCCDDEEFF00\"), expected: 12 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpf0rigi0v_test.go:72:6: expected ''('', found TestHex_Key

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074686
- exit_code: 2
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    n\
    \ := len(num)\n    hexDigits := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D,\
    \ E, F}\n    primes := []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43,\
    \ 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131,\
    \ 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223,\
    \ 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311,\
    \ 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409,\
    \ 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503,\
    \ 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613,\
    \ 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719,\
    \ 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827,\
    \ 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941,\
    \ 947, 953, 967, 971, 977, 983, 991, 997}\n    \n    count := 0\n    \n    for\
    \ i := 0; i < n; i++ {\n        digit := int(num[i])\n        if digit < 0 ||\
    \ digit > 9 {\n            continue\n        }\n        \n        if digit ==\
    \ 0 {\n            continue\n        }\n        \n        if primes[digit] ==\
    \ 1 {\n            count++\n        }\n    }\n    \n    return count\n}\n\nfunc\
    \ TestHex_Key(t *testing.T) {\n  candidate := hex_key\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"AB\"), expected: 1 },\n     { actual: candidate(\"\
    1077E\"), expected: 2 },\n     { actual: candidate(\"ABED1A33\"), expected: 4\
    \ },\n     { actual: candidate(\"2020\"), expected: 2 },\n     { actual: candidate(\"\
    123456789ABCDEF0\"), expected: 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"\
    ), expected: 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxp659d0t_test.go:31:5: hexDigits declared but not used

    /tmp/tmpxp659d0t_test.go:31:54: undefined: A

    /tmp/tmpxp659d0t_test.go:31:57: undefined: B

    /tmp/tmpxp659d0t_test.go:31:60: undefined: C

    /tmp/tmpxp659d0t_test.go:31:63: undefined: D

    /tmp/tmpxp659d0t_test.go:31:66: undefined: E

    /tmp/tmpxp659d0t_test.go:31:69: undefined: F

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074686
- exit_code: 2
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    num\
    \ := strings.ToUpper(num)\n    count := 0\n    for _, v := range num {\n     \
    \   if v == 'A' || v == 'B' || v == 'C' || v == 'D' || v == 'E' || v == 'F' {\n\
    \            count++\n        }\n    }\n    return count\n}\n\nfunc TestHex_Key(t\
    \ *testing.T) {\n  candidate := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AB\"), expected: 1 },\n     { actual: candidate(\"1077E\"), expected: 2 },\n \
    \    { actual: candidate(\"ABED1A33\"), expected: 4 },\n     { actual: candidate(\"\
    2020\"), expected: 2 },\n     { actual: candidate(\"123456789ABCDEF0\"), expected:\
    \ 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"), expected:\
    \ 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp88q38rvw_test.go:30:9: no new variables on left side of :=

    /tmp/tmp88q38rvw_test.go:30:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074577
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    //\
    \ Your code here\n    \n    return 0\n}\n</code>\n<|/ a tags=go,primes |>\n<|\
    \ a tags=go,primes |>\n<code>\npackage main\n\nimport (\n    \"fmt\"\n    \"math\"\
    \n)\n\nfunc TestHex_Key(t *testing.T) {\n  candidate := hex_key\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AB\"), expected: 1 },\n     { actual: candidate(\"\
    1077E\"), expected: 2 },\n     { actual: candidate(\"ABED1A33\"), expected: 4\
    \ },\n     { actual: candidate(\"2020\"), expected: 2 },\n     { actual: candidate(\"\
    123456789ABCDEF0\"), expected: 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"\
    ), expected: 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpigmn0ku5_test.go:34:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074686
- exit_code: 2
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    num\
    \ := strings.ToUpper(num)\n    count := 0\n    for _, r := range num {\n     \
    \   if r == 'A' || r == 'B' || r == 'C' || r == 'D' || r == 'E' || r == 'F' {\n\
    \            count++\n        }\n    }\n    return count\n}\n\nfunc TestHex_Key(t\
    \ *testing.T) {\n  candidate := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AB\"), expected: 1 },\n     { actual: candidate(\"1077E\"), expected: 2 },\n \
    \    { actual: candidate(\"ABED1A33\"), expected: 4 },\n     { actual: candidate(\"\
    2020\"), expected: 2 },\n     { actual: candidate(\"123456789ABCDEF0\"), expected:\
    \ 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"), expected:\
    \ 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4qeoci93_test.go:30:9: no new variables on left side of :=

    /tmp/tmp4qeoci93_test.go:30:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074579
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    n\
    \ := len(num)\n    prime := make([]bool, len(num)+1)\n    prime[0]=true\n    prime[1]=true\n\
    \    prime[2]=true\n    prime[3]=true\n    prime[4]=true\n    prime[5]=true\n\
    \    prime[6]=true\n    prime[7]=true\n    prime[8]=true\n    prime[9]=true\n\
    \    prime[10]=true\n    prime[11]=true\n    prime[12]=true\n    prime[13]=true\n\
    \    prime[14]=true\n    prime[15]=true\n    prime[16]=true\n    prime[17]=true\n\
    \    prime[18]=true\n    prime[19]=true\n    prime[20]=true\n    prime[21]=true\n\
    \    prime[22]=true\n    prime[23]=true\n    prime[24]=true\n    prime[25]=true\n\
    \    prime[26]=true\n    prime[27]=true\n    prime[28]=true\n    prime[29]=true\n\
    \    prime[30]=true\n    prime[31]=true\n    prime[32]=true\n    prime[33]=true\n\
    \    prime[34]=true\n    prime[35]=true\n    prime[36]=true\n    prime[37]=true\n\
    \    prime[38]=true\n    prime[39]=true\n    prime[40]=true\n    prime[41]=true\n\
    \    prime[42]=true\n    prime[43]=true\n    prime[44]=true\n    prime[45]=true\n\
    \    prime[46]=true\n    prime[47]=true\n    prime[48]=true\n    prime[49]=true\n\
    \    prime[50]=true\n    prime[51]=true\n    prime[52]=true\n    prime[53]=true\n\
    \    prime[54]=true\n    prime[55]=true\n    prime[56]=true\n    prime[57]=true\n\
    \    prime[58]=true\n    prime[59]=true\n    prime[60]=true\n    prime[61]=true\n\
    \    prime[62]=true\n    prime[63]=true\n    prime[64]=true\n    prime[65]=true\n\
    \    prime[66]=true\n    prime[67]=true\n    prime[68]=true\n    prime[69]=true\n\
    \    prime[70]=true\n    prime[71]=true\n    prime[7\nfunc TestHex_Key(t *testing.T)\
    \ {\n  candidate := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AB\"), expected: 1 },\n     { actual: candidate(\"1077E\"), expected: 2 },\n \
    \    { actual: candidate(\"ABED1A33\"), expected: 4 },\n     { actual: candidate(\"\
    2020\"), expected: 2 },\n     { actual: candidate(\"123456789ABCDEF0\"), expected:\
    \ 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"), expected:\
    \ 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpbz2do6l9_test.go:104:12: expected '']'', found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074686
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    num\
    \ := strings.ToUpper(num)\n    num := strings.TrimSpace(num)\n    num := strings.Replace(num,\
    \ \"A\", \"1\", -1)\n    num := strings.Replace(num, \"B\", \"2\", -1)\n    num\
    \ := strings.Replace(num, \"C\", \"3\", -1)\n    num := strings.Replace(num, \"\
    D\", \"4\", -1)\n    num := strings.Replace(num, \"E\", \"5\", -1)\n    num :=\
    \ strings.Replace(num, \"F\", \"6\", -1)\n    num := strings.Replace(num, \"0\"\
    , \"7\", -1)\n    num := strings.Replace(num, \"1\", \"8\", -1)\n    num := strings.Replace(num,\
    \ \"2\", \"9\", -1)\n    num := strings.Replace(num, \"3\", \"A\", -1)\n    num\
    \ := strings.Replace(num, \"4\", \"B\", -1)\n    num := strings.Replace(num, \"\
    5\", \"C\", -1)\n    num := strings.Replace(num, \"6\", \"D\", -1)\n    num :=\
    \ strings.Replace(num, \"7\", \"E\", -1)\n    num := strings.Replace(num, \"8\"\
    , \"F\", -1)\n    num := strings.Replace(num, \"9\", \"A\", -1)\n    num := strings.Replace(num,\
    \ \"+\", \"A\", -1)\n    num := strings.Replace(num, \"-\", \"A\", -1)\n    num\
    \ := strings.Replace(num, \".\", \"A\", -1)\n    num := strings.Replace(num, \"\
    /\", \"A\", -1)\n    num := strings.Replace(num, \"*\", \"A\", -1)\n    num :=\
    \ strings.Replace(num, \"=\", \"A\", -1)\n    num := strings.Replace(num, \"?\"\
    , \"A\", -1)\n    num := strings.Replace(num, \"!\", \"A\", -1)\n    num := strings.Replace(num,\
    \ \"<\", \"A\", -1)\n    num := strings.Replace(num, \">\", \"A\", -1)\n    num\
    \ := strings.Replace(num, \"&\", \"A\", -1)\n    num := strings.Replace(num, \"\
    %\", \"A\", -1)\n    num := strings.Replace(num, \"(\", \"A\", -1)\n    num :=\
    \ strings.Replace(num, \"[\", \"A\", -1)\n    num := strings.Replace(num, \"]\"\
    , \"A\", -1)\n    num := strings.Replace(num, \"{\", \"A\", -1)\n    num := strings.Replace(num,\
    \ \"}\", \"A\", -1)\n    num := strings.Replace(num, \"|\", \"A\", -1)\n    num\
    \ := strings.Replace(num, \"~\", \"A\", -1)\n    num := strings.Replace(num, \"\
    `\", \"A\", -1)\n    num := strings.Replace(num, \"!\", \"A\", -1)\n    num :=\
    \ strings.Replace(num, \"@\", \"A\", -1)\n    num := strings.Replace(num, \"\n\
    func TestHex_Key(t *testing.T) {\n  candidate := hex_key\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AB\"), expected: 1 },\n     { actual: candidate(\"\
    1077E\"), expected: 2 },\n     { actual: candidate(\"ABED1A33\"), expected: 4\
    \ },\n     { actual: candidate(\"2020\"), expected: 2 },\n     { actual: candidate(\"\
    123456789ABCDEF0\"), expected: 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"\
    ), expected: 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp341vaorv_test.go:70:33: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074686
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    n\
    \ := len(num)\n    result := 0\n    \n    for i := 0; i < n; i++ {\n        digit\
    \ := int(num[i])\n        if digit > 9 {\n            digit = digit - 10\n   \
    \     }\n        \n        if digit % 2 == 0 {\n            result += 1\n    \
    \    }\n    }\n    \n    return result\n}\n\nfunc TestHex_Key(t *testing.T) {\n\
    \  candidate := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AB\"\
    ), expected: 1 },\n     { actual: candidate(\"1077E\"), expected: 2 },\n     {\
    \ actual: candidate(\"ABED1A33\"), expected: 4 },\n     { actual: candidate(\"\
    2020\"), expected: 2 },\n     { actual: candidate(\"123456789ABCDEF0\"), expected:\
    \ 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"), expected:\
    \ 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestHex_Key (0.00s)\n    --- FAIL: TestHex_Key/test_num__1 (0.00s)\n\
    \        tmpx6txkb12_test.go:65: expected '%!s(int=2)', got '%!s(int=1)'\n   \
    \ --- FAIL: TestHex_Key/test_num__2 (0.00s)\n        tmpx6txkb12_test.go:65: expected\
    \ '%!s(int=4)', got '%!s(int=2)'\n    --- FAIL: TestHex_Key/test_num__3 (0.00s)\n\
    \        tmpx6txkb12_test.go:65: expected '%!s(int=2)', got '%!s(int=4)'\n   \
    \ --- FAIL: TestHex_Key/test_num__4 (0.00s)\n        tmpx6txkb12_test.go:65: expected\
    \ '%!s(int=6)', got '%!s(int=8)'\n    --- FAIL: TestHex_Key/test_num__5 (0.00s)\n\
    \        tmpx6txkb12_test.go:65: expected '%!s(int=12)', got '%!s(int=16)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074687
- exit_code: 2
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    num\
    \ := strings.ToUpper(num)\n    count := 0\n    for _, v := range num {\n     \
    \   if v == 'A' || v == 'B' || v == 'C' || v == 'D' || v == 'E' || v == 'F' {\n\
    \            count++\n        }\n    }\n    return count\n}\n\nfunc TestHex_Key(t\
    \ *testing.T) {\n  candidate := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AB\"), expected: 1 },\n     { actual: candidate(\"1077E\"), expected: 2 },\n \
    \    { actual: candidate(\"ABED1A33\"), expected: 4 },\n     { actual: candidate(\"\
    2020\"), expected: 2 },\n     { actual: candidate(\"123456789ABCDEF0\"), expected:\
    \ 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"), expected:\
    \ 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp88q38rvw_test.go:30:9: no new variables on left side of :=

    /tmp/tmp88q38rvw_test.go:30:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074577
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    //\
    \ Your code here\n    num := strings.ToUpper(num)\n    num := strings.Replace(num,\
    \ \"A\", \"10\", -1)\n    num := strings.Replace(num, \"B\", \"11\", -1)\n   \
    \ num := strings.Replace(num, \"C\", \"12\", -1)\n    num := strings.Replace(num,\
    \ \"D\", \"13\", -1)\n    num := strings.Replace(num, \"E\", \"14\", -1)\n   \
    \ num := strings.Replace(num, \"F\", \"15\", -1)\n    num := strings.Replace(num,\
    \ \"0\", \"10\", -1)\n    num := strings.Replace(num, \"1\", \"11\", -1)\n   \
    \ num := strings.Replace(num, \"2\", \"12\", -1)\n    num := strings.Replace(num,\
    \ \"3\", \"13\", -1)\n    num := strings.Replace(num, \"4\", \"14\", -1)\n   \
    \ num := strings.Replace(num, \"5\", \"15\", -1)\n    num := strings.Replace(num,\
    \ \"6\", \"16\", -1)\n    num := strings.Replace(num, \"7\", \"17\", -1)\n   \
    \ num := strings.Replace(num, \"8\", \"18\", -1)\n    num := strings.Replace(num,\
    \ \"9\", \"19\", -1)\n    num := strings.Replace(num, \"+\", \"20\", -1)\n   \
    \ num := strings.Replace(num, \"-\", \"21\", -1)\n    num := strings.Replace(num,\
    \ \".\", \"22\", -1)\n    num := strings.Replace(num, \"/\", \"23\", -1)\n   \
    \ num := strings.Replace(num, \"=\", \"24\", -1)\n    num := strings.Replace(num,\
    \ \"?\", \"25\", -1)\n    num := strings.Replace(num, \"*\", \"26\", -1)\n   \
    \ num := strings.Replace(num, \"&\", \"27\", -1)\n    num := strings.Replace(num,\
    \ \"(\", \"28\", -1)\n    num := strings.Replace(num, \"!\", \"29\", -1)\n   \
    \ num := strings.Replace(num, \"@\", \"30\", -1)\n    num := strings.Replace(num,\
    \ \"#\", \"31\", -1)\n    num := strings.Replace(num, \"$\", \"32\", -1)\n   \
    \ num := strings.Replace(num, \"%\", \"33\", -1)\n    num := strings.Replace(num,\
    \ \"^\", \"34\", -1)\n    num := strings.Replace(num, \"&\", \"35\", -1)\n   \
    \ num := strings.Replace(num, \"*\", \"36\", -1)\n    num := strings.Replace(num,\
    \ \"(\", \"37\", -1)\n    num := strings.Replace(num, \"!\", \"38\", -1)\n   \
    \ num := strings.Replace(num, \"@\", \"39\", -1)\n    num := strings.Replace(num,\
    \ \"#\", \"40\", -1)\n    num := strings.Replace(num, \"$\", \"41\", -1)\n   \
    \ num := strings.Replace(num, \"%\nfunc TestHex_Key(t *testing.T) {\n  candidate\
    \ := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AB\"), expected: 1 },\n \
    \    { actual: candidate(\"1077E\"), expected: 2 },\n     { actual: candidate(\"\
    ABED1A33\"), expected: 4 },\n     { actual: candidate(\"2020\"), expected: 2 },\n\
    \     { actual: candidate(\"123456789ABCDEF0\"), expected: 6 },\n     { actual:\
    \ candidate(\"112233445566778899AABBCCDDEEFF00\"), expected: 12 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp47scfbzy_test.go:70:33: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074686
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    num\
    \ := strings.ToUpper(num)\n    num := strings.Replace(num, \"A\", \"10\", -1)\n\
    \    num := strings.Replace(num, \"B\", \"11\", -1)\n    num := strings.Replace(num,\
    \ \"C\", \"12\", -1)\n    num := strings.Replace(num, \"D\", \"13\", -1)\n   \
    \ num := strings.Replace(num, \"E\", \"14\", -1)\n    num := strings.Replace(num,\
    \ \"F\", \"15\", -1)\n    num := strings.Replace(num, \"0\", \"10\", -1)\n   \
    \ num := strings.Replace(num, \"1\", \"11\", -1)\n    num := strings.Replace(num,\
    \ \"2\", \"12\", -1)\n    num := strings.Replace(num, \"3\", \"13\", -1)\n   \
    \ num := strings.Replace(num, \"4\", \"14\", -1)\n    num := strings.Replace(num,\
    \ \"5\", \"15\", -1)\n    num := strings.Replace(num, \"6\", \"16\", -1)\n   \
    \ num := strings.Replace(num, \"7\", \"17\", -1)\n    num := strings.Replace(num,\
    \ \"8\", \"18\", -1)\n    num := strings.Replace(num, \"9\", \"19\", -1)\n   \
    \ num := strings.Replace(num, \"+\", \"-\", -1)\n    num := strings.Replace(num,\
    \ \"-\", \"+\", -1)\n    num := strings.Replace(num, \".\", \"0\", -1)\n    num\
    \ := strings.Replace(num, \"/\", \"0\", -1)\n    num := strings.Replace(num, \"\
    0\", \"0\", -1)\n    num := strings.Replace(num, \"1\", \"1\", -1)\n    num :=\
    \ strings.Replace(num, \"2\", \"2\", -1)\n    num := strings.Replace(num, \"3\"\
    , \"3\", -1)\n    num := strings.Replace(num, \"4\", \"4\", -1)\n    num := strings.Replace(num,\
    \ \"5\", \"5\", -1)\n    num := strings.Replace(num, \"6\", \"6\", -1)\n    num\
    \ := strings.Replace(num, \"7\", \"7\", -1)\n    num := strings.Replace(num, \"\
    8\", \"8\", -1)\n    num := strings.Replace(num, \"9\", \"9\", -1)\n    num :=\
    \ strings.Replace(num, \"*\", \"0\", -1)\n    num := strings.Replace(num, \"/\"\
    , \"0\", -1)\n    num := strings.Replace(num, \"0\", \"0\", -1)\n    num := strings.Replace(num,\
    \ \"1\", \"1\", -1)\n    num := strings.Replace(num, \"2\", \"2\", -1)\n    num\
    \ := strings.Replace(num, \"3\", \"3\", -1)\n    num := strings.Replace(num, \"\
    4\", \"4\", -1)\n    num := strings.Replace(num, \"5\", \"5\", -1)\n    num :=\
    \ strings.Replace(num, \"6\", \"6\", -1)\n    num := strings.Replace(num, \"7\"\
    , \"7\", -1)\n    num := \nfunc TestHex_Key(t *testing.T) {\n  candidate := hex_key\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"AB\"), expected: 1 },\n     {\
    \ actual: candidate(\"1077E\"), expected: 2 },\n     { actual: candidate(\"ABED1A33\"\
    ), expected: 4 },\n     { actual: candidate(\"2020\"), expected: 2 },\n     {\
    \ actual: candidate(\"123456789ABCDEF0\"), expected: 6 },\n     { actual: candidate(\"\
    112233445566778899AABBCCDDEEFF00\"), expected: 12 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpd2nw0pos_test.go:72:6: expected ''('', found TestHex_Key

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074686
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    //\
    \ Your code here\n    num := strings.ToUpper(num)\n    num := strings.Replace(num,\
    \ \"A\", \"10\", -1)\n    num := strings.Replace(num, \"B\", \"11\", -1)\n   \
    \ num := strings.Replace(num, \"C\", \"12\", -1)\n    num := strings.Replace(num,\
    \ \"D\", \"13\", -1)\n    num := strings.Replace(num, \"E\", \"14\", -1)\n   \
    \ num := strings.Replace(num, \"F\", \"15\", -1)\n    num := strings.Replace(num,\
    \ \"0\", \"10\", -1)\n    num := strings.Replace(num, \"1\", \"11\", -1)\n   \
    \ num := strings.Replace(num, \"2\", \"12\", -1)\n    num := strings.Replace(num,\
    \ \"3\", \"13\", -1)\n    num := strings.Replace(num, \"4\", \"14\", -1)\n   \
    \ num := strings.Replace(num, \"5\", \"15\", -1)\n    num := strings.Replace(num,\
    \ \"6\", \"16\", -1)\n    num := strings.Replace(num, \"7\", \"17\", -1)\n   \
    \ num := strings.Replace(num, \"8\", \"18\", -1)\n    num := strings.Replace(num,\
    \ \"9\", \"19\", -1)\n    num := strings.Replace(num, \"+\", \"-\", -1)\n    num\
    \ := strings.Replace(num, \"-\", \"+\", -1)\n    num := strings.Replace(num, \"\
    /\", \"*\", -1)\n    num := strings.Replace(num, \"*\", \"/\", -1)\n    num :=\
    \ strings.Replace(num, \"=\", \"+\", -1)\n    num := strings.Replace(num, \"(\"\
    , \"*\", -1)\n    num := strings.Replace(num, \")\", \"*\", -1)\n    num := strings.Replace(num,\
    \ \"*\", \"(\", -1)\n    num := strings.Replace(num, \"*\", \")\", -1)\n    num\
    \ := strings.Replace(num, \"*\", \"*\", -1)\n    num := strings.Replace(num, \"\
    *\", \"*\", -1)\n    num := strings.Replace(num, \"*\", \"*\", -1)\n    num :=\
    \ strings.Replace(num, \"*\", \"*\", -1)\n    num := strings.Replace(num, \"*\"\
    , \"*\", -1)\n    num := strings.Replace(num, \"*\", \"*\", -1)\n    num := strings.Replace(num,\
    \ \"*\", \"*\", -1)\n    num := strings.Replace(num, \"*\", \"*\", -1)\n    num\
    \ := strings.Replace(num, \"*\", \"*\", -1)\n    num := strings.Replace(num, \"\
    *\", \"*\", -1)\n    num := strings.Replace(num, \"*\", \"*\", -1)\n    num :=\
    \ strings.Replace(num, \"*\", \"*\", -1)\n    num := strings.Replace(num, \"*\"\
    , \"*\", -1)\n    num := strings.Replace(num, \"*\", \"*\", \nfunc TestHex_Key(t\
    \ *testing.T) {\n  candidate := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AB\"), expected: 1 },\n     { actual: candidate(\"1077E\"), expected: 2 },\n \
    \    { actual: candidate(\"ABED1A33\"), expected: 4 },\n     { actual: candidate(\"\
    2020\"), expected: 2 },\n     { actual: candidate(\"123456789ABCDEF0\"), expected:\
    \ 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"), expected:\
    \ 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp31u2e6ce_test.go:71:6: expected ''('', found TestHex_Key

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074686
- exit_code: 2
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    num\
    \ := strings.ToUpper(num)\n    n := len(num)\n    result := 0\n    for i := 0;\
    \ i < n; i++ {\n        digit := num[i]\n        if digit == \"A\" || digit ==\
    \ \"B\" || digit == \"C\" || digit == \"D\" || digit == \"E\" || digit == \"F\"\
    \ {\n            result += int(digit) - int(digit)\n        } else {\n       \
    \     result += int(digit) - int(digit) + int(digit)\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestHex_Key(t *testing.T) {\n  candidate := hex_key\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"AB\"), expected: 1 },\n     { actual:\
    \ candidate(\"1077E\"), expected: 2 },\n     { actual: candidate(\"ABED1A33\"\
    ), expected: 4 },\n     { actual: candidate(\"2020\"), expected: 2 },\n     {\
    \ actual: candidate(\"123456789ABCDEF0\"), expected: 6 },\n     { actual: candidate(\"\
    112233445566778899AABBCCDDEEFF00\"), expected: 12 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfrsj5g78_test.go:30:9: no new variables on left side of :=

    /tmp/tmpfrsj5g78_test.go:30:12: undefined: strings

    /tmp/tmpfrsj5g78_test.go:35:21: invalid operation: digit == "A" (mismatched types
    byte and untyped string)

    /tmp/tmpfrsj5g78_test.go:35:37: invalid operation: digit == "B" (mismatched types
    byte and untyped string)

    /tmp/tmpfrsj5g78_test.go:35:53: invalid operation: digit == "C" (mismatched types
    byte and untyped string)

    /tmp/tmpfrsj5g78_test.go:35:69: invalid operation: digit == "D" (mismatched types
    byte and untyped string)

    /tmp/tmpfrsj5g78_test.go:35:85: invalid operation: digit == "E" (mismatched types
    byte and untyped string)

    /tmp/tmpfrsj5g78_test.go:35:101: invalid operation: digit == "F" (mismatched types
    byte and untyped string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074687
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    n\
    \ := 0\n    i := 0\n    for ; i < len(num); i++ {\n        n += int(num[i]) -\
    \ 'A'\n    }\n    if n > 0 {\n        for ; i < len(num); i++ {\n            n\
    \ += int(num[i]) - '0'\n        }\n    }\n    return n\n}\n\nfunc TestHex_Key(t\
    \ *testing.T) {\n  candidate := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AB\"), expected: 1 },\n     { actual: candidate(\"1077E\"), expected: 2 },\n \
    \    { actual: candidate(\"ABED1A33\"), expected: 4 },\n     { actual: candidate(\"\
    2020\"), expected: 2 },\n     { actual: candidate(\"123456789ABCDEF0\"), expected:\
    \ 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"), expected:\
    \ 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestHex_Key (0.00s)\n    --- FAIL: TestHex_Key/test_num__1 (0.00s)\n\
    \        tmpb2amyker_test.go:61: expected '%!s(int=2)', got '%!s(int=-49)'\n \
    \   --- FAIL: TestHex_Key/test_num__2 (0.00s)\n        tmpb2amyker_test.go:61:\
    \ expected '%!s(int=4)', got '%!s(int=-36)'\n    --- FAIL: TestHex_Key/test_num__3\
    \ (0.00s)\n        tmpb2amyker_test.go:61: expected '%!s(int=2)', got '%!s(int=-64)'\n\
    \    --- FAIL: TestHex_Key/test_num__4 (0.00s)\n        tmpb2amyker_test.go:61:\
    \ expected '%!s(int=6)', got '%!s(int=-110)'\n    --- FAIL: TestHex_Key/test_num__5\
    \ (0.00s)\n        tmpb2amyker_test.go:61: expected '%!s(int=12)', got '%!s(int=-220)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074687
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    n\
    \ := 0\n    for _, r := range num {\n        if r == 'A' || r == 'B' || r == 'C'\
    \ || r == 'D' || r == 'E' || r == 'F' {\n            n = n + 1\n        }\n  \
    \  }\n    return n\n}\n\nfunc TestHex_Key(t *testing.T) {\n  candidate := hex_key\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"AB\"), expected: 1 },\n     {\
    \ actual: candidate(\"1077E\"), expected: 2 },\n     { actual: candidate(\"ABED1A33\"\
    ), expected: 4 },\n     { actual: candidate(\"2020\"), expected: 2 },\n     {\
    \ actual: candidate(\"123456789ABCDEF0\"), expected: 6 },\n     { actual: candidate(\"\
    112233445566778899AABBCCDDEEFF00\"), expected: 12 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestHex_Key (0.00s)\n    --- FAIL: TestHex_Key/test_num__0 (0.00s)\n\
    \        tmpo9w9bgib_test.go:57: expected '%!s(int=1)', got '%!s(int=2)'\n   \
    \ --- FAIL: TestHex_Key/test_num__1 (0.00s)\n        tmpo9w9bgib_test.go:57: expected\
    \ '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestHex_Key/test_num__2 (0.00s)\n\
    \        tmpo9w9bgib_test.go:57: expected '%!s(int=4)', got '%!s(int=5)'\n   \
    \ --- FAIL: TestHex_Key/test_num__3 (0.00s)\n        tmpo9w9bgib_test.go:57: expected\
    \ '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074579
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    num\
    \ := strings.ToUpper(num)\n    num := strings.Replace(num, \"A\", \"1\", -1)\n\
    \    num := strings.Replace(num, \"B\", \"2\", -1)\n    num := strings.Replace(num,\
    \ \"C\", \"3\", -1)\n    num := strings.Replace(num, \"D\", \"4\", -1)\n    num\
    \ := strings.Replace(num, \"E\", \"5\", -1)\n    num := strings.Replace(num, \"\
    F\", \"6\", -1)\n    num := strings.Replace(num, \"0\", \"7\", -1)\n    num :=\
    \ strings.Replace(num, \"1\", \"8\", -1)\n    num := strings.Replace(num, \"2\"\
    , \"9\", -1)\n    num := strings.Replace(num, \"3\", \"A\", -1)\n    num := strings.Replace(num,\
    \ \"4\", \"B\", -1)\n    num := strings.Replace(num, \"5\", \"C\", -1)\n    num\
    \ := strings.Replace(num, \"6\", \"D\", -1)\n    num := strings.Replace(num, \"\
    7\", \"E\", -1)\n    num := strings.Replace(num, \"8\", \"F\", -1)\n    num :=\
    \ strings.Replace(num, \"9\", \"0\", -1)\n    num := strings.Replace(num, \"+\"\
    , \"-\", -1)\n    num := strings.Replace(num, \"/\", \"*\", -1)\n    num := strings.Replace(num,\
    \ \"=\", \"*\", -1)\n    num := strings.Replace(num, \"*\", \"*\", -1)\n    num\
    \ := strings.Replace(num, \"-\", \"+\", -1)\n    num := strings.Replace(num, \"\
    (\", \"\", -1)\n    num := strings.Replace(num, \")\", \"\", -1)\n    num := strings.Replace(num,\
    \ \"*\", \"*\", -1)\n    num := strings.Replace(num, \"+\", \"-\", -1)\n    num\
    \ := strings.Replace(num, \"-\", \"+\", -1)\n    num := strings.Replace(num, \"\
    /\", \"*\", -1)\n    num := strings.Replace(num, \"=\", \"*\", -1)\n    num :=\
    \ strings.Replace(num, \"*\", \"*\", -1)\n    num := strings.Replace(num, \"(\"\
    , \"\", -1)\n    num := strings.Replace(num, \")\", \"\", -1)\n    num := strings.Replace(num,\
    \ \"*\", \"*\", -1)\n    num := strings.Replace(num, \"+\", \"-\", -1)\n    num\
    \ := strings.Replace(num, \"-\", \"+\", -1)\n    num := strings.Replace(num, \"\
    /\", \"*\", -1)\n    num := strings.Replace(num, \"=\", \"*\", -1)\n    num :=\
    \ strings.Replace(num, \"*\", \"*\", -1)\n    num := strings.Replace(num, \"(\"\
    , \"\", -1)\n    num := strings.Replace(num, \")\", \"\", -1)\n    num := strings.Replace(num,\
    \ \"*\", \"*\", -1)\n\nfunc TestHex_Key(t *testing.T) {\n  candidate := hex_key\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"AB\"), expected: 1 },\n     {\
    \ actual: candidate(\"1077E\"), expected: 2 },\n     { actual: candidate(\"ABED1A33\"\
    ), expected: 4 },\n     { actual: candidate(\"2020\"), expected: 2 },\n     {\
    \ actual: candidate(\"123456789ABCDEF0\"), expected: 6 },\n     { actual: candidate(\"\
    112233445566778899AABBCCDDEEFF00\"), expected: 12 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpufh2rkx8_test.go:72:6: expected ''('', found TestHex_Key

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074686
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    n\
    \ := 0\n    for _, r := range num {\n        n += int(rune(r) - '0')\n    }\n\
    \    return n\n}\n\nfunc TestHex_Key(t *testing.T) {\n  candidate := hex_key\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"AB\"), expected: 1 },\n     {\
    \ actual: candidate(\"1077E\"), expected: 2 },\n     { actual: candidate(\"ABED1A33\"\
    ), expected: 4 },\n     { actual: candidate(\"2020\"), expected: 2 },\n     {\
    \ actual: candidate(\"123456789ABCDEF0\"), expected: 6 },\n     { actual: candidate(\"\
    112233445566778899AABBCCDDEEFF00\"), expected: 12 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestHex_Key (0.00s)\n    --- FAIL: TestHex_Key/test_num__0 (0.00s)\n\
    \        tmpsucyn_gd_test.go:55: expected '%!s(int=1)', got '%!s(int=35)'\n  \
    \  --- FAIL: TestHex_Key/test_num__1 (0.00s)\n        tmpsucyn_gd_test.go:55:\
    \ expected '%!s(int=2)', got '%!s(int=36)'\n    --- FAIL: TestHex_Key/test_num__2\
    \ (0.00s)\n        tmpsucyn_gd_test.go:55: expected '%!s(int=4)', got '%!s(int=100)'\n\
    \    --- FAIL: TestHex_Key/test_num__3 (0.00s)\n        tmpsucyn_gd_test.go:55:\
    \ expected '%!s(int=2)', got '%!s(int=4)'\n    --- FAIL: TestHex_Key/test_num__4\
    \ (0.00s)\n        tmpsucyn_gd_test.go:55: expected '%!s(int=6)', got '%!s(int=162)'\n\
    \    --- FAIL: TestHex_Key/test_num__5 (0.00s)\n        tmpsucyn_gd_test.go:55:\
    \ expected '%!s(int=12)', got '%!s(int=324)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074582
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    //\
    \ Your code here\n    num := strings.ToUpper(num)\n    num := strings.Replace(num,\
    \ \"A\", \"10\", -1)\n    num := strings.Replace(num, \"B\", \"11\", -1)\n   \
    \ num := strings.Replace(num, \"C\", \"12\", -1)\n    num := strings.Replace(num,\
    \ \"D\", \"13\", -1)\n    num := strings.Replace(num, \"E\", \"14\", -1)\n   \
    \ num := strings.Replace(num, \"F\", \"15\", -1)\n    num := strings.Replace(num,\
    \ \"0\", \"1\", -1)\n    num := strings.Replace(num, \"1\", \"2\", -1)\n    num\
    \ := strings.Replace(num, \"2\", \"3\", -1)\n    num := strings.Replace(num, \"\
    3\", \"4\", -1)\n    num := strings.Replace(num, \"4\", \"5\", -1)\n    num :=\
    \ strings.Replace(num, \"5\", \"6\", -1)\n    num := strings.Replace(num, \"6\"\
    , \"7\", -1)\n    num := strings.Replace(num, \"7\", \"8\", -1)\n    num := strings.Replace(num,\
    \ \"8\", \"9\", -1)\n    num := strings.Replace(num, \"9\", \"10\", -1)\n    num\
    \ := strings.Replace(num, \"10\", \"11\", -1)\n    num := strings.Replace(num,\
    \ \"11\", \"12\", -1)\n    num := strings.Replace(num, \"12\", \"13\", -1)\n \
    \   num := strings.Replace(num, \"13\", \"14\", -1)\n    num := strings.Replace(num,\
    \ \"14\", \"15\", -1)\n    num := strings.Replace(num, \"15\", \"16\", -1)\n \
    \   num := strings.Replace(num, \"16\", \"17\", -1)\n    num := strings.Replace(num,\
    \ \"17\", \"18\", -1)\n    num := strings.Replace(num, \"18\", \"19\", -1)\n \
    \   num := strings.Replace(num, \"19\", \"20\", -1)\n    num := strings.Replace(num,\
    \ \"20\", \"21\", -1)\n    num := strings.Replace(num, \"21\", \"22\", -1)\n \
    \   num := strings.Replace(num, \"22\", \"23\", -1)\n    num := strings.Replace(num,\
    \ \"23\", \"24\", -1)\n    num := strings.Replace(num, \"24\", \"25\", -1)\n \
    \   num := strings.Replace(num, \"25\", \"26\", -1)\n    num := strings.Replace(num,\
    \ \"26\", \"27\", -1)\n    num := strings.Replace(num, \"27\", \"28\", -1)\n \
    \   num := strings.Replace(num, \"28\", \"29\", -1)\n    num := strings.Replace(num,\
    \ \"29\", \"30\", -1)\n    num := strings.Replace(num, \"30\", \"31\", -1)\n \
    \   num := strings.Replace(num, \"31\", \"32\", -1)\n    num := strings.Replace(num,\
    \ \"32\", \"33\", -1)\nfunc TestHex_Key(t *testing.T) {\n  candidate := hex_key\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"AB\"), expected: 1 },\n     {\
    \ actual: candidate(\"1077E\"), expected: 2 },\n     { actual: candidate(\"ABED1A33\"\
    ), expected: 4 },\n     { actual: candidate(\"2020\"), expected: 2 },\n     {\
    \ actual: candidate(\"123456789ABCDEF0\"), expected: 6 },\n     { actual: candidate(\"\
    112233445566778899AABBCCDDEEFF00\"), expected: 12 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp12hppnjr_test.go:71:6: expected ''('', found TestHex_Key

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074587
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    num\
    \ := strings.ToUpper(num)\n    num := strings.Replace(num, \"A\", \"10\", -1)\n\
    \    num := strings.Replace(num, \"B\", \"11\", -1)\n    num := strings.Replace(num,\
    \ \"C\", \"12\", -1)\n    num := strings.Replace(num, \"D\", \"13\", -1)\n   \
    \ num := strings.Replace(num, \"E\", \"14\", -1)\n    num := strings.Replace(num,\
    \ \"F\", \"15\", -1)\n    num := strings.Replace(num, \"0\", \"10\", -1)\n   \
    \ num := strings.Replace(num, \"1\", \"11\", -1)\n    num := strings.Replace(num,\
    \ \"2\", \"12\", -1)\n    num := strings.Replace(num, \"3\", \"13\", -1)\n   \
    \ num := strings.Replace(num, \"4\", \"14\", -1)\n    num := strings.Replace(num,\
    \ \"5\", \"15\", -1)\n    num := strings.Replace(num, \"6\", \"16\", -1)\n   \
    \ num := strings.Replace(num, \"7\", \"17\", -1)\n    num := strings.Replace(num,\
    \ \"8\", \"18\", -1)\n    num := strings.Replace(num, \"9\", \"19\", -1)\n   \
    \ num := strings.Replace(num, \"+\", \"-\", -1)\n    num := strings.Replace(num,\
    \ \"-\", \"+\", -1)\n    num := strings.Replace(num, \"/\", \"*\", -1)\n    num\
    \ := strings.Replace(num, \"*\", \"/\", -1)\n    num := strings.Replace(num, \"\
    =\", \"*\", -1)\n    num := strings.Replace(num, \"(\", \"*\", -1)\n    num :=\
    \ strings.Replace(num, \"[\", \"*\", -1)\n    num := strings.Replace(num, \"]\"\
    , \"*\", -1)\n    num := strings.Replace(num, \"{\", \"*\", -1)\n    num := strings.Replace(num,\
    \ \"}\", \"*\", -1)\n    num := strings.Replace(num, \"<\", \"*\", -1)\n    num\
    \ := strings.Replace(num, \">\", \"*\", -1)\n    num := strings.Replace(num, \"\
    !\", \"*\", -1)\n    num := strings.Replace(num, \"~\", \"*\", -1)\n    num :=\
    \ strings.Replace(num, \"@\", \"*\", -1)\n    num := strings.Replace(num, \"#\"\
    , \"*\", -1)\n    num := strings.Replace(num, \"$\", \"*\", -1)\n    num := strings.Replace(num,\
    \ \"%\", \"*\", -1)\n    num := strings.Replace(num, \"^\", \"*\", -1)\n    num\
    \ := strings.Replace(num, \"&\", \"*\", -1)\n    num := strings.Replace(num, \"\
    *\", \"+\", -1)\n    num := strings.Replace(num, \"+\", \"+\", -1)\n    num :=\
    \ strings.Replace(num, \"-\", \"+\", -1)\n    num \nfunc TestHex_Key(t *testing.T)\
    \ {\n  candidate := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AB\"), expected: 1 },\n     { actual: candidate(\"1077E\"), expected: 2 },\n \
    \    { actual: candidate(\"ABED1A33\"), expected: 4 },\n     { actual: candidate(\"\
    2020\"), expected: 2 },\n     { actual: candidate(\"123456789ABCDEF0\"), expected:\
    \ 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"), expected:\
    \ 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpt8new0hz_test.go:71:6: expected ''('', found TestHex_Key

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074686
- exit_code: 2
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    n\
    \ := 0\n    for _, r := range num {\n        n += (r - 'A') * 16\n    }\n    return\
    \ n\n}\n\nfunc TestHex_Key(t *testing.T) {\n  candidate := hex_key\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"AB\"), expected: 1 },\n     { actual:\
    \ candidate(\"1077E\"), expected: 2 },\n     { actual: candidate(\"ABED1A33\"\
    ), expected: 4 },\n     { actual: candidate(\"2020\"), expected: 2 },\n     {\
    \ actual: candidate(\"123456789ABCDEF0\"), expected: 6 },\n     { actual: candidate(\"\
    112233445566778899AABBCCDDEEFF00\"), expected: 12 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpksqd9hfl_test.go:32:9: invalid operation: n += (r - ''A'') * 16 (mismatched
    types int and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074580
- exit_code: 2
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    //\
    \ Your code here\n    num := strings.ToUpper(num)\n    count := 0\n    for _,\
    \ v := range num {\n        if v == 'A' || v == 'B' || v == 'C' || v == 'D' ||\
    \ v == 'E' || v == 'F' {\n            continue\n        }\n        count += int(v)\n\
    \    }\n    return count\n}\n\nfunc TestHex_Key(t *testing.T) {\n  candidate :=\
    \ hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AB\"), expected: 1 },\n \
    \    { actual: candidate(\"1077E\"), expected: 2 },\n     { actual: candidate(\"\
    ABED1A33\"), expected: 4 },\n     { actual: candidate(\"2020\"), expected: 2 },\n\
    \     { actual: candidate(\"123456789ABCDEF0\"), expected: 6 },\n     { actual:\
    \ candidate(\"112233445566778899AABBCCDDEEFF00\"), expected: 12 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpsq_vlkv2_test.go:31:9: no new variables on left side of :=

    /tmp/tmpsq_vlkv2_test.go:31:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074687
- exit_code: 2
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    num\
    \ := strings.ToUpper(num)\n    count := 0\n    for _, v := range num {\n     \
    \   if v == 'A' || v == 'B' || v == 'C' || v == 'D' || v == 'E' || v == 'F' {\n\
    \            continue\n        }\n        count += int(v)\n    }\n    return count\n\
    }\n\nfunc TestHex_Key(t *testing.T) {\n  candidate := hex_key\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AB\"), expected: 1 },\n     { actual: candidate(\"\
    1077E\"), expected: 2 },\n     { actual: candidate(\"ABED1A33\"), expected: 4\
    \ },\n     { actual: candidate(\"2020\"), expected: 2 },\n     { actual: candidate(\"\
    123456789ABCDEF0\"), expected: 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"\
    ), expected: 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp16c7kfeh_test.go:30:9: no new variables on left side of :=

    /tmp/tmp16c7kfeh_test.go:30:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074579
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    n\
    \ := len(num)\n    prime := make([]int, n)\n    prime[0] = 2\n    prime[1] = 3\n\
    \    prime[2] = 5\n    prime[3] = 7\n    prime[4] = 11\n    prime[5] = 13\n  \
    \  prime[6] = 17\n    prime[7] = 19\n    prime[8] = 23\n    prime[9] = 29\n  \
    \  prime[10] = 31\n    prime[11] = 37\n    prime[12] = 41\n    prime[13] = 43\n\
    \    prime[14] = 47\n    prime[15] = 53\n    prime[16] = 59\n    prime[17] = 61\n\
    \    prime[18] = 67\n    prime[19] = 71\n    prime[20] = 73\n    prime[21] = 79\n\
    \    prime[22] = 83\n    prime[23] = 89\n    prime[24] = 97\n    prime[25] = 101\n\
    \    prime[26] = 103\n    prime[27] = 107\n    prime[28] = 109\n    prime[29]\
    \ = 113\n    prime[30] = 116\n    prime[31] = 120\n    prime[32] = 124\n    prime[33]\
    \ = 127\n    prime[34] = 130\n    prime[35] = 133\n    prime[36] = 137\n    prime[37]\
    \ = 139\n    prime[38] = 142\n    prime[39] = 145\n    prime[40] = 147\n    prime[41]\
    \ = 149\n    prime[42] = 151\n    prime[43] = 154\n    prime[44] = 157\n    prime[45]\
    \ = 159\n    prime[46] = 162\n    prime[47] = 165\n    prime[48] = 168\n    prime[49]\
    \ = 171\n    prime[50] = 173\n    prime[51] = 177\n    prime[52] = 179\n    prime[53]\
    \ = 181\n    prime[54] = 183\n    prime[55] = 186\n    prime[56] = 189\n    prime[57]\
    \ = 191\n    prime[58] = 194\n    prime[59] = 197\n    prime[60] = 200\n    prime[61]\
    \ = 202\n    prime[62] = 205\n    prime[63] = 208\n    prime[64] = 211\n    prime[65]\
    \ = 213\n    prime[66] = 216\n    prime[67] = 219\n    prime[68] = 222\n    prime[69]\
    \ = 225\n    prime[70] = 228\n    prime[71] = 231\n    prime[72] = 233\nfunc TestHex_Key(t\
    \ *testing.T) {\n  candidate := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AB\"), expected: 1 },\n     { actual: candidate(\"1077E\"), expected: 2 },\n \
    \    { actual: candidate(\"ABED1A33\"), expected: 4 },\n     { actual: candidate(\"\
    2020\"), expected: 2 },\n     { actual: candidate(\"123456789ABCDEF0\"), expected:\
    \ 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"), expected:\
    \ 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpdqrugjor_test.go:105:6: expected ''('', found TestHex_Key

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074687
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    var\
    \ count int = 0\n    for _, c := range num {\n        if c >= '0' && c <= '9'\
    \ {\n            count++\n        }\n    }\n    return count\n}\n\nfunc TestHex_Key(t\
    \ *testing.T) {\n  candidate := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AB\"), expected: 1 },\n     { actual: candidate(\"1077E\"), expected: 2 },\n \
    \    { actual: candidate(\"ABED1A33\"), expected: 4 },\n     { actual: candidate(\"\
    2020\"), expected: 2 },\n     { actual: candidate(\"123456789ABCDEF0\"), expected:\
    \ 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"), expected:\
    \ 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestHex_Key (0.00s)\n    --- FAIL: TestHex_Key/test_num__0 (0.00s)\n\
    \        tmpk61m3u86_test.go:57: expected '%!s(int=1)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestHex_Key/test_num__1 (0.00s)\n        tmpk61m3u86_test.go:57: expected\
    \ '%!s(int=2)', got '%!s(int=4)'\n    --- FAIL: TestHex_Key/test_num__2 (0.00s)\n\
    \        tmpk61m3u86_test.go:57: expected '%!s(int=4)', got '%!s(int=3)'\n   \
    \ --- FAIL: TestHex_Key/test_num__3 (0.00s)\n        tmpk61m3u86_test.go:57: expected\
    \ '%!s(int=2)', got '%!s(int=4)'\n    --- FAIL: TestHex_Key/test_num__4 (0.00s)\n\
    \        tmpk61m3u86_test.go:57: expected '%!s(int=6)', got '%!s(int=10)'\n  \
    \  --- FAIL: TestHex_Key/test_num__5 (0.00s)\n        tmpk61m3u86_test.go:57:\
    \ expected '%!s(int=12)', got '%!s(int=20)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074583
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    num\
    \ := strings.ToUpper(num)\n    num := strings.Replace(num, \"A\", \"10\", -1)\n\
    \    num := strings.Replace(num, \"B\", \"11\", -1)\n    num := strings.Replace(num,\
    \ \"C\", \"12\", -1)\n    num := strings.Replace(num, \"D\", \"13\", -1)\n   \
    \ num := strings.Replace(num, \"E\", \"14\", -1)\n    num := strings.Replace(num,\
    \ \"F\", \"15\", -1)\n    num := strings.Replace(num, \"0\", \"10\", -1)\n   \
    \ num := strings.Replace(num, \"1\", \"11\", -1)\n    num := strings.Replace(num,\
    \ \"2\", \"12\", -1)\n    num := strings.Replace(num, \"3\", \"13\", -1)\n   \
    \ num := strings.Replace(num, \"4\", \"14\", -1)\n    num := strings.Replace(num,\
    \ \"5\", \"15\", -1)\n    num := strings.Replace(num, \"6\", \"16\", -1)\n   \
    \ num := strings.Replace(num, \"7\", \"17\", -1)\n    num := strings.Replace(num,\
    \ \"8\", \"18\", -1)\n    num := strings.Replace(num, \"9\", \"19\", -1)\n   \
    \ num := strings.Replace(num, \"+\", \"-\", -1)\n    num := strings.Replace(num,\
    \ \"-\", \"+\", -1)\n    num := strings.Replace(num, \".\", \"0\", -1)\n    num\
    \ := strings.Replace(num, \"/\", \"0\", -1)\n    num := strings.Replace(num, \"\
    0\", \"0\", -1)\n    num := strings.Replace(num, \"1\", \"1\", -1)\n    num :=\
    \ strings.Replace(num, \"2\", \"2\", -1)\n    num := strings.Replace(num, \"3\"\
    , \"3\", -1)\n    num := strings.Replace(num, \"4\", \"4\", -1)\n    num := strings.Replace(num,\
    \ \"5\", \"5\", -1)\n    num := strings.Replace(num, \"6\", \"6\", -1)\n    num\
    \ := strings.Replace(num, \"7\", \"7\", -1)\n    num := strings.Replace(num, \"\
    8\", \"8\", -1)\n    num := strings.Replace(num, \"9\", \"9\", -1)\n    num :=\
    \ strings.Replace(num, \"*\", \"0\", -1)\n    num := strings.Replace(num, \"/\"\
    , \"0\", -1)\n    num := strings.Replace(num, \"0\", \"0\", -1)\n    num := strings.Replace(num,\
    \ \"1\", \"1\", -1)\n    num := strings.Replace(num, \"2\", \"2\", -1)\n    num\
    \ := strings.Replace(num, \"3\", \"3\", -1)\n    num := strings.Replace(num, \"\
    4\", \"4\", -1)\n    num := strings.Replace(num, \"5\", \"5\", -1)\n    num :=\
    \ strings.Replace(num, \"6\", \"6\", -1)\n    num := strings.Replace(num, \"7\"\
    , \"7\", -1)\n    num := \nfunc TestHex_Key(t *testing.T) {\n  candidate := hex_key\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"AB\"), expected: 1 },\n     {\
    \ actual: candidate(\"1077E\"), expected: 2 },\n     { actual: candidate(\"ABED1A33\"\
    ), expected: 4 },\n     { actual: candidate(\"2020\"), expected: 2 },\n     {\
    \ actual: candidate(\"123456789ABCDEF0\"), expected: 6 },\n     { actual: candidate(\"\
    112233445566778899AABBCCDDEEFF00\"), expected: 12 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpd2nw0pos_test.go:72:6: expected ''('', found TestHex_Key

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074686
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    var\
    \ count int = 0\n    for _, v := range num {\n        count += int(v)\n    }\n\
    \    return count\n}\n\nfunc TestHex_Key(t *testing.T) {\n  candidate := hex_key\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"AB\"), expected: 1 },\n     {\
    \ actual: candidate(\"1077E\"), expected: 2 },\n     { actual: candidate(\"ABED1A33\"\
    ), expected: 4 },\n     { actual: candidate(\"2020\"), expected: 2 },\n     {\
    \ actual: candidate(\"123456789ABCDEF0\"), expected: 6 },\n     { actual: candidate(\"\
    112233445566778899AABBCCDDEEFF00\"), expected: 12 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestHex_Key (0.00s)\n    --- FAIL: TestHex_Key/test_num__0 (0.00s)\n\
    \        tmpq03z4tna_test.go:55: expected '%!s(int=1)', got '%!s(int=131)'\n \
    \   --- FAIL: TestHex_Key/test_num__1 (0.00s)\n        tmpq03z4tna_test.go:55:\
    \ expected '%!s(int=2)', got '%!s(int=276)'\n    --- FAIL: TestHex_Key/test_num__2\
    \ (0.00s)\n        tmpq03z4tna_test.go:55: expected '%!s(int=4)', got '%!s(int=484)'\n\
    \    --- FAIL: TestHex_Key/test_num__3 (0.00s)\n        tmpq03z4tna_test.go:55:\
    \ expected '%!s(int=2)', got '%!s(int=196)'\n    --- FAIL: TestHex_Key/test_num__4\
    \ (0.00s)\n        tmpq03z4tna_test.go:55: expected '%!s(int=6)', got '%!s(int=930)'\n\
    \    --- FAIL: TestHex_Key/test_num__5 (0.00s)\n        tmpq03z4tna_test.go:55:\
    \ expected '%!s(int=12)', got '%!s(int=1860)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074589
- exit_code: 2
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    num\
    \ := strings.ToUpper(num)\n    n := len(num)\n    prime := make([]int, n)\n  \
    \  for i := 0; i < n; i++ {\n        prime[i] = 0\n    }\n    for i := 0; i <\
    \ n; i++ {\n        prime[i] = 1\n    }\n    for i := 1; i < n; i++ {\n      \
    \  for j := 1; j < i; j++ {\n            if num[i]%j == 0 {\n                prime[i]\
    \ = 0\n                break\n            }\n        }\n    }\n    return prime[n-1]\n\
    }\n\nfunc TestHex_Key(t *testing.T) {\n  candidate := hex_key\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AB\"), expected: 1 },\n     { actual: candidate(\"\
    1077E\"), expected: 2 },\n     { actual: candidate(\"ABED1A33\"), expected: 4\
    \ },\n     { actual: candidate(\"2020\"), expected: 2 },\n     { actual: candidate(\"\
    123456789ABCDEF0\"), expected: 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"\
    ), expected: 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqqsx01tv_test.go:30:9: no new variables on left side of :=

    /tmp/tmpqqsx01tv_test.go:30:12: undefined: strings

    /tmp/tmpqqsx01tv_test.go:41:16: invalid operation: num[i] % j (mismatched types
    byte and int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074687
- exit_code: 2
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    n\
    \ := 0\n    base := 0\n    for _, c := range num {\n        base += int(c)\n \
    \   }\n    for i := 2; i < base; i++ {\n        if isprime(i) {\n            n\
    \ += i\n        }\n    }\n    return n\n}\n\nfunc TestHex_Key(t *testing.T) {\n\
    \  candidate := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AB\"\
    ), expected: 1 },\n     { actual: candidate(\"1077E\"), expected: 2 },\n     {\
    \ actual: candidate(\"ABED1A33\"), expected: 4 },\n     { actual: candidate(\"\
    2020\"), expected: 2 },\n     { actual: candidate(\"123456789ABCDEF0\"), expected:\
    \ 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"), expected:\
    \ 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpq20v07e3_test.go:36:12: undefined: isprime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074687
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    num\
    \ := strings.ToUpper(num)\n    num := strings.TrimSpace(num)\n    num := strings.Replace(num,\
    \ \"A\", \"0\", 1)\n    num := strings.Replace(num, \"B\", \"1\", 1)\n    num\
    \ := strings.Replace(num, \"C\", \"2\", 1)\n    num := strings.Replace(num, \"\
    D\", \"3\", 1)\n    num := strings.Replace(num, \"E\", \"4\", 1)\n    num := strings.Replace(num,\
    \ \"F\", \"5\", 1)\n    num := strings.Replace(num, \"0\", \"A\", 1)\n    num\
    \ := strings.Replace(num, \"1\", \"B\", 1)\n    num := strings.Replace(num, \"\
    2\", \"C\", 1)\n    num := strings.Replace(num, \"3\", \"D\", 1)\n    num := strings.Replace(num,\
    \ \"4\", \"E\", 1)\n    num := strings.Replace(num, \"5\", \"F\", 1)\n    num\
    \ := strings.Replace(num, \"6\", \"0\", 1)\n    num := strings.Replace(num, \"\
    7\", \"1\", 1)\n    num := strings.Replace(num, \"8\", \"2\", 1)\n    num := strings.Replace(num,\
    \ \"9\", \"3\", 1)\n    num := strings.Replace(num, \"+\", \"-\", 1)\n    num\
    \ := strings.Replace(num, \"/\", \"*\", 1)\n    num := strings.Replace(num, \"\
    *\", \"+\", 1)\n    num := strings.Replace(num, \"-\", \"+\", 1)\n    num := strings.Replace(num,\
    \ \".\", \"*\", 1)\n    num := strings.Replace(num, \"*\", \".\", 1)\n    num\
    \ := strings.Replace(num, \"*\", \"*\", 1)\n    num := strings.Replace(num, \"\
    *\", \"*\", 1)\n    num := strings.Replace(num, \"*\", \"*\", 1)\n    num := strings.Replace(num,\
    \ \"*\", \"*\", 1)\n    num := strings.Replace(num, \"*\", \"*\", 1)\n    num\
    \ := strings.Replace(num, \"*\", \"*\", 1)\n    num := strings.Replace(num, \"\
    *\", \"*\", 1)\n    num := strings.Replace(num, \"*\", \"*\", 1)\n    num := strings.Replace(num,\
    \ \"*\", \"*\", 1)\n    num := strings.Replace(num, \"*\", \"*\", 1)\n    num\
    \ := strings.Replace(num, \"*\", \"*\", 1)\n    num := strings.Replace(num, \"\
    *\", \"*\", 1)\n    num := strings.Replace(num, \"*\", \"*\", 1)\n    num := strings.Replace(num,\
    \ \"*\", \"*\", 1)\n    num := strings.Replace(num, \"*\", \"*\", 1)\n    num\
    \ := strings.Replace(num, \"*\", \"*\", 1)\n    num := strings.Replace(num, \"\
    *\", \"*\", 1)\n    num := strings.Replace(num, \"*\", \"*\", 1)\n    num := strings.Replace(num,\
    \ \"*\", \"*\", 1)\n    num := strings.Replace(num, \"*\nfunc TestHex_Key(t *testing.T)\
    \ {\n  candidate := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AB\"), expected: 1 },\n     { actual: candidate(\"1077E\"), expected: 2 },\n \
    \    { actual: candidate(\"ABED1A33\"), expected: 4 },\n     { actual: candidate(\"\
    2020\"), expected: 2 },\n     { actual: candidate(\"123456789ABCDEF0\"), expected:\
    \ 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"), expected:\
    \ 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpca7owh6i_test.go:73:33: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074687
- exit_code: 2
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    num\
    \ := strings.ToUpper(num)\n    \n    count := 0\n    \n    for _, digit := range\
    \ num {\n        if digit == 'A' || digit == 'B' || digit == 'C' || digit == 'D'\
    \ || digit == 'E' || digit == 'F' {\n            count++\n        }\n    }\n \
    \   \n    return count\n}\n\nfunc TestHex_Key(t *testing.T) {\n  candidate :=\
    \ hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AB\"), expected: 1 },\n \
    \    { actual: candidate(\"1077E\"), expected: 2 },\n     { actual: candidate(\"\
    ABED1A33\"), expected: 4 },\n     { actual: candidate(\"2020\"), expected: 2 },\n\
    \     { actual: candidate(\"123456789ABCDEF0\"), expected: 6 },\n     { actual:\
    \ candidate(\"112233445566778899AABBCCDDEEFF00\"), expected: 12 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpytnwfv4y_test.go:30:9: no new variables on left side of :=

    /tmp/tmpytnwfv4y_test.go:30:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074688
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    n\
    \ := len(num)\n    prime := make([]bool, len(num)+1)\n    prime[0] = true\n  \
    \  prime[1] = true\n    prime[2] = true\n    prime[3] = true\n    prime[4] = true\n\
    \    prime[5] = true\n    prime[6] = true\n    prime[7] = true\n    prime[8] =\
    \ true\n    prime[9] = true\n    prime[10] = true\n    prime[11] = true\n    prime[12]\
    \ = true\n    prime[13] = true\n    prime[14] = true\n    prime[15] = true\n \
    \   prime[16] = true\n    prime[17] = true\n    prime[18] = true\n    prime[19]\
    \ = true\n    prime[20] = true\n    prime[21] = true\n    prime[22] = true\n \
    \   prime[23] = true\n    prime[24] = true\n    prime[25] = true\n    prime[26]\
    \ = true\n    prime[27] = true\n    prime[28] = true\n    prime[29] = true\n \
    \   prime[30] = true\n    prime[31] = true\n    prime[32] = true\n    prime[33]\
    \ = true\n    prime[34] = true\n    prime[35] = true\n    prime[36] = true\n \
    \   prime[37] = true\n    prime[38] = true\n    prime[39] = true\n    prime[40]\
    \ = true\n    prime[41] = true\n    prime[42] = true\n    prime[43] = true\n \
    \   prime[44] = true\n    prime[45] = true\n    prime[46] = true\n    prime[47]\
    \ = true\n    prime[48] = true\n    prime[49] = true\n    prime[50] = true\n \
    \   prime[51] = true\n    prime[52] = true\n    prime[53] = true\n    prime[54]\
    \ = true\n    prime[55] = true\n    prime[56] = true\n    prime[57] = true\n \
    \   prime[58] = true\n    prime[59] = true\n    prime[60] = true\n    prime[61]\
    \ = true\n    prime[62] = true\n    prime[63] = true\n    prime[64] = true\n \
    \   prime[65] = true\n    prime[66] = true\n    prime[67] = true\n    prime[68]\
    \ = true\n    prime[69] = true\n    prime[70] = true\n    prime[71] = true\n \
    \   prime[72] = true\n    prime[73] = true\n    prime[74\nfunc TestHex_Key(t *testing.T)\
    \ {\n  candidate := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AB\"), expected: 1 },\n     { actual: candidate(\"1077E\"), expected: 2 },\n \
    \    { actual: candidate(\"ABED1A33\"), expected: 4 },\n     { actual: candidate(\"\
    2020\"), expected: 2 },\n     { actual: candidate(\"123456789ABCDEF0\"), expected:\
    \ 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"), expected:\
    \ 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp4sgr58ta_test.go:106:13: expected '']'', found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074687
- exit_code: 2
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    n\
    \ := 0\n    base := 0\n    for _, r := range num {\n        n += (r - 'A') * base\n\
    \        base *= 16\n    }\n    if n > 0 {\n        return n\n    }\n    return\
    \ 0\n}\n\nfunc TestHex_Key(t *testing.T) {\n  candidate := hex_key\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"AB\"), expected: 1 },\n     { actual:\
    \ candidate(\"1077E\"), expected: 2 },\n     { actual: candidate(\"ABED1A33\"\
    ), expected: 4 },\n     { actual: candidate(\"2020\"), expected: 2 },\n     {\
    \ actual: candidate(\"123456789ABCDEF0\"), expected: 6 },\n     { actual: candidate(\"\
    112233445566778899AABBCCDDEEFF00\"), expected: 12 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprp3qs1ig_test.go:33:14: invalid operation: (r - ''A'') * base (mismatched
    types rune and int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074688
- exit_code: 2
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    num\
    \ := strings.ToUpper(num)\n    n := len(num)\n    prime := 0\n    i := 0\n   \
    \ for ; i < n; i++ {\n        digit := num[i]\n        if digit == \"A\" || digit\
    \ == \"B\" || digit == \"C\" || digit == \"D\" || digit == \"E\" || digit == \"\
    F\" {\n            prime += int(digit)\n        }\n    }\n    if prime == 0 {\n\
    \        return 0\n    }\n    prime += int(num[n-1])\n    for ; i < n; i++ {\n\
    \        digit := num[i]\n        if digit == \"A\" || digit == \"B\" || digit\
    \ == \"C\" || digit == \"D\" || digit == \"E\" || digit == \"F\" {\n         \
    \   prime += int(digit)\n        }\n    }\n    return prime\n}\n\nfunc TestHex_Key(t\
    \ *testing.T) {\n  candidate := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AB\"), expected: 1 },\n     { actual: candidate(\"1077E\"), expected: 2 },\n \
    \    { actual: candidate(\"ABED1A33\"), expected: 4 },\n     { actual: candidate(\"\
    2020\"), expected: 2 },\n     { actual: candidate(\"123456789ABCDEF0\"), expected:\
    \ 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"), expected:\
    \ 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfifa0v95_test.go:30:9: no new variables on left side of :=

    /tmp/tmpfifa0v95_test.go:30:12: undefined: strings

    /tmp/tmpfifa0v95_test.go:36:21: invalid operation: digit == "A" (mismatched types
    byte and untyped string)

    /tmp/tmpfifa0v95_test.go:36:37: invalid operation: digit == "B" (mismatched types
    byte and untyped string)

    /tmp/tmpfifa0v95_test.go:36:53: invalid operation: digit == "C" (mismatched types
    byte and untyped string)

    /tmp/tmpfifa0v95_test.go:36:69: invalid operation: digit == "D" (mismatched types
    byte and untyped string)

    /tmp/tmpfifa0v95_test.go:36:85: invalid operation: digit == "E" (mismatched types
    byte and untyped string)

    /tmp/tmpfifa0v95_test.go:36:101: invalid operation: digit == "F" (mismatched types
    byte and untyped string)

    /tmp/tmpfifa0v95_test.go:46:21: invalid operation: digit == "A" (mismatched types
    byte and untyped string)

    /tmp/tmpfifa0v95_test.go:46:37: invalid operation: digit == "B" (mismatched types
    byte and untyped string)

    /tmp/tmpfifa0v95_test.go:46:37: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074688
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    n\
    \ := len(num)\n    hexDigits := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D,\
    \ E, F}\n    primes := []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43,\
    \ 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131,\
    \ 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223,\
    \ 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311,\
    \ 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409,\
    \ 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503,\
    \ 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613,\
    \ 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719,\
    \ 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827,\
    \ 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941,\
    \ 947, 953, 967, 971, 977, 983, 991, 997}\n    \n    primeCount := 0\n    for\
    \ _, prime := range primes {\n        if n%prime == 0 {\n            primeCount++\n\
    \        }\n    }\n    \n    primeCount += primeCount/2\n    \n    primeCount\
    \ += primeCount/2\n    \n    primeCount += primeCount/2\n    \n    primeCount\
    \ += primeCount/2\n    \n    primeCount += primeCount/2\n    \n    primeCount\
    \ += primeCount/2\n    \n    primeCount += primeCount/2\n    \n    primeCount\
    \ += primeCount/2\n    \n    primeCount += primeCount/2\n    \n    primeCount\
    \ += primeCount/2\n    \n    primeCount += primeCount/2\n    \n    primeCount\
    \ += primeCount/2\n    \n    primeCount \nfunc TestHex_Key(t *testing.T) {\n \
    \ candidate := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AB\"), expected:\
    \ 1 },\n     { actual: candidate(\"1077E\"), expected: 2 },\n     { actual: candidate(\"\
    ABED1A33\"), expected: 4 },\n     { actual: candidate(\"2020\"), expected: 2 },\n\
    \     { actual: candidate(\"123456789ABCDEF0\"), expected: 6 },\n     { actual:\
    \ candidate(\"112233445566778899AABBCCDDEEFF00\"), expected: 12 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp146yi43y_test.go:66:6: expected ''('', found TestHex_Key

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074687
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    var\
    \ count int = 0\n    for _, v := range num {\n        if v == 'A' || v == 'B'\
    \ || v == 'C' || v == 'D' || v == 'E' || v == 'F' {\n            continue\n  \
    \      }\n        if v == '0' {\n            continue\n        }\n        if v\
    \ == '1' {\n            count++\n            continue\n        }\n        if v\
    \ == '2' {\n            count++\n            continue\n        }\n        if v\
    \ == '3' {\n            count++\n            continue\n        }\n        if v\
    \ == '4' {\n            count++\n            continue\n        }\n        if v\
    \ == '5' {\n            count++\n            continue\n        }\n        if v\
    \ == '6' {\n            count++\n            continue\n        }\n        if v\
    \ == '7' {\n            count++\n            continue\n        }\n        if v\
    \ == '8' {\n            count++\n            continue\n        }\n        if v\
    \ == '9' {\n            count++\n            continue\n        }\n        if v\
    \ == 'A' {\n            count++\n            continue\n        }\n        if v\
    \ == 'B' {\n            count++\n            continue\n        }\n        if v\
    \ == 'C' {\n            count++\n            continue\n        }\n        if v\
    \ == 'D' {\n            count++\n            continue\n        }\n        if v\
    \ == 'E' {\n            count++\n            continue\n        }\n        if v\
    \ == 'F' {\n            count++\n            continue\n        }\n        if v\
    \ == 'a' {\n            count++\n            continue\n        }\n        if v\
    \ == 'b' {\n            count++\n            continue\n        }\n        if v\
    \ == 'c' {\n            count++\n            continue\n        }\n        if v\
    \ == 'd' {\n            count++\n            continue\n        }\n        if v\
    \ == 'e' {\n            count++\n            continue\n        }\n        if v\
    \ == 'f' {\n            count++\n            continue\n        }\n        if v\
    \ == '0' {\n            count++\n            continue\n        }\n        if v\
    \ == '1' {\n            count++\n            continue\n        }\n        if v\
    \ == '2' {\n            count++\n            continue\n        }\n        if v\
    \ == '3' {\n            count++\n            continue\n        }\n        if v\
    \ == '4' {\n            count++\n            continue\n        }\n        if v\
    \ == '5' {\n            count++\n            continue\n        }\n        if v\
    \ == '6' {\n            count++\n            continue\n        }\n        if v\
    \ == '7' {\n            count++\n            continue\n        }\n        if v\
    \ == '8' {\n            count++\n            continue\n        }\n        if v\
    \ == '9' {\n            count++\n\nfunc TestHex_Key(t *testing.T) {\n  candidate\
    \ := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AB\"), expected: 1 },\n \
    \    { actual: candidate(\"1077E\"), expected: 2 },\n     { actual: candidate(\"\
    ABED1A33\"), expected: 4 },\n     { actual: candidate(\"2020\"), expected: 2 },\n\
    \     { actual: candidate(\"123456789ABCDEF0\"), expected: 6 },\n     { actual:\
    \ candidate(\"112233445566778899AABBCCDDEEFF00\"), expected: 12 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpf9qpfqbh_test.go:161:6: expected ''('', found TestHex_Key

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074687
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    num\
    \ := strings.ToUpper(num)\n    num := strings.TrimSpace(num)\n    num := strings.Replace(num,\
    \ \"A\", \"1\", -1)\n    num := strings.Replace(num, \"B\", \"2\", -1)\n    num\
    \ := strings.Replace(num, \"C\", \"3\", -1)\n    num := strings.Replace(num, \"\
    D\", \"4\", -1)\n    num := strings.Replace(num, \"E\", \"5\", -1)\n    num :=\
    \ strings.Replace(num, \"F\", \"6\", -1)\n    num := strings.Replace(num, \"0\"\
    , \"7\", -1)\n    num := strings.Replace(num, \"1\", \"8\", -1)\n    num := strings.Replace(num,\
    \ \"2\", \"9\", -1)\n    num := strings.Replace(num, \"3\", \"A\", -1)\n    num\
    \ := strings.Replace(num, \"4\", \"B\", -1)\n    num := strings.Replace(num, \"\
    5\", \"C\", -1)\n    num := strings.Replace(num, \"6\", \"D\", -1)\n    num :=\
    \ strings.Replace(num, \"7\", \"E\", -1)\n    num := strings.Replace(num, \"8\"\
    , \"F\", -1)\n    num := strings.Replace(num, \"9\", \"0\", -1)\n    num := strings.Replace(num,\
    \ \"+\", \"-\", -1)\n    num := strings.Replace(num, \"/\", \"*\", -1)\n    num\
    \ := strings.Replace(num, \"=\", \"+\", -1)\n    num := strings.Replace(num, \"\
    -\", \"*\", -1)\n    num := strings.Replace(num, \"*\", \"/\", -1)\n    num :=\
    \ strings.Replace(num, \"(\", \"-\", -1)\n    num := strings.Replace(num, \")\"\
    , \"-\", -1)\n    num := strings.Replace(num, \"/\", \"*\", -1)\n    num := strings.Replace(num,\
    \ \"*\", \"/\", -1)\n    num := strings.Replace(num, \"+\", \"-\", -1)\n    num\
    \ := strings.Replace(num, \"-\", \"*\", -1)\n    num := strings.Replace(num, \"\
    *\", \"/\", -1)\n    num := strings.Replace(num, \"(\", \"-\", -1)\n    num :=\
    \ strings.Replace(num, \")\", \"-\", -1)\n    num := strings.Replace(num, \"/\"\
    , \"*\", -1)\n    num := strings.Replace(num, \"*\", \"/\", -1)\n    num := strings.Replace(num,\
    \ \"+\", \"-\", -1)\n    num := strings.Replace(num, \"-\", \"*\", -1)\n    num\
    \ := strings.Replace(num, \"*\", \"/\", -1)\n    num := strings.Replace(num, \"\
    (\", \"-\", -1)\n    num := strings.Replace(num, \")\", \"-\", -1)\n    num :=\
    \ strings.Replace(num, \"/\", \"*\", -1)\n    num := strings.Replace(num, \"*\"\
    , \"/\", -1)\n    num := strings.Replace(num\nfunc TestHex_Key(t *testing.T) {\n\
    \  candidate := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AB\"\
    ), expected: 1 },\n     { actual: candidate(\"1077E\"), expected: 2 },\n     {\
    \ actual: candidate(\"ABED1A33\"), expected: 4 },\n     { actual: candidate(\"\
    2020\"), expected: 2 },\n     { actual: candidate(\"123456789ABCDEF0\"), expected:\
    \ 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"), expected:\
    \ 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp1aqk77jn_test.go:71:31: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074687
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    n\
    \ := 0\n    for _, r := range num {\n        if r == 'A' || r == 'B' || r == 'C'\
    \ || r == 'D' || r == 'E' || r == 'F' {\n            n += 2\n        } else {\n\
    \            n += 1\n        }\n    }\n    return n\n}\n\nfunc TestHex_Key(t *testing.T)\
    \ {\n  candidate := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AB\"), expected: 1 },\n     { actual: candidate(\"1077E\"), expected: 2 },\n \
    \    { actual: candidate(\"ABED1A33\"), expected: 4 },\n     { actual: candidate(\"\
    2020\"), expected: 2 },\n     { actual: candidate(\"123456789ABCDEF0\"), expected:\
    \ 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"), expected:\
    \ 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestHex_Key (0.00s)\n    --- FAIL: TestHex_Key/test_num__0 (0.00s)\n\
    \        tmpzr1nui6s_test.go:59: expected '%!s(int=1)', got '%!s(int=4)'\n   \
    \ --- FAIL: TestHex_Key/test_num__1 (0.00s)\n        tmpzr1nui6s_test.go:59: expected\
    \ '%!s(int=2)', got '%!s(int=6)'\n    --- FAIL: TestHex_Key/test_num__2 (0.00s)\n\
    \        tmpzr1nui6s_test.go:59: expected '%!s(int=4)', got '%!s(int=13)'\n  \
    \  --- FAIL: TestHex_Key/test_num__3 (0.00s)\n        tmpzr1nui6s_test.go:59:\
    \ expected '%!s(int=2)', got '%!s(int=4)'\n    --- FAIL: TestHex_Key/test_num__4\
    \ (0.00s)\n        tmpzr1nui6s_test.go:59: expected '%!s(int=6)', got '%!s(int=22)'\n\
    \    --- FAIL: TestHex_Key/test_num__5 (0.00s)\n        tmpzr1nui6s_test.go:59:\
    \ expected '%!s(int=12)', got '%!s(int=44)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074583
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    num\
    \ := strings.ToUpper(num)\n    num := strings.Replace(num, \"A\", \"10\", -1)\n\
    \    num := strings.Replace(num, \"B\", \"11\", -1)\n    num := strings.Replace(num,\
    \ \"C\", \"12\", -1)\n    num := strings.Replace(num, \"D\", \"13\", -1)\n   \
    \ num := strings.Replace(num, \"E\", \"14\", -1)\n    num := strings.Replace(num,\
    \ \"F\", \"15\", -1)\n    num := strings.Replace(num, \"0\", \"10\", -1)\n   \
    \ num := strings.Replace(num, \"1\", \"11\", -1)\n    num := strings.Replace(num,\
    \ \"2\", \"12\", -1)\n    num := strings.Replace(num, \"3\", \"13\", -1)\n   \
    \ num := strings.Replace(num, \"4\", \"14\", -1)\n    num := strings.Replace(num,\
    \ \"5\", \"15\", -1)\n    num := strings.Replace(num, \"6\", \"16\", -1)\n   \
    \ num := strings.Replace(num, \"7\", \"17\", -1)\n    num := strings.Replace(num,\
    \ \"8\", \"18\", -1)\n    num := strings.Replace(num, \"9\", \"19\", -1)\n   \
    \ num := strings.Replace(num, \"+\", \"10\", -1)\n    num := strings.Replace(num,\
    \ \"-\", \"11\", -1)\n    num := strings.Replace(num, \".\", \"12\", -1)\n   \
    \ num := strings.Replace(num, \"/\", \"13\", -1)\n    num := strings.Replace(num,\
    \ \"*\", \"14\", -1)\n    num := strings.Replace(num, \"=\", \"15\", -1)\n   \
    \ num := strings.Replace(num, \"?\", \"16\", -1)\n    num := strings.Replace(num,\
    \ \"!\", \"17\", -1)\n    num := strings.Replace(num, \"(\", \"18\", -1)\n   \
    \ num := strings.Replace(num, \"[\", \"19\", -1)\n    num := strings.Replace(num,\
    \ \"]\", \"20\", -1)\n    num := strings.Replace(num, \"{\", \"21\", -1)\n   \
    \ num := strings.Replace(num, \"}\", \"22\", -1)\n    num := strings.Replace(num,\
    \ \"|\", \"23\", -1)\n    num := strings.Replace(num, \"~\", \"24\", -1)\n   \
    \ num := strings.Replace(num, \"!\", \"25\", -1)\n    num := strings.Replace(num,\
    \ \"@\", \"26\", -1)\n    num := strings.Replace(num, \"#\", \"27\", -1)\n   \
    \ num := strings.Replace(num, \"$\", \"28\", -1)\n    num := strings.Replace(num,\
    \ \"%\", \"29\", -1)\n    num := strings.Replace(num, \"^\", \"30\", -1)\n   \
    \ num := strings.Replace(num, \"&\", \"31\", -1)\n    num := strings.Replace(num,\
    \ \"*\", \"32\", -1)\n    \nfunc TestHex_Key(t *testing.T) {\n  candidate := hex_key\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"AB\"), expected: 1 },\n     {\
    \ actual: candidate(\"1077E\"), expected: 2 },\n     { actual: candidate(\"ABED1A33\"\
    ), expected: 4 },\n     { actual: candidate(\"2020\"), expected: 2 },\n     {\
    \ actual: candidate(\"123456789ABCDEF0\"), expected: 6 },\n     { actual: candidate(\"\
    112233445566778899AABBCCDDEEFF00\"), expected: 12 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpfz08tak2_test.go:71:6: expected ''('', found TestHex_Key

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074687
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    num\
    \ := strings.ToUpper(num)\n    hexDigits := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9,\
    \ A, B, C, D, E, F}\n    primes := []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31,\
    \ 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97}\n    primesLen := len(primes)\n\
    \    primesLen -= 1\n    primesLen += primesLen/2\n    primesLen += primesLen/2\n\
    \    primesLen += primesLen/2\n    primesLen += primesLen/2\n    primesLen +=\
    \ primesLen/2\n    primesLen += primesLen/2\n    primesLen += primesLen/2\n  \
    \  primesLen += primesLen/2\n    primesLen += primesLen/2\n    primesLen += primesLen/2\n\
    \    primesLen += primesLen/2\n    primesLen += primesLen/2\n    primesLen +=\
    \ primesLen/2\n    primesLen += primesLen/2\n    primesLen += primesLen/2\n  \
    \  primesLen += primesLen/2\n    primesLen += primesLen/2\n    primesLen += primesLen/2\n\
    \    primesLen += primesLen/2\n    primesLen += primesLen/2\n    primesLen +=\
    \ primesLen/2\n    primesLen += primesLen/2\n    primesLen += primesLen/2\n  \
    \  primesLen += primesLen/2\n    primesLen += primesLen/2\n    primesLen += primesLen/2\n\
    \    primesLen += primesLen/2\n    primesLen += primesLen/2\n    primesLen +=\
    \ primesLen/2\n    primesLen += primesLen/2\n    primesLen += primesLen/2\n  \
    \  primesLen += primesLen/2\n    primesLen += primesLen/2\n    primesLen += primesLen/2\n\
    \    primesLen += primesLen/2\n    primesLen += primesLen/2\n    primesLen +=\
    \ primesLen/2\n    primesLen += primesLen/2\n    primesLen += primesLen/2\n  \
    \  primesLen += primesLen/2\n    primesLen += primesLen/2\n    primesLen += primesLen/2\n\
    \    primesLen += primesLen/2\nfunc TestHex_Key(t *testing.T) {\n  candidate :=\
    \ hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AB\"), expected: 1 },\n \
    \    { actual: candidate(\"1077E\"), expected: 2 },\n     { actual: candidate(\"\
    ABED1A33\"), expected: 4 },\n     { actual: candidate(\"2020\"), expected: 2 },\n\
    \     { actual: candidate(\"123456789ABCDEF0\"), expected: 6 },\n     { actual:\
    \ candidate(\"112233445566778899AABBCCDDEEFF00\"), expected: 12 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpxet42vvb_test.go:78:6: expected ''('', found TestHex_Key

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074687
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    num\
    \ := strings.ToUpper(num)\n    num := strings.Replace(num, \"A\", \"10\", -1)\n\
    \    num := strings.Replace(num, \"B\", \"11\", -1)\n    num := strings.Replace(num,\
    \ \"C\", \"12\", -1)\n    num := strings.Replace(num, \"D\", \"13\", -1)\n   \
    \ num := strings.Replace(num, \"E\", \"14\", -1)\n    num := strings.Replace(num,\
    \ \"F\", \"15\", -1)\n    num := strings.Replace(num, \"0\", \"10\", -1)\n   \
    \ num := strings.Replace(num, \"1\", \"11\", -1)\n    num := strings.Replace(num,\
    \ \"2\", \"12\", -1)\n    num := strings.Replace(num, \"3\", \"13\", -1)\n   \
    \ num := strings.Replace(num, \"4\", \"14\", -1)\n    num := strings.Replace(num,\
    \ \"5\", \"15\", -1)\n    num := strings.Replace(num, \"6\", \"16\", -1)\n   \
    \ num := strings.Replace(num, \"7\", \"17\", -1)\n    num := strings.Replace(num,\
    \ \"8\", \"18\", -1)\n    num := strings.Replace(num, \"9\", \"19\", -1)\n   \
    \ num := strings.Replace(num, \"+\", \"-\", -1)\n    num := strings.Replace(num,\
    \ \"/\", \"*\", -1)\n    num := strings.Replace(num, \"=\", \"*\", -1)\n    num\
    \ := strings.Replace(num, \"-\", \"+\", -1)\n    num := strings.Replace(num, \"\
    *\", \"/\", -1)\n    num := strings.Replace(num, \"(\", \"-\", -1)\n    num :=\
    \ strings.Replace(num, \")\", \"-\", -1)\n    num := strings.Replace(num, \".\"\
    , \"*\", -1)\n    num := strings.Replace(num, \"*\", \"*\", -1)\n    num := strings.Replace(num,\
    \ \"-\", \"+\", -1)\n    num := strings.Replace(num, \"+\", \"+\", -1)\n    num\
    \ := strings.Replace(num, \"/\", \"*\", -1)\n    num := strings.Replace(num, \"\
    *\", \"/\", -1)\n    num := strings.Replace(num, \"*\", \"*\", -1)\n    num :=\
    \ strings.Replace(num, \"-\", \"+\", -1)\n    num := strings.Replace(num, \"+\"\
    , \"+\", -1)\n    num := strings.Replace(num, \"*\", \"/\", -1)\n    num := strings.Replace(num,\
    \ \"*\", \"*\", -1)\n    num := strings.Replace(num, \"-\", \"+\", -1)\n    num\
    \ := strings.Replace(num, \"+\", \"+\", -1)\n    num := strings.Replace(num, \"\
    *\", \"/\", -1)\n    num := strings.Replace(num, \"*\", \"*\", -1)\n    num :=\
    \ strings.Replace(num, \"-\", \"+\", -1)\n    num := strings.Replace(num, \"\n\
    func TestHex_Key(t *testing.T) {\n  candidate := hex_key\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AB\"), expected: 1 },\n     { actual: candidate(\"\
    1077E\"), expected: 2 },\n     { actual: candidate(\"ABED1A33\"), expected: 4\
    \ },\n     { actual: candidate(\"2020\"), expected: 2 },\n     { actual: candidate(\"\
    123456789ABCDEF0\"), expected: 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"\
    ), expected: 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8wy0uyu__test.go:70:33: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074687
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    num\
    \ := strings.ToUpper(num)\n    num := strings.TrimSpace(num)\n    num := strings.Replace(num,\
    \ \"A\", \"1\", -1)\n    num := strings.Replace(num, \"B\", \"2\", -1)\n    num\
    \ := strings.Replace(num, \"C\", \"3\", -1)\n    num := strings.Replace(num, \"\
    D\", \"4\", -1)\n    num := strings.Replace(num, \"E\", \"5\", -1)\n    num :=\
    \ strings.Replace(num, \"F\", \"6\", -1)\n    num := strings.Replace(num, \"0\"\
    , \"7\", -1)\n    num := strings.Replace(num, \"1\", \"8\", -1)\n    num := strings.Replace(num,\
    \ \"2\", \"9\", -1)\n    num := strings.Replace(num, \"3\", \"A\", -1)\n    num\
    \ := strings.Replace(num, \"4\", \"B\", -1)\n    num := strings.Replace(num, \"\
    5\", \"C\", -1)\n    num := strings.Replace(num, \"6\", \"D\", -1)\n    num :=\
    \ strings.Replace(num, \"7\", \"E\", -1)\n    num := strings.Replace(num, \"8\"\
    , \"F\", -1)\n    num := strings.Replace(num, \"9\", \"0\", -1)\n    num := strings.Replace(num,\
    \ \"+\", \"-\", -1)\n    num := strings.Replace(num, \"/\", \"*\", -1)\n    num\
    \ := strings.Replace(num, \"=\", \"+\", -1)\n    num := strings.Replace(num, \"\
    -\", \"*\", -1)\n    num := strings.Replace(num, \"*\", \"/\", -1)\n    num :=\
    \ strings.Replace(num, \"(\", \"-\", -1)\n    num := strings.Replace(num, \")\"\
    , \"-\", -1)\n    num := strings.Replace(num, \".\", \"*\", -1)\n    num := strings.Replace(num,\
    \ \"*\", \".\", -1)\n    num := strings.Replace(num, \"-\", \".\", -1)\n    num\
    \ := strings.Replace(num, \"*\", \"-\", -1)\n    num := strings.Replace(num, \"\
    -\", \"+\", -1)\n    num := strings.Replace(num, \"+\", \"+\", -1)\n    num :=\
    \ strings.Replace(num, \"+\", \"-\", -1)\n    num := strings.Replace(num, \"-\"\
    , \"+\", -1)\n    num := strings.Replace(num, \"+\", \"+\", -1)\n    num := strings.Replace(num,\
    \ \"+\", \"-\", -1)\n    num := strings.Replace(num, \"-\", \"+\", -1)\n    num\
    \ := strings.Replace(num, \"+\", \"+\", -1)\n    num := strings.Replace(num, \"\
    +\", \"-\", -1)\n    num := strings.Replace(num, \"-\", \"+\", -1)\n    num :=\
    \ strings.Replace(num, \"+\", \"+\", -1)\n    num := strings.Replace(num, \"+\"\
    , \"-\", -1)\n    num := strings.\nfunc TestHex_Key(t *testing.T) {\n  candidate\
    \ := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AB\"), expected: 1 },\n \
    \    { actual: candidate(\"1077E\"), expected: 2 },\n     { actual: candidate(\"\
    ABED1A33\"), expected: 4 },\n     { actual: candidate(\"2020\"), expected: 2 },\n\
    \     { actual: candidate(\"123456789ABCDEF0\"), expected: 6 },\n     { actual:\
    \ candidate(\"112233445566778899AABBCCDDEEFF00\"), expected: 12 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpt1_e8r0a_test.go:72:1: expected selector or type assertion, found ''func''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074687
- exit_code: 2
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    num\
    \ := strings.ToUpper(num)\n    n := len(num)\n    result := 0\n    for i := 0;\
    \ i < n; i++ {\n        digit := num[i]\n        if digit == \"A\" || digit ==\
    \ \"B\" || digit == \"C\" || digit == \"D\" || digit == \"E\" || digit == \"F\"\
    \ {\n            result += 1\n        }\n    }\n    return result\n}\n\nfunc TestHex_Key(t\
    \ *testing.T) {\n  candidate := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AB\"), expected: 1 },\n     { actual: candidate(\"1077E\"), expected: 2 },\n \
    \    { actual: candidate(\"ABED1A33\"), expected: 4 },\n     { actual: candidate(\"\
    2020\"), expected: 2 },\n     { actual: candidate(\"123456789ABCDEF0\"), expected:\
    \ 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"), expected:\
    \ 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdl3cs34g_test.go:30:9: no new variables on left side of :=

    /tmp/tmpdl3cs34g_test.go:30:12: undefined: strings

    /tmp/tmpdl3cs34g_test.go:35:21: invalid operation: digit == "A" (mismatched types
    byte and untyped string)

    /tmp/tmpdl3cs34g_test.go:35:37: invalid operation: digit == "B" (mismatched types
    byte and untyped string)

    /tmp/tmpdl3cs34g_test.go:35:53: invalid operation: digit == "C" (mismatched types
    byte and untyped string)

    /tmp/tmpdl3cs34g_test.go:35:69: invalid operation: digit == "D" (mismatched types
    byte and untyped string)

    /tmp/tmpdl3cs34g_test.go:35:85: invalid operation: digit == "E" (mismatched types
    byte and untyped string)

    /tmp/tmpdl3cs34g_test.go:35:101: invalid operation: digit == "F" (mismatched types
    byte and untyped string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074589
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    //\
    \ Your code here\n    \n    return 0\n}\n\nfunc TestHex_Key(t *testing.T) {\n\
    \  candidate := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AB\"\
    ), expected: 1 },\n     { actual: candidate(\"1077E\"), expected: 2 },\n     {\
    \ actual: candidate(\"ABED1A33\"), expected: 4 },\n     { actual: candidate(\"\
    2020\"), expected: 2 },\n     { actual: candidate(\"123456789ABCDEF0\"), expected:\
    \ 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"), expected:\
    \ 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestHex_Key (0.00s)\n    --- FAIL: TestHex_Key/test_num__0 (0.00s)\n\
    \        tmpcshf94km_test.go:53: expected '%!s(int=1)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestHex_Key/test_num__1 (0.00s)\n        tmpcshf94km_test.go:53: expected\
    \ '%!s(int=2)', got '%!s(int=0)'\n    --- FAIL: TestHex_Key/test_num__2 (0.00s)\n\
    \        tmpcshf94km_test.go:53: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestHex_Key/test_num__3 (0.00s)\n        tmpcshf94km_test.go:53: expected\
    \ '%!s(int=2)', got '%!s(int=0)'\n    --- FAIL: TestHex_Key/test_num__4 (0.00s)\n\
    \        tmpcshf94km_test.go:53: expected '%!s(int=6)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestHex_Key/test_num__5 (0.00s)\n        tmpcshf94km_test.go:53: expected\
    \ '%!s(int=12)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074578
- exit_code: 2
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    num\
    \ := strings.ToUpper(num)\n    count := 0\n    for _, r := range num {\n     \
    \   if r == 'A' || r == 'B' || r == 'C' || r == 'D' || r == 'E' || r == 'F' {\n\
    \            count++\n        }\n    }\n    return count\n}\n\nfunc TestHex_Key(t\
    \ *testing.T) {\n  candidate := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AB\"), expected: 1 },\n     { actual: candidate(\"1077E\"), expected: 2 },\n \
    \    { actual: candidate(\"ABED1A33\"), expected: 4 },\n     { actual: candidate(\"\
    2020\"), expected: 2 },\n     { actual: candidate(\"123456789ABCDEF0\"), expected:\
    \ 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"), expected:\
    \ 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4qeoci93_test.go:30:9: no new variables on left side of :=

    /tmp/tmp4qeoci93_test.go:30:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074579
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    var\
    \ count int = 0\n    for _, r := range num {\n        if r == 'A' || r == 'B'\
    \ || r == 'C' || r == 'D' || r == 'E' || r == 'F' {\n            count++\n   \
    \     }\n    }\n    return count\n}\n\nfunc TestHex_Key(t *testing.T) {\n  candidate\
    \ := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AB\"), expected: 1 },\n \
    \    { actual: candidate(\"1077E\"), expected: 2 },\n     { actual: candidate(\"\
    ABED1A33\"), expected: 4 },\n     { actual: candidate(\"2020\"), expected: 2 },\n\
    \     { actual: candidate(\"123456789ABCDEF0\"), expected: 6 },\n     { actual:\
    \ candidate(\"112233445566778899AABBCCDDEEFF00\"), expected: 12 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestHex_Key (0.00s)\n    --- FAIL: TestHex_Key/test_num__0 (0.00s)\n\
    \        tmpon0xm6jg_test.go:57: expected '%!s(int=1)', got '%!s(int=2)'\n   \
    \ --- FAIL: TestHex_Key/test_num__1 (0.00s)\n        tmpon0xm6jg_test.go:57: expected\
    \ '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestHex_Key/test_num__2 (0.00s)\n\
    \        tmpon0xm6jg_test.go:57: expected '%!s(int=4)', got '%!s(int=5)'\n   \
    \ --- FAIL: TestHex_Key/test_num__3 (0.00s)\n        tmpon0xm6jg_test.go:57: expected\
    \ '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074582
- exit_code: 2
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    num\
    \ := strings.ToUpper(num)\n    count := 0\n    for _, v := range num {\n     \
    \   count += int(v)\n    }\n    return count\n}\n\nfunc TestHex_Key(t *testing.T)\
    \ {\n  candidate := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AB\"), expected: 1 },\n     { actual: candidate(\"1077E\"), expected: 2 },\n \
    \    { actual: candidate(\"ABED1A33\"), expected: 4 },\n     { actual: candidate(\"\
    2020\"), expected: 2 },\n     { actual: candidate(\"123456789ABCDEF0\"), expected:\
    \ 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"), expected:\
    \ 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3e9itit0_test.go:30:9: no new variables on left side of :=

    /tmp/tmp3e9itit0_test.go:30:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074577
- exit_code: 2
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    num\
    \ := strings.ToUpper(num)\n    hexDigits := []string{\"0\", \"1\", \"2\", \"3\"\
    , \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"A\", \"B\", \"C\", \"D\", \"E\"\
    , \"F\"}\n    primes := []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41,\
    \ 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97}\n    primesCount := 0\n    for\
    \ _, digit := range hexDigits {\n        if num == digit {\n            primesCount++\n\
    \        }\n    }\n    return primes[primesCount]\n}\n\nfunc TestHex_Key(t *testing.T)\
    \ {\n  candidate := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AB\"), expected: 1 },\n     { actual: candidate(\"1077E\"), expected: 2 },\n \
    \    { actual: candidate(\"ABED1A33\"), expected: 4 },\n     { actual: candidate(\"\
    2020\"), expected: 2 },\n     { actual: candidate(\"123456789ABCDEF0\"), expected:\
    \ 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"), expected:\
    \ 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpz_rhaog1_test.go:30:9: no new variables on left side of :=

    /tmp/tmpz_rhaog1_test.go:30:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074688
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    num\
    \ := strings.ToUpper(num)\n    num := strings.Trim(num, \" \")\n    num := strings.ToUpper(num)\n\
    \    num := strings.Trim(num, \"\")\n    num := strings.Replace(num, \"A\", \"\
    1\", -1)\n    num := strings.Replace(num, \"B\", \"2\", -1)\n    num := strings.Replace(num,\
    \ \"C\", \"3\", -1)\n    num := strings.Replace(num, \"D\", \"4\", -1)\n    num\
    \ := strings.Replace(num, \"E\", \"5\", -1)\n    num := strings.Replace(num, \"\
    F\", \"6\", -1)\n    num := strings.Replace(num, \"0\", \"0\", -1)\n    num :=\
    \ strings.Replace(num, \"1\", \"1\", -1)\n    num := strings.Replace(num, \"2\"\
    , \"2\", -1)\n    num := strings.Replace(num, \"3\", \"3\", -1)\n    num := strings.Replace(num,\
    \ \"4\", \"4\", -1)\n    num := strings.Replace(num, \"5\", \"5\", -1)\n    num\
    \ := strings.Replace(num, \"6\", \"6\", -1)\n    num := strings.Replace(num, \"\
    7\", \"7\", -1)\n    num := strings.Replace(num, \"8\", \"8\", -1)\n    num :=\
    \ strings.Replace(num, \"9\", \"9\", -1)\n    num := strings.Replace(num, \"+\"\
    , \"-\", -1)\n    num := strings.Replace(num, \"-\", \"+\", -1)\n    num := strings.Replace(num,\
    \ \".\", \"0\", -1)\n    num := strings.Replace(num, \"/\", \"0\", -1)\n    num\
    \ := strings.Replace(num, \"0\", \"0\", -1)\n    num := strings.Replace(num, \"\
    1\", \"1\", -1)\n    num := strings.Replace(num, \"2\", \"2\", -1)\n    num :=\
    \ strings.Replace(num, \"3\", \"3\", -1)\n    num := strings.Replace(num, \"4\"\
    , \"4\", -1)\n    num := strings.Replace(num, \"5\", \"5\", -1)\n    num := strings.Replace(num,\
    \ \"6\", \"6\", -1)\n    num := strings.Replace(num, \"7\", \"7\", -1)\n    num\
    \ := strings.Replace(num, \"8\", \"8\", -1)\n    num := strings.Replace(num, \"\
    9\", \"9\", -1)\n    num := strings.Replace(num, \"-\", \"+\", -1)\n    num :=\
    \ strings.Replace(num, \"+\", \"-\", -1)\n    num := strings.Replace(num, \".\"\
    , \"0\", -1)\n    num := strings.Replace(num, \"/\", \"0\", -1)\n    num := strings.Replace(num,\
    \ \"0\", \"0\", -1)\n    num := strings.Replace(num, \"1\", \"1\", -1)\n    num\
    \ := strings.Replace(num, \"2\", \"2\", -1)\n    num := strings.Replace(num, \"\
    3\", \"3\", -1)\n    num := strings.Replace(num, \"4\", \"\nfunc TestHex_Key(t\
    \ *testing.T) {\n  candidate := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AB\"), expected: 1 },\n     { actual: candidate(\"1077E\"), expected: 2 },\n \
    \    { actual: candidate(\"ABED1A33\"), expected: 4 },\n     { actual: candidate(\"\
    2020\"), expected: 2 },\n     { actual: candidate(\"123456789ABCDEF0\"), expected:\
    \ 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"), expected:\
    \ 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpg29swqqn_test.go:72:38: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074687
- exit_code: 2
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    num\
    \ := strings.ToUpper(num)\n    count := 0\n    for _, v := range num {\n     \
    \   if v == 'A' || v == 'B' || v == 'C' || v == 'D' || v == 'E' || v == 'F' {\n\
    \            count++\n        }\n    }\n    return count\n}\n\nfunc TestHex_Key(t\
    \ *testing.T) {\n  candidate := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AB\"), expected: 1 },\n     { actual: candidate(\"1077E\"), expected: 2 },\n \
    \    { actual: candidate(\"ABED1A33\"), expected: 4 },\n     { actual: candidate(\"\
    2020\"), expected: 2 },\n     { actual: candidate(\"123456789ABCDEF0\"), expected:\
    \ 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"), expected:\
    \ 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp88q38rvw_test.go:30:9: no new variables on left side of :=

    /tmp/tmp88q38rvw_test.go:30:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074577
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    num\
    \ := strings.ToUpper(num)\n    num := strings.Replace(num, \"A\", \"10\", -1)\n\
    \    num := strings.Replace(num, \"B\", \"11\", -1)\n    num := strings.Replace(num,\
    \ \"C\", \"12\", -1)\n    num := strings.Replace(num, \"D\", \"13\", -1)\n   \
    \ num := strings.Replace(num, \"E\", \"14\", -1)\n    num := strings.Replace(num,\
    \ \"F\", \"15\", -1)\n    num := strings.Replace(num, \"0\", \"10\", -1)\n   \
    \ num := strings.Replace(num, \"1\", \"11\", -1)\n    num := strings.Replace(num,\
    \ \"2\", \"12\", -1)\n    num := strings.Replace(num, \"3\", \"13\", -1)\n   \
    \ num := strings.Replace(num, \"4\", \"14\", -1)\n    num := strings.Replace(num,\
    \ \"5\", \"15\", -1)\n    num := strings.Replace(num, \"6\", \"16\", -1)\n   \
    \ num := strings.Replace(num, \"7\", \"17\", -1)\n    num := strings.Replace(num,\
    \ \"8\", \"18\", -1)\n    num := strings.Replace(num, \"9\", \"19\", -1)\n   \
    \ num := strings.Replace(num, \"+\", \"-\", -1)\n    num := strings.Replace(num,\
    \ \"/\", \"*\", -1)\n    num := strings.Replace(num, \"=\", \"*\", -1)\n    num\
    \ := strings.Replace(num, \"-\", \"+\", -1)\n    num := strings.Replace(num, \"\
    *\", \"/\", -1)\n    num := strings.Replace(num, \"(\", \"-\", -1)\n    num :=\
    \ strings.Replace(num, \")\", \"-\", -1)\n    num := strings.Replace(num, \".\"\
    , \"*\", -1)\n    num := strings.Replace(num, \"*\", \".\", -1)\n    num := strings.Replace(num,\
    \ \"-\", \"+\", -1)\n    num := strings.Replace(num, \"+\", \"*\", -1)\n    num\
    \ := strings.Replace(num, \"*\", \"/\", -1)\n    num := strings.Replace(num, \"\
    -\", \"+\", -1)\n    num := strings.Replace(num, \"+\", \"*\", -1)\n    num :=\
    \ strings.Replace(num, \"*\", \"/\", -1)\n    num := strings.Replace(num, \"-\"\
    , \"+\", -1)\n    num := strings.Replace(num, \"+\", \"*\", -1)\n    num := strings.Replace(num,\
    \ \"*\", \"/\", -1)\n    num := strings.Replace(num, \"-\", \"+\", -1)\n    num\
    \ := strings.Replace(num, \"+\", \"*\", -1)\n    num := strings.Replace(num, \"\
    *\", \"/\", -1)\n    num := strings.Replace(num, \"-\", \"+\", -1)\n    num :=\
    \ strings.Replace(num, \"+\", \"*\", -1)\n    num := strings.Replace(num, \"*\"\
    , \"/\nfunc TestHex_Key(t *testing.T) {\n  candidate := hex_key\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AB\"), expected: 1 },\n     { actual: candidate(\"\
    1077E\"), expected: 2 },\n     { actual: candidate(\"ABED1A33\"), expected: 4\
    \ },\n     { actual: candidate(\"2020\"), expected: 2 },\n     { actual: candidate(\"\
    123456789ABCDEF0\"), expected: 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"\
    ), expected: 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp82agx6gh_test.go:70:38: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074687
- exit_code: 2
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    num\
    \ := strings.ToUpper(num)\n    count := 0\n    for _, v := range num {\n     \
    \   if v == 'A' || v == 'B' || v == 'C' || v == 'D' || v == 'E' || v == 'F' {\n\
    \            continue\n        }\n        count += int(v)\n    }\n    return count\n\
    }\n\nfunc TestHex_Key(t *testing.T) {\n  candidate := hex_key\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AB\"), expected: 1 },\n     { actual: candidate(\"\
    1077E\"), expected: 2 },\n     { actual: candidate(\"ABED1A33\"), expected: 4\
    \ },\n     { actual: candidate(\"2020\"), expected: 2 },\n     { actual: candidate(\"\
    123456789ABCDEF0\"), expected: 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"\
    ), expected: 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp16c7kfeh_test.go:30:9: no new variables on left side of :=

    /tmp/tmp16c7kfeh_test.go:30:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074579
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    var\
    \ count int\n    \n    for _, v := range num {\n        if v == 'A' || v == 'B'\
    \ || v == 'C' || v == 'D' || v == 'E' || v == 'F' {\n            count++\n   \
    \     }\n    }\n    \n    return count\n}\n\nfunc TestHex_Key(t *testing.T) {\n\
    \  candidate := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AB\"\
    ), expected: 1 },\n     { actual: candidate(\"1077E\"), expected: 2 },\n     {\
    \ actual: candidate(\"ABED1A33\"), expected: 4 },\n     { actual: candidate(\"\
    2020\"), expected: 2 },\n     { actual: candidate(\"123456789ABCDEF0\"), expected:\
    \ 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"), expected:\
    \ 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestHex_Key (0.00s)\n    --- FAIL: TestHex_Key/test_num__0 (0.00s)\n\
    \        tmphqyony4g_test.go:59: expected '%!s(int=1)', got '%!s(int=2)'\n   \
    \ --- FAIL: TestHex_Key/test_num__1 (0.00s)\n        tmphqyony4g_test.go:59: expected\
    \ '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestHex_Key/test_num__2 (0.00s)\n\
    \        tmphqyony4g_test.go:59: expected '%!s(int=4)', got '%!s(int=5)'\n   \
    \ --- FAIL: TestHex_Key/test_num__3 (0.00s)\n        tmphqyony4g_test.go:59: expected\
    \ '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074689
- exit_code: 2
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    num\
    \ := strings.ToUpper(num)\n    count := 0\n    for _, v := range num {\n     \
    \   count += int(v)\n    }\n    return count\n}\n\nfunc TestHex_Key(t *testing.T)\
    \ {\n  candidate := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AB\"), expected: 1 },\n     { actual: candidate(\"1077E\"), expected: 2 },\n \
    \    { actual: candidate(\"ABED1A33\"), expected: 4 },\n     { actual: candidate(\"\
    2020\"), expected: 2 },\n     { actual: candidate(\"123456789ABCDEF0\"), expected:\
    \ 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"), expected:\
    \ 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3e9itit0_test.go:30:9: no new variables on left side of :=

    /tmp/tmp3e9itit0_test.go:30:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074577
- exit_code: 2
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    n\
    \ := 0\n    for _, r := range num {\n        n += (r - '0') * (r - '0') * (r -\
    \ '0') * (r - '0')\n    }\n    return n\n}\n\nfunc TestHex_Key(t *testing.T) {\n\
    \  candidate := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AB\"\
    ), expected: 1 },\n     { actual: candidate(\"1077E\"), expected: 2 },\n     {\
    \ actual: candidate(\"ABED1A33\"), expected: 4 },\n     { actual: candidate(\"\
    2020\"), expected: 2 },\n     { actual: candidate(\"123456789ABCDEF0\"), expected:\
    \ 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"), expected:\
    \ 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjh9u5zqh_test.go:32:9: invalid operation: n += (r - ''0'') * (r - ''0'')
    * (r - ''0'') * (r - ''0'') (mismatched types int and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074689
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    //\
    \ Your code here\n    num := strings.ToUpper(num)\n    num := strings.Replace(num,\
    \ \"A\", \"1\", -1)\n    num := strings.Replace(num, \"B\", \"2\", -1)\n    num\
    \ := strings.Replace(num, \"C\", \"3\", -1)\n    num := strings.Replace(num, \"\
    D\", \"4\", -1)\n    num := strings.Replace(num, \"E\", \"5\", -1)\n    num :=\
    \ strings.Replace(num, \"F\", \"6\", -1)\n    num := strings.Replace(num, \"0\"\
    , \"7\", -1)\n    num := strings.Replace(num, \"1\", \"8\", -1)\n    num := strings.Replace(num,\
    \ \"2\", \"9\", -1)\n    num := strings.Replace(num, \"3\", \"A\", -1)\n    num\
    \ := strings.Replace(num, \"4\", \"B\", -1)\n    num := strings.Replace(num, \"\
    5\", \"C\", -1)\n    num := strings.Replace(num, \"6\", \"D\", -1)\n    num :=\
    \ strings.Replace(num, \"7\", \"E\", -1)\n    num := strings.Replace(num, \"8\"\
    , \"F\", -1)\n    num := strings.Replace(num, \"9\", \"0\", -1)\n    num := strings.Replace(num,\
    \ \"+\", \"-\", -1)\n    num := strings.Replace(num, \"/\", \"*\", -1)\n    num\
    \ := strings.Replace(num, \"=\", \"+\", -1)\n    num := strings.Replace(num, \"\
    -\", \"*\", -1)\n    num := strings.Replace(num, \"*\", \"/\", -1)\n    num :=\
    \ strings.Replace(num, \"%\", \"%\", -1)\n    num := strings.Replace(num, \"(\"\
    , \"\", -1)\n    num := strings.Replace(num, \")\", \"\", -1)\n    num := strings.Replace(num,\
    \ \".\", \"\", -1)\n    num := strings.Replace(num, \"-\", \"\", -1)\n    num\
    \ := strings.Replace(num, \"*\", \"\", -1)\n    num := strings.Replace(num, \"\
    /\", \"\", -1)\n    num := strings.Replace(num, \"%\", \"\", -1)\n    num := strings.Replace(num,\
    \ \"+\", \"\", -1)\n    num := strings.Replace(num, \"=\", \"\", -1)\n    num\
    \ := strings.Replace(num, \"-\", \"\", -1)\n    num := strings.Replace(num, \"\
    *\", \"\", -1)\n    num := strings.Replace(num, \"/\", \"\", -1)\n    num := strings.Replace(num,\
    \ \"%\", \"\", -1)\n    num := strings.Replace(num, \"+\", \"\", -1)\n    num\
    \ := strings.Replace(num, \"=\", \"\", -1)\n    num := strings.Replace(num, \"\
    -\", \"\", -1)\n    num := strings.Replace(num, \"*\", \"\", -1)\n    num := strings.Replace(num,\
    \ \"/\", \"\", -1)\n    num := strings.Replace(num\nfunc TestHex_Key(t *testing.T)\
    \ {\n  candidate := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AB\"), expected: 1 },\n     { actual: candidate(\"1077E\"), expected: 2 },\n \
    \    { actual: candidate(\"ABED1A33\"), expected: 4 },\n     { actual: candidate(\"\
    2020\"), expected: 2 },\n     { actual: candidate(\"123456789ABCDEF0\"), expected:\
    \ 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"), expected:\
    \ 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphcdk4fx__test.go:72:31: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074688
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    //\
    \ Your code here\n    \n    return 0\n}\n</code>\n<|/ a tags=go,algorithm |>\n\
    <| c |>\nThanks for your answer. Can you please explain how you came up with these\
    \ prime numbers?\n<|/ c |>\n<| c |>\nI used the [Sieve of Eratosthenes](https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes)\
    \ algorithm to find all the prime numbers between 1 and 100. Then, I used the\
    \ [Sieve of Atkin](https://en.wikipedia.org/wiki/Sieve_of_Atkin) algorithm to\
    \ find all the prime numbers between 1 and 100. Then, I used the [Sieve of Sundaram](https://en.wikipedia.org/wiki/Sieve_of_Sundaram)\
    \ algorithm to find all the prime numbers between 1 and 100. Then, I used the\
    \ [Sieve of Siemens](https://en.wikipedia.org/wiki/Sieve_of_Siemens) algorithm\
    \ to find all the prime numbers between 1 and 100. Then, I used the [Sieve of\
    \ Atkin](https://en.wikipedia.org/wiki/Sieve_of_Atkin) algorithm to find all the\
    \ prime numbers between 1 and 100. Then, I used the [Sieve of Sundaram](https://en.wikipedia.org/wiki/Sieve_of_Sundaram)\
    \ algorithm to find all the prime numbers between 1 and 100. Then, I used the\
    \ [Sieve of Eratosthenes](https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes)\
    \ algorithm to find all the prime numbers between 1 and 100. Then, I used the\
    \ [Sieve of Siemens](https://en.wikipedia.org/wiki/Sieve_of_Siemens) algorithm\
    \ to find all the prime numbers between 1 and 100. Then, I used the [Sieve of\
    \ Sundaram](https://en.wikipedia.org/wiki/Sieve_of_Sundaram) algorithm to find\
    \ all the prime numbers between 1 and 100. Then, I used the [Sieve of Eratosthenes](https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes)\
    \ algorithm to find all the prime numbers between 1 and 100. Then, I used the\
    \ [Sieve of Siemens](https://en.wikipedia.org/wiki/Sieve_of_Siemens) algorithm\
    \ to find all the prime numbers between 1 and 100. Then, I used the [Sieve of\
    \ Atkin](https://en.wikipedia.org/wiki/Sieve_of_Atkin) algorithm to find all the\
    \ prime numbers between 1 and 100. Then, I used the [Sieve of Sundaram](https://en.wikipedia.org/wiki/Sieve_of_Sundaram)\
    \ algorithm to find all the prime numbers between 1 and 100. Then, I used the\
    \ [Sieve of Eratosthenes](https://en.wikipedia.org/wiki/Sieve_of_Erato\nfunc TestHex_Key(t\
    \ *testing.T) {\n  candidate := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AB\"), expected: 1 },\n     { actual: candidate(\"1077E\"), expected: 2 },\n \
    \    { actual: candidate(\"ABED1A33\"), expected: 4 },\n     { actual: candidate(\"\
    2020\"), expected: 2 },\n     { actual: candidate(\"123456789ABCDEF0\"), expected:\
    \ 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"), expected:\
    \ 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpw0mf5b07_test.go:34:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074688
- exit_code: 2
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    num\
    \ := strings.ToUpper(num)\n    count := 0\n    for _, r := range num {\n     \
    \   count += int(unicode.ToLower(r) - 'A') + 1\n    }\n    return count\n}\n\n\
    func TestHex_Key(t *testing.T) {\n  candidate := hex_key\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AB\"), expected: 1 },\n     { actual: candidate(\"\
    1077E\"), expected: 2 },\n     { actual: candidate(\"ABED1A33\"), expected: 4\
    \ },\n     { actual: candidate(\"2020\"), expected: 2 },\n     { actual: candidate(\"\
    123456789ABCDEF0\"), expected: 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"\
    ), expected: 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_1_iz6v8_test.go:30:9: no new variables on left side of :=

    /tmp/tmp_1_iz6v8_test.go:30:12: undefined: strings

    /tmp/tmp_1_iz6v8_test.go:33:22: undefined: unicode

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074684
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    n\
    \ := len(num)\n    prime := make([]int, n)\n    prime[0] = 2 // 2 is prime\n \
    \   prime[1] = 3 // 3 is prime\n    prime[2] = 5 // 5 is prime\n    prime[3] =\
    \ 7 // 7 is prime\n    prime[4] = 11 // 11 is prime\n    prime[5] = 13 // 13 is\
    \ prime\n    prime[6] = 17 // 17 is prime\n    prime[7] = 19 // 19 is prime\n\
    \    prime[8] = 23 // 23 is prime\n    prime[9] = 29 // 29 is prime\n    prime[10]\
    \ = 37 // 37 is prime\n    prime[11] = 37 // 37 is prime\n    prime[12] = 39 //\
    \ 39 is prime\n    prime[13] = 41 // 41 is prime\n    prime[14] = 43 // 43 is\
    \ prime\n    prime[15] = 47 // 47 is prime\n    prime[16] = 59 // 59 is prime\n\
    \    prime[17] = 61 // 61 is prime\n    prime[18] = 67 // 67 is prime\n    prime[19]\
    \ = 73 // 73 is prime\n    prime[20] = 79 // 79 is prime\n    prime[21] = 89 //\
    \ 89 is prime\n    prime[22] = 97 // 97 is prime\n    prime[23] = 101 // 101 is\
    \ prime\n    prime[24] = 103 // 103 is prime\n    prime[25] = 107 // 107 is prime\n\
    \    prime[26] = 113 // 113 is prime\n    prime[27] = 119 // 119 is prime\n  \
    \  prime[28] = 127 // 127 is prime\n    prime[29] = 131 // 131 is prime\n    prime[30]\
    \ = 133 // 133 is prime\n    prime[31] = 199 // 199 is prime\n    prime[32] =\
    \ 203 // 203 is prime\n    prime[33] = 209 // 209 is prime\n    prime[34] = 221\
    \ // 221 is prime\n    prime[35] = 227 // 227 is prime\n    prime[36] = 231 //\
    \ 231 is prime\n    prime[37] = 233 // 233 is prime\n    prime[38] = 239 // 239\
    \ is prime\n    prime[39] = 241 // 241 is prime\n    prime[40] = 247 // 247 is\
    \ prime\n    prime[41] = 251 // 251 is prime\n    prime[42] = 257 // 257 is prime\n\
    \    prime[43] = 263 // 263 is prime\n    prime[44] = 269 // 269 is \nfunc TestHex_Key(t\
    \ *testing.T) {\n  candidate := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AB\"), expected: 1 },\n     { actual: candidate(\"1077E\"), expected: 2 },\n \
    \    { actual: candidate(\"ABED1A33\"), expected: 4 },\n     { actual: candidate(\"\
    2020\"), expected: 2 },\n     { actual: candidate(\"123456789ABCDEF0\"), expected:\
    \ 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"), expected:\
    \ 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpv4qlkdcq_test.go:77:6: expected ''('', found TestHex_Key

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074688
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    //\
    \ Your code here\n    num := strings.ToUpper(num)\n    num := strings.Replace(num,\
    \ \"A\", \"10\", -1)\n    num := strings.Replace(num, \"B\", \"11\", -1)\n   \
    \ num := strings.Replace(num, \"C\", \"12\", -1)\n    num := strings.Replace(num,\
    \ \"D\", \"13\", -1)\n    num := strings.Replace(num, \"E\", \"14\", -1)\n   \
    \ num := strings.Replace(num, \"F\", \"15\", -1)\n    num := strings.Replace(num,\
    \ \"0\", \"10\", -1)\n    num := strings.Replace(num, \"1\", \"11\", -1)\n   \
    \ num := strings.Replace(num, \"2\", \"12\", -1)\n    num := strings.Replace(num,\
    \ \"3\", \"13\", -1)\n    num := strings.Replace(num, \"4\", \"14\", -1)\n   \
    \ num := strings.Replace(num, \"5\", \"15\", -1)\n    num := strings.Replace(num,\
    \ \"6\", \"16\", -1)\n    num := strings.Replace(num, \"7\", \"17\", -1)\n   \
    \ num := strings.Replace(num, \"8\", \"18\", -1)\n    num := strings.Replace(num,\
    \ \"9\", \"19\", -1)\n    num := strings.Replace(num, \"+\", \"20\", -1)\n   \
    \ num := strings.Replace(num, \"-\", \"21\", -1)\n    num := strings.Replace(num,\
    \ \".\", \"22\", -1)\n    num := strings.Replace(num, \"/\", \"23\", -1)\n   \
    \ num := strings.Replace(num, \"=\", \"24\", -1)\n    num := strings.Replace(num,\
    \ \"%\", \"25\", -1)\n    num := strings.Replace(num, \"*\", \"26\", -1)\n   \
    \ num := strings.Replace(num, \"(\", \"27\", -1)\n    num := strings.Replace(num,\
    \ \"!\", \"28\", -1)\n    num := strings.Replace(num, \"$\", \"29\", -1)\n   \
    \ num := strings.Replace(num, \"@\", \"30\", -1)\n    num := strings.Replace(num,\
    \ \"[\", \"31\", -1)\n    num := strings.Replace(num, \"]\", \"32\", -1)\n   \
    \ num := strings.Replace(num, \"{\", \"33\", -1)\n    num := strings.Replace(num,\
    \ \"}\", \"34\", -1)\n    num := strings.Replace(num, \"|\", \"35\", -1)\n   \
    \ num := strings.Replace(num, \"~\", \"36\", -1)\n    num := strings.Replace(num,\
    \ \"?\", \"37\", -1)\n    num := strings.Replace(num, \":\", \"38\", -1)\n   \
    \ num := strings.Replace(num, \";\", \"39\", -1)\n    num := strings.Replace(num,\
    \ \"<\", \"40\", -1)\n    num := strings.Replace(num, \">\", \"41\", -1)\n   \
    \ num := strings.Replace(num, \"?\nfunc TestHex_Key(t *testing.T) {\n  candidate\
    \ := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AB\"), expected: 1 },\n \
    \    { actual: candidate(\"1077E\"), expected: 2 },\n     { actual: candidate(\"\
    ABED1A33\"), expected: 4 },\n     { actual: candidate(\"2020\"), expected: 2 },\n\
    \     { actual: candidate(\"123456789ABCDEF0\"), expected: 6 },\n     { actual:\
    \ candidate(\"112233445566778899AABBCCDDEEFF00\"), expected: 12 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpt1k6zr5a_test.go:70:33: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074688
- exit_code: 2
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    num\
    \ := strings.ToUpper(num)\n    count := 0\n    for _, v := range num {\n     \
    \   if v == 'A' || v == 'B' || v == 'C' || v == 'D' || v == 'E' || v == 'F' {\n\
    \            continue\n        }\n        count += int(v)\n    }\n    return count\n\
    }\n\nfunc TestHex_Key(t *testing.T) {\n  candidate := hex_key\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AB\"), expected: 1 },\n     { actual: candidate(\"\
    1077E\"), expected: 2 },\n     { actual: candidate(\"ABED1A33\"), expected: 4\
    \ },\n     { actual: candidate(\"2020\"), expected: 2 },\n     { actual: candidate(\"\
    123456789ABCDEF0\"), expected: 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"\
    ), expected: 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp16c7kfeh_test.go:30:9: no new variables on left side of :=

    /tmp/tmp16c7kfeh_test.go:30:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074579
- exit_code: 2
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    num\
    \ := strings.ToUpper(num)\n    result := 0\n    for _, c := range num {\n    \
    \    if c == 'A' || c == 'B' || c == 'C' || c == 'D' || c == 'E' || c == 'F' {\n\
    \            continue\n        }\n        result += 1\n    }\n    return result\n\
    }\n\nfunc TestHex_Key(t *testing.T) {\n  candidate := hex_key\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AB\"), expected: 1 },\n     { actual: candidate(\"\
    1077E\"), expected: 2 },\n     { actual: candidate(\"ABED1A33\"), expected: 4\
    \ },\n     { actual: candidate(\"2020\"), expected: 2 },\n     { actual: candidate(\"\
    123456789ABCDEF0\"), expected: 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"\
    ), expected: 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpul1us4ta_test.go:30:9: no new variables on left side of :=

    /tmp/tmpul1us4ta_test.go:30:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074689
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    n\
    \ := len(num)\n    prime := make([]int, n)\n    prime[0] = 2\n    prime[1] = 3\n\
    \    prime[2] = 5\n    prime[3] = 7\n    prime[4] = 11\n    prime[5] = 13\n  \
    \  prime[6] = 17\n    prime[7] = 19\n    prime[8] = 23\n    prime[9] = 29\n  \
    \  prime[10] = 31\n    prime[11] = 31\n    prime[12] = 31\n    prime[13] = 31\n\
    \    prime[14] = 31\n    prime[15] = 31\n    prime[16] = 31\n    prime[17] = 31\n\
    \    prime[18] = 31\n    prime[19] = 31\n    prime[20] = 31\n    prime[21] = 31\n\
    \    prime[22] = 31\n    prime[23] = 31\n    prime[24] = 31\n    prime[25] = 31\n\
    \    prime[26] = 31\n    prime[27] = 31\n    prime[28] = 31\n    prime[29] = 31\n\
    \    prime[30] = 31\n    prime[31] = 31\n    prime[32] = 31\n    prime[33] = 31\n\
    \    prime[34] = 31\n    prime[35] = 31\n    prime[36] = 31\n    prime[37] = 31\n\
    \    prime[38] = 31\n    prime[39] = 31\n    prime[40] = 31\n    prime[41] = 31\n\
    \    prime[42] = 31\n    prime[43] = 31\n    prime[44] = 31\n    prime[45] = 31\n\
    \    prime[46] = 31\n    prime[47] = 31\n    prime[48] = 31\n    prime[49] = 31\n\
    \    prime[50] = 31\n    prime[51] = 31\n    prime[52] = 31\n    prime[53] = 31\n\
    \    prime[54] = 31\n    prime[55] = 31\n    prime[56] = 31\n    prime[57] = 31\n\
    \    prime[58] = 31\n    prime[59] = 31\n    prime[60] = 31\n    prime[61] = 31\n\
    \    prime[62] = 31\n    prime[63] = 31\n    prime[64] = 31\n    prime[65] = 31\n\
    \    prime[66] = 31\n\nfunc TestHex_Key(t *testing.T) {\n  candidate := hex_key\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"AB\"), expected: 1 },\n     {\
    \ actual: candidate(\"1077E\"), expected: 2 },\n     { actual: candidate(\"ABED1A33\"\
    ), expected: 4 },\n     { actual: candidate(\"2020\"), expected: 2 },\n     {\
    \ actual: candidate(\"123456789ABCDEF0\"), expected: 6 },\n     { actual: candidate(\"\
    112233445566778899AABBCCDDEEFF00\"), expected: 12 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpn113atsk_test.go:100:6: expected ''('', found TestHex_Key

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074576
- exit_code: 2
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    num\
    \ := strings.ToUpper(num)\n    count := 0\n    for _, c := range num {\n     \
    \   if c >= '0' && c <= '9' {\n            count++\n        }\n    }\n    if count\
    \ > 0 {\n        return count\n    }\n    count := 0\n    for _, c := range num\
    \ {\n        if c >= 'A' && c <= 'F' {\n            count++\n        }\n    }\n\
    \    if count > 0 {\n        return count\n    }\n    return 0\n}\n\nfunc TestHex_Key(t\
    \ *testing.T) {\n  candidate := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AB\"), expected: 1 },\n     { actual: candidate(\"1077E\"), expected: 2 },\n \
    \    { actual: candidate(\"ABED1A33\"), expected: 4 },\n     { actual: candidate(\"\
    2020\"), expected: 2 },\n     { actual: candidate(\"123456789ABCDEF0\"), expected:\
    \ 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"), expected:\
    \ 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp53t3ik9y_test.go:30:9: no new variables on left side of :=

    /tmp/tmp53t3ik9y_test.go:30:12: undefined: strings

    /tmp/tmp53t3ik9y_test.go:40:11: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074689
- exit_code: 2
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    num\
    \ := strings.ToUpper(num)\n    count := 0\n    for _, r := range num {\n     \
    \   if r == 'A' || r == 'B' || r == 'C' || r == 'D' || r == 'E' || r == 'F' {\n\
    \            count++\n        }\n    }\n    return count\n}\n\nfunc TestHex_Key(t\
    \ *testing.T) {\n  candidate := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AB\"), expected: 1 },\n     { actual: candidate(\"1077E\"), expected: 2 },\n \
    \    { actual: candidate(\"ABED1A33\"), expected: 4 },\n     { actual: candidate(\"\
    2020\"), expected: 2 },\n     { actual: candidate(\"123456789ABCDEF0\"), expected:\
    \ 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"), expected:\
    \ 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4qeoci93_test.go:30:9: no new variables on left side of :=

    /tmp/tmp4qeoci93_test.go:30:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074579
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    n\
    \ := len(num)\n    count := 0\n    for i := 0; i < n; i++ {\n        digit :=\
    \ int(num[i])\n        if digit == 0 {\n            continue\n        }\n    \
    \    if digit == 1 {\n            count++\n            continue\n        }\n \
    \       if digit == 2 {\n            count++\n            continue\n        }\n\
    \        if digit == 3 {\n            count++\n            continue\n        }\n\
    \        if digit == 5 {\n            count++\n            continue\n        }\n\
    \        if digit == 7 {\n            count++\n            continue\n        }\n\
    \        if digit == 11 {\n            count++\n            continue\n       \
    \ }\n        if digit == 13 {\n            count++\n            continue\n   \
    \     }\n        if digit == 17 {\n            count++\n            continue\n\
    \        }\n        if digit == 19 {\n            count++\n            continue\n\
    \        }\n        if digit == 29 {\n            count++\n            continue\n\
    \        }\n        if digit == 31 {\n            count++\n            continue\n\
    \        }\n        if digit == 37 {\n            count++\n            continue\n\
    \        }\n        if digit == 41 {\n            count++\n            continue\n\
    \        }\n        if digit == 43 {\n            count++\n            continue\n\
    \        }\n        if digit == 47 {\n            count++\n            continue\n\
    \        }\n        if digit == 53 {\n            count++\n            continue\n\
    \        }\n        if digit == 59 {\n            count++\n            continue\n\
    \        }\n        if digit == 61 {\n            count++\n            continue\n\
    \        }\n        if digit == 67 {\n            count++\n            continue\n\
    \        }\n        if digit == 73 {\n            count++\n            continue\n\
    \        }\n        if digit == 79 {\n            count++\n            continue\n\
    \        }\n        if digit == 83 {\n            count++\n            continue\n\
    \        }\n        if digit == 89 {\n            count++\n            continue\n\
    \        }\n        if digit == 97 {\n            count++\n            continue\n\
    \        }\n        if digit == 103 {\n            count++\n            continue\n\
    \        }\n        if digit == 109 {\n            count++\n            continue\n\
    \        }\n        if digit == 113 {\n            count++\n            continue\n\
    \        }\n        if digit == 117 {\n            count++\n            continue\n\
    \        }\n        if digit == 121 {\n            count++\n            continue\n\
    \        }\n        if digit == 127 {\n            count++\n            continue\n\
    \        }\n        if digit == 131 {\n            count++\n            continue\n\
    \        }\n        if digit == 137 {\n            count++\n            continue\n\
    \        }\n        if digit == 143 {\n            count++\n            continue\n\
    \        }\n        if digit == 149 {\n            count++\n            continue\n\
    \        }\n        if digit \nfunc TestHex_Key(t *testing.T) {\n  candidate :=\
    \ hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AB\"), expected: 1 },\n \
    \    { actual: candidate(\"1077E\"), expected: 2 },\n     { actual: candidate(\"\
    ABED1A33\"), expected: 4 },\n     { actual: candidate(\"2020\"), expected: 2 },\n\
    \     { actual: candidate(\"123456789ABCDEF0\"), expected: 6 },\n     { actual:\
    \ candidate(\"112233445566778899AABBCCDDEEFF00\"), expected: 12 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpqtjjxblx_test.go:174:6: expected ''('', found TestHex_Key

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074689
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    num\
    \ := strings.ToUpper(num)\n    num := strings.Replace(num, \"A\", \"1\", -1)\n\
    \    num := strings.Replace(num, \"B\", \"2\", -1)\n    num := strings.Replace(num,\
    \ \"C\", \"3\", -1)\n    num := strings.Replace(num, \"D\", \"4\", -1)\n    num\
    \ := strings.Replace(num, \"E\", \"5\", -1)\n    num := strings.Replace(num, \"\
    F\", \"6\", -1)\n    num := strings.Replace(num, \"0\", \"7\", -1)\n    num :=\
    \ strings.Replace(num, \"1\", \"8\", -1)\n    num := strings.Replace(num, \"2\"\
    , \"9\", -1)\n    num := strings.Replace(num, \"3\", \"A\", -1)\n    num := strings.Replace(num,\
    \ \"4\", \"B\", -1)\n    num := strings.Replace(num, \"5\", \"C\", -1)\n    num\
    \ := strings.Replace(num, \"6\", \"D\", -1)\n    num := strings.Replace(num, \"\
    7\", \"E\", -1)\n    num := strings.Replace(num, \"8\", \"F\", -1)\n    num :=\
    \ strings.Replace(num, \"9\", \"0\", -1)\n    num := strings.Replace(num, \"+\"\
    , \"-\", -1)\n    num := strings.Replace(num, \"/\", \"*\", -1)\n    num := strings.Replace(num,\
    \ \"=\", \"+\", -1)\n    num := strings.Replace(num, \"-\", \"*\", -1)\n    num\
    \ := strings.Replace(num, \"*\", \"/\", -1)\n    num := strings.Replace(num, \"\
    (\", \"-\", -1)\n    num := strings.Replace(num, \")\", \"-\", -1)\n    num :=\
    \ strings.Replace(num, \".\", \"*\", -1)\n    num := strings.Replace(num, \"*\"\
    , \"*\", -1)\n    num := strings.Replace(num, \"-\", \"+\", -1)\n    num := strings.Replace(num,\
    \ \"+\", \"+\", -1)\n    num := strings.Replace(num, \"/\", \"*\", -1)\n    num\
    \ := strings.Replace(num, \"*\", \"/\", -1)\n    num := strings.Replace(num, \"\
    *\", \"*\", -1)\n    num := strings.Replace(num, \"*\", \"*\", -1)\n    num :=\
    \ strings.Replace(num, \"*\", \"*\", -1)\n    num := strings.Replace(num, \"*\"\
    , \"*\", -1)\n    num := strings.Replace(num, \"*\", \"*\", -1)\n    num := strings.Replace(num,\
    \ \"*\", \"*\", -1)\n    num := strings.Replace(num, \"*\", \"*\", -1)\n    num\
    \ := strings.Replace(num, \"*\", \"*\", -1)\n    num := strings.Replace(num, \"\
    *\", \"*\", -1)\n    num := strings.Replace(num, \"*\", \"*\", -1)\n    num :=\
    \ strings.Replace(num, \"\nfunc TestHex_Key(t *testing.T) {\n  candidate := hex_key\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"AB\"), expected: 1 },\n     {\
    \ actual: candidate(\"1077E\"), expected: 2 },\n     { actual: candidate(\"ABED1A33\"\
    ), expected: 4 },\n     { actual: candidate(\"2020\"), expected: 2 },\n     {\
    \ actual: candidate(\"123456789ABCDEF0\"), expected: 6 },\n     { actual: candidate(\"\
    112233445566778899AABBCCDDEEFF00\"), expected: 12 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpl2bub052_test.go:70:33: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074689
- exit_code: 2
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    num\
    \ := strings.ToUpper(num)\n    count := 0\n    for _, r := range num {\n     \
    \   if r == 'A' || r == 'B' || r == 'C' || r == 'D' || r == 'E' || r == 'F' {\n\
    \            count++\n        }\n    }\n    return count\n}\n\nfunc TestHex_Key(t\
    \ *testing.T) {\n  candidate := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AB\"), expected: 1 },\n     { actual: candidate(\"1077E\"), expected: 2 },\n \
    \    { actual: candidate(\"ABED1A33\"), expected: 4 },\n     { actual: candidate(\"\
    2020\"), expected: 2 },\n     { actual: candidate(\"123456789ABCDEF0\"), expected:\
    \ 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"), expected:\
    \ 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4qeoci93_test.go:30:9: no new variables on left side of :=

    /tmp/tmp4qeoci93_test.go:30:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074579
- exit_code: 2
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    n\
    \ := 0\n    for _, r := range num {\n        n += int(string(r))\n    }\n    if\
    \ n%2 == 0 {\n        n++\n    }\n    for i := 3; i <= n/3; i++ {\n        if\
    \ n%i == 0 {\n            return i\n        }\n    }\n    return n\n}\n\nfunc\
    \ TestHex_Key(t *testing.T) {\n  candidate := hex_key\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"AB\"), expected: 1 },\n     { actual: candidate(\"\
    1077E\"), expected: 2 },\n     { actual: candidate(\"ABED1A33\"), expected: 4\
    \ },\n     { actual: candidate(\"2020\"), expected: 2 },\n     { actual: candidate(\"\
    123456789ABCDEF0\"), expected: 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"\
    ), expected: 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4gxmc0t0_test.go:32:18: cannot convert string(r) (value of type string)
    to type int

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074689
- exit_code: 2
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    num\
    \ := strings.ToUpper(num)\n    count := 0\n    for _, v := range num {\n     \
    \   count += int(v)\n    }\n    return count\n}\n\nfunc TestHex_Key(t *testing.T)\
    \ {\n  candidate := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AB\"), expected: 1 },\n     { actual: candidate(\"1077E\"), expected: 2 },\n \
    \    { actual: candidate(\"ABED1A33\"), expected: 4 },\n     { actual: candidate(\"\
    2020\"), expected: 2 },\n     { actual: candidate(\"123456789ABCDEF0\"), expected:\
    \ 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"), expected:\
    \ 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3e9itit0_test.go:30:9: no new variables on left side of :=

    /tmp/tmp3e9itit0_test.go:30:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074577
- exit_code: 2
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    n\
    \ := len(num)\n    hexDigits := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D,\
    \ E, F}\n    primes := []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43,\
    \ 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97}\n    result := 0\n    for i := 0;\
    \ i < n; i++ {\n        digit := int(num[i])\n        if digit < 0 || digit >\
    \ 9 {\n            return -1\n        }\n        if digit == 0 {\n           \
    \ continue\n        }\n        result += 1\n        for _, prime := range primes\
    \ {\n            if digit % prime == 0 {\n                break\n            }\n\
    \        }\n    }\n    return result\n}\n\nfunc TestHex_Key(t *testing.T) {\n\
    \  candidate := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AB\"\
    ), expected: 1 },\n     { actual: candidate(\"1077E\"), expected: 2 },\n     {\
    \ actual: candidate(\"ABED1A33\"), expected: 4 },\n     { actual: candidate(\"\
    2020\"), expected: 2 },\n     { actual: candidate(\"123456789ABCDEF0\"), expected:\
    \ 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"), expected:\
    \ 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5zxqbouo_test.go:31:5: hexDigits declared but not used

    /tmp/tmp5zxqbouo_test.go:31:54: undefined: A

    /tmp/tmp5zxqbouo_test.go:31:57: undefined: B

    /tmp/tmp5zxqbouo_test.go:31:60: undefined: C

    /tmp/tmp5zxqbouo_test.go:31:63: undefined: D

    /tmp/tmp5zxqbouo_test.go:31:66: undefined: E

    /tmp/tmp5zxqbouo_test.go:31:69: undefined: F

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074689
- exit_code: 2
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    n\
    \ := len(num)\n    count := 0\n    digit := 0\n    i := 0\n    for i < n {\n \
    \       digit = num[i]\n        if digit >= '0' && digit <= '9' {\n          \
    \  digit = digit - '0'\n        } else {\n            digit = digit - 'A' + 10\n\
    \        }\n        if digit % 2 == 0 {\n            count++\n        }\n    \
    \    i += 2\n    }\n    return count\n}\n\nfunc TestHex_Key(t *testing.T) {\n\
    \  candidate := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AB\"\
    ), expected: 1 },\n     { actual: candidate(\"1077E\"), expected: 2 },\n     {\
    \ actual: candidate(\"ABED1A33\"), expected: 4 },\n     { actual: candidate(\"\
    2020\"), expected: 2 },\n     { actual: candidate(\"123456789ABCDEF0\"), expected:\
    \ 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"), expected:\
    \ 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphh9wk6ml_test.go:35:17: cannot use num[i] (value of type byte) as type
    int in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074689
- exit_code: 2
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    num\
    \ := strings.ToUpper(num)\n    count := 0\n    for _, v := range num {\n     \
    \   if v == 'A' || v == 'B' || v == 'C' || v == 'D' || v == 'E' || v == 'F' {\n\
    \            continue\n        }\n        count += int(v)\n    }\n    return count\n\
    }\n\nfunc TestHex_Key(t *testing.T) {\n  candidate := hex_key\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AB\"), expected: 1 },\n     { actual: candidate(\"\
    1077E\"), expected: 2 },\n     { actual: candidate(\"ABED1A33\"), expected: 4\
    \ },\n     { actual: candidate(\"2020\"), expected: 2 },\n     { actual: candidate(\"\
    123456789ABCDEF0\"), expected: 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"\
    ), expected: 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp16c7kfeh_test.go:30:9: no new variables on left side of :=

    /tmp/tmp16c7kfeh_test.go:30:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074579
- exit_code: 2
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    num\
    \ := strings.ToUpper(num)\n    count := 0\n    for _, v := range num {\n     \
    \   if v == 'A' || v == 'B' || v == 'C' || v == 'D' || v == 'E' || v == 'F' {\n\
    \            count++\n        }\n    }\n    return count\n}\n\nfunc TestHex_Key(t\
    \ *testing.T) {\n  candidate := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AB\"), expected: 1 },\n     { actual: candidate(\"1077E\"), expected: 2 },\n \
    \    { actual: candidate(\"ABED1A33\"), expected: 4 },\n     { actual: candidate(\"\
    2020\"), expected: 2 },\n     { actual: candidate(\"123456789ABCDEF0\"), expected:\
    \ 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"), expected:\
    \ 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp88q38rvw_test.go:30:9: no new variables on left side of :=

    /tmp/tmp88q38rvw_test.go:30:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074577
- exit_code: 2
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    num\
    \ := strings.ToUpper(num)\n    n := len(num)\n    result := 0\n    for i := 0;\
    \ i < n; i++ {\n        digit := num[i]\n        if digit == \"A\" || digit ==\
    \ \"B\" || digit == \"C\" || digit == \"D\" || digit == \"E\" || digit == \"F\"\
    \ {\n            continue\n        }\n        result += 1\n    }\n    return result\n\
    }\n\nfunc TestHex_Key(t *testing.T) {\n  candidate := hex_key\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AB\"), expected: 1 },\n     { actual: candidate(\"\
    1077E\"), expected: 2 },\n     { actual: candidate(\"ABED1A33\"), expected: 4\
    \ },\n     { actual: candidate(\"2020\"), expected: 2 },\n     { actual: candidate(\"\
    123456789ABCDEF0\"), expected: 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"\
    ), expected: 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp21gsus00_test.go:30:9: no new variables on left side of :=

    /tmp/tmp21gsus00_test.go:30:12: undefined: strings

    /tmp/tmp21gsus00_test.go:35:21: invalid operation: digit == "A" (mismatched types
    byte and untyped string)

    /tmp/tmp21gsus00_test.go:35:37: invalid operation: digit == "B" (mismatched types
    byte and untyped string)

    /tmp/tmp21gsus00_test.go:35:53: invalid operation: digit == "C" (mismatched types
    byte and untyped string)

    /tmp/tmp21gsus00_test.go:35:69: invalid operation: digit == "D" (mismatched types
    byte and untyped string)

    /tmp/tmp21gsus00_test.go:35:85: invalid operation: digit == "E" (mismatched types
    byte and untyped string)

    /tmp/tmp21gsus00_test.go:35:101: invalid operation: digit == "F" (mismatched types
    byte and untyped string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074586
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    //\
    \ Your code here\n    \n    \n    \n    return 0\n}\n\nfunc TestHex_Key(t *testing.T)\
    \ {\n  candidate := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AB\"), expected: 1 },\n     { actual: candidate(\"1077E\"), expected: 2 },\n \
    \    { actual: candidate(\"ABED1A33\"), expected: 4 },\n     { actual: candidate(\"\
    2020\"), expected: 2 },\n     { actual: candidate(\"123456789ABCDEF0\"), expected:\
    \ 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"), expected:\
    \ 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestHex_Key (0.00s)\n    --- FAIL: TestHex_Key/test_num__0 (0.00s)\n\
    \        tmpimyhtumx_test.go:55: expected '%!s(int=1)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestHex_Key/test_num__1 (0.00s)\n        tmpimyhtumx_test.go:55: expected\
    \ '%!s(int=2)', got '%!s(int=0)'\n    --- FAIL: TestHex_Key/test_num__2 (0.00s)\n\
    \        tmpimyhtumx_test.go:55: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestHex_Key/test_num__3 (0.00s)\n        tmpimyhtumx_test.go:55: expected\
    \ '%!s(int=2)', got '%!s(int=0)'\n    --- FAIL: TestHex_Key/test_num__4 (0.00s)\n\
    \        tmpimyhtumx_test.go:55: expected '%!s(int=6)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestHex_Key/test_num__5 (0.00s)\n        tmpimyhtumx_test.go:55: expected\
    \ '%!s(int=12)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074690
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    num\
    \ := strings.ToUpper(num)\n    num := strings.Replace(num, \"A\", \"1\", -1)\n\
    \    num := strings.Replace(num, \"B\", \"2\", -1)\n    num := strings.Replace(num,\
    \ \"C\", \"3\", -1)\n    num := strings.Replace(num, \"D\", \"4\", -1)\n    num\
    \ := strings.Replace(num, \"E\", \"5\", -1)\n    num := strings.Replace(num, \"\
    F\", \"6\", -1)\n    num := strings.Replace(num, \"0\", \"7\", -1)\n    num :=\
    \ strings.Replace(num, \"1\", \"8\", -1)\n    num := strings.Replace(num, \"2\"\
    , \"9\", -1)\n    num := strings.Replace(num, \"3\", \"A\", -1)\n    num := strings.Replace(num,\
    \ \"4\", \"B\", -1)\n    num := strings.Replace(num, \"5\", \"C\", -1)\n    num\
    \ := strings.Replace(num, \"6\", \"D\", -1)\n    num := strings.Replace(num, \"\
    7\", \"E\", -1)\n    num := strings.Replace(num, \"8\", \"F\", -1)\n    num :=\
    \ strings.Replace(num, \"9\", \"0\", -1)\n    num := strings.Replace(num, \"+\"\
    , \"-\", -1)\n    num := strings.Replace(num, \"/\", \"*\", -1)\n    num := strings.Replace(num,\
    \ \".\", \"*\", -1)\n    num := strings.Replace(num, \"*\", \"*\", -1)\n    num\
    \ := strings.Replace(num, \"-\", \"+\", -1)\n    num := strings.Replace(num, \"\
    =\", \"*\", -1)\n    num := strings.Replace(num, \"?\", \"*\", -1)\n    num :=\
    \ strings.Replace(num, \"!\", \"*\", -1)\n    num := strings.Replace(num, \"(\"\
    , \"*\", -1)\n    num := strings.Replace(num, \"[\", \"*\", -1)\n    num := strings.Replace(num,\
    \ \"]\", \"*\", -1)\n    num := strings.Replace(num, \"{\", \"*\", -1)\n    num\
    \ := strings.Replace(num, \"}\", \"*\", -1)\n    num := strings.Replace(num, \"\
    <\", \"*\", -1)\n    num := strings.Replace(num, \">\", \"*\", -1)\n    num :=\
    \ strings.Replace(num, \"!\", \"*\", -1)\n    num := strings.Replace(num, \"@\"\
    , \"*\", -1)\n    num := strings.Replace(num, \"#\", \"*\", -1)\n    num := strings.Replace(num,\
    \ \"$\", \"*\", -1)\n    num := strings.Replace(num, \"%\", \"*\", -1)\n    num\
    \ := strings.Replace(num, \"^\", \"*\", -1)\n    num := strings.Replace(num, \"\
    &\", \"*\", -1)\n    num := strings.Replace(num, \"*\", \"*\", -1)\n    num :=\
    \ strings.Replace\nfunc TestHex_Key(t *testing.T) {\n  candidate := hex_key\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"AB\"), expected: 1 },\n     {\
    \ actual: candidate(\"1077E\"), expected: 2 },\n     { actual: candidate(\"ABED1A33\"\
    ), expected: 4 },\n     { actual: candidate(\"2020\"), expected: 2 },\n     {\
    \ actual: candidate(\"123456789ABCDEF0\"), expected: 6 },\n     { actual: candidate(\"\
    112233445566778899AABBCCDDEEFF00\"), expected: 12 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp131ygnh__test.go:71:6: expected ''('', found TestHex_Key

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074689
- exit_code: 2
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    num\
    \ := strings.ToUpper(num)\n    count := 0\n    for _, v := range num {\n     \
    \   if v == 'A' || v == 'B' || v == 'C' || v == 'D' || v == 'E' || v == 'F' {\n\
    \            count++\n        }\n    }\n    return count\n}\n\nfunc TestHex_Key(t\
    \ *testing.T) {\n  candidate := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AB\"), expected: 1 },\n     { actual: candidate(\"1077E\"), expected: 2 },\n \
    \    { actual: candidate(\"ABED1A33\"), expected: 4 },\n     { actual: candidate(\"\
    2020\"), expected: 2 },\n     { actual: candidate(\"123456789ABCDEF0\"), expected:\
    \ 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"), expected:\
    \ 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp88q38rvw_test.go:30:9: no new variables on left side of :=

    /tmp/tmp88q38rvw_test.go:30:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074577
- exit_code: 2
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    num\
    \ := strings.ToUpper(num)\n    count := 0\n    for _, c := range num {\n     \
    \   if c == '0' {\n            count++\n        } else {\n            break\n\
    \        }\n    }\n    return count\n}\n\nfunc TestHex_Key(t *testing.T) {\n \
    \ candidate := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AB\"), expected:\
    \ 1 },\n     { actual: candidate(\"1077E\"), expected: 2 },\n     { actual: candidate(\"\
    ABED1A33\"), expected: 4 },\n     { actual: candidate(\"2020\"), expected: 2 },\n\
    \     { actual: candidate(\"123456789ABCDEF0\"), expected: 6 },\n     { actual:\
    \ candidate(\"112233445566778899AABBCCDDEEFF00\"), expected: 12 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpk5nb1t0q_test.go:30:9: no new variables on left side of :=

    /tmp/tmpk5nb1t0q_test.go:30:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074689
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    n\
    \ := len(num)\n    prime := 0\n    i := 0\n    for ; i < n; i++ {\n        digit\
    \ := int(num[i])\n        if digit < 'A' || digit > 'F' {\n            continue\n\
    \        }\n        prime += digit - 'A'\n    }\n    return prime\n}\n\nfunc TestHex_Key(t\
    \ *testing.T) {\n  candidate := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AB\"), expected: 1 },\n     { actual: candidate(\"1077E\"), expected: 2 },\n \
    \    { actual: candidate(\"ABED1A33\"), expected: 4 },\n     { actual: candidate(\"\
    2020\"), expected: 2 },\n     { actual: candidate(\"123456789ABCDEF0\"), expected:\
    \ 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"), expected:\
    \ 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestHex_Key (0.00s)\n    --- FAIL: TestHex_Key/test_num__1 (0.00s)\n\
    \        tmpqjr_rm1q_test.go:61: expected '%!s(int=2)', got '%!s(int=4)'\n   \
    \ --- FAIL: TestHex_Key/test_num__2 (0.00s)\n        tmpqjr_rm1q_test.go:61: expected\
    \ '%!s(int=4)', got '%!s(int=8)'\n    --- FAIL: TestHex_Key/test_num__3 (0.00s)\n\
    \        tmpqjr_rm1q_test.go:61: expected '%!s(int=2)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestHex_Key/test_num__4 (0.00s)\n        tmpqjr_rm1q_test.go:61: expected\
    \ '%!s(int=6)', got '%!s(int=15)'\n    --- FAIL: TestHex_Key/test_num__5 (0.00s)\n\
    \        tmpqjr_rm1q_test.go:61: expected '%!s(int=12)', got '%!s(int=30)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074690
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    n\
    \ := 0\n    base := len(num)\n    for i := 0; i < base; i++ {\n        n += int(num[i])\
    \ - 'A'\n    }\n    return n\n}\n\nfunc TestHex_Key(t *testing.T) {\n  candidate\
    \ := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AB\"), expected: 1 },\n \
    \    { actual: candidate(\"1077E\"), expected: 2 },\n     { actual: candidate(\"\
    ABED1A33\"), expected: 4 },\n     { actual: candidate(\"2020\"), expected: 2 },\n\
    \     { actual: candidate(\"123456789ABCDEF0\"), expected: 6 },\n     { actual:\
    \ candidate(\"112233445566778899AABBCCDDEEFF00\"), expected: 12 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestHex_Key (0.00s)\n    --- FAIL: TestHex_Key/test_num__1 (0.00s)\n\
    \        tmp28q4_olh_test.go:56: expected '%!s(int=2)', got '%!s(int=-49)'\n \
    \   --- FAIL: TestHex_Key/test_num__2 (0.00s)\n        tmp28q4_olh_test.go:56:\
    \ expected '%!s(int=4)', got '%!s(int=-36)'\n    --- FAIL: TestHex_Key/test_num__3\
    \ (0.00s)\n        tmp28q4_olh_test.go:56: expected '%!s(int=2)', got '%!s(int=-64)'\n\
    \    --- FAIL: TestHex_Key/test_num__4 (0.00s)\n        tmp28q4_olh_test.go:56:\
    \ expected '%!s(int=6)', got '%!s(int=-110)'\n    --- FAIL: TestHex_Key/test_num__5\
    \ (0.00s)\n        tmp28q4_olh_test.go:56: expected '%!s(int=12)', got '%!s(int=-220)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074690
- exit_code: 2
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    n\
    \ := 0\n    for _, r := range num {\n        n += int(unicode.ToLower(r) - 'a')\n\
    \    }\n    return n\n}\n\nfunc TestHex_Key(t *testing.T) {\n  candidate := hex_key\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"AB\"), expected: 1 },\n     {\
    \ actual: candidate(\"1077E\"), expected: 2 },\n     { actual: candidate(\"ABED1A33\"\
    ), expected: 4 },\n     { actual: candidate(\"2020\"), expected: 2 },\n     {\
    \ actual: candidate(\"123456789ABCDEF0\"), expected: 6 },\n     { actual: candidate(\"\
    112233445566778899AABBCCDDEEFF00\"), expected: 12 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpd8oyde4w_test.go:32:18: undefined: unicode

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074577
- exit_code: 2
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    num\
    \ := strings.ToUpper(num)\n    hexDigits := []string{\"0\", \"1\", \"2\", \"3\"\
    , \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"A\", \"B\", \"C\", \"D\", \"E\"\
    , \"F\"}\n    primes := []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41,\
    \ 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97}\n    primesCount := 0\n    primesCount\
    \ += primes[primesCount]\n    for _, digit := range hexDigits {\n        if num\
    \ == digit {\n            primesCount++\n        }\n    }\n    return primesCount\n\
    }\n\nfunc TestHex_Key(t *testing.T) {\n  candidate := hex_key\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AB\"), expected: 1 },\n     { actual: candidate(\"\
    1077E\"), expected: 2 },\n     { actual: candidate(\"ABED1A33\"), expected: 4\
    \ },\n     { actual: candidate(\"2020\"), expected: 2 },\n     { actual: candidate(\"\
    123456789ABCDEF0\"), expected: 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"\
    ), expected: 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8ep_9iw4_test.go:30:9: no new variables on left side of :=

    /tmp/tmp8ep_9iw4_test.go:30:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074689
- exit_code: 2
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    num\
    \ := strings.ToUpper(num)\n    count := 0\n    for _, v := range num {\n     \
    \   if v == 'A' || v == 'B' || v == 'C' || v == 'D' || v == 'E' || v == 'F' {\n\
    \            count++\n        }\n    }\n    return count\n}\n\nfunc TestHex_Key(t\
    \ *testing.T) {\n  candidate := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AB\"), expected: 1 },\n     { actual: candidate(\"1077E\"), expected: 2 },\n \
    \    { actual: candidate(\"ABED1A33\"), expected: 4 },\n     { actual: candidate(\"\
    2020\"), expected: 2 },\n     { actual: candidate(\"123456789ABCDEF0\"), expected:\
    \ 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"), expected:\
    \ 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp88q38rvw_test.go:30:9: no new variables on left side of :=

    /tmp/tmp88q38rvw_test.go:30:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074577
- exit_code: 2
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    num\
    \ := strings.ToUpper(num)\n    count := 0\n    for _, v := range num {\n     \
    \   if v == 'A' || v == 'B' || v == 'C' || v == 'D' || v == 'E' || v == 'F' {\n\
    \            count++\n        }\n    }\n    return count\n}\n\nfunc TestHex_Key(t\
    \ *testing.T) {\n  candidate := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AB\"), expected: 1 },\n     { actual: candidate(\"1077E\"), expected: 2 },\n \
    \    { actual: candidate(\"ABED1A33\"), expected: 4 },\n     { actual: candidate(\"\
    2020\"), expected: 2 },\n     { actual: candidate(\"123456789ABCDEF0\"), expected:\
    \ 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"), expected:\
    \ 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp88q38rvw_test.go:30:9: no new variables on left side of :=

    /tmp/tmp88q38rvw_test.go:30:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074577
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    var\
    \ count int = 0\n    for _, v := range num {\n        count += int(v)\n    }\n\
    \    return count\n}\n\nfunc TestHex_Key(t *testing.T) {\n  candidate := hex_key\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"AB\"), expected: 1 },\n     {\
    \ actual: candidate(\"1077E\"), expected: 2 },\n     { actual: candidate(\"ABED1A33\"\
    ), expected: 4 },\n     { actual: candidate(\"2020\"), expected: 2 },\n     {\
    \ actual: candidate(\"123456789ABCDEF0\"), expected: 6 },\n     { actual: candidate(\"\
    112233445566778899AABBCCDDEEFF00\"), expected: 12 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestHex_Key (0.00s)\n    --- FAIL: TestHex_Key/test_num__0 (0.00s)\n\
    \        tmpq03z4tna_test.go:55: expected '%!s(int=1)', got '%!s(int=131)'\n \
    \   --- FAIL: TestHex_Key/test_num__1 (0.00s)\n        tmpq03z4tna_test.go:55:\
    \ expected '%!s(int=2)', got '%!s(int=276)'\n    --- FAIL: TestHex_Key/test_num__2\
    \ (0.00s)\n        tmpq03z4tna_test.go:55: expected '%!s(int=4)', got '%!s(int=484)'\n\
    \    --- FAIL: TestHex_Key/test_num__3 (0.00s)\n        tmpq03z4tna_test.go:55:\
    \ expected '%!s(int=2)', got '%!s(int=196)'\n    --- FAIL: TestHex_Key/test_num__4\
    \ (0.00s)\n        tmpq03z4tna_test.go:55: expected '%!s(int=6)', got '%!s(int=930)'\n\
    \    --- FAIL: TestHex_Key/test_num__5 (0.00s)\n        tmpq03z4tna_test.go:55:\
    \ expected '%!s(int=12)', got '%!s(int=1860)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074589
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    //\
    \ Your code here\n    \n    return 0\n}\n\nfunc TestHex_Key(t *testing.T) {\n\
    \  candidate := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AB\"\
    ), expected: 1 },\n     { actual: candidate(\"1077E\"), expected: 2 },\n     {\
    \ actual: candidate(\"ABED1A33\"), expected: 4 },\n     { actual: candidate(\"\
    2020\"), expected: 2 },\n     { actual: candidate(\"123456789ABCDEF0\"), expected:\
    \ 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"), expected:\
    \ 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestHex_Key (0.00s)\n    --- FAIL: TestHex_Key/test_num__0 (0.00s)\n\
    \        tmpcshf94km_test.go:53: expected '%!s(int=1)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestHex_Key/test_num__1 (0.00s)\n        tmpcshf94km_test.go:53: expected\
    \ '%!s(int=2)', got '%!s(int=0)'\n    --- FAIL: TestHex_Key/test_num__2 (0.00s)\n\
    \        tmpcshf94km_test.go:53: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestHex_Key/test_num__3 (0.00s)\n        tmpcshf94km_test.go:53: expected\
    \ '%!s(int=2)', got '%!s(int=0)'\n    --- FAIL: TestHex_Key/test_num__4 (0.00s)\n\
    \        tmpcshf94km_test.go:53: expected '%!s(int=6)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestHex_Key/test_num__5 (0.00s)\n        tmpcshf94km_test.go:53: expected\
    \ '%!s(int=12)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074578
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    n\
    \ := len(num)\n    count := 0\n    i := 0\n    for ; i < n; i++ {\n        c :=\
    \ num[i]\n        if c >= '0' && c <= '9' {\n            count++\n        }\n\
    \    }\n    return count\n}\n\nfunc TestHex_Key(t *testing.T) {\n  candidate :=\
    \ hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AB\"), expected: 1 },\n \
    \    { actual: candidate(\"1077E\"), expected: 2 },\n     { actual: candidate(\"\
    ABED1A33\"), expected: 4 },\n     { actual: candidate(\"2020\"), expected: 2 },\n\
    \     { actual: candidate(\"123456789ABCDEF0\"), expected: 6 },\n     { actual:\
    \ candidate(\"112233445566778899AABBCCDDEEFF00\"), expected: 12 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestHex_Key (0.00s)\n    --- FAIL: TestHex_Key/test_num__0 (0.00s)\n\
    \        tmp0td0koap_test.go:60: expected '%!s(int=1)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestHex_Key/test_num__1 (0.00s)\n        tmp0td0koap_test.go:60: expected\
    \ '%!s(int=2)', got '%!s(int=4)'\n    --- FAIL: TestHex_Key/test_num__2 (0.00s)\n\
    \        tmp0td0koap_test.go:60: expected '%!s(int=4)', got '%!s(int=3)'\n   \
    \ --- FAIL: TestHex_Key/test_num__3 (0.00s)\n        tmp0td0koap_test.go:60: expected\
    \ '%!s(int=2)', got '%!s(int=4)'\n    --- FAIL: TestHex_Key/test_num__4 (0.00s)\n\
    \        tmp0td0koap_test.go:60: expected '%!s(int=6)', got '%!s(int=10)'\n  \
    \  --- FAIL: TestHex_Key/test_num__5 (0.00s)\n        tmp0td0koap_test.go:60:\
    \ expected '%!s(int=12)', got '%!s(int=20)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074690
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    num\
    \ := strings.ToUpper(num)\n    num := strings.Replace(num, \"A\", \"1\", -1)\n\
    \    num := strings.Replace(num, \"B\", \"2\", -1)\n    num := strings.Replace(num,\
    \ \"C\", \"3\", -1)\n    num := strings.Replace(num, \"D\", \"4\", -1)\n    num\
    \ := strings.Replace(num, \"E\", \"5\", -1)\n    num := strings.Replace(num, \"\
    F\", \"6\", -1)\n    num := strings.Replace(num, \"0\", \"0\", -1)\n    num :=\
    \ strings.Replace(num, \"1\", \"1\", -1)\n    num := strings.Replace(num, \"2\"\
    , \"2\", -1)\n    num := strings.Replace(num, \"3\", \"3\", -1)\n    num := strings.Replace(num,\
    \ \"4\", \"4\", -1)\n    num := strings.Replace(num, \"5\", \"5\", -1)\n    num\
    \ := strings.Replace(num, \"6\", \"6\", -1)\n    num := strings.Replace(num, \"\
    7\", \"7\", -1)\n    num := strings.Replace(num, \"8\", \"8\", -1)\n    num :=\
    \ strings.Replace(num, \"9\", \"9\", -1)\n    num := strings.Replace(num, \"+\"\
    , \"-\", -1)\n    num := strings.Replace(num, \"-\", \"+\", -1)\n    num := strings.Replace(num,\
    \ \".\", \"0\", -1)\n    num := strings.Replace(num, \"/\", \"0\", -1)\n    num\
    \ := strings.Replace(num, \"0\", \"0\", -1)\n    num := strings.Replace(num, \"\
    1\", \"1\", -1)\n    num := strings.Replace(num, \"2\", \"2\", -1)\n    num :=\
    \ strings.Replace(num, \"3\", \"3\", -1)\n    num := strings.Replace(num, \"4\"\
    , \"4\", -1)\n    num := strings.Replace(num, \"5\", \"5\", -1)\n    num := strings.Replace(num,\
    \ \"6\", \"6\", -1)\n    num := strings.Replace(num, \"7\", \"7\", -1)\n    num\
    \ := strings.Replace(num, \"8\", \"8\", -1)\n    num := strings.Replace(num, \"\
    9\", \"9\", -1)\n    num := strings.Replace(num, \"-\", \"+\", -1)\n    num :=\
    \ strings.Replace(num, \"+\", \"+\", -1)\n    num := strings.Replace(num, \".\"\
    , \"0\", -1)\n    num := strings.Replace(num, \"/\", \"0\", -1)\n    num := strings.Replace(num,\
    \ \"0\", \"0\", -1)\n    num := strings.Replace(num, \"1\", \"1\", -1)\n    num\
    \ := strings.Replace(num, \"2\", \"2\", -1)\n    num := strings.Replace(num, \"\
    3\", \"3\", -1)\n    num := strings.Replace(num, \"4\", \"4\", -1)\n    num :=\
    \ strings.Replace(num, \"5\", \"5\", -1)\n    num := strings.Replace(num, \"6\"\
    , \"\nfunc TestHex_Key(t *testing.T) {\n  candidate := hex_key\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AB\"), expected: 1 },\n     { actual: candidate(\"\
    1077E\"), expected: 2 },\n     { actual: candidate(\"ABED1A33\"), expected: 4\
    \ },\n     { actual: candidate(\"2020\"), expected: 2 },\n     { actual: candidate(\"\
    123456789ABCDEF0\"), expected: 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"\
    ), expected: 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpumhcs4_q_test.go:71:38: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074580
- exit_code: 2
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    num\
    \ := strings.ToUpper(num)\n    count := 0\n    for _, v := range num {\n     \
    \   if v == 'A' || v == 'B' || v == 'C' || v == 'D' || v == 'E' || v == 'F' {\n\
    \            count++\n        }\n    }\n    return count\n}\n\nfunc TestHex_Key(t\
    \ *testing.T) {\n  candidate := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AB\"), expected: 1 },\n     { actual: candidate(\"1077E\"), expected: 2 },\n \
    \    { actual: candidate(\"ABED1A33\"), expected: 4 },\n     { actual: candidate(\"\
    2020\"), expected: 2 },\n     { actual: candidate(\"123456789ABCDEF0\"), expected:\
    \ 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"), expected:\
    \ 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp88q38rvw_test.go:30:9: no new variables on left side of :=

    /tmp/tmp88q38rvw_test.go:30:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074577
- exit_code: 2
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    num\
    \ := strings.ToUpper(num)\n    n := len(num)\n    prime := make([]int, n)\n  \
    \  for i := 0; i < n; i++ {\n        prime[i] = 0\n    }\n    for i := 0; i <\
    \ n; i++ {\n        if num[i] >= '0' && num[i] <= '9' {\n            prime[i]\
    \ += int(num[i] - '0')\n        }\n    }\n    for i := 0; i < n; i++ {\n     \
    \   if prime[i] > 1 {\n            prime[i] = 0\n        }\n    }\n    for i :=\
    \ 0; i < n; i++ {\n        if prime[i] == 1 {\n            prime[i] += 2\n   \
    \     }\n    }\n    return len(prime)\n}\n\nfunc TestHex_Key(t *testing.T) {\n\
    \  candidate := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AB\"\
    ), expected: 1 },\n     { actual: candidate(\"1077E\"), expected: 2 },\n     {\
    \ actual: candidate(\"ABED1A33\"), expected: 4 },\n     { actual: candidate(\"\
    2020\"), expected: 2 },\n     { actual: candidate(\"123456789ABCDEF0\"), expected:\
    \ 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"), expected:\
    \ 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8_686428_test.go:30:9: no new variables on left side of :=

    /tmp/tmp8_686428_test.go:30:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074689
- exit_code: 2
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    num\
    \ := strings.ToUpper(num)\n    count := 0\n    for _, v := range num {\n     \
    \   if v == 'A' || v == 'B' || v == 'C' || v == 'D' || v == 'E' || v == 'F' {\n\
    \            count++\n        }\n    }\n    return count\n}\n\nfunc TestHex_Key(t\
    \ *testing.T) {\n  candidate := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AB\"), expected: 1 },\n     { actual: candidate(\"1077E\"), expected: 2 },\n \
    \    { actual: candidate(\"ABED1A33\"), expected: 4 },\n     { actual: candidate(\"\
    2020\"), expected: 2 },\n     { actual: candidate(\"123456789ABCDEF0\"), expected:\
    \ 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"), expected:\
    \ 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp88q38rvw_test.go:30:9: no new variables on left side of :=

    /tmp/tmp88q38rvw_test.go:30:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074577
- exit_code: 2
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    num\
    \ := strings.ToUpper(num)\n    \n    count := 0\n    \n    for _, v := range num\
    \ {\n        count += int(v)\n    }\n    \n    return count\n}\n\nfunc TestHex_Key(t\
    \ *testing.T) {\n  candidate := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AB\"), expected: 1 },\n     { actual: candidate(\"1077E\"), expected: 2 },\n \
    \    { actual: candidate(\"ABED1A33\"), expected: 4 },\n     { actual: candidate(\"\
    2020\"), expected: 2 },\n     { actual: candidate(\"123456789ABCDEF0\"), expected:\
    \ 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"), expected:\
    \ 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxbi7v9cg_test.go:30:9: no new variables on left side of :=

    /tmp/tmpxbi7v9cg_test.go:30:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074689
- exit_code: 2
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    num\
    \ := strings.ToUpper(num)\n    count := 0\n    for _, c := range num {\n     \
    \   if c >= '0' && c <= '9' {\n            count += int(c - '0')\n        } else\
    \ if c >= 'A' && c <= 'F' {\n            count += int(c - 'A') + 10\n        }\
    \ else if c >= 'a' && c <= 'f' {\n            count += int(c - 'a') + 10\n   \
    \     }\n    }\n    return count\n}\n\nfunc TestHex_Key(t *testing.T) {\n  candidate\
    \ := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AB\"), expected: 1 },\n \
    \    { actual: candidate(\"1077E\"), expected: 2 },\n     { actual: candidate(\"\
    ABED1A33\"), expected: 4 },\n     { actual: candidate(\"2020\"), expected: 2 },\n\
    \     { actual: candidate(\"123456789ABCDEF0\"), expected: 6 },\n     { actual:\
    \ candidate(\"112233445566778899AABBCCDDEEFF00\"), expected: 12 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpwnr48fof_test.go:30:9: no new variables on left side of :=

    /tmp/tmpwnr48fof_test.go:30:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074690
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    count\
    \ := 0\n    for _, r := range num {\n        if r == 'A' || r == 'B' || r == 'C'\
    \ || r == 'D' || r == 'E' || r == 'F' {\n            count++\n        }\n    }\n\
    \    return count\n}\n\nfunc TestHex_Key(t *testing.T) {\n  candidate := hex_key\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"AB\"), expected: 1 },\n     {\
    \ actual: candidate(\"1077E\"), expected: 2 },\n     { actual: candidate(\"ABED1A33\"\
    ), expected: 4 },\n     { actual: candidate(\"2020\"), expected: 2 },\n     {\
    \ actual: candidate(\"123456789ABCDEF0\"), expected: 6 },\n     { actual: candidate(\"\
    112233445566778899AABBCCDDEEFF00\"), expected: 12 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestHex_Key (0.00s)\n    --- FAIL: TestHex_Key/test_num__0 (0.00s)\n\
    \        tmplgj1i__0_test.go:57: expected '%!s(int=1)', got '%!s(int=2)'\n   \
    \ --- FAIL: TestHex_Key/test_num__1 (0.00s)\n        tmplgj1i__0_test.go:57: expected\
    \ '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestHex_Key/test_num__2 (0.00s)\n\
    \        tmplgj1i__0_test.go:57: expected '%!s(int=4)', got '%!s(int=5)'\n   \
    \ --- FAIL: TestHex_Key/test_num__3 (0.00s)\n        tmplgj1i__0_test.go:57: expected\
    \ '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074587
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    n\
    \ := len(num)\n    count := 0\n    for i := 0; i < n; i++ {\n        digit :=\
    \ int(num[i])\n        if digit > 9 {\n            digit = digit - 10\n      \
    \  }\n        if digit == 0 {\n            continue\n        }\n        if digit\
    \ == 1 {\n            count++\n            continue\n        }\n        if digit\
    \ % 2 == 0 {\n            count++\n            continue\n        }\n        count\
    \ += digit % 3\n    }\n    return count\n}\n\nfunc TestHex_Key(t *testing.T) {\n\
    \  candidate := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AB\"\
    ), expected: 1 },\n     { actual: candidate(\"1077E\"), expected: 2 },\n     {\
    \ actual: candidate(\"ABED1A33\"), expected: 4 },\n     { actual: candidate(\"\
    2020\"), expected: 2 },\n     { actual: candidate(\"123456789ABCDEF0\"), expected:\
    \ 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"), expected:\
    \ 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestHex_Key (0.00s)\n    --- FAIL: TestHex_Key/test_num__0 (0.00s)\n\
    \        tmpt6616jy0_test.go:71: expected '%!s(int=1)', got '%!s(int=2)'\n   \
    \ --- FAIL: TestHex_Key/test_num__1 (0.00s)\n        tmpt6616jy0_test.go:71: expected\
    \ '%!s(int=2)', got '%!s(int=3)'\n    --- FAIL: TestHex_Key/test_num__2 (0.00s)\n\
    \        tmpt6616jy0_test.go:71: expected '%!s(int=4)', got '%!s(int=10)'\n  \
    \  --- FAIL: TestHex_Key/test_num__3 (0.00s)\n        tmpt6616jy0_test.go:71:\
    \ expected '%!s(int=2)', got '%!s(int=4)'\n    --- FAIL: TestHex_Key/test_num__4\
    \ (0.00s)\n        tmpt6616jy0_test.go:71: expected '%!s(int=6)', got '%!s(int=16)'\n\
    \    --- FAIL: TestHex_Key/test_num__5 (0.00s)\n        tmpt6616jy0_test.go:71:\
    \ expected '%!s(int=12)', got '%!s(int=32)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074690
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    num\
    \ := strings.ToUpper(num)\n    num := strings.Replace(num, \"A\", \"1\", -1)\n\
    \    num := strings.Replace(num, \"B\", \"2\", -1)\n    num := strings.Replace(num,\
    \ \"C\", \"3\", -1)\n    num := strings.Replace(num, \"D\", \"4\", -1)\n    num\
    \ := strings.Replace(num, \"E\", \"5\", -1)\n    num := strings.Replace(num, \"\
    F\", \"6\", -1)\n    num := strings.Replace(num, \"1\", \"2\", -1)\n    num :=\
    \ strings.Replace(num, \"2\", \"3\", -1)\n    num := strings.Replace(num, \"3\"\
    , \"5\", -1)\n    num := strings.Replace(num, \"4\", \"7\", -1)\n    num := strings.Replace(num,\
    \ \"5\", \"11\", -1)\n    num := strings.Replace(num, \"6\", \"13\", -1)\n   \
    \ num := strings.Replace(num, \"7\", \"17\", -1)\n    num := strings.Replace(num,\
    \ \"8\", \"19\", -1)\n    num := strings.Replace(num, \"9\", \"23\", -1)\n   \
    \ num := strings.Replace(num, \"10\", \"29\", -1)\n    num := strings.Replace(num,\
    \ \"11\", \"31\", -1)\n    num := strings.Replace(num, \"12\", \"37\", -1)\n \
    \   num := strings.Replace(num, \"13\", \"41\", -1)\n    num := strings.Replace(num,\
    \ \"14\", \"43\", -1)\n    num := strings.Replace(num, \"15\", \"47\", -1)\n \
    \   num := strings.Replace(num, \"16\", \"53\", -1)\n    num := strings.Replace(num,\
    \ \"17\", \"59\", -1)\n    num := strings.Replace(num, \"18\", \"61\", -1)\n \
    \   num := strings.Replace(num, \"19\", \"67\", -1)\n    num := strings.Replace(num,\
    \ \"20\", \"71\", -1)\n    num := strings.Replace(num, \"21\", \"73\", -1)\n \
    \   num := strings.Replace(num, \"22\", \"79\", -1)\n    num := strings.Replace(num,\
    \ \"23\", \"83\", -1)\n    num := strings.Replace(num, \"24\", \"89\", -1)\n \
    \   num := strings.Replace(num, \"25\", \"97\", -1)\n    num := strings.Replace(num,\
    \ \"26\", \"101\", -1)\n    num := strings.Replace(num, \"27\", \"103\", -1)\n\
    \    num := strings.Replace(num, \"28\", \"107\", -1)\n    num := strings.Replace(num,\
    \ \"29\", \"109\", -1)\n    num := strings.Replace(num, \"30\", \"111\", -1)\n\
    \    num := strings.Replace(num, \"31\", \"113\", -1)\n    num := strings.Replace(num,\
    \ \"32\", \"117\", -1)\n    num := strings.Replace(num, \"33\", \"119\", -1)\n\
    \    num := strings.Replace\nfunc TestHex_Key(t *testing.T) {\n  candidate :=\
    \ hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AB\"), expected: 1 },\n \
    \    { actual: candidate(\"1077E\"), expected: 2 },\n     { actual: candidate(\"\
    ABED1A33\"), expected: 4 },\n     { actual: candidate(\"2020\"), expected: 2 },\n\
    \     { actual: candidate(\"123456789ABCDEF0\"), expected: 6 },\n     { actual:\
    \ candidate(\"112233445566778899AABBCCDDEEFF00\"), expected: 12 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp0zlfj4b8_test.go:71:6: expected ''('', found TestHex_Key

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074588
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    //\
    \ Your code here\n    count := 0\n    for _, c := range num {\n        if c >=\
    \ '0' && c <= '9' {\n            count++\n        }\n    }\n    return count\n\
    }\n\nfunc TestHex_Key(t *testing.T) {\n  candidate := hex_key\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AB\"), expected: 1 },\n     { actual: candidate(\"\
    1077E\"), expected: 2 },\n     { actual: candidate(\"ABED1A33\"), expected: 4\
    \ },\n     { actual: candidate(\"2020\"), expected: 2 },\n     { actual: candidate(\"\
    123456789ABCDEF0\"), expected: 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"\
    ), expected: 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestHex_Key (0.00s)\n    --- FAIL: TestHex_Key/test_num__0 (0.00s)\n\
    \        tmpyjk4rxlu_test.go:58: expected '%!s(int=1)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestHex_Key/test_num__1 (0.00s)\n        tmpyjk4rxlu_test.go:58: expected\
    \ '%!s(int=2)', got '%!s(int=4)'\n    --- FAIL: TestHex_Key/test_num__2 (0.00s)\n\
    \        tmpyjk4rxlu_test.go:58: expected '%!s(int=4)', got '%!s(int=3)'\n   \
    \ --- FAIL: TestHex_Key/test_num__3 (0.00s)\n        tmpyjk4rxlu_test.go:58: expected\
    \ '%!s(int=2)', got '%!s(int=4)'\n    --- FAIL: TestHex_Key/test_num__4 (0.00s)\n\
    \        tmpyjk4rxlu_test.go:58: expected '%!s(int=6)', got '%!s(int=10)'\n  \
    \  --- FAIL: TestHex_Key/test_num__5 (0.00s)\n        tmpyjk4rxlu_test.go:58:\
    \ expected '%!s(int=12)', got '%!s(int=20)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074690
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    n\
    \ := len(num)\n    result := 0\n    for i := 0; i < n; i++ {\n        result +=\
    \ (int(num[i]) - 'A') * (int(num[i]) - 'A') * (int(num[i]) - 'A')\n    }\n   \
    \ return result\n}\n\nfunc TestHex_Key(t *testing.T) {\n  candidate := hex_key\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"AB\"), expected: 1 },\n     {\
    \ actual: candidate(\"1077E\"), expected: 2 },\n     { actual: candidate(\"ABED1A33\"\
    ), expected: 4 },\n     { actual: candidate(\"2020\"), expected: 2 },\n     {\
    \ actual: candidate(\"123456789ABCDEF0\"), expected: 6 },\n     { actual: candidate(\"\
    112233445566778899AABBCCDDEEFF00\"), expected: 12 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestHex_Key (0.00s)\n    --- FAIL: TestHex_Key/test_num__1 (0.00s)\n\
    \        tmpu4wcakl7_test.go:56: expected '%!s(int=2)', got '%!s(int=-10945)'\n\
    \    --- FAIL: TestHex_Key/test_num__2 (0.00s)\n        tmpu4wcakl7_test.go:56:\
    \ expected '%!s(int=4)', got '%!s(int=-9492)'\n    --- FAIL: TestHex_Key/test_num__3\
    \ (0.00s)\n        tmpu4wcakl7_test.go:56: expected '%!s(int=2)', got '%!s(int=-16576)'\n\
    \    --- FAIL: TestHex_Key/test_num__4 (0.00s)\n        tmpu4wcakl7_test.go:56:\
    \ expected '%!s(int=6)', got '%!s(int=-22400)'\n    --- FAIL: TestHex_Key/test_num__5\
    \ (0.00s)\n        tmpu4wcakl7_test.go:56: expected '%!s(int=12)', got '%!s(int=-44800)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074690
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    //\
    \ Your code here\n    \n    return 0\n}\n\nfunc TestHex_Key(t *testing.T) {\n\
    \  candidate := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AB\"\
    ), expected: 1 },\n     { actual: candidate(\"1077E\"), expected: 2 },\n     {\
    \ actual: candidate(\"ABED1A33\"), expected: 4 },\n     { actual: candidate(\"\
    2020\"), expected: 2 },\n     { actual: candidate(\"123456789ABCDEF0\"), expected:\
    \ 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"), expected:\
    \ 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestHex_Key (0.00s)\n    --- FAIL: TestHex_Key/test_num__0 (0.00s)\n\
    \        tmpcshf94km_test.go:53: expected '%!s(int=1)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestHex_Key/test_num__1 (0.00s)\n        tmpcshf94km_test.go:53: expected\
    \ '%!s(int=2)', got '%!s(int=0)'\n    --- FAIL: TestHex_Key/test_num__2 (0.00s)\n\
    \        tmpcshf94km_test.go:53: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestHex_Key/test_num__3 (0.00s)\n        tmpcshf94km_test.go:53: expected\
    \ '%!s(int=2)', got '%!s(int=0)'\n    --- FAIL: TestHex_Key/test_num__4 (0.00s)\n\
    \        tmpcshf94km_test.go:53: expected '%!s(int=6)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestHex_Key/test_num__5 (0.00s)\n        tmpcshf94km_test.go:53: expected\
    \ '%!s(int=12)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074578
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    n\
    \ := 0\n    for _, r := range num {\n        if r == 'A' || r == 'B' || r == 'C'\
    \ || r == 'D' || r == 'E' || r == 'F' {\n            n += 2\n        } else {\n\
    \            n += 1\n        }\n    }\n    return n\n}\n\nfunc TestHex_Key(t *testing.T)\
    \ {\n  candidate := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AB\"), expected: 1 },\n     { actual: candidate(\"1077E\"), expected: 2 },\n \
    \    { actual: candidate(\"ABED1A33\"), expected: 4 },\n     { actual: candidate(\"\
    2020\"), expected: 2 },\n     { actual: candidate(\"123456789ABCDEF0\"), expected:\
    \ 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"), expected:\
    \ 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestHex_Key (0.00s)\n    --- FAIL: TestHex_Key/test_num__0 (0.00s)\n\
    \        tmpzr1nui6s_test.go:59: expected '%!s(int=1)', got '%!s(int=4)'\n   \
    \ --- FAIL: TestHex_Key/test_num__1 (0.00s)\n        tmpzr1nui6s_test.go:59: expected\
    \ '%!s(int=2)', got '%!s(int=6)'\n    --- FAIL: TestHex_Key/test_num__2 (0.00s)\n\
    \        tmpzr1nui6s_test.go:59: expected '%!s(int=4)', got '%!s(int=13)'\n  \
    \  --- FAIL: TestHex_Key/test_num__3 (0.00s)\n        tmpzr1nui6s_test.go:59:\
    \ expected '%!s(int=2)', got '%!s(int=4)'\n    --- FAIL: TestHex_Key/test_num__4\
    \ (0.00s)\n        tmpzr1nui6s_test.go:59: expected '%!s(int=6)', got '%!s(int=22)'\n\
    \    --- FAIL: TestHex_Key/test_num__5 (0.00s)\n        tmpzr1nui6s_test.go:59:\
    \ expected '%!s(int=12)', got '%!s(int=44)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074583
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    n\
    \ := len(num)\n    result := 0\n    for i := 0; i < n; i++ {\n        result +=\
    \ (int(num[i]) - '0') * (int(num[i]) - '0')\n    }\n    return result\n}\n\nfunc\
    \ TestHex_Key(t *testing.T) {\n  candidate := hex_key\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"AB\"), expected: 1 },\n     { actual: candidate(\"\
    1077E\"), expected: 2 },\n     { actual: candidate(\"ABED1A33\"), expected: 4\
    \ },\n     { actual: candidate(\"2020\"), expected: 2 },\n     { actual: candidate(\"\
    123456789ABCDEF0\"), expected: 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"\
    ), expected: 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestHex_Key (0.00s)\n    --- FAIL: TestHex_Key/test_num__0 (0.00s)\n\
    \        tmpxgnqkewf_test.go:56: expected '%!s(int=1)', got '%!s(int=613)'\n \
    \   --- FAIL: TestHex_Key/test_num__1 (0.00s)\n        tmpxgnqkewf_test.go:56:\
    \ expected '%!s(int=2)', got '%!s(int=540)'\n    --- FAIL: TestHex_Key/test_num__2\
    \ (0.00s)\n        tmpxgnqkewf_test.go:56: expected '%!s(int=4)', got '%!s(int=1762)'\n\
    \    --- FAIL: TestHex_Key/test_num__3 (0.00s)\n        tmpxgnqkewf_test.go:56:\
    \ expected '%!s(int=2)', got '%!s(int=8)'\n    --- FAIL: TestHex_Key/test_num__4\
    \ (0.00s)\n        tmpxgnqkewf_test.go:56: expected '%!s(int=6)', got '%!s(int=2584)'\n\
    \    --- FAIL: TestHex_Key/test_num__5 (0.00s)\n        tmpxgnqkewf_test.go:56:\
    \ expected '%!s(int=12)', got '%!s(int=5168)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074690
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    var\
    \ count int = 0\n    for _, v := range num {\n        if v == 'A' || v == 'B'\
    \ || v == 'C' || v == 'D' || v == 'E' || v == 'F' {\n            count++\n   \
    \     }\n    }\n    return count\n}\n\nfunc TestHex_Key(t *testing.T) {\n  candidate\
    \ := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AB\"), expected: 1 },\n \
    \    { actual: candidate(\"1077E\"), expected: 2 },\n     { actual: candidate(\"\
    ABED1A33\"), expected: 4 },\n     { actual: candidate(\"2020\"), expected: 2 },\n\
    \     { actual: candidate(\"123456789ABCDEF0\"), expected: 6 },\n     { actual:\
    \ candidate(\"112233445566778899AABBCCDDEEFF00\"), expected: 12 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestHex_Key (0.00s)\n    --- FAIL: TestHex_Key/test_num__0 (0.00s)\n\
    \        tmptke48s7e_test.go:57: expected '%!s(int=1)', got '%!s(int=2)'\n   \
    \ --- FAIL: TestHex_Key/test_num__1 (0.00s)\n        tmptke48s7e_test.go:57: expected\
    \ '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestHex_Key/test_num__2 (0.00s)\n\
    \        tmptke48s7e_test.go:57: expected '%!s(int=4)', got '%!s(int=5)'\n   \
    \ --- FAIL: TestHex_Key/test_num__3 (0.00s)\n        tmptke48s7e_test.go:57: expected\
    \ '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074580
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    n\
    \ := 0\n    switch num {\n    case \"A\":\n        n = 1\n    case \"B\":\n  \
    \      n = 2\n    case \"C\":\n        n = 3\n    case \"D\":\n        n = 4\n\
    \    case \"E\":\n        n = 5\n    case \"F\":\n        n = 6\n    default:\n\
    \        fmt.Println(\"Invalid input\")\n    }\n    return n\n}\n\nfunc TestHex_Key(t\
    \ *testing.T) {\n  candidate := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AB\"), expected: 1 },\n     { actual: candidate(\"1077E\"), expected: 2 },\n \
    \    { actual: candidate(\"ABED1A33\"), expected: 4 },\n     { actual: candidate(\"\
    2020\"), expected: 2 },\n     { actual: candidate(\"123456789ABCDEF0\"), expected:\
    \ 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"), expected:\
    \ 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "Invalid input\nInvalid input\nInvalid input\nInvalid input\nInvalid input\n\
    Invalid input\n--- FAIL: TestHex_Key (0.00s)\n    --- FAIL: TestHex_Key/test_num__0\
    \ (0.00s)\n        tmpn7m9ef0k_test.go:68: expected '%!s(int=1)', got '%!s(int=0)'\n\
    \    --- FAIL: TestHex_Key/test_num__1 (0.00s)\n        tmpn7m9ef0k_test.go:68:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\n    --- FAIL: TestHex_Key/test_num__2\
    \ (0.00s)\n        tmpn7m9ef0k_test.go:68: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestHex_Key/test_num__3 (0.00s)\n        tmpn7m9ef0k_test.go:68:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\n    --- FAIL: TestHex_Key/test_num__4\
    \ (0.00s)\n        tmpn7m9ef0k_test.go:68: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestHex_Key/test_num__5 (0.00s)\n        tmpn7m9ef0k_test.go:68:\
    \ expected '%!s(int=12)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074690
- exit_code: 2
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    num\
    \ := strings.ToUpper(num)\n    result := 0\n    for _, v := range num {\n    \
    \    result += (int(v)-48)\n    }\n    return result\n}\n\nfunc TestHex_Key(t\
    \ *testing.T) {\n  candidate := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AB\"), expected: 1 },\n     { actual: candidate(\"1077E\"), expected: 2 },\n \
    \    { actual: candidate(\"ABED1A33\"), expected: 4 },\n     { actual: candidate(\"\
    2020\"), expected: 2 },\n     { actual: candidate(\"123456789ABCDEF0\"), expected:\
    \ 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"), expected:\
    \ 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkcgrj_jk_test.go:30:9: no new variables on left side of :=

    /tmp/tmpkcgrj_jk_test.go:30:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074690
- exit_code: 2
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    n\
    \ := 0\n    for _, r := range num {\n        n += (r - 'A') * 16\n    }\n    return\
    \ n\n}\n\nfunc TestHex_Key(t *testing.T) {\n  candidate := hex_key\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"AB\"), expected: 1 },\n     { actual:\
    \ candidate(\"1077E\"), expected: 2 },\n     { actual: candidate(\"ABED1A33\"\
    ), expected: 4 },\n     { actual: candidate(\"2020\"), expected: 2 },\n     {\
    \ actual: candidate(\"123456789ABCDEF0\"), expected: 6 },\n     { actual: candidate(\"\
    112233445566778899AABBCCDDEEFF00\"), expected: 12 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpksqd9hfl_test.go:32:9: invalid operation: n += (r - ''A'') * 16 (mismatched
    types int and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074580
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    num\
    \ := strings.ToUpper(num)\n    num := strings.Replace(num, \"A\", \"10\", -1)\n\
    \    num := strings.Replace(num, \"B\", \"11\", -1)\n    num := strings.Replace(num,\
    \ \"C\", \"12\", -1)\n    num := strings.Replace(num, \"D\", \"13\", -1)\n   \
    \ num := strings.Replace(num, \"E\", \"14\", -1)\n    num := strings.Replace(num,\
    \ \"F\", \"15\", -1)\n    num := strings.Replace(num, \"0\", \"10\", -1)\n   \
    \ num := strings.Replace(num, \"1\", \"11\", -1)\n    num := strings.Replace(num,\
    \ \"2\", \"12\", -1)\n    num := strings.Replace(num, \"3\", \"13\", -1)\n   \
    \ num := strings.Replace(num, \"4\", \"14\", -1)\n    num := strings.Replace(num,\
    \ \"5\", \"15\", -1)\n    num := strings.Replace(num, \"6\", \"16\", -1)\n   \
    \ num := strings.Replace(num, \"7\", \"17\", -1)\n    num := strings.Replace(num,\
    \ \"8\", \"18\", -1)\n    num := strings.Replace(num, \"9\", \"19\", -1)\n   \
    \ num := strings.Replace(num, \"+\", \"-\", -1)\n    num := strings.Replace(num,\
    \ \"/\", \"*\", -1)\n    num := strings.Replace(num, \"=\", \"+\", -1)\n    num\
    \ := strings.Replace(num, \"-\", \"*\", -1)\n    num := strings.Replace(num, \"\
    *\", \"*\", -1)\n    num := strings.Replace(num, \"(\", \"*\", -1)\n    num :=\
    \ strings.Replace(num, \")\", \"*\", -1)\n    num := strings.Replace(num, \"%\"\
    , \"*\", -1)\n    num := strings.Replace(num, \"!\", \"*\", -1)\n    num := strings.Replace(num,\
    \ \"~\", \"*\", -1)\n    num := strings.Replace(num, \"@\", \"*\", -1)\n    num\
    \ := strings.Replace(num, \"#\", \"*\", -1)\n    num := strings.Replace(num, \"\
    $\", \"*\", -1)\n    num := strings.Replace(num, \"%\", \"*\", -1)\n    num :=\
    \ strings.Replace(num, \"^\", \"*\", -1)\n    num := strings.Replace(num, \"&\"\
    , \"*\", -1)\n    num := strings.Replace(num, \"*\", \"*\", -1)\n    num := strings.Replace(num,\
    \ \"_\", \"*\", -1)\n    num := strings.Replace(num, \"+\", \"*\", -1)\n    num\
    \ := strings.Replace(num, \"=\", \"*\", -1)\n    num := strings.Replace(num, \"\
    <\", \"*\", -1)\n    num := strings.Replace(num, \">\", \"*\", -1)\n    num :=\
    \ strings.Replace(num, \"?\", \"*\", -1)\n    num \nfunc TestHex_Key(t *testing.T)\
    \ {\n  candidate := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AB\"), expected: 1 },\n     { actual: candidate(\"1077E\"), expected: 2 },\n \
    \    { actual: candidate(\"ABED1A33\"), expected: 4 },\n     { actual: candidate(\"\
    2020\"), expected: 2 },\n     { actual: candidate(\"123456789ABCDEF0\"), expected:\
    \ 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"), expected:\
    \ 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpmyo13shk_test.go:71:6: expected ''('', found TestHex_Key

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074690
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    num\
    \ := strings.ToUpper(num)\n    n := len(num)\n    prime := make([]int, n)\n  \
    \  prime[0] = 1\n    prime[1] = 2\n    prime[2] = 2\n    prime[3] = 2\n    prime[4]\
    \ = 2\n    prime[5] = 3\n    prime[6] = 3\n    prime[7] = 3\n    prime[8] = 3\n\
    \    prime[9] = 3\n    prime[10] = 5\n    prime[11] = 5\n    prime[12] = 5\n \
    \   prime[13] = 5\n    prime[14] = 5\n    prime[15] = 5\n    prime[16] = 7\n \
    \   prime[17] = 7\n    prime[18] = 7\n    prime[19] = 7\n    prime[20] = 7\n \
    \   prime[21] = 7\n    prime[22] = 7\n    prime[23] = 7\n    prime[24] = 7\n \
    \   prime[25] = 7\n    prime[26] = 7\n    prime[27] = 7\n    prime[28] = 7\n \
    \   prime[29] = 7\n    prime[30] = 7\n    prime[31] = 7\n    prime[32] = 7\n \
    \   prime[33] = 7\n    prime[34] = 7\n    prime[35] = 7\n    prime[36] = 7\n \
    \   prime[37] = 7\n    prime[38] = 7\n    prime[39] = 7\n    prime[40] = 7\n \
    \   prime[41] = 7\n    prime[42] = 7\n    prime[43] = 7\n    prime[44] = 7\n \
    \   prime[45] = 7\n    prime[46] = 7\n    prime[47] = 7\n    prime[48] = 7\n \
    \   prime[49] = 7\n    prime[50] = 7\n    prime[51] = 7\n    prime[52] = 7\n \
    \   prime[53] = 7\n    prime[54] = 7\n    prime[55] = 7\n    prime[56] = 7\n \
    \   prime[57] = 7\n    prime[58] = 7\n    prime[59] = 7\n    prime[60] = 7\n \
    \   prime[61] = 7\n    prime[62] = 7\n    prime[63] = 7\n    prime[64] = 7\n \
    \   prime[65] = 7\n    prime[66] = 7\n    prime[67] = 7\n    prime[68] = 7\n \
    \   prime[69] = 7\n    prime[70] = 7\n    prime[71] = 7\n    prime[72] = 7\n \
    \   prime[73] = \nfunc TestHex_Key(t *testing.T) {\n  candidate := hex_key\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"AB\"), expected: 1 },\n     {\
    \ actual: candidate(\"1077E\"), expected: 2 },\n     { actual: candidate(\"ABED1A33\"\
    ), expected: 4 },\n     { actual: candidate(\"2020\"), expected: 2 },\n     {\
    \ actual: candidate(\"123456789ABCDEF0\"), expected: 6 },\n     { actual: candidate(\"\
    112233445566778899AABBCCDDEEFF00\"), expected: 12 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpeofnm5nj_test.go:107:6: expected ''('', found TestHex_Key

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074690
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    num\
    \ := strings.ToUpper(num)\n    num := strings.Replace(num, \"A\", \"10\", -1)\n\
    \    num := strings.Replace(num, \"B\", \"11\", -1)\n    num := strings.Replace(num,\
    \ \"C\", \"12\", -1)\n    num := strings.Replace(num, \"D\", \"13\", -1)\n   \
    \ num := strings.Replace(num, \"E\", \"14\", -1)\n    num := strings.Replace(num,\
    \ \"F\", \"15\", -1)\n    num := strings.Replace(num, \"0\", \"10\", -1)\n   \
    \ num := strings.Replace(num, \"1\", \"11\", -1)\n    num := strings.Replace(num,\
    \ \"2\", \"12\", -1)\n    num := strings.Replace(num, \"3\", \"13\", -1)\n   \
    \ num := strings.Replace(num, \"4\", \"14\", -1)\n    num := strings.Replace(num,\
    \ \"5\", \"15\", -1)\n    num := strings.Replace(num, \"6\", \"16\", -1)\n   \
    \ num := strings.Replace(num, \"7\", \"17\", -1)\n    num := strings.Replace(num,\
    \ \"8\", \"18\", -1)\n    num := strings.Replace(num, \"9\", \"19\", -1)\n   \
    \ num := strings.Replace(num, \"+\", \"-\", -1)\n    num := strings.Replace(num,\
    \ \"-\", \"+\", -1)\n    num := strings.Replace(num, \".\", \"0\", -1)\n    num\
    \ := strings.Replace(num, \"/\", \"0\", -1)\n    num := strings.Replace(num, \"\
    0\", \"0\", -1)\n    num := strings.Replace(num, \"1\", \"1\", -1)\n    num :=\
    \ strings.Replace(num, \"2\", \"2\", -1)\n    num := strings.Replace(num, \"3\"\
    , \"3\", -1)\n    num := strings.Replace(num, \"4\", \"4\", -1)\n    num := strings.Replace(num,\
    \ \"5\", \"5\", -1)\n    num := strings.Replace(num, \"6\", \"6\", -1)\n    num\
    \ := strings.Replace(num, \"7\", \"7\", -1)\n    num := strings.Replace(num, \"\
    8\", \"8\", -1)\n    num := strings.Replace(num, \"9\", \"9\", -1)\n    num :=\
    \ strings.Replace(num, \"*\", \"0\", -1)\n    num := strings.Replace(num, \"/\"\
    , \"0\", -1)\n    num := strings.Replace(num, \"0\", \"0\", -1)\n    num := strings.Replace(num,\
    \ \"1\", \"1\", -1)\n    num := strings.Replace(num, \"2\", \"2\", -1)\n    num\
    \ := strings.Replace(num, \"3\", \"3\", -1)\n    num := strings.Replace(num, \"\
    4\", \"4\", -1)\n    num := strings.Replace(num, \"5\", \"5\", -1)\n    num :=\
    \ strings.Replace(num, \"6\", \"6\", -1)\n    num := strings.Replace(num, \"7\"\
    , \"7\", -1)\n    num := \nfunc TestHex_Key(t *testing.T) {\n  candidate := hex_key\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"AB\"), expected: 1 },\n     {\
    \ actual: candidate(\"1077E\"), expected: 2 },\n     { actual: candidate(\"ABED1A33\"\
    ), expected: 4 },\n     { actual: candidate(\"2020\"), expected: 2 },\n     {\
    \ actual: candidate(\"123456789ABCDEF0\"), expected: 6 },\n     { actual: candidate(\"\
    112233445566778899AABBCCDDEEFF00\"), expected: 12 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpd2nw0pos_test.go:72:6: expected ''('', found TestHex_Key

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074686
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    num\
    \ := strings.ToUpper(num)\n    num := strings.Replace(num, \"A\", \"1\", -1)\n\
    \    num := strings.Replace(num, \"B\", \"2\", -1)\n    num := strings.Replace(num,\
    \ \"C\", \"3\", -1)\n    num := strings.Replace(num, \"D\", \"4\", -1)\n    num\
    \ := strings.Replace(num, \"E\", \"5\", -1)\n    num := strings.Replace(num, \"\
    F\", \"6\", -1)\n    num := strings.Replace(num, \"1\", \"2\", -1)\n    num :=\
    \ strings.Replace(num, \"2\", \"3\", -1)\n    num := strings.Replace(num, \"3\"\
    , \"4\", -1)\n    num := strings.Replace(num, \"4\", \"5\", -1)\n    num := strings.Replace(num,\
    \ \"5\", \"6\", -1)\n    num := strings.Replace(num, \"6\", \"7\", -1)\n    num\
    \ := strings.Replace(num, \"7\", \"8\", -1)\n    num := strings.Replace(num, \"\
    8\", \"9\", -1)\n    num := strings.Replace(num, \"9\", \"A\", -1)\n    num :=\
    \ strings.Replace(num, \"A\", \"B\", -1)\n    num := strings.Replace(num, \"B\"\
    , \"C\", -1)\n    num := strings.Replace(num, \"C\", \"D\", -1)\n    num := strings.Replace(num,\
    \ \"D\", \"E\", -1)\n    num := strings.Replace(num, \"E\", \"F\", -1)\n    num\
    \ := strings.Replace(num, \"F\", \"10\", -1)\n    num := strings.Replace(num,\
    \ \"10\", \"11\", -1)\n    num := strings.Replace(num, \"11\", \"12\", -1)\n \
    \   num := strings.Replace(num, \"12\", \"13\", -1)\n    num := strings.Replace(num,\
    \ \"13\", \"14\", -1)\n    num := strings.Replace(num, \"14\", \"15\", -1)\n \
    \   num := strings.Replace(num, \"15\", \"16\", -1)\n    num := strings.Replace(num,\
    \ \"16\", \"17\", -1)\n    num := strings.Replace(num, \"17\", \"18\", -1)\n \
    \   num := strings.Replace(num, \"18\", \"19\", -1)\n    num := strings.Replace(num,\
    \ \"19\", \"20\", -1)\n    num := strings.Replace(num, \"20\", \"21\", -1)\n \
    \   num := strings.Replace(num, \"21\", \"22\", -1)\n    num := strings.Replace(num,\
    \ \"22\", \"23\", -1)\n    num := strings.Replace(num, \"23\", \"24\", -1)\n \
    \   num := strings.Replace(num, \"24\", \"25\", -1)\n    num := strings.Replace(num,\
    \ \"25\", \"26\", -1)\n    num := strings.Replace(num, \"26\", \"27\", -1)\n \
    \   num := strings.Replace(num, \"27\", \"28\", -1)\n    num := strings.Replace(num\n\
    func TestHex_Key(t *testing.T) {\n  candidate := hex_key\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AB\"), expected: 1 },\n     { actual: candidate(\"\
    1077E\"), expected: 2 },\n     { actual: candidate(\"ABED1A33\"), expected: 4\
    \ },\n     { actual: candidate(\"2020\"), expected: 2 },\n     { actual: candidate(\"\
    123456789ABCDEF0\"), expected: 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"\
    ), expected: 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6adf77vj_test.go:70:31: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074690
- exit_code: 2
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    num\
    \ := strings.ToUpper(num)\n    count := 0\n    for _, v := range num {\n     \
    \   if v == 'A' || v == 'B' || v == 'C' || v == 'D' || v == 'E' || v == 'F' {\n\
    \            count++\n        }\n    }\n    return count\n}\n\nfunc TestHex_Key(t\
    \ *testing.T) {\n  candidate := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AB\"), expected: 1 },\n     { actual: candidate(\"1077E\"), expected: 2 },\n \
    \    { actual: candidate(\"ABED1A33\"), expected: 4 },\n     { actual: candidate(\"\
    2020\"), expected: 2 },\n     { actual: candidate(\"123456789ABCDEF0\"), expected:\
    \ 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"), expected:\
    \ 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp88q38rvw_test.go:30:9: no new variables on left side of :=

    /tmp/tmp88q38rvw_test.go:30:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074577
- exit_code: 2
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    num\
    \ := strings.ToUpper(num)\n    n := len(num)\n    result := 0\n    for i := 0;\
    \ i < n; i++ {\n        digit := num[i]\n        if digit == \"A\" || digit ==\
    \ \"B\" || digit == \"C\" || digit == \"D\" || digit == \"E\" || digit == \"F\"\
    \ {\n            result += int(digit)\n        }\n    }\n    return result\n}\n\
    \nfunc TestHex_Key(t *testing.T) {\n  candidate := hex_key\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AB\"), expected: 1 },\n     { actual: candidate(\"\
    1077E\"), expected: 2 },\n     { actual: candidate(\"ABED1A33\"), expected: 4\
    \ },\n     { actual: candidate(\"2020\"), expected: 2 },\n     { actual: candidate(\"\
    123456789ABCDEF0\"), expected: 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"\
    ), expected: 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_vlbcb7f_test.go:30:9: no new variables on left side of :=

    /tmp/tmp_vlbcb7f_test.go:30:12: undefined: strings

    /tmp/tmp_vlbcb7f_test.go:35:21: invalid operation: digit == "A" (mismatched types
    byte and untyped string)

    /tmp/tmp_vlbcb7f_test.go:35:37: invalid operation: digit == "B" (mismatched types
    byte and untyped string)

    /tmp/tmp_vlbcb7f_test.go:35:53: invalid operation: digit == "C" (mismatched types
    byte and untyped string)

    /tmp/tmp_vlbcb7f_test.go:35:69: invalid operation: digit == "D" (mismatched types
    byte and untyped string)

    /tmp/tmp_vlbcb7f_test.go:35:85: invalid operation: digit == "E" (mismatched types
    byte and untyped string)

    /tmp/tmp_vlbcb7f_test.go:35:101: invalid operation: digit == "F" (mismatched types
    byte and untyped string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074690
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    n\
    \ := len(num)\n    if n == 0 {\n        return 0\n    }\n    count := 0\n    i\
    \ := 0\n    for ; i < n; i++ {\n        c := num[i]\n        if c >= '0' && c\
    \ <= '9' {\n            count += int(c - '0')\n        } else {\n            if\
    \ c == 'A' || c == 'B' || c == 'C' || c == 'D' || c == 'E' || c == 'F' {\n   \
    \             count += int(c - 'A') + 1\n            } else {\n              \
    \  fmt.Printf(\"invalid hexadecimal digit: %c\\n\", c)\n                return\
    \ 0\n            }\n        }\n    }\n    if count < 2 {\n        return 0\n \
    \   }\n    count += 2\n    for ; i < n; i++ {\n        c := num[i]\n        if\
    \ c >= '0' && c <= '9' {\n            count += int(c - '0')\n        } else {\n\
    \            if c == 'A' || c == 'B' || c == 'C' || c == 'D' || c == 'E' || c\
    \ == 'F' {\n                count += int(c - 'A') + 1\n            } else {\n\
    \                fmt.Printf(\"invalid hexadecimal digit: %c\\n\", c)\n       \
    \         return 0\n            }\n        }\n    }\n    return count\n}\n\nfunc\
    \ TestHex_Key(t *testing.T) {\n  candidate := hex_key\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"AB\"), expected: 1 },\n     { actual: candidate(\"\
    1077E\"), expected: 2 },\n     { actual: candidate(\"ABED1A33\"), expected: 4\
    \ },\n     { actual: candidate(\"2020\"), expected: 2 },\n     { actual: candidate(\"\
    123456789ABCDEF0\"), expected: 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"\
    ), expected: 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestHex_Key (0.00s)\n    --- FAIL: TestHex_Key/test_num__0 (0.00s)\n\
    \        tmpheh_7zg3_test.go:87: expected '%!s(int=1)', got '%!s(int=5)'\n   \
    \ --- FAIL: TestHex_Key/test_num__1 (0.00s)\n        tmpheh_7zg3_test.go:87: expected\
    \ '%!s(int=2)', got '%!s(int=22)'\n    --- FAIL: TestHex_Key/test_num__2 (0.00s)\n\
    \        tmpheh_7zg3_test.go:87: expected '%!s(int=4)', got '%!s(int=22)'\n  \
    \  --- FAIL: TestHex_Key/test_num__3 (0.00s)\n        tmpheh_7zg3_test.go:87:\
    \ expected '%!s(int=2)', got '%!s(int=6)'\n    --- FAIL: TestHex_Key/test_num__4\
    \ (0.00s)\n        tmpheh_7zg3_test.go:87: expected '%!s(int=6)', got '%!s(int=68)'\n\
    \    --- FAIL: TestHex_Key/test_num__5 (0.00s)\n        tmpheh_7zg3_test.go:87:\
    \ expected '%!s(int=12)', got '%!s(int=134)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074690
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    n\
    \ := len(num)\n    prime := make([]int, n)\n    prime[0] = 2\n    prime[1] = 3\n\
    \    prime[2] = 5\n    prime[3] = 7\n    prime[4] = 11\n    prime[5] = 13\n  \
    \  prime[6] = 17\n    prime[7] = 19\n    prime[8] = 23\n    prime[9] = 29\n  \
    \  prime[10] = 31\n    prime[11] = 31\n    prime[12] = 31\n    prime[13] = 31\n\
    \    prime[14] = 31\n    prime[15] = 31\n    prime[16] = 31\n    prime[17] = 31\n\
    \    prime[18] = 31\n    prime[19] = 31\n    prime[20] = 31\n    prime[21] = 31\n\
    \    prime[22] = 31\n    prime[23] = 31\n    prime[24] = 31\n    prime[25] = 31\n\
    \    prime[26] = 31\n    prime[27] = 31\n    prime[28] = 31\n    prime[29] = 31\n\
    \    prime[30] = 31\n    prime[31] = 31\n    prime[32] = 31\n    prime[33] = 31\n\
    \    prime[34] = 31\n    prime[35] = 31\n    prime[36] = 31\n    prime[37] = 31\n\
    \    prime[38] = 31\n    prime[39] = 31\n    prime[40] = 31\n    prime[41] = 31\n\
    \    prime[42] = 31\n    prime[43] = 31\n    prime[44] = 31\n    prime[45] = 31\n\
    \    prime[46] = 31\n    prime[47] = 31\n    prime[48] = 31\n    prime[49] = 31\n\
    \    prime[50] = 31\n    prime[51] = 31\n    prime[52] = 31\n    prime[53] = 31\n\
    \    prime[54] = 31\n    prime[55] = 31\n    prime[56] = 31\n    prime[57] = 31\n\
    \    prime[58] = 31\n    prime[59] = 31\n    prime[60] = 31\n    prime[61] = 31\n\
    \    prime[62] = 31\n    prime[63] = 31\n    prime[64] = 31\n    prime[65] = 31\n\
    \    prime[66] = 31\n\nfunc TestHex_Key(t *testing.T) {\n  candidate := hex_key\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"AB\"), expected: 1 },\n     {\
    \ actual: candidate(\"1077E\"), expected: 2 },\n     { actual: candidate(\"ABED1A33\"\
    ), expected: 4 },\n     { actual: candidate(\"2020\"), expected: 2 },\n     {\
    \ actual: candidate(\"123456789ABCDEF0\"), expected: 6 },\n     { actual: candidate(\"\
    112233445566778899AABBCCDDEEFF00\"), expected: 12 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpn113atsk_test.go:100:6: expected ''('', found TestHex_Key

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074576
- exit_code: 2
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    num\
    \ := strings.ToUpper(num)\n    n := len(num)\n    result := 0\n    for i := 0;\
    \ i < n; i++ {\n        digit := int(num[i])\n        if digit == 0 {\n      \
    \      continue\n        }\n        result += (digit % 10) * primes[digit]\n \
    \   }\n    return result\n}\n\nfunc TestHex_Key(t *testing.T) {\n  candidate :=\
    \ hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AB\"), expected: 1 },\n \
    \    { actual: candidate(\"1077E\"), expected: 2 },\n     { actual: candidate(\"\
    ABED1A33\"), expected: 4 },\n     { actual: candidate(\"2020\"), expected: 2 },\n\
    \     { actual: candidate(\"123456789ABCDEF0\"), expected: 6 },\n     { actual:\
    \ candidate(\"112233445566778899AABBCCDDEEFF00\"), expected: 12 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfa9g8uhp_test.go:30:9: no new variables on left side of :=

    /tmp/tmpfa9g8uhp_test.go:30:12: undefined: strings

    /tmp/tmpfa9g8uhp_test.go:38:34: undefined: primes

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074690
- exit_code: 2
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    var\
    \ count int\n    for _, r := range num {\n        count += int(unicode.ToLower(r)\
    \ - '0')\n    }\n    return count\n}\n\nfunc TestHex_Key(t *testing.T) {\n  candidate\
    \ := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AB\"), expected: 1 },\n \
    \    { actual: candidate(\"1077E\"), expected: 2 },\n     { actual: candidate(\"\
    ABED1A33\"), expected: 4 },\n     { actual: candidate(\"2020\"), expected: 2 },\n\
    \     { actual: candidate(\"123456789ABCDEF0\"), expected: 6 },\n     { actual:\
    \ candidate(\"112233445566778899AABBCCDDEEFF00\"), expected: 12 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpm0f6wrmz_test.go:32:22: undefined: unicode

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074577
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    num\
    \ := strings.ToUpper(num)\n    num := strings.Replace(num, \"A\", \"10\", -1)\n\
    \    num := strings.Replace(num, \"B\", \"11\", -1)\n    num := strings.Replace(num,\
    \ \"C\", \"12\", -1)\n    num := strings.Replace(num, \"D\", \"13\", -1)\n   \
    \ num := strings.Replace(num, \"E\", \"14\", -1)\n    num := strings.Replace(num,\
    \ \"F\", \"15\", -1)\n    num := strings.Replace(num, \"0\", \"10\", -1)\n   \
    \ num := strings.Replace(num, \"1\", \"11\", -1)\n    num := strings.Replace(num,\
    \ \"2\", \"12\", -1)\n    num := strings.Replace(num, \"3\", \"13\", -1)\n   \
    \ num := strings.Replace(num, \"4\", \"14\", -1)\n    num := strings.Replace(num,\
    \ \"5\", \"15\", -1)\n    num := strings.Replace(num, \"6\", \"16\", -1)\n   \
    \ num := strings.Replace(num, \"7\", \"17\", -1)\n    num := strings.Replace(num,\
    \ \"8\", \"18\", -1)\n    num := strings.Replace(num, \"9\", \"19\", -1)\n   \
    \ num := strings.Replace(num, \"+\", \"-\", -1)\n    num := strings.Replace(num,\
    \ \"-\", \"+\", -1)\n    num := strings.Replace(num, \".\", \"0\", -1)\n    num\
    \ := strings.Replace(num, \"/\", \"0\", -1)\n    num := strings.Replace(num, \"\
    0\", \"0\", -1)\n    num := strings.Replace(num, \"1\", \"1\", -1)\n    num :=\
    \ strings.Replace(num, \"2\", \"2\", -1)\n    num := strings.Replace(num, \"3\"\
    , \"3\", -1)\n    num := strings.Replace(num, \"4\", \"4\", -1)\n    num := strings.Replace(num,\
    \ \"5\", \"5\", -1)\n    num := strings.Replace(num, \"6\", \"6\", -1)\n    num\
    \ := strings.Replace(num, \"7\", \"7\", -1)\n    num := strings.Replace(num, \"\
    8\", \"8\", -1)\n    num := strings.Replace(num, \"9\", \"9\", -1)\n    num :=\
    \ strings.Replace(num, \"*\", \"0\", -1)\n    num := strings.Replace(num, \"/\"\
    , \"0\", -1)\n    num := strings.Replace(num, \"0\", \"0\", -1)\n    num := strings.Replace(num,\
    \ \"1\", \"1\", -1)\n    num := strings.Replace(num, \"2\", \"2\", -1)\n    num\
    \ := strings.Replace(num, \"3\", \"3\", -1)\n    num := strings.Replace(num, \"\
    4\", \"4\", -1)\n    num := strings.Replace(num, \"5\", \"5\", -1)\n    num :=\
    \ strings.Replace(num, \"6\", \"6\", -1)\n    num := strings.Replace(num, \"7\"\
    , \"7\", -1)\n    num := \nfunc TestHex_Key(t *testing.T) {\n  candidate := hex_key\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"AB\"), expected: 1 },\n     {\
    \ actual: candidate(\"1077E\"), expected: 2 },\n     { actual: candidate(\"ABED1A33\"\
    ), expected: 4 },\n     { actual: candidate(\"2020\"), expected: 2 },\n     {\
    \ actual: candidate(\"123456789ABCDEF0\"), expected: 6 },\n     { actual: candidate(\"\
    112233445566778899AABBCCDDEEFF00\"), expected: 12 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpd2nw0pos_test.go:72:6: expected ''('', found TestHex_Key

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074686
- exit_code: 2
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    num\
    \ := strings.ToUpper(num)\n    count := 0\n    for _, v := range num {\n     \
    \   if v == 'A' || v == 'B' || v == 'C' || v == 'D' || v == 'E' || v == 'F' {\n\
    \            count++\n        }\n    }\n    return count\n}\n\nfunc TestHex_Key(t\
    \ *testing.T) {\n  candidate := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AB\"), expected: 1 },\n     { actual: candidate(\"1077E\"), expected: 2 },\n \
    \    { actual: candidate(\"ABED1A33\"), expected: 4 },\n     { actual: candidate(\"\
    2020\"), expected: 2 },\n     { actual: candidate(\"123456789ABCDEF0\"), expected:\
    \ 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"), expected:\
    \ 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp88q38rvw_test.go:30:9: no new variables on left side of :=

    /tmp/tmp88q38rvw_test.go:30:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074577
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    num\
    \ := strings.ToUpper(num)\n    num := strings.Replace(num, \"A\", \"10\", -1)\n\
    \    num := strings.Replace(num, \"B\", \"11\", -1)\n    num := strings.Replace(num,\
    \ \"C\", \"12\", -1)\n    num := strings.Replace(num, \"D\", \"13\", -1)\n   \
    \ num := strings.Replace(num, \"E\", \"14\", -1)\n    num := strings.Replace(num,\
    \ \"F\", \"15\", -1)\n    num := strings.Replace(num, \"0\", \"1\", -1)\n    num\
    \ := strings.Replace(num, \"1\", \"2\", -1)\n    num := strings.Replace(num, \"\
    2\", \"3\", -1)\n    num := strings.Replace(num, \"3\", \"4\", -1)\n    num :=\
    \ strings.Replace(num, \"4\", \"5\", -1)\n    num := strings.Replace(num, \"5\"\
    , \"6\", -1)\n    num := strings.Replace(num, \"6\", \"7\", -1)\n    num := strings.Replace(num,\
    \ \"7\", \"8\", -1)\n    num := strings.Replace(num, \"8\", \"9\", -1)\n    num\
    \ := strings.Replace(num, \"9\", \"10\", -1)\n    num := strings.Replace(num,\
    \ \"10\", \"11\", -1)\n    num := strings.Replace(num, \"11\", \"12\", -1)\n \
    \   num := strings.Replace(num, \"12\", \"13\", -1)\n    num := strings.Replace(num,\
    \ \"13\", \"14\", -1)\n    num := strings.Replace(num, \"14\", \"15\", -1)\n \
    \   num := strings.Replace(num, \"15\", \"16\", -1)\n    num := strings.Replace(num,\
    \ \"16\", \"17\", -1)\n    num := strings.Replace(num, \"17\", \"18\", -1)\n \
    \   num := strings.Replace(num, \"18\", \"19\", -1)\n    num := strings.Replace(num,\
    \ \"19\", \"20\", -1)\n    num := strings.Replace(num, \"20\", \"21\", -1)\n \
    \   num := strings.Replace(num, \"21\", \"22\", -1)\n    num := strings.Replace(num,\
    \ \"22\", \"23\", -1)\n    num := strings.Replace(num, \"23\", \"24\", -1)\n \
    \   num := strings.Replace(num, \"24\", \"25\", -1)\n    num := strings.Replace(num,\
    \ \"25\", \"26\", -1)\n    num := strings.Replace(num, \"26\", \"27\", -1)\n \
    \   num := strings.Replace(num, \"27\", \"28\", -1)\n    num := strings.Replace(num,\
    \ \"28\", \"29\", -1)\n    num := strings.Replace(num, \"29\", \"30\", -1)\n \
    \   num := strings.Replace(num, \"30\", \"31\", -1)\n    num := strings.Replace(num,\
    \ \"31\", \"32\", -1)\n    num := strings.Replace(num, \"32\", \"33\", -1)\n \
    \   num := strings.\nfunc TestHex_Key(t *testing.T) {\n  candidate := hex_key\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"AB\"), expected: 1 },\n     {\
    \ actual: candidate(\"1077E\"), expected: 2 },\n     { actual: candidate(\"ABED1A33\"\
    ), expected: 4 },\n     { actual: candidate(\"2020\"), expected: 2 },\n     {\
    \ actual: candidate(\"123456789ABCDEF0\"), expected: 6 },\n     { actual: candidate(\"\
    112233445566778899AABBCCDDEEFF00\"), expected: 12 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpxyevmdnl_test.go:71:1: expected selector or type assertion, found ''func''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074589
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    num\
    \ := strings.ToUpper(num)\n    num := strings.TrimSpace(num)\n    num := strings.Replace(num,\
    \ \"A\", \"1\", -1)\n    num := strings.Replace(num, \"B\", \"2\", -1)\n    num\
    \ := strings.Replace(num, \"C\", \"3\", -1)\n    num := strings.Replace(num, \"\
    D\", \"4\", -1)\n    num := strings.Replace(num, \"E\", \"5\", -1)\n    num :=\
    \ strings.Replace(num, \"F\", \"6\", -1)\n    num := strings.Replace(num, \"0\"\
    , \"7\", -1)\n    num := strings.Replace(num, \"1\", \"8\", -1)\n    num := strings.Replace(num,\
    \ \"2\", \"9\", -1)\n    num := strings.Replace(num, \"3\", \"A\", -1)\n    num\
    \ := strings.Replace(num, \"4\", \"B\", -1)\n    num := strings.Replace(num, \"\
    5\", \"C\", -1)\n    num := strings.Replace(num, \"6\", \"D\", -1)\n    num :=\
    \ strings.Replace(num, \"7\", \"E\", -1)\n    num := strings.Replace(num, \"8\"\
    , \"F\", -1)\n    num := strings.Replace(num, \"9\", \"0\", -1)\n    num := strings.Replace(num,\
    \ \"+\", \"-\", -1)\n    num := strings.Replace(num, \"/\", \"*\", -1)\n    num\
    \ := strings.Replace(num, \"=\", \"+\", -1)\n    num := strings.Replace(num, \"\
    -\", \"*\", -1)\n    num := strings.Replace(num, \"*\", \"/\", -1)\n    num :=\
    \ strings.Replace(num, \"%\", \"%\", -1)\n    num := strings.Replace(num, \"(\"\
    , \"\", -1)\n    num := strings.Replace(num, \")\", \"\", -1)\n    num := strings.Replace(num,\
    \ \".\", \"\", -1)\n    num := strings.Replace(num, \"-\", \"\", -1)\n    num\
    \ := strings.Replace(num, \"+\", \"\", -1)\n    num := strings.Replace(num, \"\
    /\", \"\", -1)\n    num := strings.Replace(num, \"*\", \"\", -1)\n    num := strings.Replace(num,\
    \ \"%\", \"\", -1)\n    num := strings.Replace(num, \"=\", \"\", -1)\n    num\
    \ := strings.Replace(num, \"-\", \"\", -1)\n    num := strings.Replace(num, \"\
    +\", \"\", -1)\n    num := strings.Replace(num, \"/\", \"\", -1)\n    num := strings.Replace(num,\
    \ \"*\", \"\", -1)\n    num := strings.Replace(num, \"%\", \"\", -1)\n    num\
    \ := strings.Replace(num, \"(\", \"\", -1)\n    num := strings.Replace(num, \"\
    )\", \"\", -1)\n    num := strings.Replace(num, \".\", \"\", -1)\n    num := strings.Replace(num,\
    \ \"-\", \"\", -1)\n    \nfunc TestHex_Key(t *testing.T) {\n  candidate := hex_key\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"AB\"), expected: 1 },\n     {\
    \ actual: candidate(\"1077E\"), expected: 2 },\n     { actual: candidate(\"ABED1A33\"\
    ), expected: 4 },\n     { actual: candidate(\"2020\"), expected: 2 },\n     {\
    \ actual: candidate(\"123456789ABCDEF0\"), expected: 6 },\n     { actual: candidate(\"\
    112233445566778899AABBCCDDEEFF00\"), expected: 12 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpxihannn2_test.go:73:6: expected ''('', found TestHex_Key

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074690
- exit_code: 1
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    //\
    \ Your code here\n    \n    return 0\n}\n\nfunc TestHex_Key(t *testing.T) {\n\
    \  candidate := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AB\"\
    ), expected: 1 },\n     { actual: candidate(\"1077E\"), expected: 2 },\n     {\
    \ actual: candidate(\"ABED1A33\"), expected: 4 },\n     { actual: candidate(\"\
    2020\"), expected: 2 },\n     { actual: candidate(\"123456789ABCDEF0\"), expected:\
    \ 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"), expected:\
    \ 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestHex_Key (0.00s)\n    --- FAIL: TestHex_Key/test_num__0 (0.00s)\n\
    \        tmpcshf94km_test.go:53: expected '%!s(int=1)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestHex_Key/test_num__1 (0.00s)\n        tmpcshf94km_test.go:53: expected\
    \ '%!s(int=2)', got '%!s(int=0)'\n    --- FAIL: TestHex_Key/test_num__2 (0.00s)\n\
    \        tmpcshf94km_test.go:53: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestHex_Key/test_num__3 (0.00s)\n        tmpcshf94km_test.go:53: expected\
    \ '%!s(int=2)', got '%!s(int=0)'\n    --- FAIL: TestHex_Key/test_num__4 (0.00s)\n\
    \        tmpcshf94km_test.go:53: expected '%!s(int=6)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestHex_Key/test_num__5 (0.00s)\n        tmpcshf94km_test.go:53: expected\
    \ '%!s(int=12)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074578
- exit_code: 2
  program: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You have been tasked to write a function that receives \n// a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n// digits that are primes\
    \ (prime number, or a prime, is a natural number \n// greater than 1 that is not\
    \ a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7,\
    \ 11, 13, 17,...\n// So you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume\
    \ the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are\
    \ always uppercase.\n// Examples:\n// >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"\
    1077E\")\n// 2\n// >>> hex_key(\"ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\"\
    )\n// 6\n// >>> hex_key(\"2020\")\n// 2\nfunc hex_key(num string) int {\n    num\
    \ := strings.ToUpper(num)\n    count := 0\n    for _, v := range num {\n     \
    \   if v == 'A' || v == 'B' || v == 'C' || v == 'D' || v == 'E' || v == 'F' {\n\
    \            count++\n        }\n    }\n    return count\n}\n\nfunc TestHex_Key(t\
    \ *testing.T) {\n  candidate := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AB\"), expected: 1 },\n     { actual: candidate(\"1077E\"), expected: 2 },\n \
    \    { actual: candidate(\"ABED1A33\"), expected: 4 },\n     { actual: candidate(\"\
    2020\"), expected: 2 },\n     { actual: candidate(\"123456789ABCDEF0\"), expected:\
    \ 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"), expected:\
    \ 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp88q38rvw_test.go:30:9: no new variables on left side of :=

    /tmp/tmp88q38rvw_test.go:30:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074577
