language: go_test.go
name: HumanEval_10_make_palindrome
results:
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        longestPalindromeLen := longestPalindromeLen + 1\n        longestPalindrome\
    \ += myString[i]\n    }\n    longestPalindrome += myString[:longestPalindromeLen]\n\
    \    longestPalindromeLen -= len(longestPalindrome)\n    longestPalindrome = longestPalindrome[:longestPalindromeLen]\n\
    \    for i := 0; i < len(longestPalindrome); i++ {\n        longestPalindromeLen\
    \ := longestPalindromeLen + 1\n        longestPalindrome += myString[len(myString)-1-i]\n\
    \    }\n    longestPalindrome += myString[:longestPalindromeLen]\n    return longestPalindrome\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkrf8u69f_test.go:22:9: longestPalindromeLen declared but not used

    /tmp/tmpkrf8u69f_test.go:23:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    /tmp/tmpkrf8u69f_test.go:29:9: longestPalindromeLen declared but not used

    /tmp/tmpkrf8u69f_test.go:30:9: invalid operation: longestPalindrome += myString[len(myString)
    - 1 - i] (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075542
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm\
    \ idea is simple:\n    // - Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    longestPalindrome := \"\
    \"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++ {\n\
    \        postfix := myString[0 : len(myString)-i]\n        postfix += string(myString[len(myString)-i:]\
    \ + string(myString[0:len(myString)-i]))\n        \n        // Check if postfix\
    \ is a palindrome.\n        if isPalindrome(postfix) {\n            longestPalindrome\
    \ = postfix\n            longestPalindromeLen = len(postfix)\n        }\n    }\n\
    \    \n    // Append to the end of the string reverse of a string prefix that\
    \ comes before the palindromic suffix.\n    prefix := myString[0:longestPalindromeLen]\n\
    \    prefix += string(myString[longestPalindromeLen:] + string(myString[0:longestPalindromeLen]))\n\
    \    \n    // Return the palindrome string.\n    return prefix + longestPalindrome\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpzy26df5p_test.go:38:12: undefined: isPalindrome

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075542
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm\
    \ idea is simple:\n    // - Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    longestPalindrome := \"\
    \"\n    longestPalindromeLen := 0\n    for i := len(myString) - 1; i >= 0; i--\
    \ {\n        postfix := myString[:i+1]\n        postfix += myString[len(myString)-i:len(myString)]\n\
    \        if postfix != myString {\n            longestPalindrome = postfix\n \
    \           longestPalindromeLen = len(postfix)\n        }\n    }\n    // Append\
    \ to the end of the string reverse of a string prefix that comes before the palindromic\
    \ suffix.\n    prefix := myString[:longestPalindromeLen]\n    prefix += myString[len(myString)-longestPalindromeLen:]\n\
    \    return prefix + longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMake_Palindrome (0.00s)\n    --- FAIL: TestMake_Palindrome/test_num__1\
    \ (0.00s)\n        tmpmgvd17p9_test.go:56: expected 'x', got ''\n    --- FAIL:\
    \ TestMake_Palindrome/test_num__2 (0.00s)\n        tmpmgvd17p9_test.go:56: expected\
    \ 'xyzyx', got 'xzx'\n    --- FAIL: TestMake_Palindrome/test_num__3 (0.00s)\n\
    \        tmpmgvd17p9_test.go:56: expected 'xyx', got 'xxx'\n    --- FAIL: TestMake_Palindrome/test_num__4\
    \ (0.00s)\n        tmpmgvd17p9_test.go:56: expected 'jerryrrej', got 'jyj'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660075543
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLength := 0\n    for i := len(myString) - 1; i\
    \ >= 0; i-- {\n        prefix := myString[:i]\n        suffix := myString[i+1:]\n\
    \        postfix := reverseString(prefix)\n        if suffix == postfix {\n  \
    \          longestPalindrome = prefix + postfix\n            longestPalindromeLength\
    \ = i + 1\n        }\n    }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmppiuham78_test.go:20:5: longestPalindromeLength declared but not used

    /tmp/tmppiuham78_test.go:24:20: undefined: reverseString

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075542
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        prefix := myString[:i]\n        suffix := myString[i:]\n        longestPalindromeLen\
    \ := len(longestPalindrome)\n        if longestPalindromeLen > len(prefix) + len(suffix)\
    \ {\n            longestPalindrome = prefix\n        }\n        longestPalindrome\
    \ = longestPalindrome + suffix\n    }\n    return longestPalindrome\n}\n\nfunc\
    \ TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual:\
    \ candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected:\
    \ \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n    \
    \ { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpei6ea8e8_test.go:20:5: longestPalindromeLen declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075542
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := len(myString) - 1; i >=\
    \ 0; i-- {\n        postfix := myString[:i+1]\n        if isPalindrome(postfix)\
    \ {\n            longestPalindrome = postfix\n            longestPalindromeLen\
    \ = len(postfix)\n        }\n    }\n\n    // Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    prefix :=\
    \ myString[:longestPalindromeLen]\n    return prefix + reverse(prefix)\n}\n\n\
    func TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual:\
    \ candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected:\
    \ \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n    \
    \ { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpa0690hmz_test.go:20:5: longestPalindrome declared but not used

    /tmp/tmpa0690hmz_test.go:24:12: undefined: isPalindrome

    /tmp/tmpa0690hmz_test.go:32:21: undefined: reverse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075542
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    longestPalindrome\
    \ := \"\"\n    for i := len(myString) - 1; i >= 0; i-- {\n        longestPalindrome\
    \ += myString[i]\n    }\n    // Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    longestPalindrome += myString[len(longestPalindrome):]\n\
    \    // Return palindrome string.\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpg3irkaw1_test.go:22:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075542
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := len(myString) - 1; i >=\
    \ 0; i-- {\n        postfix := myString[:i+1]\n        if isPalindrome(postfix)\
    \ {\n            longestPalindrome = longestPalindrome + postfix\n           \
    \ longestPalindromeLen = len(longestPalindrome)\n        }\n    }\n\n    // Append\
    \ to the end of the string reverse of a string prefix that comes before the palindromic\
    \ suffix.\n    prefix := myString[:longestPalindromeLen]\n    return prefix +\
    \ reverseString(prefix)\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate\
    \ := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual:\
    \ candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"\
    ), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpwaft_s4a_test.go:24:12: undefined: isPalindrome

    /tmp/tmpwaft_s4a_test.go:32:21: undefined: reverseString

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075542
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    var\
    \ myStringLen int = len(myString)\n    var myStringPrefix string\n    var myStringSuffix\
    \ string\n    var myStringPalindrome string\n\n    // Find the longest postfix\
    \ of supplied string that is a palindrome.\n    for i := 0; i < myStringLen; i++\
    \ {\n        if myString[i] == myString[myStringLen-1] {\n            myStringPrefix\
    \ = myString[:i]\n            myStringSuffix = myString[i:]\n            myStringPalindrome\
    \ = myStringPrefix + myStringSuffix\n            break\n        }\n    }\n\n \
    \   // Append to the end of the string reverse of a string prefix that comes before\
    \ the palindromic suffix.\n    myStringPalindrome += myString[myStringLen-1:]\
    \ + myStringPrefix\n    return myStringPalindrome\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMake_Palindrome (0.00s)\npanic: runtime error: slice bounds\
    \ out of range [-1:] [recovered]\n\tpanic: runtime error: slice bounds out of\
    \ range [-1:]\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440, 0xc000014360})\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.make_palindrome(...)\n\t/tmp/tmpacnxcotn_test.go:35\n\
    command-line-arguments_test.TestMake_Palindrome(0x0?)\n\t/tmp/tmpacnxcotn_test.go:46\
    \ +0x1c\ntesting.tRunner(0xc0001a01a0, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075543
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLength := 0\n    for i := 0; i < len(myString);\
    \ i++ {\n        longestPalindromeLength = 0\n        for j := 0; j < i; j++ {\n\
    \            if myString[j] != myString[j+i] {\n                longestPalindromeLength++\n\
    \                break\n            }\n        }\n        if longestPalindromeLength\
    \ > longestPalindromeLength {\n            longestPalindrome = myString[:i]\n\
    \            longestPalindromeLength = i\n        }\n    }\n    return longestPalindrome\
    \ + myString[len(longestPalindrome):]\n}\n\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMake_Palindrome (0.00s)\npanic: runtime error: index out\
    \ of range [3] with length 3 [recovered]\n\tpanic: runtime error: index out of\
    \ range [3] with length 3\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.make_palindrome(...)\n\t/tmp/tmp2a7jp0m1_test.go:24\n\
    command-line-arguments_test.TestMake_Palindrome(0x0?)\n\t/tmp/tmp2a7jp0m1_test.go:47\
    \ +0x465\ntesting.tRunner(0xc0001a0340, 0x527f60)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075543
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm\
    \ idea is simple:\n    // - Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    var longestPalindrome\
    \ string\n    for i := 0; i < len(myString); i++ {\n        longestPalindrome\
    \ += myString[i]\n    }\n    \n    // Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    for i := 0;\
    \ i < len(myString); i++ {\n        if myString[i] != longestPalindrome[len(longestPalindrome)-i:]\
    \ {\n            longestPalindrome += myString[len(myString)-i:len(myString)-i+1]\n\
    \            break\n        }\n    }\n    \n    return longestPalindrome\n}\n\n\
    func TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual:\
    \ candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected:\
    \ \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n    \
    \ { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpe_afcx76_test.go:33:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    /tmp/tmpe_afcx76_test.go:38:44: invalid operation: myString[i] != longestPalindrome[len(longestPalindrome)
    - i:] (mismatched types byte and string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075542
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := len(myString) - 1; i >=\
    \ 0; i-- {\n        prefix := myString[:i]\n        suffix := myString[i+1:]\n\
    \        postfix := reversePostfix(prefix)\n        if postfix != suffix {\n \
    \           longestPalindrome = prefix + postfix\n            longestPalindromeLen\
    \ = len(longestPalindrome)\n        }\n    }\n    return longestPalindrome\n}\n\
    \nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmpjfe3hp_test.go:20:5: longestPalindromeLen declared but not used

    /tmp/tmpmpjfe3hp_test.go:24:20: undefined: reversePostfix

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075542
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm\
    \ idea is simple:\n    // - Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    // >>> make_palindrome(\"\")\n    // \"\"\
    \n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"\
    cata\")\n    // \"catac\"\n    \n    // Find the longest postfix of supplied string\
    \ that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // - Append to the end\
    \ of the string reverse of a string prefix that comes before the palindromic suffix.\n\
    \    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"\
    cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\
    \n    \n    // Find the longest postfix of supplied string that is a palindrome.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string \nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpn1otdhwh_test.go:67:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075439
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find longest postfix of myString that is a palindrome.\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        prefix := myString[:i]\n        postfix := myString[i:]\n       \
    \ if isPalindrome(prefix, postfix) {\n            longestPalindrome = prefix +\
    \ reverseString(postfix)\n            longestPalindromeLen = len(longestPalindrome)\n\
    \        }\n    }\n    if longestPalindromeLen > 0 {\n        // Append to the\
    \ end of the string reverse of a string prefix that comes before the palindromic\
    \ suffix.\n        result := myString\n        for i := 0; i < longestPalindromeLen;\
    \ i++ {\n            result = result + longestPalindrome[longestPalindromeLen-i:]\n\
    \        }\n        return result\n    }\n    return \"\"\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1tk3cro__test.go:25:12: undefined: isPalindrome

    /tmp/tmp1tk3cro__test.go:26:42: undefined: reverseString

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075542
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := len(myString) - 1; i >=\
    \ 0; i-- {\n        prefix := myString[:i]\n        postfix := myString[i:]\n\
    \        postfix += strings.Reverse(prefix)\n        postfix += prefix\n     \
    \   postfix += strings.Reverse(postfix)\n        postfix += postfix\n        postfix\
    \ += strings.Reverse(postfix)\n        postfix += postfix\n        postfix +=\
    \ strings.Reverse(postfix)\n        postfix += postfix\n        postfix += strings.Reverse(postfix)\n\
    \        postfix += postfix\n        postfix += strings.Reverse(postfix)\n   \
    \     postfix += postfix\n        postfix += strings.Reverse(postfix)\n      \
    \  postfix += postfix\n        postfix += strings.Reverse(postfix)\n        postfix\
    \ += postfix\n        postfix += strings.Reverse(postfix)\n        postfix +=\
    \ postfix\n        postfix += strings.Reverse(postfix)\n        postfix += postfix\n\
    \        postfix += strings.Reverse(postfix)\n        postfix += postfix\n   \
    \     postfix += strings.Reverse(postfix)\n        postfix += postfix\n      \
    \  postfix += strings.Reverse(postfix)\n        postfix += postfix\n        postfix\
    \ += strings.Reverse(postfix)\n        postfix += postfix\n        postfix +=\
    \ strings.Reverse(postfix)\n        postfix += postfix\n        postfix += strings.Reverse(postfix)\n\
    \        postfix += postfix\n        postfix += strings.Reverse(postfix)\n   \
    \     postfix += postfix\n        postfix += strings.Reverse(postfix)\n      \
    \  postfix += postfix\n        postfix += strings.Reverse(postfix)\n        postfix\
    \ += postfix\n        postfix += strings.Reverse(postfix)\n        postfix +=\
    \ postfix\n        postfix += strings.Reverse(postfix)\n        postfix += postfix\n\
    \        postfix += strings.Reverse(postfix)\n        postfix += postfix\n   \
    \     postfix += strings.Reverse(postfix)\n        postfix += postfix\n      \
    \  postfix += strings.Reverse(postfix)\n        postfix += postfix\n        postfix\
    \ += strings.Reverse(postfix)\n        postfix += postfix\n        postfix +=\
    \ strings.Reverse(postfix)\n        postfix += postfix\n        postfix += strings.Reverse(postfix)\n\
    \        postfix += postfix\n        postfix += strings.Reverse(postfix)\n   \
    \     postfix += postfix\n        postfix += strings.Reverse(postfix)\n      \
    \  postfix += postfix\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate :=\
    \ make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual:\
    \ candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"\
    ), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpwzndhkzp_test.go:82:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075541
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        postfix := myString[i:]\n        postfix += myString[:i]\n      \
    \  postfix += myString[:len(myString)-i]\n        postfix += myString[len(myString)-1-i:]\n\
    \        postfix += myString[len(myString)-2-i:]\n        postfix += myString[len(myString)-3-i:]\n\
    \        postfix += myString[len(myString)-4-i:]\n        postfix += myString[len(myString)-5-i:]\n\
    \        postfix += myString[len(myString)-6-i:]\n        postfix += myString[len(myString)-7-i:]\n\
    \        postfix += myString[len(myString)-8-i:]\n        postfix += myString[len(myString)-9-i:]\n\
    \        postfix += myString[len(myString)-10-i:]\n        postfix += myString[len(myString)-11-i:]\n\
    \        postfix += myString[len(myString)-12-i:]\n        postfix += myString[len(myString)-13-i:]\n\
    \        postfix += myString[len(myString)-14-i:]\n        postfix += myString[len(myString)-15-i:]\n\
    \        postfix += myString[len(myString)-16-i:]\n        postfix += myString[len(myString)-17-i:]\n\
    \        postfix += myString[len(myString)-18-i:]\n        postfix += myString[len(myString)-19-i:]\n\
    \        postfix += myString[len(myString)-20-i:]\n        postfix += myString[len(myString)-21-i:]\n\
    \        postfix += myString[len(myString)-22-i:]\n        postfix += myString[len(myString)-23-i:]\n\
    \        postfix += myString[len(myString)-24-i:]\n        postfix += myString[len(myString)-25-i:]\n\
    \        postfix += myString[len(myString)-26-i:]\n        postfix += myString[len(myString)-27-i:]\n\
    \        postfix += myString[len(myString)-28-i:]\n        postfix += myString[len(myString)-29-i:]\n\
    \        postfix += myString[len(myString)-30-i:]\n        postfix += myString[len(myString)-31-i:]\n\
    \        postfix += myString[len(myString)-32-i:]\n        postfix += myString[len(myString)-33-i:]\n\
    \        postfix += myString\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate\
    \ := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual:\
    \ candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"\
    ), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmplliqm1mm_test.go:59:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075541
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    longestPalindromeLen := len(myString)\n\
    \    for i := 0; i < longestPalindromeLen; i++ {\n        longestPalindrome +=\
    \ myString[i]\n    }\n    for i := 0; i < longestPalindromeLen; i++ {\n      \
    \  longestPalindrome += myString[len(myString)-i-1]\n    }\n    return longestPalindrome\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpw20hrist_test.go:21:26: no new variables on left side of :=

    /tmp/tmpw20hrist_test.go:23:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    /tmp/tmpw20hrist_test.go:26:9: invalid operation: longestPalindrome += myString[len(myString)
    - i - 1] (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075542
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        prefix := myString[:i]\n        suffix := myString[i:]\n        longestPalindromeLen\
    \ := len(longestPalindrome)\n        longestPalindrome = longestPalindrome + suffix\n\
    \        longestPalindromeLen += len(prefix)\n        if longestPalindromeLen\
    \ > len(myString) {\n            break\n        }\n    }\n    return longestPalindrome\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp937ev6tz_test.go:20:5: longestPalindromeLen declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075542
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    longestPalindromeLen += len(myString)\n\
    \    for i := 0; i < len(myString); i++ {\n        longestPalindrome += myString[i]\n\
    \        longestPalindromeLen += 1\n    }\n    for i := 0; i < longestPalindromeLen;\
    \ i++ {\n        longestPalindrome += myString[len(myString)-i-1]\n    }\n   \
    \ return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate\
    \ := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual:\
    \ candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"\
    ), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpsh3w5fzx_test.go:23:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    /tmp/tmpsh3w5fzx_test.go:27:9: invalid operation: longestPalindrome += myString[len(myString)
    - i - 1] (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075542
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLength := 0\n    longestPalindromeLength := len(myString)\n\
    \    for i := 0; i < longestPalindromeLength; i++ {\n        longestPalindrome\
    \ += myString[i]\n    }\n    for i := 0; i < longestPalindromeLength; i++ {\n\
    \        longestPalindrome += myString[len(myString)-(i+1)]\n    }\n    return\
    \ longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate\
    \ := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual:\
    \ candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"\
    ), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbtzvswkv_test.go:21:29: no new variables on left side of :=

    /tmp/tmpbtzvswkv_test.go:23:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    /tmp/tmpbtzvswkv_test.go:26:9: invalid operation: longestPalindrome += myString[len(myString)
    - (i + 1)] (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075542
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        prefix := myString[:i]\n        suffix := myString[i:]\n        postfix\
    \ := make_palindrome_test(suffix)\n        if postfix != \"\" {\n            longestPalindrome\
    \ = prefix + postfix\n            longestPalindromeLen = len(longestPalindrome)\n\
    \        }\n    }\n    if longestPalindromeLen > 0 {\n        return longestPalindrome\n\
    \    }\n    return \"\"\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate\
    \ := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual:\
    \ candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"\
    ), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5a_xwxw5_test.go:24:20: undefined: make_palindrome_test

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075439
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find longest postfix of myString that is a palindrome.\n    // This will be\
    \ the prefix of the palindrome we want.\n    var longestPalindrome string\n  \
    \  for i := 0; i < len(myString); i++ {\n        // Find the longest postfix of\
    \ myString that is a palindrome.\n        // This will be the prefix of the palindrome\
    \ we want.\n        longestPalindrome += myString[0 : len(myString)-i]\n     \
    \   // Find the longest postfix of myString that is a palindrome.\n        //\
    \ This will be the suffix of the palindrome we want.\n        longestPalindrome\
    \ += myString[len(myString)-i : len(myString)]\n    }\n    // Append to the end\
    \ of the string reverse of a string prefix that comes before the palindromic suffix.\n\
    \    longestPalindrome += myString[len(myString)-len(longestPalindrome):]\n  \
    \  return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n \
    \ candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMake_Palindrome (0.00s)\npanic: runtime error: slice bounds\
    \ out of range [-6:] [recovered]\n\tpanic: runtime error: slice bounds out of\
    \ range [-6:]\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620, 0xc000014360})\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.make_palindrome(...)\n\t/tmp/tmpw_gy4q7w_test.go:31\n\
    command-line-arguments_test.TestMake_Palindrome(0x0?)\n\t/tmp/tmpw_gy4q7w_test.go:44\
    \ +0x6d2\ntesting.tRunner(0xc0001924e0, 0x528f60)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075543
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    longestPalindromeLen := len(myString)\n\
    \    for i := 0; i < longestPalindromeLen; i++ {\n        longestPalindrome +=\
    \ myString[i]\n    }\n    for i := 0; i < longestPalindromeLen; i++ {\n      \
    \  longestPalindrome += myString[len(myString)-i-1]\n    }\n    return longestPalindrome\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpw20hrist_test.go:21:26: no new variables on left side of :=

    /tmp/tmpw20hrist_test.go:23:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    /tmp/tmpw20hrist_test.go:26:9: invalid operation: longestPalindrome += myString[len(myString)
    - i - 1] (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075542
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm\
    \ idea is simple:\n    // - Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    longestPalindrome := \"\
    \"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++ {\n\
    \        postfix := myString[i:]\n        postfix := append(postfix, myString[:i]...)\n\
    \        postfix := append(postfix, myString[len(myString)-i:]...)\n        postfix\
    \ := append(postfix, myString[len(myString)-i:]...)\n        postfix := append(postfix,\
    \ myString[:i]...)\n        postfix := append(postfix, myString[:i]...)\n    \
    \    postfix := append(postfix, myString[:i]...)\n        postfix := append(postfix,\
    \ myString[:i]...)\n        postfix := append(postfix, myString[:i]...)\n    \
    \    postfix := append(postfix, myString[:i]...)\n        postfix := append(postfix,\
    \ myString[:i]...)\n        postfix := append(postfix, myString[:i]...)\n    \
    \    postfix := append(postfix, myString[:i]...)\n        postfix := append(postfix,\
    \ myString[:i]...)\n        postfix := append(postfix, myString[:i]...)\n    \
    \    postfix := append(postfix, myString[:i]...)\n        postfix := append(postfix,\
    \ myString[:i]...)\n        postfix := append(postfix, myString[:i]...)\n    \
    \    postfix := append(postfix, myString[:i]...)\n        postfix := append(postfix,\
    \ myString[:i]...)\n        postfix := append(postfix, myString[:i]...)\n    \
    \    postfix := append(postfix, myString[:i]...)\n        postfix := append(postfix,\
    \ myString[:i]...)\n        postfix := append(postfix, myString[:i]...)\n    \
    \    postfix := append(postfix, myString[:i]...)\n        postfix := append(postfix,\
    \ myString[:i]...)\n        post\nfunc TestMake_Palindrome(t *testing.T) {\n \
    \ candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmplsjibx00_test.go:59:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075446
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    var\
    \ myStringLen int = len(myString)\n    var myStringPrefix string\n    var myStringSuffix\
    \ string\n    var myStringPalindrome string\n    var myStringPalindromeLen int\n\
    \    var myStringPalindromePrefix string\n    var myStringPalindromeSuffix string\n\
    \    var myStringPalindromePalindrome string\n    var myStringPalindromePalindromeLen\
    \ int\n    var myStringPalindromePalindromePrefix string\n    var myStringPalindromePalindromeSuffix\
    \ string\n\n    // Find longest postfix of myString that is a palindrome.\n  \
    \  for i := 0; i < myStringLen; i++ {\n        myStringPrefix = myString[:i]\n\
    \        myStringSuffix = myString[i:]\n        myStringPalindrome = myStringPrefix\
    \ + reverse(myStringSuffix) + myStringSuffix\n        myStringPalindromeLen =\
    \ len(myStringPalindrome)\n        myStringPalindromePrefix = myStringPrefix\n\
    \        myStringPalindromeSuffix = myStringSuffix\n        myStringPalindromePalindrome\
    \ = myStringPalindromePrefix\n        myStringPalindromePalindromeLen = len(myStringPalindromePalindrome)\n\
    \        if myStringPalindromeLen > myStringLen {\n            myStringLen = myStringPalindromeLen\n\
    \            myStringPrefix = myStringPalindromePrefix\n            myStringSuffix\
    \ = myStringPalindromeSuffix\n            myStringPalindrome = myStringPalindromePalindrome\n\
    \            myStringPalindromeLen = len(myStringPalindromePalindrome)\n     \
    \   }\n    }\n    return myStringPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp03g21k81_test.go:27:9: myStringPalindromePalindromeLen declared but not
    used

    /tmp/tmp03g21k81_test.go:28:9: myStringPalindromePalindromePrefix declared but
    not used

    /tmp/tmp03g21k81_test.go:29:9: myStringPalindromePalindromeSuffix declared but
    not used

    /tmp/tmp03g21k81_test.go:35:47: undefined: reverse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075542
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLength := 0\n    for i := 0; i < len(myString);\
    \ i++ {\n        postfix := myString[:i]\n        reversedPostfix := append([]rune(postfix)[len(postfix)-1:0:-1],\
    \ postfix...)\n        longestPalindromeLength = len(longestPalindrome) + len(reversedPostfix)\n\
    \        if longestPalindromeLength > len(longestPalindrome) {\n            longestPalindrome\
    \ = postfix\n        }\n    }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprcm44vvy_test.go:23:68: invalid argument: index -1 (constant of type int)
    must not be negative

    /tmp/tmprcm44vvy_test.go:23:73: cannot use postfix (variable of type string) as
    type []rune in argument to append

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075542
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm\
    \ idea is simple:\n    // - Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    longestPalindrome := \"\
    \"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++ {\n\
    \        postfix := myString[:i]\n        postfix += myString[len(postfix)-i:]\n\
    \        postfix += myString[:len(postfix)-i]\n        postfix += myString[len(postfix)-i:]\n\
    \        postfix += myString[:len(postfix)-i]\n        postfix += myString[len(postfix)-i:]\n\
    \        postfix += myString[:len(postfix)-i]\n        postfix += myString[len(postfix)-i:]\n\
    \        postfix += myString[:len(postfix)-i]\n        postfix += myString[len(postfix)-i:]\n\
    \        postfix += myString[:len(postfix)-i]\n        postfix += myString[len(postfix)-i:]\n\
    \        postfix += myString[:len(postfix)-i]\n        postfix += myString[len(postfix)-i:]\n\
    \        postfix += myString[:len(postfix)-i]\n        postfix += myString[len(postfix)-i:]\n\
    \        postfix += myString[:len(postfix)-i]\n        postfix += myString[len(postfix)-i:]\n\
    \        postfix += myString[:len(postfix)-i]\n        postfix += myString[len(postfix)-i:]\n\
    \        postfix += myString[:len(postfix)-i]\n        postfix += myString[len(postfix)-i:]\n\
    \        postfix += myString[:len(postfix)-i]\n        postfix += myString[len(postfix)-i:]\n\
    \        postfix += myString[:len(postfix)-i]\n        postfix += myString[len(postfix)-i:]\n\
    \        postfix += myString[:len(postfix)-i]\n        postfix += myString[len(postfix)-i:]\n\
    \        postfix += myString[:len(postfix)-i]\n        postfix += myString[len(postfix\n\
    func TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual:\
    \ candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected:\
    \ \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n    \
    \ { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmppylwwpuq_test.go:61:40: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075541
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    var\
    \ myStringLen int = len(myString)\n    var myStringPrefix string\n    var myStringSuffix\
    \ string\n    var myStringReverseSuffix string\n    var myStringReversePrefix\
    \ string\n    var myStringReverseReverseSuffix string\n    var myStringReverseReversePrefix\
    \ string\n    var myStringReverseReverseReverseSuffix string\n    var myStringReverseReverseReversePrefix\
    \ string\n    var myStringReverseReverseReverseSuffix string\n    var myStringReverseReverseReversePrefix\
    \ string\n    var myStringReverseReverseReverseSuffix string\n    var myStringReverseReverseReversePrefix\
    \ string\n    var myStringReverseReverseReverseSuffix string\n    var myStringReverseReverseReversePrefix\
    \ string\n    var myStringReverseReverseReverseSuffix string\n    var myStringReverseReverseReversePrefix\
    \ string\n    var myStringReverseReverseReverseSuffix string\n    var myStringReverseReverseReversePrefix\
    \ string\n    var myStringReverseReverseReverseSuffix string\n    var myStringReverseReverseReversePrefix\
    \ string\n    var myStringReverseReverseReverseSuffix string\n    var myStringReverseReverseReversePrefix\
    \ string\n    var myStringReverseReverseReverseSuffix string\n    var myStringReverseReverseReversePrefix\
    \ string\n    var myStringReverseReverseReverseSuffix string\n    var myStringReverseReverseReversePrefix\
    \ string\n    var myStringReverseReverseReverseSuffix string\n    var myStringReverseReverseReversePrefix\
    \ string\n    var myStringReverseReverseReverseSuffix string\n    var myStringReverseReverseReversePrefix\
    \ string\n    var myStringReverseReverseReverseSuffix string\n    var myStringReverseReverseReversePrefix\
    \ string\n    var myStringReverseReverseReverseSuffix string\n    var myStringReverseReverseReversePrefix\
    \ string\n    var myStringReverseReverseReverseSuffix string\n    var myStringReverseReverseReversePrefix\
    \ string\n    var myStringReverseReverseReverseSuffix string\n    var myStringReverseReverseReversePrefix\
    \ string\n    var myStringReverseReverseReverseSuffix string\n    var myStringReverseReverseReversePrefix\
    \ string\n    var myStringReverseReverseReverseSuffix string\n    var myStringReverseReverseReversePrefix\
    \ string\n    var myStringReverseReverseReverseSuffix string\n    var myStringReverseReverseReversePrefix\
    \ string\n    var myStringReverseReverseReverseSuffix string\n    var myStringReverseReverseReversePrefix\
    \ string\n    var myStringReverseReverseReverseSuffix string\n    var myStringReverseReverseReversePrefix\
    \ string\n    var myStringReverseReverseReverseSuffix string\n    var myStringReverseReverseReversePrefix\
    \ string\n    var myStringReverseReverseReverseSuffix string\n    var myStringReverseReverse\n\
    func TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual:\
    \ candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected:\
    \ \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n    \
    \ { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp7mm6u6iz_test.go:71:9: missing variable type or initialization

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075442
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm\
    \ idea is simple:\n    // - Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    longestPalindrome := \"\
    \"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++ {\n\
    \        postfix := myString[:i]\n        postfix += myString[len(postfix)-i:]\n\
    \        postfix += myString[:len(postfix)-i]\n        postfix += myString[len(postfix)-i:len(postfix)]\n\
    \        postfix += myString[:len(postfix)-i]\n        postfix += myString[len(postfix)-i:len(postfix)]\n\
    \        postfix += myString[:len(postfix)-i]\n        postfix += myString[len(postfix)-i:len(postfix)]\n\
    \        postfix += myString[:len(postfix)-i]\n        postfix += myString[len(postfix)-i:len(postfix)]\n\
    \        postfix += myString[:len(postfix)-i]\n        postfix += myString[len(postfix)-i:len(postfix)]\n\
    \        postfix += myString[:len(postfix)-i]\n        postfix += myString[len(postfix)-i:len(postfix)]\n\
    \        postfix += myString[:len(postfix)-i]\n        postfix += myString[len(postfix)-i:len(postfix)]\n\
    \        postfix += myString[:len(postfix)-i]\n        postfix += myString[len(postfix)-i:len(postfix)]\n\
    \        postfix += myString[:len(postfix)-i]\n        postfix += myString[len(postfix)-i:len(postfix)]\n\
    \        postfix += myString[:len(postfix)-i]\n        postfix += myString[len(postfix)-i:len(postfix)]\n\
    \        postfix += myString[:len(postfix)-i]\n        postfix += myString[len(postfix)-i:len(postfix)]\n\
    \        postfix += myString[:len(postfix)-i]\n        postfix += myString[len(postfix)-i:len(postfix)]\n\
    \        postfix += myString[:len(postfix)\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpqdxrwdzh_test.go:58:42: expected '']'', found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075542
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find longest postfix of myString that is a palindrome.\n    // The longest postfix\
    \ is found by reversing a prefix of myString that comes before a palindromic suffix.\n\
    \    // The prefix is found by finding the longest postfix of myString that is\
    \ a palindrome.\n    // The longest postfix is found by reversing a prefix of\
    \ myString that comes before a palindromic suffix.\n    // The prefix is found\
    \ by finding the longest postfix of myString that is a palindrome.\n    // The\
    \ longest postfix is found by reversing a prefix of myString that comes before\
    \ a palindromic suffix.\n    // The prefix is found by finding the longest postfix\
    \ of myString that is a palindrome.\n    // The longest postfix is found by reversing\
    \ a prefix of myString that comes before a palindromic suffix.\n    // The prefix\
    \ is found by finding the longest postfix of myString that is a palindrome.\n\
    \    // The longest postfix is found by reversing a prefix of myString that comes\
    \ before a palindromic suffix.\n    // The prefix is found by finding the longest\
    \ postfix of myString that is a palindrome.\n    // The longest postfix is found\
    \ by reversing a prefix of myString that comes before a palindromic suffix.\n\
    \    // The prefix is found by finding the longest postfix of myString that is\
    \ a palindrome.\n    // The longest postfix is found by reversing a prefix of\
    \ myString that comes before a palindromic suffix.\n    // The prefix is found\
    \ by finding the longest postfix of myString that is a palindrome.\n    // The\
    \ longest postfix is found by reversing a prefix of myString that comes before\
    \ a palindromic suffix.\n    // The prefix is found by finding the longest postfix\
    \ of myString that is a palindrome.\n    // The longest postfix is found by reversing\
    \ a prefix of myString that comes before a palindromic suffix.\n    // The prefix\
    \ is found by finding the longest postfix of myString that is a palindrome.\n\
    \    // The longest postfix is found by reversing a prefix of myString that comes\
    \ before a palindromic suffix.\n    // The prefix is found by finding the longest\
    \ postfix of myString that is a p\nfunc TestMake_Palindrome(t *testing.T) {\n\
    \  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmprsyq144k_test.go:40:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075542
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        longestPalindromeLen += len(myString) - i\n        longestPalindrome\
    \ += myString[len(myString)-i:] + myString[:len(myString)-i]\n    }\n    longestPalindromeLen\
    \ += len(myString) - longestPalindromeLen\n    longestPalindrome += myString[len(myString)-longestPalindromeLen:]\
    \ + myString[:len(myString)-longestPalindromeLen]\n    return longestPalindrome\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMake_Palindrome (0.00s)\n    --- FAIL: TestMake_Palindrome/test_num__1\
    \ (0.00s)\n        tmp_d2k20rn_test.go:47: expected 'x', got 'xx'\n    --- FAIL:\
    \ TestMake_Palindrome/test_num__2 (0.00s)\n        tmp_d2k20rn_test.go:47: expected\
    \ 'xyzyx', got 'xyzzxyyzxxyz'\n    --- FAIL: TestMake_Palindrome/test_num__3 (0.00s)\n\
    \        tmp_d2k20rn_test.go:47: expected 'xyx', got 'xyxxxyyxxxyx'\n    --- FAIL:\
    \ TestMake_Palindrome/test_num__4 (0.00s)\n        tmp_d2k20rn_test.go:47: expected\
    \ 'jerryrrej', got 'jerryyjerrryjerrryjeerryjjerry'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660075543
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        longestPalindromeLen := longestPalindromeLen + 1\n        longestPalindrome\
    \ += myString[i]\n        longestPalindrome += myString[len(myString)-longestPalindromeLen:]\n\
    \    }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpgoaybr1b_test.go:23:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075543
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    var\
    \ myStringLen int = len(myString)\n    var myStringPrefix string\n    var myStringSuffix\
    \ string\n    var myStringPalindrome string\n    var myStringPalindromeLen int\n\
    \    var myStringPalindromePrefix string\n    var myStringPalindromeSuffix string\n\
    \n    // Find the longest postfix of supplied string that is a palindrome.\n \
    \   for i := 0; i < myStringLen; i++ {\n        myStringPrefix = myString[:i]\n\
    \        myStringSuffix = myString[i:]\n        myStringPalindrome = myStringPrefix\
    \ + myStringSuffix\n        myStringPalindromeLen = len(myStringPalindrome)\n\
    \        if myStringPalindromeLen > myStringLen {\n            break\n       \
    \ }\n    }\n\n    // Append to the end of the string reverse of a string prefix\
    \ that comes before the palindromic suffix.\n    for i := 0; i < myStringLen;\
    \ i++ {\n        myStringPrefix = myString[:i]\n        myStringSuffix = myString[i:]\n\
    \        myStringPalindrome = myStringPrefix + myStringSuffix\n        myStringPalindromeLen\
    \ = len(myStringPalindrome)\n        if myStringPalindromeLen > myStringLen {\n\
    \            break\n        }\n        myStringPalindromePrefix = myStringPalindrome[:myStringLen\
    \ - myStringPalindromeLen]\n        myStringPalindromeSuffix = myStringPalindrome[myStringLen\
    \ - myStringPalindromeLen:]\n        myStringPalindrome = myStringPalindromePrefix\
    \ + myStringPalindromeSuffix\n    }\n\n    return myStringPalindrome\n}\n\nfunc\
    \ TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual:\
    \ candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected:\
    \ \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n    \
    \ { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMake_Palindrome (0.00s)\n    --- FAIL: TestMake_Palindrome/test_num__2\
    \ (0.00s)\n        tmp60zu4yp5_test.go:72: expected 'xyzyx', got 'xyz'\n    ---\
    \ FAIL: TestMake_Palindrome/test_num__4 (0.00s)\n        tmp60zu4yp5_test.go:72:\
    \ expected 'jerryrrej', got 'jerry'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075544
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm\
    \ idea is simple:\n    // - Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    longestPalindrome := \"\
    \"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++ {\n\
    \        longestPalindromeLen += 1 // Increment the length of the longest palindrome\
    \ so far.\n        longestPalindrome += myString[i]\n    }\n    \n    // Append\
    \ to the end of the string reverse of a string prefix that comes before the palindromic\
    \ suffix.\n    longestPalindromeReverse := \"\"\n    for i := 0; i < longestPalindromeLen;\
    \ i++ {\n        longestPalindromeReverse += myString[len(myString)-(i+1)]\n \
    \   }\n    \n    // Return the concatenation of the two strings.\n    return longestPalindrome\
    \ + longestPalindromeReverse\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n\
    \  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpz_df3ikc_test.go:35:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    /tmp/tmpz_df3ikc_test.go:41:9: invalid operation: longestPalindromeReverse +=
    myString[len(myString) - (i + 1)] (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075543
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm\
    \ idea is simple:\n    // - Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    longestPalindrome := \"\
    \"\n    for i := len(myString) - 1; i >= 0; i-- {\n        longestPalindrome +=\
    \ myString[i]\n    }\n    \n    // Append to the end of the string reverse of\
    \ a string prefix that comes before the palindromic suffix.\n    longestPalindrome\
    \ += myString[len(longestPalindrome):]\n    \n    // Return the palindrome string.\n\
    \    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n\
    \  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp74m_qbh7_test.go:33:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075543
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLength := 0\n    for i := 0; i < len(myString);\
    \ i++ {\n        prefix := myString[:i]\n        suffix := myString[i:]\n    \
    \    postfix := reversePostfix(prefix)\n        postfix += suffix\n        postfix\
    \ += reversePostfix(suffix)\n        postfix += prefix\n        postfix += reversePostfix(prefix)\n\
    \        postfix += suffix\n        postfix += reversePostfix(suffix)\n      \
    \  postfix += prefix\n        postfix += suffix\n        postfix += reversePostfix(prefix)\n\
    \        postfix += suffix\n        postfix += reversePostfix(suffix)\n      \
    \  postfix += prefix\n        postfix += suffix\n        postfix += reversePostfix(prefix)\n\
    \        postfix += suffix\n        postfix += reversePostfix(suffix)\n      \
    \  postfix += prefix\n        postfix += suffix\n        postfix += reversePostfix(prefix)\n\
    \        postfix += suffix\n        postfix += reversePostfix(suffix)\n      \
    \  postfix += prefix\n        postfix += suffix\n        postfix += reversePostfix(prefix)\n\
    \        postfix += suffix\n        postfix += reversePostfix(suffix)\n      \
    \  postfix += prefix\n        postfix += suffix\n        postfix += reversePostfix(prefix)\n\
    \        postfix += suffix\n        postfix += reversePostfix(suffix)\n      \
    \  postfix += prefix\n        postfix += suffix\n        postfix += reversePostfix(prefix)\n\
    \        postfix += suffix\n        postfix += reversePostfix(suffix)\n      \
    \  postfix += prefix\n        postfix += suffix\n        postfix += reversePostfix(prefix)\n\
    \        postfix += suffix\n        postfix += reversePostfix(suffix)\n      \
    \  postfix += prefix\n        postfix += suffix\n        postfix += reversePostfix(prefix)\n\
    \        postfix += suffix\n        postfix += reversePostfix(suffix)\n      \
    \  postfix += prefix\n        postfix += suffix\n        postfix += reversePostfix(prefix)\n\
    \        postfix += suffix\n        postfix += reversePostfix(suffix)\n      \
    \  postfix += prefix\n        postfix += suffix\n        postfix += reversePostfix(prefix)\n\
    \        postfix += suffix\n        postfix += reversePostfix(suffix)\n      \
    \  postfix += prefix\n        postfix += suffix\n        post\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpsyvkgf_8_test.go:84:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075543
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := len(myString) - 1; i >=\
    \ 0; i-- {\n        postfix := myString[:i+1]\n        postfix += string(myString[len(myString)-i-1:])\n\
    \        postfix += string(myString[:i])\n        postfix += string(myString[i+1:])\n\
    \        if postfix != make_palindrome(postfix) {\n            longestPalindrome\
    \ = postfix\n            longestPalindromeLen = len(postfix)\n        }\n    }\n\
    \    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n\
    \  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpaiddoq5v_test.go:20:5: longestPalindromeLen declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075544
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm\
    \ idea is simple:\n    // - Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    // >>> make_palindrome(\"\")\n    // \"\"\
    \n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"\
    cata\")\n    // \"catac\"\n    \n    // Find the longest postfix of supplied string\
    \ that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // - Append to the end\
    \ of the string reverse of a string prefix that comes before the palindromic suffix.\n\
    \    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"\
    cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\
    \n    \n    // Find the longest postfix of supplied string that is a palindrome.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string \nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpn1otdhwh_test.go:67:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075439
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm\
    \ idea is simple:\n    // - Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    var longestPalindrome\
    \ string\n    for i := len(myString) - 1; i >= 0; i-- {\n        if myString[i]\
    \ == myString[len(myString)-i-1] {\n            longestPalindrome = myString[:len(myString)-i]\
    \ + myString[len(myString)-i:]\n            break\n        }\n    }\n    \n  \
    \  // Append to the end of the string reverse of a string prefix that comes before\
    \ the palindromic suffix.\n    // >>> make_palindrome(\"\")\n    // \"\"\n   \
    \ // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"\
    cata\")\n    // \"catac\"\n    return longestPalindrome + myString[len(longestPalindrome):]\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMake_Palindrome (0.00s)\n    --- FAIL: TestMake_Palindrome/test_num__2\
    \ (0.00s)\n        tmp1zz19a0f_test.go:66: expected 'xyzyx', got 'xyz'\n    ---\
    \ FAIL: TestMake_Palindrome/test_num__4 (0.00s)\n        tmp1zz19a0f_test.go:66:\
    \ expected 'jerryrrej', got 'jerry'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660075544
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    var\
    \ myPalindrome string = \"\"\n    var myPalindromeLen int = 0\n    var myPalindromePrefix\
    \ string = \"\"\n    var myPalindromeSuffix string = \"\"\n    var myPalindromePostfix\
    \ string = \"\"\n    var myPalindromePostfixLen int = 0\n    var myPalindromePostfixPrefix\
    \ string = \"\"\n    var myPalindromePostfixSuffix string = \"\"\n    var myPalindromePostfixPostfix\
    \ string = \"\"\n    var myPalindromePostfixPostfixLen int = 0\n    var myPalindromePostfixPostfixPrefix\
    \ string = \"\"\n    var myPalindromePostfixPostfixSuffix string = \"\"\n    var\
    \ myPalindromePostfixPostfixPostfix string = \"\"\n    var myPalindromePostfixPostfixPostfixLen\
    \ int = 0\n    var myPalindromePostfixPostfixPostfixPrefix string = \"\"\n   \
    \ var myPalindromePostfixPostfixPostfixSuffix string = \"\"\n    var myPalindromePostfixPostfixPostfixPostfix\
    \ string = \"\"\n    var myPalindromePostfixPostfixPostfixPostfixLen int = 0\n\
    \    var myPalindromePostfixPostfixPostfixPostfixPrefix string = \"\"\n    var\
    \ myPalindromePostfixPostfixPostfixPostfixSuffix string = \"\"\n    var myPalindromePostfixPostfixPostfixPostfixPostfix\
    \ string = \"\"\n    var myPalindromePostfixPostfixPostfixPostfixPostfixLen int\
    \ = 0\n    var myPalindromePostfixPostfixPostfixPostfixPostfixPrefix string =\
    \ \"\"\n    var myPalindromePostfixPostfixPostfixPostfixPostfixSuffix string =\
    \ \"\"\n    var myPalindromePostfixPostfixPostfixPostfixPostfixPostfix string\
    \ = \"\"\n    var myPalindromePostfixPostfixPostfixPostfixPostfixPostfixLen int\
    \ = 0\n    var myPalindromePostfixPostfixPostfixPostfixPostfixPostfixPrefix string\
    \ = \"\"\n    var myPalindromePostfixPostfixPostfixPostfixPostfixPostfixSuffix\
    \ string = \"\"\n    var myPalindromePostfixPostfixPostfixPostfixPostfixPostfixPostfix\
    \ string = \"\"\n    var myPalindromePostfixPostfixPostfixPostfixPostfixPostfixPostfixLen\
    \ int = 0\n    var myPalindromePostfixPostfix\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpmcap6e0d_test.go:49:9: missing variable type or initialization

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075543
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    var\
    \ myStringLen int = len(myString)\n    var myStringPrefix string\n    var myStringSuffix\
    \ string\n    var myStringPalindrome string\n    var myStringPalindromeLen int\n\
    \    var myStringPalindromePrefix string\n    var myStringPalindromeSuffix string\n\
    \    var myStringPalindromePalindrome string\n    var myStringPalindromePalindromeLen\
    \ int\n\n    for i := 0; i < myStringLen; i++ {\n        myStringPrefix = myString[:i]\n\
    \        myStringSuffix = myString[i:]\n        myStringPalindrome = myStringPrefix\
    \ + reverse(myStringSuffix) + myStringSuffix\n        myStringPalindromeLen =\
    \ len(myStringPalindrome)\n        myStringPalindromePrefix = myStringPrefix[:myStringPalindromeLen]\n\
    \        myStringPalindromeSuffix = myStringSuffix[:myStringPalindromeLen]\n \
    \       myStringPalindromePalindrome = myStringPalindromePrefix + reverse(myStringPalindromeSuffix)\
    \ + myStringPalindromeSuffix\n        myStringPalindromePalindromeLen = len(myStringPalindromePalindrome)\n\
    \        if myStringPalindromeLen > myStringLen {\n            return myString\n\
    \        }\n        if myStringPalindromeLen < myStringLen {\n            return\
    \ myStringPalindrome\n        }\n        if myStringPalindromePalindromeLen >\
    \ myStringLen {\n            return myString\n        }\n        if myStringPalindromePalindromeLen\
    \ < myStringLen {\n            return myStringPalindrome\n        }\n    }\n \
    \   return myString\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate\
    \ := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual:\
    \ candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"\
    ), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpolx1qzz2_test.go:32:47: undefined: reverse

    /tmp/tmpolx1qzz2_test.go:36:67: undefined: reverse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075544
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm\
    \ idea is simple:\n    // - Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    // >>> make_palindrome(\"\")\n    // \"\"\
    \n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"\
    cata\")\n    // \"catac\"\n    \n    // Find the longest postfix of supplied string\
    \ that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // - Append to the end\
    \ of the string reverse of a string prefix that comes before the palindromic suffix.\n\
    \    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"\
    cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\
    \n    \n    // Find the longest postfix of supplied string that is a palindrome.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string \nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpn1otdhwh_test.go:67:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075439
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ If string is empty or only contains spaces, return empty string\n    if len(myString)\
    \ == 0 || myString == \" \" {\n        return \"\"\n    }\n\n    // Find longest\
    \ postfix of string that is a palindrome\n    longestPalindrome := \"\"\n    longestPalindromeLen\
    \ := 0\n    for i := len(myString) - 1; i >= 0; i-- {\n        postfix := myString[:i+1]\n\
    \        if postfix != \"\" && isPalindrome(postfix) {\n            longestPalindrome\
    \ = postfix\n            longestPalindromeLen = len(postfix)\n        }\n    }\n\
    \n    // Append reverse of string prefix that comes before the palindromic suffix\n\
    \    prefix := myString[:longestPalindromeLen]\n    return prefix + longestPalindrome\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpc0pu54m9_test.go:29:29: undefined: isPalindrome

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075544
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find longest postfix of myString that is a palindrome.\n    // The longest postfix\
    \ is defined as the longest prefix of myString that is a palindrome.\n    // The\
    \ longest prefix is defined as the longest prefix of myString that is a palindrome.\n\
    \    // The longest prefix of myString that is a palindrome is defined as the\
    \ longest prefix of myString that is a palindrome.\n    // The longest prefix\
    \ of myString that is a palindrome is defined as the longest prefix of myString\
    \ that is a palindrome.\n    // The longest prefix of myString that is a palindrome\
    \ is defined as the longest prefix of myString that is a palindrome.\n    // The\
    \ longest prefix of myString that is a palindrome is defined as the longest prefix\
    \ of myString that is a palindrome.\n    // The longest prefix of myString that\
    \ is a palindrome is defined as the longest prefix of myString that is a palindrome.\n\
    \    // The longest prefix of myString that is a palindrome is defined as the\
    \ longest prefix of myString that is a palindrome.\n    // The longest prefix\
    \ of myString that is a palindrome is defined as the longest prefix of myString\
    \ that is a palindrome.\n    // The longest prefix of myString that is a palindrome\
    \ is defined as the longest prefix of myString that is a palindrome.\n    // The\
    \ longest prefix of myString that is a palindrome is defined as the longest prefix\
    \ of myString that is a palindrome.\n    // The longest prefix of myString that\
    \ is a palindrome is defined as the longest prefix of myString that is a palindrome.\n\
    \    // The longest prefix of myString that is a palindrome is defined as the\
    \ longest prefix of myString that is a palindrome.\n    // The longest prefix\
    \ of myString that is a palindrome is defined as the longest prefix of myString\
    \ that is a palindrome.\n    // The longest prefix of myString that is a palindrome\
    \ is defined as the longest prefix of myString that is a palindrome.\n    // The\
    \ longest prefix of myString that is a palindrome is defined as the longest prefix\
    \ of myString that is a palindrome.\n    // The longest prefix of myString that\
    \ is a palindrome is defined as the longest prefix of myString that is a palindrome.\n\
    \    // The lon\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpkmjdi51k_test.go:38:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075543
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find longest postfix of myString that is a palindrome.\n    // This will be\
    \ the length of the palindrome plus 1.\n    longestPalindrome := 0\n    for i\
    \ := len(myString) - 1; i >= 0; i-- {\n        // If this character is a palindrome,\
    \ then we know that the\n        // length of the palindrome is one more than\
    \ the length of the prefix.\n        // So we know that myString[:i] must be a\
    \ palindrome.\n        if myString[i] == myString[len(myString)-(i+1)] {\n   \
    \         longestPalindrome++\n        }\n    }\n\n    // Append the reverse of\
    \ the string prefix that comes before the palindromic suffix.\n    // This will\
    \ be the length of the palindrome plus 1.\n    longestPalindrome += 1 + len(myString[:longestPalindrome])\n\
    \n    // Return the string that is the palindrome plus the reverse of the string\
    \ prefix.\n    return myString[:longestPalindrome] + string(myString[longestPalindrome:])\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMake_Palindrome (0.00s)\npanic: runtime error: slice bounds\
    \ out of range [:1] with length 0 [recovered]\n\tpanic: runtime error: slice bounds\
    \ out of range [:1] with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.make_palindrome(...)\n\t/tmp/tmpiqjit077_test.go:36\n\
    command-line-arguments_test.TestMake_Palindrome(0x0?)\n\t/tmp/tmpiqjit077_test.go:46\
    \ +0x1a\ntesting.tRunner(0xc0001a0340, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075544
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        longestPalindromeLen := longestPalindromeLen + 1\n        longestPalindrome\
    \ += myString[i]\n    }\n    for i := 0; i < longestPalindromeLen; i++ {\n   \
    \     longestPalindrome += myString[len(myString)-i]\n    }\n    return longestPalindrome\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbs6w6a4o_test.go:22:9: longestPalindromeLen declared but not used

    /tmp/tmpbs6w6a4o_test.go:23:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    /tmp/tmpbs6w6a4o_test.go:26:9: invalid operation: longestPalindrome += myString[len(myString)
    - i] (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075544
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find longest postfix of myString that is a palindrome\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := len(myString) - 1; i >=\
    \ 0; i-- {\n        postfix := myString[:i+1]\n        if isPalindrome(postfix)\
    \ {\n            longestPalindrome = postfix\n            longestPalindromeLen\
    \ = len(postfix)\n        }\n    }\n\n    // Append reverse of prefix that comes\
    \ before longestPalindrome\n    prefix := myString[:longestPalindromeLen]\n  \
    \  prefix += make_reverse_string(prefix)\n    return prefix + longestPalindrome\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0myb4a2g_test.go:24:12: undefined: isPalindrome

    /tmp/tmp0myb4a2g_test.go:32:15: undefined: make_reverse_string

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075544
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm\
    \ idea is simple:\n    // - Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    // >>> make_palindrome(\"\")\n    // \"\"\
    \n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"\
    cata\")\n    // \"catac\"\n    \n    // Find the longest postfix of supplied string\
    \ that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // - Append to the end\
    \ of the string reverse of a string prefix that comes before the palindromic suffix.\n\
    \    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"\
    cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\
    \n    \n    // Find the longest postfix of supplied string that is a palindrome.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string \nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpn1otdhwh_test.go:67:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075439
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm\
    \ idea is simple:\n    // - Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    // >>> make_palindrome(\"\")\n    // \"\"\
    \n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"\
    cata\")\n    // \"catac\"\n    \n    // Find the longest postfix of supplied string\
    \ that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // - Append to the end\
    \ of the string reverse of a string prefix that comes before the palindromic suffix.\n\
    \    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"\
    cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\
    \n    \n    // Find the longest postfix of supplied string that is a palindrome.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string \nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpn1otdhwh_test.go:67:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075439
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := len(myString) - 1; i >=\
    \ 0; i-- {\n        prefix := myString[:i]\n        suffix := myString[i+1:]\n\
    \        postfix := reversePostfix(prefix)\n        if postfix != suffix {\n \
    \           longestPalindrome = prefix + postfix\n            longestPalindromeLen\
    \ = len(longestPalindrome)\n        }\n    }\n    if longestPalindromeLen > 0\
    \ {\n        return longestPalindrome + reversePostfix(myString[:longestPalindromeLen])\n\
    \    }\n    return \"\"\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate\
    \ := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual:\
    \ candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"\
    ), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpoo3eanjy_test.go:24:20: undefined: reversePostfix

    /tmp/tmpoo3eanjy_test.go:31:36: undefined: reversePostfix

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075544
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLength := 0\n    for i := 0; i < len(myString);\
    \ i++ {\n        prefix := myString[:i]\n        suffix := myString[i+1:]\n  \
    \      longestPalindromeLength = len(longestPalindrome)\n        if longestPalindromeLength\
    \ == 0 {\n            longestPalindrome = prefix\n        } else {\n         \
    \   longestPalindrome += suffix\n        }\n        if longestPalindrome == prefix\
    \ {\n            longestPalindromeLength++\n        }\n    }\n    return longestPalindrome\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMake_Palindrome (0.00s)\n    --- FAIL: TestMake_Palindrome/test_num__1\
    \ (0.00s)\n        tmpt601eqmv_test.go:54: expected 'x', got ''\n    --- FAIL:\
    \ TestMake_Palindrome/test_num__2 (0.00s)\n        tmpt601eqmv_test.go:54: expected\
    \ 'xyzyx', got 'x'\n    --- FAIL: TestMake_Palindrome/test_num__3 (0.00s)\n  \
    \      tmpt601eqmv_test.go:54: expected 'xyx', got 'x'\n    --- FAIL: TestMake_Palindrome/test_num__4\
    \ (0.00s)\n        tmpt601eqmv_test.go:54: expected 'jerryrrej', got 'jryy'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075544
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm\
    \ idea is simple:\n    // - Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    longestPalindrome := \"\
    \"\n    longestPalindromeLen := 0\n    for i := len(myString) - 1; i >= 0; i--\
    \ {\n        postfix := myString[:i+1]\n        postfix += string(myString[len(myString)-i-1:])\n\
    \        postfix += string(myString[:i])\n        postfix += string(myString[i+1:])\n\
    \        postfix += string(myString[:len(myString)-i])\n        postfix += string(myString[len(myString)-i:])\n\
    \        postfix += string(myString[:len(myString)-i-1:])\n        postfix +=\
    \ string(myString[:len(myString)-i-1:])\n        postfix += string(myString[:len(myString)-i-1:])\n\
    \        postfix += string(myString[:len(myString)-i-1:])\n        postfix +=\
    \ string(myString[:len(myString)-i-1:])\n        postfix += string(myString[:len(myString)-i-1:])\n\
    \        postfix += string(myString[:len(myString)-i-1:])\n        postfix +=\
    \ string(myString[:len(myString)-i-1:])\n        postfix += string(myString[:len(myString)-i-1:])\n\
    \        postfix += string(myString[:len(myString)-i-1:])\n        postfix +=\
    \ string(myString[:len(myString)-i-1:])\n        postfix += string(myString[:len(myString)-i-1:])\n\
    \        postfix += string(myString[:len(myString)-i-1:])\n        postfix +=\
    \ string(myString[:len(myString)-i-1:])\n        postfix += string(myString[:len(myString)-i-1:])\n\
    \        postfix += string(myString[:len(myString)-i-1:])\n        postfix +=\
    \ string(myString[:len(myString)-i-1:])\n        postfix += string(myString[:len(myString)-i-1:])\n\
    \        postfix += string(myString[:len(myString)-i-1:])\n        postfix +=\
    \ string(myString\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpeixz8pqf_test.go:38:54: 3rd index required in 3-index slice

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075543
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find longest postfix of myString that is a palindrome.\n    longestPostfix :=\
    \ \"\"\n    longestPostfixLen := 0\n    for i := 0; i < len(myString); i++ {\n\
    \        postfix := myString[i:]\n        postfix := append(postfix, myString[:i]...)\n\
    \        postfix := append(postfix, myString[:i]...)\n        postfix := append(postfix,\
    \ myString[:i]...)\n        postfix := append(postfix, myString[:i]...)\n    \
    \    postfix := append(postfix, myString[:i]...)\n        postfix := append(postfix,\
    \ myString[:i]...)\n        postfix := append(postfix, myString[:i]...)\n    \
    \    postfix := append(postfix, myString[:i]...)\n        postfix := append(postfix,\
    \ myString[:i]...)\n        postfix := append(postfix, myString[:i]...)\n    \
    \    postfix := append(postfix, myString[:i]...)\n        postfix := append(postfix,\
    \ myString[:i]...)\n        postfix := append(postfix, myString[:i]...)\n    \
    \    postfix := append(postfix, myString[:i]...)\n        postfix := append(postfix,\
    \ myString[:i]...)\n        postfix := append(postfix, myString[:i]...)\n    \
    \    postfix := append(postfix, myString[:i]...)\n        postfix := append(postfix,\
    \ myString[:i]...)\n        postfix := append(postfix, myString[:i]...)\n    \
    \    postfix := append(postfix, myString[:i]...)\n        postfix := append(postfix,\
    \ myString[:i]...)\n        postfix := append(postfix, myString[:i]...)\n    \
    \    postfix := append(postfix, myString[:i]...)\n        postfix := append(postfix,\
    \ myString[:i]...)\n        postfix := append(postfix, myString[:i]...)\n    \
    \    postfix := append(postfix, myString[:i]...)\n        postfix := append(postfix,\
    \ myString[:i]...)\n        postfix := append(postfix, myString[:i]...)\n    \
    \    postfix := append(postfix, myString[:i]...)\n        postfix := append(postfix,\
    \ myString[:i]...)\n        postfix := append(postfix, myString[:i]...)\n    \
    \    postfix := append(postfix, myString[:i]...)\n        postfix := append(postfix,\
    \ myString[:i]\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp0fuzr2_s_test.go:56:48: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075543
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm\
    \ idea is simple:\n    // - Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    // >>> make_palindrome(\"\")\n    // \"\"\
    \n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"\
    cata\")\n    // \"catac\"\n    \n    // Find the longest postfix of supplied string\
    \ that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // - Append to the end\
    \ of the string reverse of a string prefix that comes before the palindromic suffix.\n\
    \    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"\
    cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\
    \n    \n    // Find the longest postfix of supplied string that is a palindrome.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string \nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpn1otdhwh_test.go:67:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075439
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        longestPalindromeLen := 0\n        for j := 0; j < len(myString);\
    \ j++ {\n            if myString[i] == myString[j] {\n                longestPalindromeLen\
    \ += 1\n            }\n        }\n        if longestPalindromeLen > longestPalindromeLen\
    \ {\n            longestPalindrome = myString[:i]\n            longestPalindromeLen\
    \ = longestPalindromeLen\n        }\n    }\n    return longestPalindrome + myString[len(longestPalindrome):]\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpi_wmhzci_test.go:20:5: longestPalindromeLen declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075545
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        prefix := myString[:i]\n        suffix := myString[i:]\n        postfix\
    \ := make_palindrome_test(suffix)\n        if postfix != \"\" {\n            longestPalindrome\
    \ = prefix + postfix\n            longestPalindromeLen = len(longestPalindrome)\n\
    \        }\n    }\n    if longestPalindromeLen > 0 {\n        return longestPalindrome\n\
    \    }\n    return \"\"\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate\
    \ := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual:\
    \ candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"\
    ), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5a_xwxw5_test.go:24:20: undefined: make_palindrome_test

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075439
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        longestPalindromeLen := longestPalindromeLen + 1\n        longestPalindrome\
    \ += myString[i]\n    }\n    for i := 0; i < longestPalindromeLen; i++ {\n   \
    \     longestPalindrome += myString[len(myString)-i]\n    }\n    return longestPalindrome\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbs6w6a4o_test.go:22:9: longestPalindromeLen declared but not used

    /tmp/tmpbs6w6a4o_test.go:23:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    /tmp/tmpbs6w6a4o_test.go:26:9: invalid operation: longestPalindrome += myString[len(myString)
    - i] (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075544
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := len(myString); i >= 0;\
    \ i-- {\n        postfix := myString[:i]\n        postfix += string(myString[len(postfix)-1:])\n\
    \        postfix += string(myString[:len(postfix)-1])\n        if postfix != longestPalindrome\
    \ {\n            longestPalindrome = postfix\n            longestPalindromeLen\
    \ = len(postfix)\n        }\n    }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3li8dmsi_test.go:20:5: longestPalindromeLen declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075545
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        longestPalindromeLen := 0\n        longestPalindrome += myString[i]\n\
    \        for j := i + 1; j < len(myString); j++ {\n            if myString[j]\
    \ != myString[j] {\n                longestPalindromeLen += 1\n              \
    \  if longestPalindromeLen > longestPalindromeLen {\n                    longestPalindrome\
    \ = myString[:j] + myString[j:]\n                    longestPalindromeLen = j\n\
    \                }\n                break\n            }\n        }\n    }\n \
    \   return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n\
    \  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4joi173h_test.go:20:5: longestPalindromeLen declared but not used

    /tmp/tmp4joi173h_test.go:23:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075545
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm\
    \ idea is simple:\n    // - Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    longestPalindrome := \"\
    \"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++ {\n\
    \        prefix := myString[:i]\n        postfix := myString[i:]\n        longestPalindromeLen\
    \ := len(longestPalindrome)\n        longestPalindrome = longestPalindrome + string(append(append([]rune(longestPalindrome),\
    \ []rune(prefix), []rune(postfix)...)[longestPalindromeLen-1:], []rune('a')...))\n\
    \    }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5r82176z_test.go:30:5:\
    \ longestPalindromeLen declared but not used\n/tmp/tmp5r82176z_test.go:35:113:\
    \ too many arguments in call to append\n\thave ([]rune, []rune, []rune)\n\twant\
    \ ([]rune, ...rune)\n/tmp/tmp5r82176z_test.go:35:166: cannot convert 'a' (untyped\
    \ rune constant 97) to type []rune\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075545
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        longestPalindromeLen := 0\n        for j := 0; j < len(myString);\
    \ j++ {\n            if myString[i] == myString[j] {\n                longestPalindromeLen\
    \ += 1\n            }\n        }\n        if longestPalindromeLen > longestPalindromeLen\
    \ {\n            longestPalindrome = myString[:i]\n            longestPalindromeLen\
    \ = longestPalindromeLen\n        }\n    }\n    return longestPalindrome + myString[len(longestPalindrome):]\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpi_wmhzci_test.go:20:5: longestPalindromeLen declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075545
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        postfix := myString[:i]\n        postfix += myString[len(myString)-i:]\n\
    \        postfix += myString[:len(myString)-i]\n        postfix += myString[len(myString)-len(postfix):]\n\
    \        postfix += myString[len(myString)-len(postfix):len(myString)]\n     \
    \   postfix += myString[len(myString)-len(postfix):len(myString)-len(postfix)]\n\
    \        postfix += myString[len(myString)-len(postfix):len(myString)-len(postfix)]\n\
    \        postfix += myString[len(myString)-len(postfix):len(myString)-len(postfix)]\n\
    \        postfix += myString[len(myString)-len(postfix):len(myString)-len(postfix)]\n\
    \        postfix += myString[len(myString)-len(postfix):len(myString)-len(postfix)]\n\
    \        postfix += myString[len(myString)-len(postfix):len(myString)-len(postfix)]\n\
    \        postfix += myString[len(myString)-len(postfix):len(myString)-len(postfix)]\n\
    \        postfix += myString[len(myString)-len(postfix):len(myString)-len(postfix)]\n\
    \        postfix += myString[len(myString)-len(postfix):len(myString)-len(postfix)]\n\
    \        postfix += myString[len(myString)-len(postfix):len(myString)-len(postfix)]\n\
    \        postfix += myString[len(myString)-len(postfix):len(myString)-len(postfix)]\n\
    \        postfix += myString[len(myString)-len(postfix):len(myString)-len(postfix)]\n\
    \        postfix += myString[len(myString)-len(postfix):len(myString)-len(postfix)]\n\
    \        postfix += myString[len(myString)-len(postfix):len(myString)-len(postfix)]\n\
    \        postfix += myString[len(myString)-len(postfix):len(myString)-len(postfix)]\n\
    \        postfix += myString[len(myString)-len(postfix):len(myString)-len(postfix)]\n\
    \        postfix += myString[len(myString)-len(postfix):len(myString)-len(postfix)]\n\
    \        postfix += myString[len(myString)-len(postfix):len(myString)-len(postfix)]\n\
    \        postfix += myString[len(myString)-len(postfix):len(myString)-len(postfix)]\n\
    \        postfix += myString[len(myString)-len(postfix):len(my\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpok79wedf_test.go:46:62: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075544
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := len(myString) - 1; i >=\
    \ 0; i-- {\n        prefix := myString[:i]\n        postfix := myString[i+1:]\n\
    \        if isPalindrome(prefix, postfix) {\n            longestPalindrome = prefix\
    \ + longestPalindrome\n            longestPalindromeLen = len(longestPalindrome)\n\
    \        }\n    }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmptoscu5fg_test.go:20:5: longestPalindromeLen declared but not used

    /tmp/tmptoscu5fg_test.go:24:12: undefined: isPalindrome

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075545
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find longest postfix of myString that is a palindrome.\n    // This will be\
    \ the prefix of the palindromic suffix.\n    var longestPalindromicSuffix string\n\
    \    for i := 0; i < len(myString); i++ {\n        // Find longest postfix of\
    \ myString that is a palindrome.\n        // This will be the suffix of the palindromic\
    \ prefix.\n        longestPalindromicSuffix = make_palindrome_test(myString[i:])\n\
    \        if longestPalindromicSuffix == \"\" {\n            // No palindromic\
    \ suffix found. No palindrome found.\n            return \"\"\n        }\n   \
    \     // Append reverse of the longest postfix of myString that is a palindrome.\n\
    \        myString = myString + longestPalindromicSuffix\n    }\n    return myString\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpoeuot39e_test.go:25:36: undefined: make_palindrome_test

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075545
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        prefix := myString[:i]\n        suffix := myString[i+1:]\n      \
    \  longestPalindromeLen := len(longestPalindrome)\n        longestPalindrome =\
    \ longestPalindrome + suffix\n        if longestPalindromeLen > len(prefix) {\n\
    \            longestPalindrome = longestPalindrome + prefix\n            longestPalindromeLen\
    \ = len(longestPalindrome)\n        }\n    }\n    return longestPalindrome\n}\n\
    \nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpg6g0y7rk_test.go:20:5: longestPalindromeLen declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075446
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := len(myString); i >= 0;\
    \ i-- {\n        postfix := myString[:i]\n        postfix += string(myString[len(postfix)-1:])\n\
    \        postfix += string(myString[:i])\n        if postfix != longestPalindrome\
    \ {\n            longestPalindrome = postfix\n            longestPalindromeLen\
    \ = len(postfix)\n        }\n    }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjaj9m1py_test.go:20:5: longestPalindromeLen declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075545
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        longestPalindromeLen := 0\n        for j := 0; j < len(myString);\
    \ j++ {\n            if myString[i] == myString[j] {\n                longestPalindromeLen\
    \ += 1\n            }\n        }\n        if longestPalindromeLen > longestPalindromeLen\
    \ {\n            longestPalindrome = myString\n        }\n    }\n    return longestPalindrome\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmppgxtp6b__test.go:20:5: longestPalindromeLen declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075545
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLength := 0\n    for i := 0; i < len(myString);\
    \ i++ {\n        postfix := myString[i:]\n        postfix := append(postfix, myString[:i]...)\n\
    \        postfix := append(postfix, myString[len(myString)-i:len(myString)]...)\n\
    \        postfix := append(postfix, myString[len(myString)-i+1:len(myString)]...)\n\
    \        postfix := append(postfix, myString[:i]...)\n        postfix := append(postfix,\
    \ myString[len(myString)-i:len(myString)]...)\n        postfix := append(postfix,\
    \ myString[len(myString)-i+1:len(myString)]...)\n        postfix := append(postfix,\
    \ myString[:i]...)\n        postfix := append(postfix, myString[len(myString)-i:len(myString)]...)\n\
    \        postfix := append(postfix, myString[len(myString)-i+1:len(myString)]...)\n\
    \        postfix := append(postfix, myString[:i]...)\n        postfix := append(postfix,\
    \ myString[len(myString)-i:len(myString)]...)\n        postfix := append(postfix,\
    \ myString[len(myString)-i+1:len(myString)]...)\n        postfix := append(postfix,\
    \ myString[:i]...)\n        postfix := append(postfix, myString[len(myString)-i:len(myString)]...)\n\
    \        postfix := append(postfix, myString[len(myString)-i+1:len(myString)]...)\n\
    \        postfix := append(postfix, myString[:i]...)\n        postfix := append(postfix,\
    \ myString[len(myString)-i:len(myString)]...)\n        postfix := append(postfix,\
    \ myString[len(myString)-i+1:len(myString)]...)\n        postfix := append(postfix,\
    \ myString[:i]...)\n        postfix := append(postfix, myString[len(myString)-i:len(myString)]...)\n\
    \        postfix := append(postfix, myString[len(myString)-i+1:len(myString)]...)\n\
    \        postfix := append(postfix, myString[:i]...)\n        postfix := append(postfix,\
    \ myString[len(myString)-i:len(myString)]...)\n        postfix := append(postfix,\
    \ myString[len(myString)-i+1:len(myString)]...)\n        postfix := append(postfix,\
    \ myString[:i]...)\n        \nfunc TestMake_Palindrome(t *testing.T) {\n  candidate\
    \ := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual:\
    \ candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"\
    ), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp74hwjnoo_test.go:49:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075545
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        postfix := myString[:i+1]\n        postfix += myString[len(myString)-i-1:]\n\
    \        postfix += myString[:len(myString)-i]\n        postfix += myString[len(myString)-1:]\n\
    \        postfix += myString[:len(myString)-1]\n        postfix += myString[len(myString)-2:]\n\
    \        postfix += myString[:len(myString)-1]\n        postfix += myString[len(myString)-3:]\n\
    \        postfix += myString[:len(myString)-1]\n        postfix += myString[len(myString)-4:]\n\
    \        postfix += myString[:len(myString)-1]\n        postfix += myString[len(myString)-5:]\n\
    \        postfix += myString[:len(myString)-1]\n        postfix += myString[len(myString)-6:]\n\
    \        postfix += myString[:len(myString)-1]\n        postfix += myString[len(myString)-7:]\n\
    \        postfix += myString[:len(myString)-1]\n        postfix += myString[len(myString)-8:]\n\
    \        postfix += myString[:len(myString)-1]\n        postfix += myString[len(myString)-9:]\n\
    \        postfix += myString[:len(myString)-1]\n        postfix += myString[len(myString)-10:]\n\
    \        postfix += myString[:len(myString)-1]\n        postfix += myString[len(myString)-11:]\n\
    \        postfix += myString[:len(myString)-1]\n        postfix += myString[len(myString)-12:]\n\
    \        postfix += myString[:len(myString)-1]\n        postfix += myString[len(myString)-13:]\n\
    \        postfix += myString[:len(myString)-1]\n        postfix += myString[len(myString)-14:]\n\
    \        postfix += myString[:len(myString)-1]\n        postfix += myString[len(myString)-15:]\n\
    \        postfix += myString[:len(myString)-1]\n        postfix += myString[len(myString)-16:]\n\
    \        postfix += myString[:len(myString)-1]\n        postfix += myString[len(myString)-17:]\n\
    \        postfix += myString[:len(myString)-1]\n        postfix += myString[len(myString)-18:]\n\
    \        postfix += myString[:len(myString)-1]\n        postfix += myString[len(myString)-19:]\n\
    \        \nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp9rrj4nxp_test.go:63:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075545
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    longestPalindrome\
    \ := \"\"\n    for i := len(myString) - 1; i >= 0; i-- {\n        postfix := myString[:i+1]\n\
    \        if postfix != \"\" && isPalindrome(postfix) {\n            longestPalindrome\
    \ = postfix\n            break\n        }\n    }\n    // Append to the end of\
    \ the string reverse of a string prefix that comes before the palindromic suffix.\n\
    \    prefix := myString[:len(longestPalindrome)]\n    return prefix + reverseString(longestPalindrome)\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxl1_gq38_test.go:23:29: undefined: isPalindrome

    /tmp/tmpxl1_gq38_test.go:30:21: undefined: reverseString

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075546
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm\
    \ idea is simple:\n    // - Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    // >>> make_palindrome(\"\")\n    // \"\"\
    \n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"\
    cata\")\n    // \"catac\"\n    \n    // Find the longest postfix of supplied string\
    \ that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // - Append to the end\
    \ of the string reverse of a string prefix that comes before the palindromic suffix.\n\
    \    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"\
    cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\
    \n    \n    // Find the longest postfix of supplied string that is a palindrome.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string \nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpn1otdhwh_test.go:67:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075439
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find longest postfix of myString that is a palindrome.\n    longestPalindrome\
    \ := \"\"\n    for i := len(myString) - 1; i >= 0; i-- {\n        postfix := myString[:i+1]\n\
    \        if isPalindrome(postfix) {\n            longestPalindrome = postfix\n\
    \            break\n        }\n    }\n\n    // Append the reverse of the longest\
    \ postfix to the end of the string.\n    result := myString\n    for i := len(longestPalindrome)\
    \ - 1; i >= 0; i-- {\n        result = result + longestPalindrome[i]\n    }\n\n\
    \    return result\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate\
    \ := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual:\
    \ candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"\
    ), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpd_v50zev_test.go:23:12: undefined: isPalindrome

    /tmp/tmpd_v50zev_test.go:32:18: invalid operation: result + longestPalindrome[i]
    (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075546
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := len(myString) - 1; i >=\
    \ 0; i-- {\n        postfix := myString[:i+1]\n        if isPalindrome(postfix)\
    \ {\n            longestPalindrome = postfix\n            longestPalindromeLen\
    \ = len(postfix)\n        }\n    }\n    // Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    prefix :=\
    \ myString[:longestPalindromeLen]\n    return prefix + reverseString(longestPalindrome)\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1jy4via0_test.go:24:12: undefined: isPalindrome

    /tmp/tmp1jy4via0_test.go:31:21: undefined: reverseString

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075546
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm\
    \ idea is simple:\n    // - Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    longestPalindrome := \"\
    \"\n    longestPalindromeLen := 0\n    for i := len(myString) - 1; i >= 0; i--\
    \ {\n        postfix := myString[:i+1]\n        if isPalindrome(postfix) {\n \
    \           longestPalindrome = postfix\n            longestPalindromeLen = len(postfix)\n\
    \        }\n    }\n    \n    // Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    prefix := myString[:longestPalindromeLen]\n\
    \    suffix := myString[longestPalindromeLen:]\n    \n    return prefix + reverseString(suffix)\
    \ + longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate\
    \ := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual:\
    \ candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"\
    ), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp847so5lz_test.go:35:12: undefined: isPalindrome

    /tmp/tmp847so5lz_test.go:45:21: undefined: reverseString

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075546
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm\
    \ idea is simple:\n    // - Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    // >>> make_palindrome(\"\")\n    // \"\"\
    \n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"\
    cata\")\n    // \"catac\"\n    \n    // Find the longest postfix of supplied string\
    \ that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // - Append to the end\
    \ of the string reverse of a string prefix that comes before the palindromic suffix.\n\
    \    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"\
    cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\
    \n    \n    // Find the longest postfix of supplied string that is a palindrome.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string \nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpn1otdhwh_test.go:67:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075439
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := len(myString) - 1; i >=\
    \ 0; i-- {\n        prefix := myString[:i]\n        suffix := myString[i:]\n \
    \       postfix := reverse(prefix)\n        if postfix != suffix {\n         \
    \   longestPalindrome = append(longestPalindrome, postfix, suffix)\n         \
    \   longestPalindromeLen = len(longestPalindrome)\n        }\n    }\n    if longestPalindromeLen\
    \ > 0 {\n        return append(myString[:longestPalindromeLen], longestPalindrome...)\n\
    \    }\n    return \"\"\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate\
    \ := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual:\
    \ candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"\
    ), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmplrizad7v_test.go:24:20: undefined: reverse

    /tmp/tmplrizad7v_test.go:26:40: first argument to append must be a slice; have
    longestPalindrome (variable of type string)

    /tmp/tmplrizad7v_test.go:31:31: first argument to append must be a slice; have
    myString[:longestPalindromeLen] (value of type string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075546
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        prefix := myString[:i]\n        suffix := myString[i:]\n        longestPalindromeLen\
    \ := len(longestPalindrome)\n        longestPalindrome = longestPalindrome + suffix\n\
    \        if longestPalindromeLen > len(prefix) {\n            longestPalindrome\
    \ = longestPalindrome + prefix\n        }\n    }\n    return longestPalindrome\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7rmvh55k_test.go:20:5: longestPalindromeLen declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075546
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    longestPalindromeLen := len(myString)\n\
    \    for i := 0; i < longestPalindromeLen; i++ {\n        longestPalindrome =\
    \ myString[0:longestPalindromeLen]\n        longestPalindrome = append(longestPalindrome,\
    \ myString[longestPalindromeLen-i:]...)\n        fmt.Printf(\"%v\\n\", longestPalindrome)\n\
    \        if longestPalindrome == make_palindrome(longestPalindrome) {\n      \
    \      return longestPalindrome\n        }\n    }\n    return \"\"\n}\n\nfunc\
    \ TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual:\
    \ candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected:\
    \ \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n    \
    \ { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp37djskwx_test.go:21:26: no new variables on left side of :=

    /tmp/tmp37djskwx_test.go:24:36: first argument to append must be a slice; have
    longestPalindrome (variable of type string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075546
- exit_code: null
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find longest postfix of myString that is a palindrome\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := len(myString) - 1; i >=\
    \ 0; i-- {\n        postfix := myString[:i+1]\n        postfix += string(myString[len(myString)-i-1:])\n\
    \        if postfix != make_palindrome(postfix) {\n            continue\n    \
    \    }\n        if len(postfix) > longestPalindromeLen {\n            longestPalindrome\
    \ = postfix\n            longestPalindromeLen = len(postfix)\n        }\n    }\n\
    \    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n\
    \  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660075559
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        postfix := myString[i:]\n        reverse := myString[:i]\n      \
    \  postfix = append(reverse, postfix...)\n        postfix = append(postfix, myString[len(myString)-len(postfix):]...)\n\
    \        postfix = append(postfix, myString[:len(myString)-len(postfix)]...)\n\
    \        if myString[len(myString)-len(postfix)] == myString[len(myString)-len(postfix)-1]\
    \ {\n            longestPalindrome = postfix\n            longestPalindromeLen\
    \ = len(postfix)\n        }\n    }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp08gae65m_test.go:20:5: longestPalindromeLen declared but not used

    /tmp/tmp08gae65m_test.go:24:26: first argument to append must be a slice; have
    reverse (variable of type string)

    /tmp/tmp08gae65m_test.go:25:26: first argument to append must be a slice; have
    postfix (variable of type string)

    /tmp/tmp08gae65m_test.go:26:26: first argument to append must be a slice; have
    postfix (variable of type string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075546
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        longestPalindromeLen += len(myString) - i\n        longestPalindrome\
    \ += myString[:i]\n        longestPalindrome += myString[len(myString)-i:len(myString)]\n\
    \    }\n    longestPalindromeLen -= len(myString)\n    longestPalindrome += myString\n\
    \    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n\
    \  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMake_Palindrome (0.00s)\n    --- FAIL: TestMake_Palindrome/test_num__2\
    \ (0.00s)\n        tmpf0xeyk8__test.go:48: expected 'xyzyx', got 'xzxyyzxyz'\n\
    \    --- FAIL: TestMake_Palindrome/test_num__3 (0.00s)\n        tmpf0xeyk8__test.go:48:\
    \ expected 'xyx', got 'xxxyyxxyx'\n    --- FAIL: TestMake_Palindrome/test_num__4\
    \ (0.00s)\n        tmpf0xeyk8__test.go:48: expected 'jerryrrej', got 'jyjeryjerrryjerrerryjerry'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075547
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    longestPalindrome\
    \ := \"\"\n    for i := len(myString) - 1; i >= 0; i-- {\n        longestPalindrome\
    \ += myString[i]\n    }\n    longestPalindromeReverse := make([]rune, len(longestPalindrome))\n\
    \    for i := 0; i < len(longestPalindrome); i++ {\n        longestPalindromeReverse[i]\
    \ = longestPalindrome[len(longestPalindrome)-i-1]\n    }\n    // Append to the\
    \ end of the string reverse of a string prefix that comes before the palindromic\
    \ suffix.\n    myString += string(longestPalindromeReverse)\n    return myString\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxphmygh6_test.go:22:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    /tmp/tmpxphmygh6_test.go:26:39: cannot use longestPalindrome[len(longestPalindrome)
    - i - 1] (value of type byte) as type rune in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075546
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        longestPalindromeLen += len(myString) - i\n        if myString[i]\
    \ == myString[len(myString)-i-1] {\n            longestPalindrome = myString[:len(myString)-i]\
    \ + longestPalindrome\n            longestPalindromeLen += len(myString) - i\n\
    \        }\n    }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMake_Palindrome (0.00s)\n    --- FAIL: TestMake_Palindrome/test_num__2\
    \ (0.00s)\n        tmptp8xc_ap_test.go:48: expected 'xyzyx', got 'xy'\n    ---\
    \ FAIL: TestMake_Palindrome/test_num__3 (0.00s)\n        tmptp8xc_ap_test.go:48:\
    \ expected 'xyx', got 'xxyxyx'\n    --- FAIL: TestMake_Palindrome/test_num__4\
    \ (0.00s)\n        tmptp8xc_ap_test.go:48: expected 'jerryrrej', got 'jer'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075547
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        longestPalindromeLen := longestPalindromeLen + 1\n        longestPalindrome\
    \ += myString[i]\n    }\n    for i := 0; i < longestPalindromeLen; i++ {\n   \
    \     longestPalindrome += myString[len(myString)-i-1]\n    }\n    return longestPalindrome\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpwvrrhyqf_test.go:22:9: longestPalindromeLen declared but not used

    /tmp/tmpwvrrhyqf_test.go:23:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    /tmp/tmpwvrrhyqf_test.go:26:9: invalid operation: longestPalindrome += myString[len(myString)
    - i - 1] (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075547
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    longestPalindromeLen := len(myString)\n\
    \    for i := 0; i < longestPalindromeLen; i++ {\n        longestPalindrome +=\
    \ myString[i]\n    }\n    for i := 0; i < longestPalindromeLen; i++ {\n      \
    \  longestPalindrome += myString[len(myString)-(i+1)]\n    }\n    return longestPalindrome\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1gquw2wq_test.go:21:26: no new variables on left side of :=

    /tmp/tmp1gquw2wq_test.go:23:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    /tmp/tmp1gquw2wq_test.go:26:9: invalid operation: longestPalindrome += myString[len(myString)
    - (i + 1)] (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075448
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm\
    \ idea is simple:\n    // - Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    longestPalindrome := \"\
    \"\n    longestPalindromeLen := 0\n    for i := len(myString) - 1; i >= 0; i--\
    \ {\n        longestPalindrome = myString[:i+1] + longestPalindrome\n        longestPalindromeLen\
    \ = len(longestPalindrome)\n        if longestPalindromeLen > len(longestPalindrome)\
    \ {\n            break\n        }\n    }\n    \n    // Append to the end of the\
    \ string reverse of a string prefix that comes before the palindromic suffix.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    longestPalindromeReverse\
    \ := \"\"\n    for i := 0; i < len(longestPalindrome); i++ {\n        longestPalindromeReverse\
    \ = longestPalindromeReverse + myString[len(myString)-i:len(myString)]\n    }\n\
    \    \n    return longestPalindromeReverse + longestPalindrome\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMake_Palindrome (0.00s)\npanic: runtime error: slice bounds\
    \ out of range [-1:] [recovered]\n\tpanic: runtime error: slice bounds out of\
    \ range [-1:]\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620, 0xc000014360})\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.make_palindrome(...)\n\t/tmp/tmpxv_bci0q_test.go:54\n\
    command-line-arguments_test.TestMake_Palindrome(0x0?)\n\t/tmp/tmpxv_bci0q_test.go:69\
    \ +0x785\ntesting.tRunner(0xc0001a01a0, 0x528f60)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075547
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    var\
    \ myStringLen int = len(myString)\n    var myStringPrefix string\n    var myStringSuffix\
    \ string\n    var myStringReversedSuffix string\n    var myStringReversedPrefix\
    \ string\n    var myStringReversedSuffix string\n    var myStringReversedReversedSuffix\
    \ string\n    var myStringReversedReversedPrefix string\n    var myStringReversedReversedSuffix\
    \ string\n    var myStringReversedReversedReversedSuffix string\n    var myStringReversedReversedReversedPrefix\
    \ string\n    var myStringReversedReversedReversedSuffix string\n    var myStringReversedReversedReversedReversedPrefix\
    \ string\n    var myStringReversedReversedReversedReversedSuffix string\n    var\
    \ myStringReversedReversedReversedReversedReversedPrefix string\n    var myStringReversedReversedReversedReversedReversedSuffix\
    \ string\n    var myStringReversedReversedReversedReversedReversedReversedPrefix\
    \ string\n    var myStringReversedReversedReversedReversedReversedReversedSuffix\
    \ string\n    var myStringReversedReversedReversedReversedReversedReversedReversedPrefix\
    \ string\n    var myStringReversedReversedReversedReversedReversedReversedReversedSuffix\
    \ string\n    var myStringReversedReversedReversedReversedReversedReversedReversedPrefix\
    \ string\n    var myStringReversedReversedReversedReversedReversedReversedReversedSuffix\
    \ string\n    var myStringReversedReversedReversedReversedReversedReversedReversedReversedPrefix\
    \ string\n    var myStringReversedReversedReversedReversedReversedReversedReversedReversedSuffix\
    \ string\n    var myStringReversedReversedReversedReversedReversedReversedReversedReversedPrefix\
    \ string\n    var myStringReversedReversedReversedReversedReversedReversedReversedReversedSuffix\
    \ string\n    var myStringReversedReversedReversedReversedReversedReversedReversedReversedPrefix\
    \ string\n    var myStringReversedReversedReversedReversedReversedReversedReversedReversedSuffix\
    \ string\n    var myStringReversedReversedReversedReversedReversedReversedReversedReversedReversedPrefix\
    \ string\n    var myStringReversedReversedReversedReversedReversedReversedReversedReversedReversedSuffix\
    \ string\n    var myStringReversedReversedReversedReversedReversedReversedReverse\n\
    func TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual:\
    \ candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected:\
    \ \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n    \
    \ { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp46xbd4fv_test.go:49:9: missing variable type or initialization

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075546
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Initialize a variable to hold the longest postfix of myString that is a palindrome.\n\
    \    var longestPalindrome string = \"\"\n    // Initialize a variable to hold\
    \ the length of the longest postfix of myString that is a palindrome.\n    var\
    \ longestPalindromeLength int = 0\n    // Initialize a variable to hold the length\
    \ of the shortest postfix of myString that is a palindrome.\n    var shortestPalindromeLength\
    \ int = 0\n    // Initialize a variable to hold the length of the shortest postfix\
    \ of myString that is a palindrome.\n    var shortestPalindrome string = \"\"\n\
    \    // Initialize a variable to hold the length of the shortest postfix of myString\
    \ that is a palindrome.\n    var shortestPalindromeLength int = 0\n    // Initialize\
    \ a variable to hold the length of the shortest postfix of myString that is a\
    \ palindrome.\n    var shortestPalindromeLength int = 0\n    // Initialize a variable\
    \ to hold the length of the shortest postfix of myString that is a palindrome.\n\
    \    var shortestPalindromeLength int = 0\n    // Initialize a variable to hold\
    \ the length of the shortest postfix of myString that is a palindrome.\n    var\
    \ shortestPalindromeLength int = 0\n    // Initialize a variable to hold the length\
    \ of the shortest postfix of myString that is a palindrome.\n    var shortestPalindromeLength\
    \ int = 0\n    // Initialize a variable to hold the length of the shortest postfix\
    \ of myString that is a palindrome.\n    var shortestPalindromeLength int = 0\n\
    \    // Initialize a variable to hold the length of the shortest postfix of myString\
    \ that is a palindrome.\n    var shortestPalindromeLength int = 0\n    // Initialize\
    \ a variable to hold the length of the shortest postfix of myString that is a\
    \ palindrome.\n    var shortestPalindromeLength int = 0\n    // Initialize a variable\
    \ to hold the length of the shortest postfix of myString that is a palindrome.\n\
    \    var shortestPalindromeLength int = 0\n    // Initialize a variable to hold\
    \ the length of the shortest postfix of myString that is a palindrome.\n    var\
    \ shortestPalindromeLength int = 0\n    // Initialize a variable to hold the length\
    \ of the shortest postfix of myString that is a palindrome.\n    var shortestPalindromeLength\
    \ int = 0\n    // Initialize a variable to hold the length of the shortest postfix\
    \ of myString that is a palindrome.\n\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpemb1w377_test.go:51:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075547
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        longestPalindromeLen := 0\n        for j := 0; j < len(myString);\
    \ j++ {\n            if myString[i] == myString[j] {\n                longestPalindromeLen\
    \ += 1\n            }\n        }\n        if longestPalindromeLen > longestPalindromeLen\
    \ {\n            longestPalindrome = myString[:i]\n            longestPalindromeLen\
    \ = longestPalindromeLen\n        }\n    }\n    return longestPalindrome + myString[len(longestPalindrome):]\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpi_wmhzci_test.go:20:5: longestPalindromeLen declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075545
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm\
    \ idea is simple:\n    // - Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    // >>> make_palindrome(\"\")\n    // \"\"\
    \n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"\
    cata\")\n    // \"catac\"\n    \n    // Find the longest postfix of supplied string\
    \ that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // - Append to the end\
    \ of the string reverse of a string prefix that comes before the palindromic suffix.\n\
    \    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"\
    cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\
    \n    \n    // Find the longest postfix of supplied string that is a palindrome.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string \nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpn1otdhwh_test.go:67:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075439
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        postfix := myString[i:]\n        postfix += \"-\"\n        postfix\
    \ += myString[:i]\n        postfix += \"-\"\n        postfix += myString[i:]\n\
    \        postfix += \"-\"\n        postfix += myString[:i]\n        postfix +=\
    \ \"-\"\n        postfix += myString[i:]\n        postfix += \"-\"\n        postfix\
    \ += myString[:i]\n        postfix += \"-\"\n        postfix += myString[i:]\n\
    \        postfix += \"-\"\n        postfix += myString[:i]\n        postfix +=\
    \ \"-\"\n        postfix += myString[i:]\n        postfix += \"-\"\n        postfix\
    \ += myString[:i]\n        postfix += \"-\"\n        postfix += myString[i:]\n\
    \        postfix += \"-\"\n        postfix += myString[:i]\n        postfix +=\
    \ \"-\"\n        postfix += myString[i:]\n        postfix += \"-\"\n        postfix\
    \ += myString[:i]\n        postfix += \"-\"\n        postfix += myString[i:]\n\
    \        postfix += \"-\"\n        postfix += myString[:i]\n        postfix +=\
    \ \"-\"\n        postfix += myString[i:]\n        postfix += \"-\"\n        postfix\
    \ += myString[:i]\n        postfix += \"-\"\n        postfix += myString[i:]\n\
    \        postfix += \"-\"\n        postfix += myString[:i]\n        postfix +=\
    \ \"-\"\n        postfix += myString[i:]\n        postfix += \"-\"\n        postfix\
    \ += myString[:i]\n        postfix += \"-\"\n        postfix += myString[i:]\n\
    \        postfix += \"-\"\n        postfix += myString[:i]\n        postfix +=\
    \ \"-\"\n        postfix += myString[i:]\n        postfix += \"-\"\n        postfix\
    \ += myString[:i]\n        postfix += \"-\"\n        postfix += myString[i:]\n\
    \        postfix += \"-\"\n        postfix += myString[:i]\n        postfix +=\
    \ \"-\"\n        postfix += myString[i:]\n        postfix += \"-\"\n        postfix\
    \ += myString[:i]\n        postfix += \"-\"\n        postfix += myString[i:]\n\
    \        postfix += \"-\"\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate\
    \ := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual:\
    \ candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"\
    ), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp42cx5zsj_test.go:86:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075547
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find longest postfix of myString that is a palindrome.\n    // This will be\
    \ the longest palindrome that begins with myString.\n    var longestPalindrome\
    \ string = \"\"\n    for i := 0; i < len(myString); i++ {\n        // Find longest\
    \ postfix of myString that is a palindrome.\n        // This will be the longest\
    \ palindrome that begins with myString.\n        longestPalindrome += myString[len(myString)-i:]\n\
    \    }\n    // Append to the end of the string reverse of a string prefix that\
    \ comes before the palindromic suffix.\n    longestPalindrome += myString[:len(myString)-len(longestPalindrome)]\n\
    \    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n\
    \  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMake_Palindrome (0.00s)\npanic: runtime error: slice bounds\
    \ out of range [:-5] [recovered]\n\tpanic: runtime error: slice bounds out of\
    \ range [:-5]\n\ngoroutine 4 [running]:\ntesting.tRunner.func1.2({0x513620, 0xc000014360})\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.make_palindrome(...)\n\t/tmp/tmp3tpzty5d_test.go:28\n\
    command-line-arguments_test.TestMake_Palindrome(0x0?)\n\t/tmp/tmp3tpzty5d_test.go:43\
    \ +0x591\ntesting.tRunner(0xc00019e340, 0x528f60)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075548
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := len(myString) - 1; i >=\
    \ 0; i-- {\n        postfix := myString[:i+1]\n        postfix += myString[len(myString)-i:len(myString)]\n\
    \        if postfix != myString {\n            longestPalindrome = postfix\n \
    \           longestPalindromeLen = len(postfix)\n        }\n    }\n    // Append\
    \ to the end of the string reverse of a string prefix that comes before the palindromic\
    \ suffix.\n    prefix := myString[:longestPalindromeLen]\n    suffix := myString[longestPalindromeLen:]\n\
    \    prefix += suffix\n    prefix += longestPalindrome\n    return prefix\n}\n\
    \nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMake_Palindrome (0.00s)\n    --- FAIL: TestMake_Palindrome/test_num__2\
    \ (0.00s)\n        tmpzo76ec4q_test.go:55: expected 'xyzyx', got 'xyzx'\n    ---\
    \ FAIL: TestMake_Palindrome/test_num__3 (0.00s)\n        tmpzo76ec4q_test.go:55:\
    \ expected 'xyx', got 'xyxx'\n    --- FAIL: TestMake_Palindrome/test_num__4 (0.00s)\n\
    \        tmpzo76ec4q_test.go:55: expected 'jerryrrej', got 'jerryj'\nFAIL\nFAIL\t\
    command-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660075548
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm\
    \ idea is simple:\n    // - Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    var longestPalindrome\
    \ string\n    for i := 0; i < len(myString); i++ {\n        longestPalindrome\
    \ += myString[i]\n    }\n    longestPalindrome = longestPalindrome[:len(longestPalindrome)-1]\n\
    \    \n    // Append to the end of the string reverse of a string prefix that\
    \ comes before the palindromic suffix.\n    // >>> make_palindrome(\"\")\n   \
    \ // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"\
    cata\")\n    // \"catac\"\n    \n    // Reverse the string prefix that comes before\
    \ the palindromic suffix.\n    // >>> make_palindrome(\"\")\n    // \"\"\n   \
    \ // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"\
    cata\")\n    // \"catac\"\n    \n    // Reverse the string prefix that comes before\
    \ the palindromic suffix.\n    // >>> make_palindrome(\"\")\n    // \"\"\n   \
    \ // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"\
    cata\")\n    // \"catac\"\n    \n    // Reverse the string prefix that comes before\
    \ the palindromic suffix.\n    // >>> make_palindrome(\"\")\n    // \"\"\n   \
    \ // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"\
    cata\")\n    // \"catac\"\n    \n    // Reverse the string prefix that comes before\
    \ the palindromic suffix.\n    // >>> make_palindrome(\"\")\n    // \"\"\n   \
    \ // >>> make_palindrome(\"\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate\
    \ := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual:\
    \ candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"\
    ), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpm4rjz1p6_test.go:73:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075547
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    longestPalindromeLen := len(myString)\n\
    \    for i := 0; i < longestPalindromeLen; i++ {\n        longestPalindrome +=\
    \ myString[i]\n    }\n    for i := 0; i < longestPalindromeLen; i++ {\n      \
    \  longestPalindrome += myString[len(myString)-1-i]\n    }\n    return longestPalindrome\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpc84rx_qd_test.go:21:26: no new variables on left side of :=

    /tmp/tmpc84rx_qd_test.go:23:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    /tmp/tmpc84rx_qd_test.go:26:9: invalid operation: longestPalindrome += myString[len(myString)
    - 1 - i] (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075446
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Initialize our return value\n    var myPalindrome string = \"\"\n\n    // Find\
    \ the longest postfix of supplied string that is a palindrome.\n    // We will\
    \ use this to determine our starting point for our palindrome search\n    var\
    \ longestPalindrome string = \"\"\n    for i := 0; i < len(myString); i++ {\n\
    \        // Find the longest postfix of our current string\n        // that is\
    \ a palindrome\n        longestPalindrome = longestPalindrome + myString[i : len(myString)-i]\n\
    \    }\n\n    // Now that we have the longest postfix of our current string\n\
    \    // that is a palindrome, we can append it to the end of the string\n    //\
    \ reverse of our string prefix that comes before the palindromic suffix.\n   \
    \ // We will use this to determine our starting point for our palindrome search\n\
    \    var startingPoint int = len(myString) - len(longestPalindrome)\n    for i\
    \ := 0; i < len(myString); i++ {\n        // Append the reverse of the string\
    \ prefix that comes before the palindromic suffix\n        myPalindrome = myPalindrome\
    \ + myString[startingPoint:len(myString)-i]\n        // Increment our starting\
    \ point for our palindrome search\n        startingPoint = startingPoint - i\n\
    \    }\n\n    // Return the palindrome we found\n    return myPalindrome\n}\n\n\
    func TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual:\
    \ candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected:\
    \ \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n    \
    \ { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMake_Palindrome (0.00s)\npanic: runtime error: slice bounds\
    \ out of range [2:1] [recovered]\n\tpanic: runtime error: slice bounds out of\
    \ range [2:1]\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620, 0xc000014360})\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.make_palindrome(...)\n\t/tmp/tmpkf601rsr_test.go:28\n\
    command-line-arguments_test.TestMake_Palindrome(0x0?)\n\t/tmp/tmpkf601rsr_test.go:56\
    \ +0x8a5\ntesting.tRunner(0xc0001a0340, 0x528f60)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075548
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find longest postfix of myString that is a palindrome\n    longestPalindrome\
    \ := \"\"\n    for i := len(myString) - 1; i >= 0; i-- {\n        postfix := myString[:i+1]\n\
    \        if isPalindrome(postfix) {\n            longestPalindrome = postfix\n\
    \            break\n        }\n    }\n\n    // Append reverse of longest postfix\
    \ to myString\n    result := myString\n    for i := len(longestPalindrome) - 1;\
    \ i >= 0; i-- {\n        result = result + longestPalindrome[i]\n    }\n\n   \
    \ return result\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate :=\
    \ make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual:\
    \ candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"\
    ), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7y0faui1_test.go:23:12: undefined: isPalindrome

    /tmp/tmp7y0faui1_test.go:32:18: invalid operation: result + longestPalindrome[i]
    (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075547
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    var\
    \ myStringLen int = len(myString)\n    var myStringPrefix string\n    var myStringSuffix\
    \ string\n    var myStringReversedSuffix string\n\n    // Find longest postfix\
    \ of myString that is a palindrome.\n    for i := 0; i < myStringLen; i++ {\n\
    \        if myString[i] == myString[len(myString)-i-1] {\n            myStringPrefix\
    \ = myString[:i]\n            myStringSuffix = myString[i:]\n            myStringReversedSuffix\
    \ = myStringSuffix[len(myStringSuffix)-1:] + myStringSuffix[:len(myStringSuffix)-1]\n\
    \            break\n        }\n    }\n\n    // Append to the end of the string\
    \ reverse of a string prefix that comes before the palindromic suffix.\n    myString\
    \ = myString + myStringPrefix + myStringReversedSuffix\n\n    return myString\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMake_Palindrome (0.00s)\n    --- FAIL: TestMake_Palindrome/test_num__1\
    \ (0.00s)\n        tmpf53sazzr_test.go:57: expected 'x', got 'xx'\n    --- FAIL:\
    \ TestMake_Palindrome/test_num__2 (0.00s)\n        tmpf53sazzr_test.go:57: expected\
    \ 'xyzyx', got 'xyzxzy'\n    --- FAIL: TestMake_Palindrome/test_num__3 (0.00s)\n\
    \        tmpf53sazzr_test.go:57: expected 'xyx', got 'xyxxxy'\n    --- FAIL: TestMake_Palindrome/test_num__4\
    \ (0.00s)\n        tmpf53sazzr_test.go:57: expected 'jerryrrej', got 'jerryjeyrr'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075548
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLength := 0\n    longestPalindromeLength2 := 0\n\
    \    longestPalindromeLength3 := 0\n    longestPalindromeLength4 := 0\n    longestPalindromeLength5\
    \ := 0\n    longestPalindromeLength6 := 0\n    longestPalindromeLength7 := 0\n\
    \    longestPalindromeLength8 := 0\n    longestPalindromeLength9 := 0\n    longestPalindromeLength10\
    \ := 0\n    longestPalindromeLength11 := 0\n    longestPalindromeLength12 := 0\n\
    \    longestPalindromeLength13 := 0\n    longestPalindromeLength14 := 0\n    longestPalindromeLength15\
    \ := 0\n    longestPalindromeLength16 := 0\n    longestPalindromeLength17 := 0\n\
    \    longestPalindromeLength18 := 0\n    longestPalindromeLength19 := 0\n    longestPalindromeLength20\
    \ := 0\n    longestPalindromeLength21 := 0\n    longestPalindromeLength22 := 0\n\
    \    longestPalindromeLength23 := 0\n    longestPalindromeLength24 := 0\n    longestPalindromeLength25\
    \ := 0\n    longestPalindromeLength26 := 0\n    longestPalindromeLength27 := 0\n\
    \    longestPalindromeLength28 := 0\n    longestPalindromeLength29 := 0\n    longestPalindromeLength30\
    \ := 0\n    longestPalindromeLength31 := 0\n    longestPalindromeLength32 := 0\n\
    \    longestPalindromeLength33 := 0\n    longestPalindromeLength34 := 0\n    longestPalindromeLength35\
    \ := 0\n    longestPalindromeLength36 := 0\n    longestPalindromeLength37 := 0\n\
    \    longestPalindromeLength38 := 0\n    longestPalindromeLength39 := 0\n    longestPalindromeLength40\
    \ := 0\n    longestPalindromeLength41 := 0\n    longestPalindromeLength42 := 0\n\
    \    longestPalindromeLength43 := 0\n    longestPalindromeLength44 := 0\n    longestPalindromeLength45\
    \ := 0\n    longest\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate :=\
    \ make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual:\
    \ candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"\
    ), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp53yw27r1_test.go:66:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075547
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm\
    \ idea is simple:\n    // - Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    longestPalindrome := \"\
    \"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++ {\n\
    \        postfix := myString[:i]\n        postfix += string(myString[len(postfix)-1:])\n\
    \        postfix += string(myString[:len(postfix)-1])\n        if postfix != longestPalindrome\
    \ {\n            longestPalindrome = postfix\n            longestPalindromeLen\
    \ = len(postfix)\n        }\n    }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpw03fz8eu_test.go:30:5: longestPalindromeLen declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075548
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := len(myString) - 1; i >=\
    \ 0; i-- {\n        postfix := myString[:i+1]\n        if isPalindrome(postfix)\
    \ {\n            longestPalindrome = postfix\n            longestPalindromeLen\
    \ = len(postfix)\n        }\n    }\n    // Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    prefix :=\
    \ myString[:longestPalindromeLen]\n    return prefix + reverse(prefix)\n}\n\n\
    func TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual:\
    \ candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected:\
    \ \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n    \
    \ { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_mm2hrvf_test.go:20:5: longestPalindrome declared but not used

    /tmp/tmp_mm2hrvf_test.go:24:12: undefined: isPalindrome

    /tmp/tmp_mm2hrvf_test.go:31:21: undefined: reverse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075548
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := len(myString); i >= 0;\
    \ i-- {\n        prefix := myString[:i]\n        suffix := myString[i:]\n    \
    \    postfix := reversePostfix(prefix)\n        if postfix != suffix {\n     \
    \       longestPalindrome = prefix + postfix\n            longestPalindromeLen\
    \ = len(longestPalindrome)\n        }\n    }\n    if longestPalindromeLen > 0\
    \ {\n        return longestPalindrome + myString[len(longestPalindrome):]\n  \
    \  }\n    return \"\"\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate\
    \ := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual:\
    \ candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"\
    ), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjd1xixly_test.go:24:20: undefined: reversePostfix

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075548
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := len(myString) - 1; i >=\
    \ 0; i-- {\n        prefix := myString[:i]\n        suffix := myString[i+1:]\n\
    \        postfix := reverse(prefix)\n        if suffix == postfix {\n        \
    \    longestPalindrome = prefix + postfix\n            longestPalindromeLen =\
    \ len(longestPalindrome)\n        }\n    }\n    if longestPalindromeLen == 0 {\n\
    \        return \"\"\n    }\n    // Append to the end of the string reverse of\
    \ a string prefix that comes before the palindromic suffix.\n    result := myString\n\
    \    for i := 0; i < longestPalindromeLen; i++ {\n        result = result + longestPalindrome[longestPalindromeLen-i]\n\
    \    }\n    return result\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate\
    \ := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual:\
    \ candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"\
    ), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpoglnjog1_test.go:25:20: undefined: reverse

    /tmp/tmpoglnjog1_test.go:37:18: invalid operation: result + longestPalindrome[longestPalindromeLen
    - i] (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075548
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := len(myString) - 1; i >=\
    \ 0; i-- {\n        prefix := myString[:i]\n        suffix := myString[i+1:]\n\
    \        postfix := reverse(prefix)\n        if postfix != suffix {\n        \
    \    longestPalindrome = append(longestPalindrome, postfix)\n            longestPalindromeLen\
    \ = len(longestPalindrome)\n        }\n    }\n    if longestPalindromeLen > 0\
    \ {\n        return append(myString[:longestPalindromeLen], longestPalindrome...)\n\
    \    }\n    return myString\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n \
    \ candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpatygzlcn_test.go:24:20: undefined: reverse

    /tmp/tmpatygzlcn_test.go:26:40: first argument to append must be a slice; have
    longestPalindrome (variable of type string)

    /tmp/tmpatygzlcn_test.go:31:31: first argument to append must be a slice; have
    myString[:longestPalindromeLen] (value of type string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075548
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find longest postfix of myString that is a palindrome.\n    // The longest postfix\
    \ is found by reversing a prefix of myString that comes before a palindromic suffix.\n\
    \    // The longest postfix is found by reversing a prefix of myString that comes\
    \ before a palindromic suffix.\n    // The longest postfix is found by reversing\
    \ a prefix of myString that comes before a palindromic suffix.\n    // The longest\
    \ postfix is found by reversing a prefix of myString that comes before a palindromic\
    \ suffix.\n    // The longest postfix is found by reversing a prefix of myString\
    \ that comes before a palindromic suffix.\n    // The longest postfix is found\
    \ by reversing a prefix of myString that comes before a palindromic suffix.\n\
    \    // The longest postfix is found by reversing a prefix of myString that comes\
    \ before a palindromic suffix.\n    // The longest postfix is found by reversing\
    \ a prefix of myString that comes before a palindromic suffix.\n    // The longest\
    \ postfix is found by reversing a prefix of myString that comes before a palindromic\
    \ suffix.\n    // The longest postfix is found by reversing a prefix of myString\
    \ that comes before a palindromic suffix.\n    // The longest postfix is found\
    \ by reversing a prefix of myString that comes before a palindromic suffix.\n\
    \    // The longest postfix is found by reversing a prefix of myString that comes\
    \ before a palindromic suffix.\n    // The longest postfix is found by reversing\
    \ a prefix of myString that comes before a palindromic suffix.\n    // The longest\
    \ postfix is found by reversing a prefix of myString that comes before a palindromic\
    \ suffix.\n    // The longest postfix is found by reversing a prefix of myString\
    \ that comes before a palindromic suffix.\n    // The longest postfix is found\
    \ by reversing a prefix of myString that comes before a palindromic suffix.\n\
    \    // The longest postfix is found by reversing a prefix of myString that comes\
    \ before a palindromic suffix.\n    // The longest postfix is found by reversing\
    \ a prefix of myString that comes before a \nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp0t5cjntv_test.go:38:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075441
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        prefix := myString[:i]\n        suffix := myString[i+1:]\n      \
    \  longestPalindromeLen := len(longestPalindrome)\n        if longestPalindromeLen\
    \ < len(prefix) + len(suffix) {\n            longestPalindrome = prefix + suffix\n\
    \        }\n    }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpsrjhg_ie_test.go:20:5: longestPalindromeLen declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075548
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    var\
    \ myStringLen int = len(myString)\n    var myStringPrefix string\n    var myStringSuffix\
    \ string\n    var myStringPrefixLen int\n    var myStringSuffixLen int\n    var\
    \ myStringReverseLen int\n    var myStringReversePrefix string\n    var myStringReverseSuffix\
    \ string\n    var myStringReversePrefixLen int\n    var myStringReverseSuffixLen\
    \ int\n    var myStringReverseReverseLen int\n    var myStringReverseReversePrefix\
    \ string\n    var myStringReverseReverseSuffix string\n    var myStringReverseReversePrefixLen\
    \ int\n    var myStringReverseReverseSuffixLen int\n    var myStringReverseReverseReverseLen\
    \ int\n    var myStringReverseReverseReversePrefix string\n    var myStringReverseReverseReverseSuffix\
    \ string\n    var myStringReverseReverseReversePrefixLen int\n    var myStringReverseReverseReverseSuffixLen\
    \ int\n    var myStringReverseReverseReverseReverseLen int\n    var myStringReverseReverseReverseReversePrefix\
    \ string\n    var myStringReverseReverseReverseReverseSuffix string\n    var myStringReverseReverseReverseReversePrefixLen\
    \ int\n    var myStringReverseReverseReverseSuffixLen int\n    var myStringReverseReverseReverseReverseLen\
    \ int\n    var myStringReverseReverseReverseReversePrefix string\n    var myStringReverseReverseReverseReverseSuffix\
    \ string\n    var myStringReverseReverseReverseReversePrefixLen int\n    var myStringReverseReverseReverseSuffixLen\
    \ int\n    var myStringReverseReverseReverseLen int\n    var myStringReverseReverseReverseReversePrefix\
    \ string\n    var myStringReverseReverseReverseReverseSuffix string\n    var myStringReverseReverseReverseReversePrefixLen\
    \ int\n    var myStringReverseReverseReverseSuffixLen int\n    var myStringReverseReverseReverseLen\
    \ int\n    var myStringReverseReverseReverseReversePrefix string\n    var myStringReverseReverseReverseReverseSuffix\
    \ string\n    var myStringReverseReverseReverseReversePrefixLen int\n    var myStringReverseReverseReverseSuffixLen\
    \ int\n    var myStringReverseReverseReverseLen int\n    var myStringReverseReverseReverseReversePrefix\
    \ string\n    var myStringReverseReverseReverseReverseSuffix string\n    var myStringReverseReverseReverseReversePrefixLen\
    \ int\n    var myStringReverseReverseReverseSuffixLen int\n    var myStringReverseReverseReverseLen\
    \ int\n    var myStringReverseReverseReverseReversePrefix string\n    var myStringReverseReverseReverseReverseSuffix\
    \ string\n    var myStringReverseReverseReverseReversePrefixLen int\n    var myStringReverseReverseReverseSuffixLen\
    \ int\n    var myStringReverseReverseReverseLen int\n    var myStringReverseReverseReverseReversePrefix\
    \ string\n    var myStringReverseReverseReverseReverseSuffix \nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmph5t6_619_test.go:71:9: missing variable type or initialization

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075547
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        prefix := myString[:i]\n        suffix := myString[i:]\n        longestPalindromeLen\
    \ := len(longestPalindrome)\n        longestPalindrome = longestPalindrome + suffix[len(prefix):]\n\
    \        if longestPalindromeLen > len(prefix) {\n            longestPalindrome\
    \ = longestPalindrome + prefix[:len(longestPalindrome)]\n        }\n    }\n  \
    \  return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n \
    \ candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5860z0s0_test.go:20:5: longestPalindromeLen declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075548
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLength := 0\n    for i := 0; i < len(myString);\
    \ i++ {\n        longestPalindromeLength = 0\n        longestPalindrome = myString\n\
    \        for j := 0; j < len(myString); j++ {\n            if myString[j] != myString[len(myString)-j-1]\
    \ {\n                longestPalindromeLength++\n                longestPalindrome\
    \ = myString[:j] + myString[len(myString)-j:]\n                break\n       \
    \     }\n        }\n        if longestPalindromeLength > longestPalindromeLength\
    \ {\n            longestPalindrome = myString\n        }\n    }\n    return longestPalindrome\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMake_Palindrome (0.00s)\n    --- FAIL: TestMake_Palindrome/test_num__2\
    \ (0.00s)\n        tmpl3rmmvoi_test.go:55: expected 'xyzyx', got ''\n    --- FAIL:\
    \ TestMake_Palindrome/test_num__4 (0.00s)\n        tmpl3rmmvoi_test.go:55: expected\
    \ 'jerryrrej', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660075549
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find longest postfix of myString that is a palindrome.\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        postfix := myString[longestPalindromeLen:] + myString[:i]\n     \
    \   if isPalindrome(postfix) {\n            longestPalindrome = postfix\n    \
    \        longestPalindromeLen = len(postfix)\n        }\n    }\n\n    // Append\
    \ to the end of the string reverse of a string prefix that comes before the palindromic\
    \ suffix.\n    prefix := myString[:longestPalindromeLen]\n    return prefix +\
    \ append([]rune(longestPalindrome)..., 'x')\n}\n\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp5p2vw78o_test.go:32:58: expected '')'', found ''x''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075548
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        longestPalindromeLen := 0\n        for j := 0; j < i; j++ {\n   \
    \         if myString[j] != myString[len(myString)-j-1] {\n                longestPalindromeLen\
    \ += 1\n            }\n        }\n        if longestPalindromeLen > longestPalindromeLen\
    \ {\n            longestPalindrome = myString\n        }\n    }\n    return longestPalindrome\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpuc4q933y_test.go:20:5: longestPalindromeLen declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075549
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm\
    \ idea is simple:\n    // - Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    var longestPalindrome\
    \ string\n    for i := 0; i < len(myString); i++ {\n        longestPalindrome\
    \ += myString[i]\n    }\n    \n    // Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    longestPalindrome\
    \ += myString[len(myString)-len(longestPalindrome):]\n    \n    // Return the\
    \ result.\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmppwphw2y4_test.go:33:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075549
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm\
    \ idea is simple:\n    // - Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    // >>> make_palindrome(\"\")\n    // \"\"\
    \n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"\
    cata\")\n    // \"catac\"\n    \n    // Find the longest postfix of supplied string\
    \ that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // - Append to the end\
    \ of the string reverse of a string prefix that comes before the palindromic suffix.\n\
    \    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"\
    cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\
    \n    \n    // Find the longest postfix of supplied string that is a palindrome.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string \nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpn1otdhwh_test.go:67:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075439
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLength := 0\n    for i := 0; i < len(myString);\
    \ i++ {\n        postfix := myString[i:]\n        postfix += myString[:i]\n  \
    \      postfix += myString[:len(myString)-i]\n        postfix += myString[len(myString)-1-i:]\n\
    \        postfix += myString[len(myString)-2-i:]\n        postfix += myString[len(myString)-3-i:]\n\
    \        postfix += myString[len(myString)-4-i:]\n        postfix += myString[len(myString)-5-i:]\n\
    \        postfix += myString[len(myString)-6-i:]\n        postfix += myString[len(myString)-7-i:]\n\
    \        postfix += myString[len(myString)-8-i:]\n        postfix += myString[len(myString)-9-i:]\n\
    \        postfix += myString[len(myString)-10-i:]\n        postfix += myString[len(myString)-11-i:]\n\
    \        postfix += myString[len(myString)-12-i:]\n        postfix += myString[len(myString)-13-i:]\n\
    \        postfix += myString[len(myString)-14-i:]\n        postfix += myString[len(myString)-15-i:]\n\
    \        postfix += myString[len(myString)-16-i:]\n        postfix += myString[len(myString)-17-i:]\n\
    \        postfix += myString[len(myString)-18-i:]\n        postfix += myString[len(myString)-19-i:]\n\
    \        postfix += myString[len(myString)-20-i:]\n        postfix += myString[len(myString)-21-i:]\n\
    \        postfix += myString[len(myString)-22-i:]\n        postfix += myString[len(myString)-23-i:]\n\
    \        postfix += myString[len(myString)-24-i:]\n        postfix += myString[len(myString)-25-i:]\n\
    \        postfix += myString[len(myString)-26-i:]\n        postfix += myString[len(myString)-27-i:]\n\
    \        postfix += myString[len(myString)-28-i:]\n        postfix += myString[len(myString)-29-i:]\n\
    \        postfix += myString[len(myString)-30-i:]\n        postfix += myString[len(myString)-31-i:]\n\
    \        postfix += myString[len(myString)-32-i:]\n        postfix += myString[len(myString)-33-i:]\n\
    \        postfix += my\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate\
    \ := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual:\
    \ candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"\
    ), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpc45foz6__test.go:59:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075548
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        longestPalindromeLen := 0\n        longestPalindrome += myString[i]\n\
    \        for j := i; j < len(myString); j++ {\n            if myString[j] != myString[len(myString)-j-1]\
    \ {\n                longestPalindromeLen += 1\n            }\n        }\n   \
    \     if longestPalindromeLen > longestPalindromeLen {\n            longestPalindrome\
    \ = myString[:i]\n            longestPalindromeLen = longestPalindromeLen\n  \
    \      }\n    }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0uvxooao_test.go:20:5: longestPalindromeLen declared but not used

    /tmp/tmp0uvxooao_test.go:23:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075549
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        longestPalindromeLen := 0\n        for j := 0; j < i; j++ {\n   \
    \         if myString[j] != myString[len(myString)-j-1] {\n                longestPalindromeLen\
    \ += 1\n            }\n        }\n        if longestPalindromeLen > longestPalindromeLen\
    \ {\n            longestPalindrome = myString\n        }\n    }\n    return longestPalindrome\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpuc4q933y_test.go:20:5: longestPalindromeLen declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075549
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm\
    \ idea is simple:\n    // - Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    var longestPalindrome\
    \ string\n    for i := 0; i < len(myString); i++ {\n        longestPalindrome\
    \ += myString[i]\n    }\n    \n    // Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    var reversedString\
    \ string\n    for i := 0; i < len(myString); i++ {\n        reversedString +=\
    \ myString[len(myString)-i-1]\n    }\n    \n    // Return palindrome string.\n\
    \    return longestPalindrome + reversedString\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdhav7n5y_test.go:33:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    /tmp/tmpdhav7n5y_test.go:39:9: invalid operation: reversedString += myString[len(myString)
    - i - 1] (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075549
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLength := 0\n    longestPalindromeLength := len(myString)\n\
    \    for i := 0; i < longestPalindromeLength; i++ {\n        postfix := myString[longestPalindromeLength\
    \ - i]\n        prefix := myString[0:longestPalindromeLength - i]\n        reversedPrefix\
    \ := append(prefix, reverseString(prefix)...)\n        reversedPostfix := append(reverseString(postfix),\
    \ postfix...)\n        if reversedPrefix == reversedPostfix {\n            longestPalindrome\
    \ = reversedPrefix\n            longestPalindromeLength = len(longestPalindrome)\n\
    \        }\n    }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpa6w64n_b_test.go:21:29: no new variables on left side of :=

    /tmp/tmpa6w64n_b_test.go:25:34: first argument to append must be a slice; have
    prefix (variable of type string)

    /tmp/tmpa6w64n_b_test.go:25:42: undefined: reverseString

    /tmp/tmpa6w64n_b_test.go:26:35: undefined: reverseString

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075549
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := len(myString) - 1; i >=\
    \ 0; i-- {\n        prefix := myString[:i]\n        suffix := myString[i+1:]\n\
    \        if suffix == reverseString(prefix) {\n            longestPalindrome =\
    \ prefix + reverseString(suffix)\n            longestPalindromeLen = len(longestPalindrome)\n\
    \        }\n    }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqvlb7h3u_test.go:20:5: longestPalindromeLen declared but not used

    /tmp/tmpqvlb7h3u_test.go:24:22: undefined: reverseString

    /tmp/tmpqvlb7h3u_test.go:25:42: undefined: reverseString

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075550
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        postfix := myString[:i]\n        postfix += myString[len(postfix)-1-i:]\n\
    \        postfix += myString[:len(postfix)-1]\n        postfix += myString[len(postfix)-1-i:]\n\
    \        postfix += myString[:len(postfix)-1]\n        postfix += myString[len(postfix)-1-i:]\n\
    \        postfix += myString[:len(postfix)-1]\n        postfix += myString[len(postfix)-1-i:]\n\
    \        postfix += myString[:len(postfix)-1]\n        postfix += myString[len(postfix)-1-i:]\n\
    \        postfix += myString[:len(postfix)-1]\n        postfix += myString[len(postfix)-1-i:]\n\
    \        postfix += myString[:len(postfix)-1]\n        postfix += myString[len(postfix)-1-i:]\n\
    \        postfix += myString[:len(postfix)-1]\n        postfix += myString[len(postfix)-1-i:]\n\
    \        postfix += myString[:len(postfix)-1]\n        postfix += myString[len(postfix)-1-i:]\n\
    \        postfix += myString[:len(postfix)-1]\n        postfix += myString[len(postfix)-1-i:]\n\
    \        postfix += myString[:len(postfix)-1]\n        postfix += myString[len(postfix)-1-i:]\n\
    \        postfix += myString[:len(postfix)-1]\n        postfix += myString[len(postfix)-1-i:]\n\
    \        postfix += myString[:len(postfix)-1]\n        postfix += myString[len(postfix)-1-i:]\n\
    \        postfix += myString[:len(postfix)-1]\n        postfix += myString[len(postfix)-1-i:]\n\
    \        postfix += myString[:len(postfix)-1]\n        postfix += myString[len(postfix)-1-i:]\n\
    \        postfix += myString[:len(postfix)-1]\n        postfix += myString[len(postfix)-1-i:]\n\
    \        postfix += myString[:len(postfix)-1]\n        postfix += myString[len(postfix)-1-i:]\n\
    \        postfix += myString[:len(postfix)-1]\n        postfix += myString[len(postfix)-1-i:]\n\
    \        postfix += myString[:len(postfix)-1]\n        postfix += myString\nfunc\
    \ TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual:\
    \ candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected:\
    \ \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n    \
    \ { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpxvq2ejnc_test.go:61:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075549
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        longestPalindromeLen := longestPalindromeLen + 1\n        longestPalindrome\
    \ += myString[i]\n    }\n    for i := 0; i < longestPalindromeLen; i++ {\n   \
    \     longestPalindrome += myString[len(myString)-i-1]\n    }\n    return longestPalindrome\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpwvrrhyqf_test.go:22:9: longestPalindromeLen declared but not used

    /tmp/tmpwvrrhyqf_test.go:23:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    /tmp/tmpwvrrhyqf_test.go:26:9: invalid operation: longestPalindrome += myString[len(myString)
    - i - 1] (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075547
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        longestPalindromeLen += len(myString) - i\n        longestPalindrome\
    \ = myString[:longestPalindromeLen] + myString[len(myString) - longestPalindromeLen:]\
    \ + longestPalindrome\n    }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMake_Palindrome (0.00s)\npanic: runtime error: slice bounds\
    \ out of range [:5] with length 3 [recovered]\n\tpanic: runtime error: slice bounds\
    \ out of range [:5] with length 3\n\ngoroutine 19 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.make_palindrome(...)\n\t/tmp/tmp3yyy5mx0_test.go:23\n\
    command-line-arguments_test.TestMake_Palindrome(0x0?)\n\t/tmp/tmp3yyy5mx0_test.go:37\
    \ +0x5ec\ntesting.tRunner(0xc000103520, 0x528f60)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075450
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    longestPalindrome\
    \ := \"\"\n    for i := len(myString) - 1; i >= 0; i-- {\n        longestPalindrome\
    \ += myString[i]\n    }\n\n    // Append to the end of the string reverse of a\
    \ string prefix that comes before the palindromic suffix.\n    longestPalindrome\
    \ += myString[len(longestPalindrome):]\n\n    // Return palindrome string.\n \
    \   return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n\
    \  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpx9rb_3nn_test.go:22:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075550
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    longestPalindrome\
    \ := \"\"\n    for i := len(myString) - 1; i >= 0; i-- {\n        postfix := myString[:i+1]\n\
    \        if isPalindrome(postfix) {\n            longestPalindrome = postfix +\
    \ \"-\" + longestPalindrome\n        }\n    }\n    return longestPalindrome\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmps33mqbhi_test.go:23:12: undefined: isPalindrome

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075550
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm\
    \ idea is simple:\n    // - Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    longestPalindrome := \"\
    \"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++ {\n\
    \        postfix := myString[i:]\n        postfix := append(postfix, myString[:i]...)\n\
    \        postfix := append(postfix, myString[len(myString)-i:len(myString)]...)\n\
    \        postfix := append(postfix, myString[len(myString)-i+1:len(myString)]...)\n\
    \        postfix := append(postfix, myString[:i]...)\n        postfix := append(postfix,\
    \ myString[len(myString)-i:len(myString)]...)\n        postfix := append(postfix,\
    \ myString[len(myString)-i+1:len(myString)]...)\n        postfix := append(postfix,\
    \ myString[:i]...)\n        postfix := append(postfix, myString[len(myString)-i:len(myString)]...)\n\
    \        postfix := append(postfix, myString[len(myString)-i+1:len(myString)]...)\n\
    \        postfix := append(postfix, myString[:i]...)\n        postfix := append(postfix,\
    \ myString[len(myString)-i:len(myString)]...)\n        postfix := append(postfix,\
    \ myString[len(myString)-i+1:len(myString)]...)\n        postfix := append(postfix,\
    \ myString[:i]...)\n        postfix := append(postfix, myString[len(myString)-i:len(myString)]...)\n\
    \        postfix := append(postfix, myString[len(myString)-i+1:len(myString)]...)\n\
    \        postfix := append(postfix, myString[:i]...)\n        postfix := append(postfix,\
    \ myString[len(myString)-i:len(myString)]...)\n        postfix := append(postfix,\
    \ myString[len(myString)-i+1:len(myString)]...)\n        postfix := append(postfix,\
    \ myString[:i]...)\n        post\nfunc TestMake_Palindrome(t *testing.T) {\n \
    \ candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpdifre9o8_test.go:53:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075549
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    var\
    \ myStringLen int = len(myString)\n    var myStringPrefix string\n    var myStringSuffix\
    \ string\n    var myStringReversedSuffix string\n    var myStringReversedPrefix\
    \ string\n    var myStringReversedSuffixLen int\n    var myStringReversedPrefixLen\
    \ int\n\n    // Find longest postfix of supplied string that is a palindrome.\n\
    \    for i := 0; i < myStringLen; i++ {\n        if myString[i] == myString[len(myString)-1\
    \ {\n            myStringPrefix = myString\n            myStringSuffix = \"!\"\
    \n            myStringReversedSuffix = reverse(myStringSuffix)\n            myStringReversedSuffixLen\
    \ = len(myStringReversedSuffix)\n            myStringReversedPrefix = reverse(myStringPrefix)\n\
    \            myStringReversedPrefixLen = len(myStringReversedPrefix)\n       \
    \     break\n        }\n    }\n\n    // Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    for i := 0;\
    \ i < myStringLen; i++ {\n        if myString[i] == myStringReversedSuffixLen\
    \ {\n            myString = append(myString, myStringReversedPrefix)\n       \
    \     myStringLen = len(myString)\n        }\n    }\n\n    return myString\n}\n\
    \nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmps735jb4a_test.go:29:52: expected '']'', found ''{''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075549
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    longestPalindrome\
    \ := \"\"\n    for i := len(myString) - 1; i >= 0; i-- {\n        longestPalindrome\
    \ += myString[i]\n    }\n    // Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    longestPalindrome += myString[len(longestPalindrome):]\n\
    \    // Return palindrome string.\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpg3irkaw1_test.go:22:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075542
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        postfix := myString[i:]\n        postfix += myString[:i]\n      \
    \  postfix += myString[i:] + myString[:i]\n        postfix += myString[:i] + myString[i:]\
    \ + myString[:i]\n        postfix += myString[:i] + myString[i:] + myString[:i]\
    \ + myString[i:]\n        postfix += myString[:i] + myString[i:] + myString[:i]\
    \ + myString[i:] + myString[:i]\n        postfix += myString[:i] + myString[i:]\
    \ + myString[:i] + myString[i:] + myString[:i] + myString[i:]\n        postfix\
    \ += myString[:i] + myString[i:] + myString[:i] + myString[i:] + myString[:i]\
    \ + myString[i:] + myString[:i]\n        postfix += myString[:i] + myString[i:]\
    \ + myString[:i] + myString[i:] + myString[:i] + myString[i:] + myString[:i] +\
    \ myString[i:]\n        postfix += myString[:i] + myString[i:] + myString[:i]\
    \ + myString[i:] + myString[:i] + myString[i:] + myString[:i] + myString[i:] +\
    \ myString[:i]\n        postfix += myString[:i] + myString[i:] + myString[:i]\
    \ + myString[i:] + myString[:i] + myString[i:] + myString[:i] + myString[i:] +\
    \ myString[:i] + myString[i:] + myString[:i]\n        postfix += myString[:i]\
    \ + myString[i:] + myString[:i] + myString[i:] + myString[:i] + myString[i:] +\
    \ myString[:i] + myString[i:] + myString[:i] + myString[i:] + myString[:i] + myString[i:]\n\
    \        postfix += myString[:i] + myString[i:] + myString[:i] + myString[i:]\
    \ + myString[:i] + myString[i:] + myString[:i] + myString[i:] + myString[:i] +\
    \ myString[i:] + myString[:i] + myString[i:] + myString[:i]\n        postfix +=\
    \ myString[:i] + myString[i:] + myString[:i] + \nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpbdfaunah_test.go:36:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075549
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm\
    \ idea is simple:\n    // - Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    longestPalindrome := \"\
    \"\n    longestPalindromeLen := 0\n    for i := len(myString) - 1; i >= 0; i--\
    \ {\n        postfix := myString[:i+1]\n        postfix += string(myString[len(myString)-i-1:])\n\
    \        \n        // Check if postfix is a palindrome.\n        if isPalindrome(postfix)\
    \ {\n            longestPalindrome = postfix\n            longestPalindromeLen\
    \ = len(postfix)\n        }\n    }\n    \n    // Append to the end of the string\
    \ reverse of a string prefix that comes before the palindromic suffix.\n    prefix\
    \ := myString[:longestPalindromeLen]\n    suffix := myString[longestPalindromeLen:]\n\
    \    return prefix + string(append([]rune(suffix), reverse(prefix)...)) + \"c\"\
    \n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp528fznz7_test.go:31:5: longestPalindrome declared but not used

    /tmp/tmp528fznz7_test.go:38:12: undefined: isPalindrome

    /tmp/tmp528fznz7_test.go:47:51: undefined: reverse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075550
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    longestPalindrome\
    \ := \"\"\n    for i := len(myString) - 1; i >= 0; i-- {\n        postfix := myString[:i+1]\n\
    \        if isPalindrome(postfix) {\n            longestPalindrome = postfix +\
    \ \"-\" + longestPalindrome\n        }\n    }\n    // Append to the end of the\
    \ string reverse of a string prefix that comes before the palindromic suffix.\n\
    \    return longestPalindrome + \"-\" + myString\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6n7j8wm2_test.go:23:12: undefined: isPalindrome

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075550
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    var\
    \ myStringLen int = len(myString)\n    var myStringPrefix string\n    var myStringSuffix\
    \ string\n    var myStringReversedSuffix string\n    var myStringReversedPrefix\
    \ string\n    var myStringReversedSuffixLen int\n    var myStringReversedPrefixLen\
    \ int\n\n    // Find the longest postfix of supplied string that is a palindrome.\n\
    \    for i := 0; i < myStringLen; i++ {\n        myStringPrefix = myString[:i]\n\
    \        myStringSuffix = myString[i:]\n        myStringReversedSuffix = reverse(myStringSuffix)\n\
    \        myStringReversedPrefix = reverse(myStringPrefix)\n        if myStringSuffix\
    \ == myStringReversedSuffix {\n            myStringReversedSuffixLen = len(myStringReversedSuffix)\n\
    \        }\n        if myStringPrefix == myStringReversedPrefix {\n          \
    \  myStringReversedPrefixLen = len(myStringReversedPrefix)\n        }\n      \
    \  if myStringReversedSuffixLen > myStringReversedPrefixLen {\n            break\n\
    \        }\n    }\n\n    // Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    myStringReversedSuffix\
    \ = reverse(myStringSuffix)\n    myStringReversedPrefix = reverse(myStringPrefix)\n\
    \    myStringReversedSuffixLen = len(myStringReversedSuffix)\n    myStringReversedPrefixLen\
    \ = len(myStringReversedPrefix)\n    for i := 0; i < myStringLen; i++ {\n    \
    \    myStringPrefix = myString[:i]\n        myStringSuffix = myString[i:]\n  \
    \      myStringReversedSuffix = reverse(myStringSuffix)\n        myStringReversedPrefix\
    \ = reverse(myStringPrefix)\n        if myStringSuffix == myStringReversedSuffix\
    \ {\n            myStringReversedSuffixLen = len(myStringReversedSuffix)\n   \
    \     }\n        if myStringPrefix == myStringReversedPrefix {\n            myStringReversedPrefixLen\
    \ = len(myStringReversedPrefix)\n        }\n        if myStringReversedSuffixLen\
    \ > myStringReversedPrefixLen {\n            myString = append(myString, myStringReversedSuffix[:myStringReversedSuffixLen])\n\
    \            myString = append(myString, myStringReversedPrefix[:myStringReversedPrefixLen])\n\
    \            break\n        }\n    }\n\n    return myString\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkowa53a8_test.go:31:34: undefined: reverse

    /tmp/tmpkowa53a8_test.go:32:34: undefined: reverse

    /tmp/tmpkowa53a8_test.go:45:30: undefined: reverse

    /tmp/tmpkowa53a8_test.go:46:30: undefined: reverse

    /tmp/tmpkowa53a8_test.go:52:34: undefined: reverse

    /tmp/tmpkowa53a8_test.go:53:34: undefined: reverse

    /tmp/tmpkowa53a8_test.go:61:31: first argument to append must be a slice; have
    myString (variable of type string)

    /tmp/tmpkowa53a8_test.go:62:31: first argument to append must be a slice; have
    myString (variable of type string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075550
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLength := 0\n    longestPalindromeLength := len(myString)\n\
    \    for i := 0; i < longestPalindromeLength; i++ {\n        longestPalindrome\
    \ += myString[i]\n    }\n    for i := 0; i < longestPalindromeLength; i++ {\n\
    \        longestPalindrome += myString[len(myString)-(i+1)]\n    }\n    return\
    \ longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate\
    \ := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual:\
    \ candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"\
    ), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbtzvswkv_test.go:21:29: no new variables on left side of :=

    /tmp/tmpbtzvswkv_test.go:23:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    /tmp/tmpbtzvswkv_test.go:26:9: invalid operation: longestPalindrome += myString[len(myString)
    - (i + 1)] (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075542
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLength := 0\n    longestPalindromeLength := len(myString)\n\
    \    for i := 0; i < longestPalindromeLength; i++ {\n        longestPalindrome\
    \ += myString[i]\n    }\n    for i := 0; i < longestPalindromeLength; i++ {\n\
    \        longestPalindrome += myString[len(myString)-(i+1)]\n    }\n    return\
    \ longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate\
    \ := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual:\
    \ candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"\
    ), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbtzvswkv_test.go:21:29: no new variables on left side of :=

    /tmp/tmpbtzvswkv_test.go:23:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    /tmp/tmpbtzvswkv_test.go:26:9: invalid operation: longestPalindrome += myString[len(myString)
    - (i + 1)] (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075542
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm\
    \ idea is simple:\n    // - Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    // >>> make_palindrome(\"\")\n    // \"\"\
    \n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"\
    cata\")\n    // \"catac\"\n    \n    // Find the longest postfix of supplied string\
    \ that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // - Append to the end\
    \ of the string reverse of a string prefix that comes before the palindromic suffix.\n\
    \    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"\
    cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\
    \n    \n    // Find the longest postfix of supplied string that is a palindrome.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string \nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpn1otdhwh_test.go:67:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075439
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := len(myString) - 1; i >=\
    \ 0; i-- {\n        thisChar := myString[i]\n        thisLen := 1\n        for\
    \ j := 0; j < i; j++ {\n            if thisChar == myString[j] {\n           \
    \     thisLen++\n            } else {\n                break\n            }\n\
    \        }\n        if thisLen > longestPalindromeLen {\n            longestPalindrome\
    \ = myString[:i+longestPalindromeLen]\n            longestPalindromeLen = thisLen\n\
    \        }\n    }\n    // Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    thisLen := len(myString)\n\
    \    for i := len(longestPalindrome); i < thisLen; i++ {\n        longestPalindrome\
    \ += myString[thisLen-1-i]\n    }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0x10jic7_test.go:40:9: invalid operation: longestPalindrome += myString[thisLen
    - 1 - i] (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075550
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    longestPalindromeLen := len(myString)\n\
    \    for i := 0; i < longestPalindromeLen; i++ {\n        longestPalindrome +=\
    \ myString[i]\n    }\n    for i := 0; i < longestPalindromeLen; i++ {\n      \
    \  longestPalindrome += myString[len(myString)-1-i]\n    }\n    return longestPalindrome\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpc84rx_qd_test.go:21:26: no new variables on left side of :=

    /tmp/tmpc84rx_qd_test.go:23:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    /tmp/tmpc84rx_qd_test.go:26:9: invalid operation: longestPalindrome += myString[len(myString)
    - 1 - i] (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075446
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    longestPalindromeLen := len(myString)\n\
    \    for i := 0; i < longestPalindromeLen; i++ {\n        longestPalindrome +=\
    \ myString[i]\n    }\n    for i := 0; i < longestPalindromeLen; i++ {\n      \
    \  longestPalindrome += myString[len(myString)-(i+1)]\n    }\n    return longestPalindrome\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1gquw2wq_test.go:21:26: no new variables on left side of :=

    /tmp/tmp1gquw2wq_test.go:23:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    /tmp/tmp1gquw2wq_test.go:26:9: invalid operation: longestPalindrome += myString[len(myString)
    - (i + 1)] (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075448
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    longestPalindromeLen := len(myString)\n\
    \    for i := 0; i < longestPalindromeLen; i++ {\n        prefix := myString[0:i]\n\
    \        suffix := myString[i+1:]\n        postfix := reversePostfix(prefix)\n\
    \        if suffix == postfix {\n            longestPalindrome += prefix\n   \
    \         longestPalindromeLen += len(prefix)\n        } else {\n            longestPalindrome\
    \ += prefix\n            longestPalindromeLen += len(prefix)\n            longestPalindrome\
    \ += postfix\n            longestPalindromeLen += len(postfix)\n        }\n  \
    \  }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpefqipm4y_test.go:21:26: no new variables on left side of :=

    /tmp/tmpefqipm4y_test.go:25:20: undefined: reversePostfix

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075550
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm\
    \ idea is simple:\n    // - Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    var longestPalindrome\
    \ string\n    longestPalindrome = \"\"\n    for i := 0; i < len(myString); i++\
    \ {\n        longestPalindrome += myString[i]\n    }\n    \n    // Append to the\
    \ end of the string reverse of a string prefix that comes before the palindromic\
    \ suffix.\n    var reversedString string\n    reversedString = longestPalindrome\n\
    \    for i := 0; i < len(myString); i++ {\n        reversedString += myString[len(myString)-1-i]\n\
    \    }\n    \n    return reversedString\n}\n\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpx0jfmlny_test.go:34:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    /tmp/tmpx0jfmlny_test.go:41:9: invalid operation: reversedString += myString[len(myString)
    - 1 - i] (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075550
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find longest postfix of myString that is a palindrome.\n    // The longest postfix\
    \ is found by reversing a prefix of myString that comes before a palindromic suffix.\n\
    \    // The longest postfix is found by reversing a prefix of myString that comes\
    \ before a palindromic suffix.\n    // The longest postfix is found by reversing\
    \ a prefix of myString that comes before a palindromic suffix.\n    // The longest\
    \ postfix is found by reversing a prefix of myString that comes before a palindromic\
    \ suffix.\n    // The longest postfix is found by reversing a prefix of myString\
    \ that comes before a palindromic suffix.\n    // The longest postfix is found\
    \ by reversing a prefix of myString that comes before a palindromic suffix.\n\
    \    // The longest postfix is found by reversing a prefix of myString that comes\
    \ before a palindromic suffix.\n    // The longest postfix is found by reversing\
    \ a prefix of myString that comes before a palindromic suffix.\n    // The longest\
    \ postfix is found by reversing a prefix of myString that comes before a palindromic\
    \ suffix.\n    // The longest postfix is found by reversing a prefix of myString\
    \ that comes before a palindromic suffix.\n    // The longest postfix is found\
    \ by reversing a prefix of myString that comes before a palindromic suffix.\n\
    \    // The longest postfix is found by reversing a prefix of myString that comes\
    \ before a palindromic suffix.\n    // The longest postfix is found by reversing\
    \ a prefix of myString that comes before a palindromic suffix.\n    // The longest\
    \ postfix is found by reversing a prefix of myString that comes before a palindromic\
    \ suffix.\n    // The longest postfix is found by reversing a prefix of myString\
    \ that comes before a palindromic suffix.\n    // The longest postfix is found\
    \ by reversing a prefix of myString that comes before a palindromic suffix.\n\
    \    // The longest postfix is found by reversing a prefix of myString that comes\
    \ before a palindromic suffix.\n    // The longest postfix is found by reversing\
    \ a prefix of myString that comes before a \nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp0t5cjntv_test.go:38:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075441
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    var\
    \ myStringLen int = len(myString)\n    var myStringPrefix string\n    var myStringSuffix\
    \ string\n    var myStringReverse string\n    var myStringPalindrome string\n\n\
    \    // Find the longest postfix that is a palindrome\n    for i := 0; i < myStringLen;\
    \ i++ {\n        myStringPrefix = myString[:i]\n        myStringSuffix = myString[i:]\n\
    \        myStringReverse = reverse(myStringPrefix)\n        if myStringSuffix\
    \ == myStringReverse {\n            myStringPalindrome = myStringPrefix + myStringSuffix\n\
    \            break\n        }\n    }\n\n    return myStringPalindrome\n}\n\nfunc\
    \ TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual:\
    \ candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected:\
    \ \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n    \
    \ { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpsailua4z_test.go:29:27: undefined: reverse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075550
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    longestPalindromeLen += len(myString)\n\
    \    for i := 0; i < len(myString); i++ {\n        prefix := myString[:i]\n  \
    \      postfix := myString[i:]\n        postfix += reverseString(prefix)\n   \
    \     longestPalindromeLen += len(postfix)\n        if longestPalindromeLen >\
    \ longestPalindrome[len(longestPalindrome)-1] {\n            longestPalindrome\
    \ = postfix\n        }\n    }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpu2dy71_y_test.go:25:20: undefined: reverseString

    /tmp/tmpu2dy71_y_test.go:27:35: invalid operation: longestPalindromeLen > longestPalindrome[len(longestPalindrome)
    - 1] (mismatched types int and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075550
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm\
    \ idea is simple:\n    // - Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    // >>> make_palindrome(\"\")\n    // \"\"\
    \n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"\
    cata\")\n    // \"catac\"\n    \n    // Find the longest postfix of supplied string\
    \ that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // - Append to the end\
    \ of the string reverse of a string prefix that comes before the palindromic suffix.\n\
    \    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"\
    cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\
    \n    \n    // Find the longest postfix of supplied string that is a palindrome.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string \nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpn1otdhwh_test.go:67:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075439
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    var\
    \ myStringLen int = len(myString)\n    var myStringPrefix string = \"\"\n    var\
    \ myStringSuffix string = \"\"\n    var myStringReversedSuffix string = \"\"\n\
    \    var myStringReversedPrefix string = \"\"\n\n    // Find the longest postfix\
    \ of supplied string that is a palindrome.\n    for i := 0; i < myStringLen; i++\
    \ {\n        if myString[i] == myString[myStringLen-1] {\n            myStringPrefix\
    \ = myStringPrefix + myString[i]\n            myStringLen--\n        } else {\n\
    \            break\n        }\n    }\n\n    // Append to the end of the string\
    \ reverse of a string prefix that comes before the palindromic suffix.\n    for\
    \ i := 0; i < myStringLen; i++ {\n        if myStringLen > 1 {\n            myStringSuffix\
    \ = myStringSuffix + myString[myStringLen-1]\n            myStringLen--\n    \
    \    }\n    }\n\n    // Reverse the string suffix.\n    for i := 0; i < myStringLen;\
    \ i++ {\n        myStringReversedSuffix = myStringReversedSuffix + myString[i]\n\
    \    }\n\n    // Reverse the string prefix.\n    for i := 0; i < myStringLen;\
    \ i++ {\n        myStringReversedPrefix = myStringReversedPrefix + myString[i]\n\
    \    }\n\n    // Concatenate them and return.\n    return myStringPrefix + myStringReversedSuffix\
    \ + myStringReversedPrefix\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate\
    \ := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual:\
    \ candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"\
    ), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjtwivm81_test.go:28:30: invalid operation: myStringPrefix + myString[i]
    (mismatched types string and byte)

    /tmp/tmpjtwivm81_test.go:38:30: invalid operation: myStringSuffix + myString[myStringLen
    - 1] (mismatched types string and byte)

    /tmp/tmpjtwivm81_test.go:45:34: invalid operation: myStringReversedSuffix + myString[i]
    (mismatched types string and byte)

    /tmp/tmpjtwivm81_test.go:50:34: invalid operation: myStringReversedPrefix + myString[i]
    (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075551
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := len(myString) - 1; i >=\
    \ 0; i-- {\n        postfix := myString[:i+1]\n        if isPalindrome(postfix)\
    \ {\n            longestPalindrome = longestPalindrome + postfix\n           \
    \ longestPalindromeLen = len(longestPalindrome)\n        }\n    }\n\n    // Append\
    \ to the end of the string reverse of a string prefix that comes before the palindromic\
    \ suffix.\n    prefix := myString[:longestPalindromeLen]\n    return prefix +\
    \ strings.Reverse(longestPalindrome)\n}\n\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmps579mro0_test.go:24:12: undefined: isPalindrome

    /tmp/tmps579mro0_test.go:32:21: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075551
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLength := 0\n    longestPalindromeLength := len(myString)\n\
    \    for i := 0; i < longestPalindromeLength; i++ {\n        longestPalindrome\
    \ += myString[i]\n    }\n    for i := 0; i < longestPalindromeLength; i++ {\n\
    \        longestPalindrome += myString[len(myString)-(i+1)]\n    }\n    return\
    \ longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate\
    \ := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual:\
    \ candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"\
    ), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbtzvswkv_test.go:21:29: no new variables on left side of :=

    /tmp/tmpbtzvswkv_test.go:23:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    /tmp/tmpbtzvswkv_test.go:26:9: invalid operation: longestPalindrome += myString[len(myString)
    - (i + 1)] (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075542
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        postfix := myString[longestPalindromeLen:] + myString[:longestPalindromeLen]\n\
    \        longestPalindromeLen += len(postfix)\n        if postfix != make_palindrome(postfix)\
    \ {\n            longestPalindrome = \"\"\n            longestPalindromeLen =\
    \ 0\n        }\n        if longestPalindromeLen > len(longestPalindrome) {\n \
    \           longestPalindrome = myString\n        }\n    }\n    return longestPalindrome\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0388\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f361?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\nruntime.concatstrings(0x0?, {0xc0201e03b8?,\
    \ 0x2?, 0x2?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/string.go:25\
    \ +0x270 fp=0xc0201e0398 sp=0xc0201e0390 pc=0x44d5d0\nruntime.concatstring2(0x1?,\
    \ {0x51d187?, 0x44d650?}, {0x51d187?, 0xc0201e0420?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/string.go:60\
    \ +0x50 fp=0xc0201e03e8 sp=0xc0201e0398 pc=0x44d650\ncommand-line-arguments_test.make_palindrome({0x51d187,\
    \ 0x1})\n\t/tmp/tmpduoqsxjv_test.go:22 +0xa7 fp=0xc0201e0450 sp=0xc0201e03e8 pc=0x4ef707\n\
    command-line-arguments_test.make_palindrome({0x51d187, 0x1})\n\t/tmp/tmpduoqsxjv_test.go:24\
    \ +0xb6 fp=0xc0201e04b8 sp=0xc0201e0450 pc=0x4ef716\ncommand-line-arguments_test.make_palindrome({0x51d187,\
    \ 0x1})\n\t/tmp/tmpduoqsxjv_test.go:24 +0xb6 fp=0xc0201e0520 sp=0xc0201e04b8 pc=0x4ef716\n\
    command-line-arguments_test.make_palindrome({0x51d187, 0x1})\n\t/tmp/tmpduoqsxjv_test.go:24\
    \ +0xb6 fp=0xc0201e0588 sp=0xc0201e0520 pc=0x4ef716\ncommand-line-arguments_test.make_palindrome({0x51d187,\
    \ 0x1})\n\t/tmp/tmpduoqsxjv_test.go:24 +0xb6 fp=0xc0201e05f0 sp=0xc0201e0588 pc=0x4ef716\n\
    command-line-arguments_test.make_palindrome({0x51d187, 0x1})\n\t/tmp/tmpduoqsxjv_test.go:24\
    \ +0xb6 fp=0xc0201e0658 sp=0xc0201e05f0 pc=0x4ef716\ncommand-line-arguments_test.make_palindrome({0x51d187,\
    \ 0x1})\n\t/tmp/tmpduoqsxjv_test.go:24 +0xb6 fp=0xc0201e06c0 sp=0xc0201e0658 pc=0x4ef716\n\
    command-line-arguments_test.make_palindrome({0x51d187, 0x1})\n\t/tmp/tmpduoqsxjv_test.go:24\
    \ +0xb6 fp=0xc0201e0728 sp=0xc0201e06c0 pc=0x4ef716\ncommand-line-arguments_test.make_palindrome({0x51d187,\
    \ 0x1})\n\t/tmp/tmpduoqsxjv_test.go:24 +0"
  timestamp: 1660075552
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    longestPalindromeLen += len(myString)\n\
    \    for i := 0; i < len(myString); i++ {\n        prefix := myString[:i]\n  \
    \      suffix := myString[i:]\n        postfix := make_palindrome(suffix)\n  \
    \      if postfix != \"\" {\n            longestPalindromeLen += len(postfix)\n\
    \            if longestPalindromeLen > longestPalindromeLen {\n              \
    \  longestPalindrome = prefix\n                longestPalindromeLen = len(prefix)\n\
    \            }\n        }\n    }\n    return longestPalindrome + suffix\n}\n\n\
    func TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual:\
    \ candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected:\
    \ \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n    \
    \ { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpzxwo6a2o_test.go:34:32: undefined: suffix

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075551
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm\
    \ idea is simple:\n    // - Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    var longestPalindrome\
    \ string = \"\"\n    for i := 0; i < len(myString); i++ {\n        longestPalindrome\
    \ += myString[i]\n    }\n    \n    // Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    longestPalindrome\
    \ += myString[len(longestPalindrome):]\n    \n    // Return the result.\n    return\
    \ longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate\
    \ := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual:\
    \ candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"\
    ), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpavijw_k4_test.go:33:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075551
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := len(myString) - 1; i >=\
    \ 0; i-- {\n        prefix := myString[:i]\n        suffix := myString[i+1:]\n\
    \        postfix := reversePostfix(prefix)\n        if postfix != suffix {\n \
    \           longestPalindrome = prefix + postfix\n            longestPalindromeLen\
    \ = len(longestPalindrome)\n        }\n    }\n    if longestPalindromeLen > 0\
    \ {\n        return longestPalindrome + myString[longestPalindromeLen:]\n    }\n\
    \    return \"\"\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate :=\
    \ make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual:\
    \ candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"\
    ), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbav9ycf2_test.go:24:20: undefined: reversePostfix

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075551
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        longestPalindromeLen += 1 // increment the length of the longest\
    \ palindrome so far\n        longestPalindrome += myString[i]\n    }\n    for\
    \ i := 0; i < longestPalindromeLen; i++ {\n        longestPalindrome += myString[len(myString)-i]\n\
    \    }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7ptzzl9b_test.go:23:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    /tmp/tmp7ptzzl9b_test.go:26:9: invalid operation: longestPalindrome += myString[len(myString)
    - i] (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075551
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm\
    \ idea is simple:\n    // - Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    longestPalindrome := \"\
    \"\n    longestPalindromeLen := 0\n    for i := len(myString) - 1; i >= 0; i--\
    \ {\n        postfix := myString[:i+1]\n        postfix += myString[len(myString)-i-1:]\n\
    \        postfix += myString[len(myString)-i:]\n        postfix += myString[:i]\n\
    \        postfix += myString[i+1:]\n        postfix += myString[i:]\n        postfix\
    \ += myString[:i+1]\n        postfix += myString[len(myString)-i-1:]\n       \
    \ postfix += myString[len(myString)-i:]\n        postfix += myString[:i]\n   \
    \     postfix += myString[i+1:]\n        postfix += myString[i:]\n        postfix\
    \ += myString[:i+1]\n        postfix += myString[len(myString)-i-1:]\n       \
    \ postfix += myString[len(myString)-i:]\n        postfix += myString[:i]\n   \
    \     postfix += myString[i+1:]\n        postfix += myString[i:]\n        postfix\
    \ += myString[:i+1]\n        postfix += myString[len(myString)-i-1:]\n       \
    \ postfix += myString[len(myString)-i:]\n        postfix += myString[:i]\n   \
    \     postfix += myString[i+1:]\n        postfix += myString[i:]\n        postfix\
    \ += myString[:i+1]\n        postfix += myString[len(myString)-i-1:]\n       \
    \ postfix += myString[len(myString)-i:]\n        postfix += myString[:i]\n   \
    \     postfix += myString[i+1:]\n        postfix += myString[i:]\n        postfix\
    \ += myString[:i+1]\n        postfix += myString[len(myString)-i-1:]\n       \
    \ postfix += myString[len(myString)-i:]\n        postfix += myString[:i]\n   \
    \     postfix += myString[i+1:]\n        post\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpd5mef2tc_test.go:68:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075551
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ If string is empty, return empty string\n    if len(myString) == 0 {\n     \
    \   return \"\"\n    }\n\n    // Find the longest postfix of supplied string that\
    \ is a palindrome.\n    // The longest postfix is always a palindrome.\n    longestPalindrome\
    \ := \"\"\n    for i := len(myString) - 1; i >= 0; i-- {\n        longestPalindrome\
    \ += myString[i]\n    }\n\n    // Append to the end of the string reverse of a\
    \ string prefix that comes before the palindromic suffix.\n    // The reverse\
    \ of a string prefix is always a palindrome.\n    longestPalindrome += myString[len(myString)-len(longestPalindrome):]\n\
    \n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n\
    \  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpq08b_h64_test.go:28:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075551
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find longest postfix of myString that is a palindrome.\n    longestPalindrome\
    \ := \"\"\n    for i := 0; i < len(myString); i++ {\n        longestPalindrome\
    \ += myString[i]\n    }\n    longestPalindrome = longestPalindrome[:len(longestPalindrome)-1]\n\
    \    // Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    longestPalindromeReverse := \"\"\n    for\
    \ i := 0; i < len(longestPalindrome); i++ {\n        longestPalindromeReverse\
    \ += longestPalindrome[len(longestPalindrome)-1-i]\n    }\n    return longestPalindromeReverse\
    \ + longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate\
    \ := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual:\
    \ candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"\
    ), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpcpj55tlt_test.go:22:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    /tmp/tmpcpj55tlt_test.go:28:9: invalid operation: longestPalindromeReverse +=
    longestPalindrome[len(longestPalindrome) - 1 - i] (mismatched types string and
    byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075551
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm\
    \ idea is simple:\n    // - Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    longestPalindrome := \"\
    \"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++ {\n\
    \        longestPalindromeLen += len(myString) - i\n        if myString[len(myString)-i]\
    \ == 'a' {\n            longestPalindromeLen -= 1\n        }\n        if longestPalindromeLen\
    \ > len(longestPalindrome) {\n            longestPalindrome = myString[:len(myString)-i]\n\
    \            longestPalindromeLen = len(longestPalindrome)\n        }\n    }\n\
    \    \n    // Append to the end of the string reverse of a string prefix that\
    \ comes before the palindromic suffix.\n    longestPalindromeReverse := \"\"\n\
    \    for i := 0; i < len(longestPalindrome); i++ {\n        longestPalindromeReverse\
    \ += myString[len(myString)-i]\n    }\n    \n    // Return the palindrome that\
    \ begins with the supplied string.\n    return longestPalindrome + longestPalindromeReverse\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpceithzva_test.go:47:9: invalid operation: longestPalindromeReverse +=
    myString[len(myString) - i] (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075552
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLength := 0\n    for i := 0; i < len(myString);\
    \ i++ {\n        longestPalindromeLength++\n        longestPalindrome += myString[i]\n\
    \    }\n    for i := 0; i < longestPalindromeLength; i++ {\n        longestPalindrome\
    \ += myString[len(myString)-1-i]\n    }\n    return longestPalindrome\n}\n\nfunc\
    \ TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual:\
    \ candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected:\
    \ \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n    \
    \ { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2krrnqb3_test.go:23:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    /tmp/tmp2krrnqb3_test.go:26:9: invalid operation: longestPalindrome += myString[len(myString)
    - 1 - i] (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075439
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm\
    \ idea is simple:\n    // - Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    // >>> make_palindrome(\"\")\n    // \"\"\
    \n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"\
    cata\")\n    // \"catac\"\n    \n    // Find the longest postfix of supplied string\
    \ that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // - Append to the end\
    \ of the string reverse of a string prefix that comes before the palindromic suffix.\n\
    \    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"\
    cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\
    \n    \n    // Find the longest postfix of supplied string that is a palindrome.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string \nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpn1otdhwh_test.go:67:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075439
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        longestPalindromeLen := 0\n        longestPalindrome += myString[i]\n\
    \        for j := 0; j < len(myString); j++ {\n            if myString[j] != myString[len(myString)-j-1]\
    \ {\n                longestPalindromeLen += 1\n            }\n        }\n   \
    \     if longestPalindromeLen > longestPalindromeLen {\n            longestPalindrome\
    \ = myString\n            longestPalindromeLen = len(myString)\n        }\n  \
    \  }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbxkhfr0t_test.go:20:5: longestPalindromeLen declared but not used

    /tmp/tmpbxkhfr0t_test.go:23:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075552
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    longestPalindrome\
    \ := \"\"\n    for i := len(myString) - 1; i >= 0; i-- {\n        longestPalindrome\
    \ += myString[i]\n    }\n\n    // Append to the end of the string reverse of a\
    \ string prefix that comes before the palindromic suffix.\n    longestPalindromeReverse\
    \ := \"\"\n    for i := 0; i < len(myString); i++ {\n        longestPalindromeReverse\
    \ += myString[len(myString)-i-1]\n    }\n\n    // Return palindrome string.\n\
    \    return longestPalindrome + longestPalindromeReverse\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyubwkgyx_test.go:22:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    /tmp/tmpyubwkgyx_test.go:28:9: invalid operation: longestPalindromeReverse +=
    myString[len(myString) - i - 1] (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075552
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    var\
    \ myStringLen int = len(myString)\n    var myStringPrefix string\n    var myStringSuffix\
    \ string\n    var myStringReverse string\n\n    for i := 0; i < myStringLen; i++\
    \ {\n        myStringPrefix = myString[:i]\n        myStringSuffix = myString[i:]\n\
    \        myStringReverse = reverse(myStringPrefix) + myStringSuffix\n        if\
    \ myStringReverse == myString {\n            return myString\n        }\n    }\n\
    \    return \"\"\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate :=\
    \ make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual:\
    \ candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"\
    ), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpij58qzuh_test.go:27:27: undefined: reverse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075552
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find longest postfix of myString that is a palindrome.\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        postfix := myString[i:]\n        if isPalindrome(postfix) {\n   \
    \         longestPalindrome = myString[:i]\n            longestPalindromeLen =\
    \ len(longestPalindrome)\n        }\n    }\n\n    // Append the reverse of the\
    \ longest postfix to the end of the string.\n    result := myString\n    for i\
    \ := 0; i < longestPalindromeLen; i++ {\n        result += string(myString[len(longestPalindrome):])\n\
    \    }\n\n    return result\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n \
    \ candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmhpb5htz_test.go:24:12: undefined: isPalindrome

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075552
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLength := 0\n    for i := 0; i < len(myString);\
    \ i++ {\n        longestPalindromeLength = 0\n        for j := 0; j < len(myString);\
    \ j++ {\n            if myString[i] == myString[j] {\n                longestPalindromeLength++\n\
    \            }\n        }\n        if longestPalindromeLength > longestPalindromeLength\
    \ {\n            longestPalindrome = myString[:longestPalindromeLength]\n    \
    \    }\n    }\n    return longestPalindrome + myString[len(longestPalindrome):]\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMake_Palindrome (0.00s)\n    --- FAIL: TestMake_Palindrome/test_num__2\
    \ (0.00s)\n        tmptnkjv_td_test.go:52: expected 'xyzyx', got 'xyz'\n    ---\
    \ FAIL: TestMake_Palindrome/test_num__4 (0.00s)\n        tmptnkjv_td_test.go:52:\
    \ expected 'jerryrrej', got 'jerry'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\n\
    FAIL\n"
  timestamp: 1660075450
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLength := 0\n    for i := 0; i < len(myString);\
    \ i++ {\n        longestPalindromeLength = 0\n        longestPalindrome = myString\n\
    \        for j := i; j < len(myString); j++ {\n            if myString[j] != myString[j]\
    \ {\n                longestPalindromeLength++\n                longestPalindrome\
    \ = myString[:j] + myString[j+longestPalindromeLength:]\n                break\n\
    \            }\n        }\n    }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMake_Palindrome (0.00s)\n    --- FAIL: TestMake_Palindrome/test_num__2\
    \ (0.00s)\n        tmpp5yt8fc5_test.go:52: expected 'xyzyx', got 'xyz'\n    ---\
    \ FAIL: TestMake_Palindrome/test_num__4 (0.00s)\n        tmpp5yt8fc5_test.go:52:\
    \ expected 'jerryrrej', got 'jerry'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660075553
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find longest postfix of myString that is a palindrome\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := len(myString) - 1; i >=\
    \ 0; i-- {\n        prefix := myString[:i]\n        postfix := myString[i:]\n\
    \        if isPalindrome(prefix, postfix) {\n            longestPalindrome = prefix\
    \ + reverseString(postfix)\n            longestPalindromeLen = len(longestPalindrome)\n\
    \        }\n    }\n\n    // Append the reverse of the longest postfix to the end\
    \ of the string\n    result := myString + reverseString(longestPalindrome)\n \
    \   return result[:longestPalindromeLen]\n}\n\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpupdu4t2d_test.go:25:12: undefined: isPalindrome

    /tmp/tmpupdu4t2d_test.go:26:42: undefined: reverseString

    /tmp/tmpupdu4t2d_test.go:32:26: undefined: reverseString

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075552
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := len(myString) - 1; i >=\
    \ 0; i-- {\n        prefix := myString[:i]\n        suffix := myString[i+1:]\n\
    \        if isPalindrome(prefix, suffix) {\n            longestPalindrome = prefix\
    \ + suffix\n            longestPalindromeLen = len(longestPalindrome)\n      \
    \  }\n    }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp322rxah4_test.go:20:5: longestPalindromeLen declared but not used

    /tmp/tmp322rxah4_test.go:24:12: undefined: isPalindrome

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075441
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Initialize a variable to hold the longest postfix of myString that is a palindrome.\n\
    \    var longestPalindrome string = \"\"\n\n    // Initialize a variable to hold\
    \ the reverse of the longest postfix of myString that is a palindrome.\n    var\
    \ longestPalindromeReverse string = \"\"\n\n    // Initialize a variable to hold\
    \ the length of the longest postfix of myString that is a palindrome.\n    var\
    \ longestPalindromeLength int = 0\n\n    // Initialize a variable to hold the\
    \ length of the longest postfix of myString that is a palindrome.\n    var longestPalindromeReverseLength\
    \ int = 0\n\n    // Initialize a variable to hold the length of the longest postfix\
    \ of myString that is a palindrome.\n    var longestPalindromeReverseLength2 int\
    \ = 0\n\n    // Initialize a variable to hold the length of the longest postfix\
    \ of myString that is a palindrome.\n    var longestPalindromeReverseLength3 int\
    \ = 0\n\n    // Initialize a variable to hold the length of the longest postfix\
    \ of myString that is a palindrome.\n    var longestPalindromeReverseLength4 int\
    \ = 0\n\n    // Initialize a variable to hold the length of the longest postfix\
    \ of myString that is a palindrome.\n    var longestPalindromeReverseLength5 int\
    \ = 0\n\n    // Initialize a variable to hold the length of the longest postfix\
    \ of myString that is a palindrome.\n    var longestPalindromeReverseLength6 int\
    \ = 0\n\n    // Initialize a variable to hold the length of the longest postfix\
    \ of myString that is a palindrome.\n    var longestPalindromeReverseLength7 int\
    \ = 0\n\n    // Initialize a variable to hold the length of the longest postfix\
    \ of myString that is a palindrome.\n    var longestPalindromeReverseLength8 int\
    \ = 0\n\n    // Initialize a variable to hold the length of the longest postfix\
    \ of myString that is a palindrome.\n    var longestPalindromeReverseLength9 int\
    \ = 0\n\n    // Initialize a variable to hold the length of the longest postfix\
    \ of myString that is a palindrome.\n    var longestPalindromeReverseLength10\
    \ int = 0\n\n    // Initialize a variable to hold the length of the longest postfix\
    \ of myString that is a palindrome.\n    var longestPalindromeReverseLength11\
    \ int = 0\n\n    // Initialize a variable to hold the length of the longest postfix\
    \ of myString that is a palindrome.\n    var longestPalindromeReverseLength12\
    \ int = 0\n\n    // Initialize a variable to hold the \nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6u27i9r1_test.go:65:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075552
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        longestPalindromeLen += len(myString) - i\n        longestPalindrome\
    \ += myString[len(myString)-i:] + myString[:len(myString)-i]\n    }\n    for i\
    \ := 0; i < longestPalindromeLen; i++ {\n        longestPalindrome += myString[len(myString)-i]\n\
    \    }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpsc3hgkw2_test.go:26:9: invalid operation: longestPalindrome += myString[len(myString)
    - i] (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075552
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm\
    \ idea is simple:\n    // - Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    // >>> make_palindrome(\"\")\n    // \"\"\
    \n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"\
    cata\")\n    // \"catac\"\n    \n    // Find the longest postfix of supplied string\
    \ that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // - Append to the end\
    \ of the string reverse of a string prefix that comes before the palindromic suffix.\n\
    \    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"\
    cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\
    \n    \n    // Find the longest postfix of supplied string that is a palindrome.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string \nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpn1otdhwh_test.go:67:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075439
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find longest postfix of myString that is a palindrome\n    longestPalindrome\
    \ := \"\"\n    for i := len(myString) - 1; i >= 0; i-- {\n        longestPalindrome\
    \ += myString[i]\n    }\n\n    // Append to the end of the string reverse of a\
    \ string prefix that comes before the palindromic suffix\n    longestPalindrome\
    \ += myString[len(longestPalindrome):]\n\n    // Return result\n    return longestPalindrome\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpf06q18kz_test.go:22:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075552
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLength := 0\n    for i := 0; i < len(myString);\
    \ i++ {\n        longestPalindromeLength = 0\n        for j := 0; j < len(myString);\
    \ j++ {\n            if myString[i] == myString[j] {\n                longestPalindromeLength++\n\
    \            }\n        }\n        if longestPalindromeLength > longestPalindromeLength\
    \ {\n            longestPalindrome = myString[:longestPalindromeLength]\n    \
    \    }\n    }\n    return longestPalindrome + myString[len(longestPalindrome):]\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMake_Palindrome (0.00s)\n    --- FAIL: TestMake_Palindrome/test_num__2\
    \ (0.00s)\n        tmptnkjv_td_test.go:52: expected 'xyzyx', got 'xyz'\n    ---\
    \ FAIL: TestMake_Palindrome/test_num__4 (0.00s)\n        tmptnkjv_td_test.go:52:\
    \ expected 'jerryrrej', got 'jerry'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\n\
    FAIL\n"
  timestamp: 1660075450
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLength := 0\n    for i := 0; i < len(myString);\
    \ i++ {\n        longestPalindromeLength = 0\n        for j := 0; j < len(myString);\
    \ j++ {\n            if myString[i] == myString[j] {\n                longestPalindromeLength++\n\
    \            }\n        }\n        if longestPalindromeLength > longestPalindromeLength\
    \ {\n            longestPalindrome = myString[:longestPalindromeLength]\n    \
    \    }\n    }\n    return longestPalindrome + myString[len(longestPalindrome):]\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMake_Palindrome (0.00s)\n    --- FAIL: TestMake_Palindrome/test_num__2\
    \ (0.00s)\n        tmptnkjv_td_test.go:52: expected 'xyzyx', got 'xyz'\n    ---\
    \ FAIL: TestMake_Palindrome/test_num__4 (0.00s)\n        tmptnkjv_td_test.go:52:\
    \ expected 'jerryrrej', got 'jerry'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\n\
    FAIL\n"
  timestamp: 1660075450
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    longestPalindromeLen := len(myString)\n\
    \    for i := 0; i < longestPalindromeLen; i++ {\n        postfix := myString[longestPalindromeLen-i:longestPalindromeLen]\n\
    \        prefix := myString[0:longestPalindromeLen-i]\n        reverse := append(prefix,\
    \ append(postfix, postfix...)...)\n        if myString == reverse {\n        \
    \    longestPalindrome = reverse\n            longestPalindromeLen = len(reverse)\n\
    \        }\n    }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpwrwbjlpv_test.go:21:26: no new variables on left side of :=

    /tmp/tmpwrwbjlpv_test.go:25:27: first argument to append must be a slice; have
    prefix (variable of type string)

    /tmp/tmpwrwbjlpv_test.go:25:42: first argument to append must be a slice; have
    postfix (variable of type string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075552
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm\
    \ idea is simple:\n    // - Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    // >>> make_palindrome(\"\")\n    // \"\"\
    \n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"\
    cata\")\n    // \"catac\"\n    \n    // Find the longest postfix of supplied string\
    \ that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // - Append to the end\
    \ of the string reverse of a string prefix that comes before the palindromic suffix.\n\
    \    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"\
    cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\
    \n    \n    // Find the longest postfix of supplied string that is a palindrome.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string \nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpn1otdhwh_test.go:67:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075439
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm\
    \ idea is simple:\n    // - Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    longestPalindrome := \"\
    \"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++ {\n\
    \        postfix := myString[:i]\n        postfix += myString[len(postfix)-1-i:]\n\
    \        postfix += myString[len(postfix)-1-i:]\n        postfix += myString[len(postfix)-1-i:]\n\
    \        postfix += myString[len(postfix)-1-i:]\n        postfix += myString[len(postfix)-1-i:]\n\
    \        postfix += myString[len(postfix)-1-i:]\n        postfix += myString[len(postfix)-1-i:]\n\
    \        postfix += myString[len(postfix)-1-i:]\n        postfix += myString[len(postfix)-1-i:]\n\
    \        postfix += myString[len(postfix)-1-i:]\n        postfix += myString[len(postfix)-1-i:]\n\
    \        postfix += myString[len(postfix)-1-i:]\n        postfix += myString[len(postfix)-1-i:]\n\
    \        postfix += myString[len(postfix)-1-i:]\n        postfix += myString[len(postfix)-1-i:]\n\
    \        postfix += myString[len(postfix)-1-i:]\n        postfix += myString[len(postfix)-1-i:]\n\
    \        postfix += myString[len(postfix)-1-i:]\n        postfix += myString[len(postfix)-1-i:]\n\
    \        postfix += myString[len(postfix)-1-i:]\n        postfix += myString[len(postfix)-1-i:]\n\
    \        postfix += myString[len(postfix)-1-i:]\n        postfix += myString[len(postfix)-1-i:]\n\
    \        postfix += myString[len(postfix)-1-i:]\n        postfix += myString[len(postfix)-1-i:]\n\
    \        postfix += myString[len(postfix)-1-i:]\n        postfix += myString[len(postfix)-1-i:]\n\
    \        postfix += myString[len(\nfunc TestMake_Palindrome(t *testing.T) {\n\
    \  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp79a7e64p_test.go:61:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075552
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        longestPalindromeLen := 0\n        longestPalindrome += myString[i]\n\
    \        for j := 0; j < len(myString); j++ {\n            if myString[j] != myString[len(myString)-1-j]\
    \ {\n                longestPalindromeLen += 1\n            }\n        }\n   \
    \     if longestPalindromeLen > longestPalindromeLen {\n            longestPalindrome\
    \ = myString\n        }\n    }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_vy64in6_test.go:20:5: longestPalindromeLen declared but not used

    /tmp/tmp_vy64in6_test.go:23:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075553
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        postfix := myString[i:]\n        prefix := myString[:i]\n       \
    \ postfix, prefix := reverseString(postfix), reverseString(prefix)\n        if\
    \ postfix, prefix != \"\" {\n            if postfix, prefix != longestPalindrome\
    \ {\n                longestPalindrome = postfix\n                longestPalindromeLen\
    \ = len(postfix)\n            }\n        }\n    }\n    return longestPalindrome\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpsfqyng0y_test.go:25:12: expected 1 expression

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075552
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLength := 0\n    for i := 0; i < len(myString);\
    \ i++ {\n        longestPalindromeLength = 0\n        for j := 0; j < len(myString);\
    \ j++ {\n            if myString[i] == myString[j] {\n                longestPalindromeLength++\n\
    \            }\n        }\n        if longestPalindromeLength > longestPalindromeLength\
    \ {\n            longestPalindrome = myString[:longestPalindromeLength]\n    \
    \    }\n    }\n    return longestPalindrome + make_palindrome(myString[len(longestPalindrome):])\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc020160368\
    \ stack=[0xc020160000, 0xc040160000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f361?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.make_palindrome({0x0?,\
    \ 0x0?})\n\t/tmp/tmpa8c8fb0v_test.go:18 +0x65 fp=0xc020160378 sp=0xc020160370\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.make_palindrome({0x0?, 0x0?})\n\t/tmp/tmpa8c8fb0v_test.go:32\
    \ +0x2e fp=0xc0201603b0 sp=0xc020160378 pc=0x4ef68e\ncommand-line-arguments_test.make_palindrome({0x0?,\
    \ 0x0?})\n\t/tmp/tmpa8c8fb0v_test.go:32 +0x2e fp=0xc0201603e8 sp=0xc0201603b0\
    \ pc=0x4ef68e\ncommand-line-arguments_test.make_palindrome({0x0?, 0x0?})\n\t/tmp/tmpa8c8fb0v_test.go:32\
    \ +0x2e fp=0xc020160420 sp=0xc0201603e8 pc=0x4ef68e\ncommand-line-arguments_test.make_palindrome({0x0?,\
    \ 0x0?})\n\t/tmp/tmpa8c8fb0v_test.go:32 +0x2e fp=0xc020160458 sp=0xc020160420\
    \ pc=0x4ef68e\ncommand-line-arguments_test.make_palindrome({0x0?, 0x0?})\n\t/tmp/tmpa8c8fb0v_test.go:32\
    \ +0x2e fp=0xc020160490 sp=0xc020160458 pc=0x4ef68e\ncommand-line-arguments_test.make_palindrome({0x0?,\
    \ 0x0?})\n\t/tmp/tmpa8c8fb0v_test.go:32 +0x2e fp=0xc0201604c8 sp=0xc020160490\
    \ pc=0x4ef68e\ncommand-line-arguments_test.make_palindrome({0x0?, 0x0?})\n\t/tmp/tmpa8c8fb0v_test.go:32\
    \ +0x2e fp=0xc020160500 sp=0xc0201604c8 pc=0x4ef68e\ncommand-line-arguments_test.make_palindrome({0x0?,\
    \ 0x0?})\n\t/tmp/tmpa8c8fb0v_test.go:32 +0x2e fp=0xc020160538 sp=0xc020160500\
    \ pc=0x4ef68e\ncommand-line-arguments_test.make_palindrome({0x0?, 0x0?})\n\t/tmp/tmpa8c8fb0v_test.go:32\
    \ +0x2e fp=0xc020160570 sp=0xc020160538 pc=0x4ef68e\ncommand-line-arguments_test.make_palindrome({0x0?,\
    \ 0x0?})\n\t/tmp/tmpa8c8fb0v_test.go:32 +0x2e fp=0xc0201605a8 sp=0xc020160570\
    \ pc=0x4ef68e\ncommand-line-arguments_test.make_palindrome({0x0?, 0x0?})\n\t/tmp/tmpa8"
  timestamp: 1660075555
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        prefix := myString[:i]\n        suffix := myString[i:]\n        longestPalindromeLen\
    \ := len(longestPalindrome)\n        if longestPalindromeLen > len(prefix) + len(suffix)\
    \ {\n            longestPalindrome = prefix\n        }\n        longestPalindrome\
    \ += suffix\n    }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdost4i_c_test.go:20:5: longestPalindromeLen declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075553
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        postfix := myString[i:]\n        prefix := myString[:i]\n       \
    \ postfix, prefix := reverseString(postfix), reverseString(prefix)\n        if\
    \ postfix != prefix {\n            longestPalindrome = append(longestPalindrome,\
    \ postfix...)\n            longestPalindromeLen = len(postfix)\n        }\n  \
    \  }\n    if longestPalindromeLen > 0 {\n        return append(myString[:longestPalindromeLen],\
    \ longestPalindrome...)\n    }\n    return myString\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmps1ug_rm8_test.go:24:25: no new variables on left side of :=

    /tmp/tmps1ug_rm8_test.go:24:28: undefined: reverseString

    /tmp/tmps1ug_rm8_test.go:26:40: first argument to append must be a slice; have
    longestPalindrome (variable of type string)

    /tmp/tmps1ug_rm8_test.go:31:31: first argument to append must be a slice; have
    myString[:longestPalindromeLen] (value of type string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075553
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        longestPalindromeLen := 0\n        for j := 0; j < len(myString);\
    \ j++ {\n            if myString[i] == myString[j] {\n                longestPalindromeLen\
    \ += 1\n            }\n        }\n        if longestPalindromeLen > longestPalindromeLen\
    \ {\n            longestPalindrome = myString[:i]\n            longestPalindromeLen\
    \ = longestPalindromeLen\n        }\n    }\n    return longestPalindrome + string(myString[len(longestPalindrome):])\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpo3c35s79_test.go:20:5: longestPalindromeLen declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075553
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    // The\
    \ longest postfix is one that ends with a palindromic suffix.\n    // The longest\
    \ postfix is one that ends with a palindromic suffix.\n    // The longest postfix\
    \ is one that ends with a palindromic suffix.\n    // The longest postfix is one\
    \ that ends with a palindromic suffix.\n    // The longest postfix is one that\
    \ ends with a palindromic suffix.\n    // The longest postfix is one that ends\
    \ with a palindromic suffix.\n    // The longest postfix is one that ends with\
    \ a palindromic suffix.\n    // The longest postfix is one that ends with a palindromic\
    \ suffix.\n    // The longest postfix is one that ends with a palindromic suffix.\n\
    \    // The longest postfix is one that ends with a palindromic suffix.\n    //\
    \ The longest postfix is one that ends with a palindromic suffix.\n    // The\
    \ longest postfix is one that ends with a palindromic suffix.\n    // The longest\
    \ postfix is one that ends with a palindromic suffix.\n    // The longest postfix\
    \ is one that ends with a palindromic suffix.\n    // The longest postfix is one\
    \ that ends with a palindromic suffix.\n    // The longest postfix is one that\
    \ ends with a palindromic suffix.\n    // The longest postfix is one that ends\
    \ with a palindromic suffix.\n    // The longest postfix is one that ends with\
    \ a palindromic suffix.\n    // The longest postfix is one that ends with a palindromic\
    \ suffix.\n    // The longest postfix is one that ends with a palindromic suffix.\n\
    \    // The longest postfix is one that ends with a palindromic suffix.\n    //\
    \ The longest postfix is one that ends with a palindromic suffix.\n    // The\
    \ longest postfix is one that ends with a palindromic suffix.\n    // The longest\
    \ postfix is one that ends with a palindromic suffix.\n    // The longest postfix\
    \ is one that ends with a palindromic suffix.\n    // The longest postfix is one\
    \ that ends with a palindromic suffix.\n    // The \nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpsu89mygn_test.go:47:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075553
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm\
    \ idea is simple:\n    // - Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    longestPalindrome := \"\
    \"\n    longestPalindromeLen := 0\n    for i := len(myString) - 1; i >= 0; i--\
    \ {\n        postfix := myString[:i+1]\n        postfix += myString[len(myString)-i:]\n\
    \        \n        // Check if postfix is a palindrome.\n        if isPalindrome(postfix)\
    \ {\n            // Append to the end of the string reverse of a string prefix\
    \ that comes before the palindromic suffix.\n            myString += myString[len(myString)-len(postfix):]\n\
    \            myString += postfix\n            longestPalindrome = postfix\n  \
    \          longestPalindromeLen = len(postfix)\n        }\n    }\n    \n    //\
    \ Return the string with longest palindrome appended.\n    return myString + longestPalindrome\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9nvcac6t_test.go:32:5: longestPalindromeLen declared but not used

    /tmp/tmp9nvcac6t_test.go:38:12: undefined: isPalindrome

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075553
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Initialize our result string.\n    var result string = \"\"\n\n    // Initialize\
    \ our longest postfix string.\n    var longestPostfix string = \"\"\n\n    //\
    \ Initialize our longest postfix string length.\n    var longestPostfixLength\
    \ int = 0\n\n    // Initialize our longest prefix string.\n    var longestPrefix\
    \ string = \"\"\n\n    // Initialize our longest prefix string length.\n    var\
    \ longestPrefixLength int = 0\n\n    // Initialize our prefix string.\n    var\
    \ prefix string = \"\"\n\n    // Initialize our prefix string length.\n    var\
    \ prefixLength int = 0\n\n    // Initialize our suffix string.\n    var suffix\
    \ string = \"\"\n\n    // Initialize our suffix string length.\n    var suffixLength\
    \ int = 0\n\n    // Initialize our current postfix string.\n    var currentPostfix\
    \ string = \"\"\n\n    // Initialize our current postfix string length.\n    var\
    \ currentPostfixLength int = 0\n\n    // Initialize our current prefix string.\n\
    \    var currentPrefix string = \"\"\n\n    // Initialize our current prefix string\
    \ length.\n    var currentPrefixLength int = 0\n\n    // Initialize our current\
    \ suffix string.\n    var currentSuffix string = \"\"\n\n    // Initialize our\
    \ current suffix string length.\n    var currentSuffixLength int = 0\n\n    //\
    \ Initialize our current palindrome string.\n    var currentPalindrome string\
    \ = \"\"\n\n    // Initialize our current palindrome string length.\n    var currentPalindromeLength\
    \ int = 0\n\n    // Initialize our current palindrome suffix.\n    var currentPalindromeSuffix\
    \ string = \"\"\n\n    // Initialize our current palindrome suffix length.\n \
    \   var currentPalindromeSuffixLength int = 0\n\n    // Initialize our current\
    \ palindrome prefix.\n    var currentPalindromePrefix string = \"\"\n\n    //\
    \ Initialize our current palindrome prefix length.\n    var currentPalindromePrefixLength\
    \ int = 0\n\n    // Initialize our current palindrome suffix.\n    var currentPalindromeSuffixLength\
    \ int = 0\n\n    // Initialize our current palindrome prefix.\n    var currentPalindromePrefixLength\
    \ int = 0\n\n    // Initialize our current palindrome suffix.\n    var currentPalindromeSuffixLength\
    \ int = 0\n\n    // Initialize our current palindrome prefix.\n    var currentPalindromePrefixLength\
    \ int = 0\n\n    // Initialize our current palindrome suffix.\n    var currentPalindromeSuffixLength\
    \ int = 0\n\n    // Initialize our current palindrome prefix.\n    var currentPalindromePrefixLength\
    \ int = 0\n\n    // Initialize our current palindrome suffix.\n    var currentPalindromeSuffixLength\
    \ int = 0\n\n    // Initialize our \nfunc TestMake_Palindrome(t *testing.T) {\n\
    \  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpiukdk_e9_test.go:104:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075553
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm\
    \ idea is simple:\n    // - Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    // >>> make_palindrome(\"\")\n    // \"\"\
    \n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"\
    cata\")\n    // \"catac\"\n    \n    // Find the longest postfix of supplied string\
    \ that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // - Append to the end\
    \ of the string reverse of a string prefix that comes before the palindromic suffix.\n\
    \    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"\
    cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\
    \n    \n    // Find the longest postfix of supplied string that is a palindrome.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string \nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpn1otdhwh_test.go:67:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075439
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        postfix := myString[i:]\n        postfix := append(postfix, myString[:i]...)\n\
    \        postfix := append(postfix, myString[i:]...)\n        postfix := append(postfix,\
    \ myString[:i]...)\n        postfix := append(postfix, myString[i:]...)\n    \
    \    postfix := append(postfix, myString[:i]...)\n        postfix := append(postfix,\
    \ myString[i:]...)\n        postfix := append(postfix, myString[:i]...)\n    \
    \    postfix := append(postfix, myString[i:]...)\n        postfix := append(postfix,\
    \ myString[:i]...)\n        postfix := append(postfix, myString[i:]...)\n    \
    \    postfix := append(postfix, myString[:i]...)\n        postfix := append(postfix,\
    \ myString[i:]...)\n        postfix := append(postfix, myString[:i]...)\n    \
    \    postfix := append(postfix, myString[i:]...)\n        postfix := append(postfix,\
    \ myString[:i]...)\n        postfix := append(postfix, myString[i:]...)\n    \
    \    postfix := append(postfix, myString[:i]...)\n        postfix := append(postfix,\
    \ myString[i:]...)\n        postfix := append(postfix, myString[:i]...)\n    \
    \    postfix := append(postfix, myString[i:]...)\n        postfix := append(postfix,\
    \ myString[:i]...)\n        postfix := append(postfix, myString[i:]...)\n    \
    \    postfix := append(postfix, myString[:i]...)\n        postfix := append(postfix,\
    \ myString[i:]...)\n        postfix := append(postfix, myString[:i]...)\n    \
    \    postfix := append(postfix, myString[i:]...)\n        postfix := append(postfix,\
    \ myString[:i]...)\n        postfix := append(postfix, myString[i:]...)\n    \
    \    postfix := append(postfix, myString[:i]...)\n        postfix := append(postfix,\
    \ myString[i:]...)\n        postfix := append(postfix, myString[:i]...)\n    \
    \    postfix := append(postfix, myString[i:]...)\n        postfix := append(postfix,\
    \ myString[:i]...)\n        postfix := append(postfix, myString\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpxtpdj3oq_test.go:56:44: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075553
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        postfix := myString[i:]\n        prefix := myString[:i]\n       \
    \ postfix = append(postfix, reverseString(prefix)...)\n        longestPalindrome\
    \ = append(longestPalindrome, postfix...)\n        if longestPalindromeLen < len(postfix)\
    \ {\n            longestPalindromeLen = len(postfix)\n        }\n    }\n    return\
    \ longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate\
    \ := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual:\
    \ candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"\
    ), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpq4wtaccf_test.go:24:26: first argument to append must be a slice; have
    postfix (variable of type string)

    /tmp/tmpq4wtaccf_test.go:24:35: undefined: reverseString

    /tmp/tmpq4wtaccf_test.go:25:36: first argument to append must be a slice; have
    longestPalindrome (variable of type string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075553
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := len(myString) - 1; i >=\
    \ 0; i-- {\n        prefix := myString[:i]\n        suffix := myString[i+1:]\n\
    \        if isPalindrome(prefix, suffix) {\n            longestPalindrome = prefix\
    \ + reverseString(suffix) + longestPalindrome\n            longestPalindromeLen\
    \ = len(longestPalindrome)\n        }\n    }\n    return longestPalindrome\n}\n\
    \nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvvqhupa1_test.go:20:5: longestPalindromeLen declared but not used

    /tmp/tmpvvqhupa1_test.go:24:12: undefined: isPalindrome

    /tmp/tmpvvqhupa1_test.go:25:42: undefined: reverseString

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075553
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        prefix := myString[:i]\n        suffix := myString[i+1:]\n      \
    \  postfix := reverse(prefix)\n        if postfix != suffix {\n            longestPalindrome\
    \ = append(longestPalindrome, postfix)\n            longestPalindromeLen = len(longestPalindrome)\n\
    \        }\n    }\n    if longestPalindromeLen > 0 {\n        return append(myString[:longestPalindromeLen],\
    \ longestPalindrome...)\n    } else {\n        return myString\n    }\n}\n\nfunc\
    \ TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual:\
    \ candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected:\
    \ \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n    \
    \ { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpgiblab37_test.go:24:20: undefined: reverse

    /tmp/tmpgiblab37_test.go:26:40: first argument to append must be a slice; have
    longestPalindrome (variable of type string)

    /tmp/tmpgiblab37_test.go:31:31: first argument to append must be a slice; have
    myString[:longestPalindromeLen] (value of type string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075553
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    longestPalindromeLen += len(myString)\n\
    \    for i := 0; i < len(myString); i++ {\n        prefix := myString[:i]\n  \
    \      suffix := myString[i:]\n        postfix := reversePostfix(prefix)\n   \
    \     if suffix == postfix {\n            longestPalindromeLen += i\n        \
    \    if longestPalindromeLen > longestPalindrome {\n                longestPalindrome\
    \ = prefix\n                longestPalindromeLen = i\n            }\n        }\n\
    \    }\n    return longestPalindrome + reversePostfix(myString[:longestPalindromeLen])\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqu7k9ah0_test.go:25:20: undefined: reversePostfix

    /tmp/tmpqu7k9ah0_test.go:28:39: invalid operation: longestPalindromeLen > longestPalindrome
    (mismatched types int and string)

    /tmp/tmpqu7k9ah0_test.go:34:32: undefined: reversePostfix

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075554
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    var\
    \ myStringLen int = len(myString)\n    var myStringPrefix string\n    var myStringSuffix\
    \ string\n    var myStringPalindrome string\n\n    // Find longest postfix of\
    \ myString that is a palindrome.\n    for i := 0; i < myStringLen; i++ {\n   \
    \     if myString[i] != myString[len(myString)-i-1] {\n            myStringPrefix\
    \ = myString[:i]\n            myStringSuffix = myString[i:]\n            break\n\
    \        }\n    }\n\n    // Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    myStringPalindrome = myStringPrefix\
    \ + string([]rune(myStringSuffix)[len(string([]rune(myStringSuffix)) - len(myStringPrefix):])\n\
    \n    return myStringPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n\
    \  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp5u7b7a0__test.go:34:129: missing '','' in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075553
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        postfix := myString[i:]\n        prefix := myString[:i]\n       \
    \ postfix = append(postfix, reverse(prefix))\n        longestPalindrome = append(longestPalindrome,\
    \ postfix...)\n        longestPalindromeLen = len(longestPalindrome)\n    }\n\
    \    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n\
    \  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpg_jfntq8_test.go:20:5: longestPalindromeLen declared but not used

    /tmp/tmpg_jfntq8_test.go:24:26: first argument to append must be a slice; have
    postfix (variable of type string)

    /tmp/tmpg_jfntq8_test.go:24:35: undefined: reverse

    /tmp/tmpg_jfntq8_test.go:25:36: first argument to append must be a slice; have
    longestPalindrome (variable of type string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075554
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm\
    \ idea is simple:\n    // - Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    longestPalindrome := \"\
    \"\n    for i := 0; i < len(myString); i++ {\n        longestPalindrome += myString[i]\n\
    \    }\n    \n    // Append to the end of the string reverse of a string prefix\
    \ that comes before the palindromic suffix.\n    longestPalindromeReverse := \"\
    \"\n    for i := 0; i < len(myString); i++ {\n        longestPalindromeReverse\
    \ += myString[len(myString)-i-1]\n    }\n    \n    // Return the concatenation\
    \ of longestPalindrome and longestPalindromeReverse.\n    return longestPalindrome\
    \ + longestPalindromeReverse\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n\
    \  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4bhlu7x2_test.go:33:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    /tmp/tmp4bhlu7x2_test.go:39:9: invalid operation: longestPalindromeReverse +=
    myString[len(myString) - i - 1] (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075554
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        prefix := myString[:i]\n        suffix := myString[i:]\n        postfix\
    \ := make_palindrome_test(suffix)\n        if postfix != \"\" {\n            longestPalindromeLen\
    \ := len(postfix)\n            if longestPalindromeLen > longestPalindromeLen\
    \ {\n                longestPalindrome = postfix\n            }\n        }\n \
    \   }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp92ynn7gx_test.go:20:5: longestPalindromeLen declared but not used

    /tmp/tmp92ynn7gx_test.go:22:9: prefix declared but not used

    /tmp/tmp92ynn7gx_test.go:24:20: undefined: make_palindrome_test

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075554
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    longestPalindrome\
    \ := \"\"\n    for i := len(myString) - 1; i >= 0; i-- {\n        longestPalindrome\
    \ += myString[i]\n    }\n    // Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    longestPalindrome += myString[len(myString)-len(longestPalindrome):]\n\
    \    // Return palindrome string.\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbzcdnzl9_test.go:22:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075554
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLength := 0\n    for i := 0; i < len(myString);\
    \ i++ {\n        postfix := myString[i:]\n        postfix += \"-\"\n        postfix\
    \ += myString[:i]\n        postfix += \"-\"\n        postfix += myString[:i+1]\n\
    \        postfix += \"-\"\n        postfix += myString[:i+2]\n        postfix\
    \ += \"-\"\n        postfix += myString[:i+3]\n        postfix += \"-\"\n    \
    \    postfix += myString[:i+4]\n        postfix += \"-\"\n        postfix += myString[:i+5]\n\
    \        postfix += \"-\"\n        postfix += myString[:i+6]\n        postfix\
    \ += \"-\"\n        postfix += myString[:i+7]\n        postfix += \"-\"\n    \
    \    postfix += myString[:i+8]\n        postfix += \"-\"\n        postfix += myString[:i+9]\n\
    \        postfix += \"-\"\n        postfix += myString[:i+10]\n        postfix\
    \ += \"-\"\n        postfix += myString[:i+11]\n        postfix += \"-\"\n   \
    \     postfix += myString[:i+12]\n        postfix += \"-\"\n        postfix +=\
    \ myString[:i+13]\n        postfix += \"-\"\n        postfix += myString[:i+14]\n\
    \        postfix += \"-\"\n        postfix += myString[:i+15]\n        postfix\
    \ += \"-\"\n        postfix += myString[:i+16]\n        postfix += \"-\"\n   \
    \     postfix += myString[:i+17]\n        postfix += \"-\"\n        postfix +=\
    \ myString[:i+18]\n        postfix += \"-\"\n        postfix += myString[:i+19]\n\
    \        postfix += \"-\"\n        postfix += myString[:i+20]\n        postfix\
    \ += \"-\"\n        postfix += myString[:i+21]\n        postfix += \"-\"\n   \
    \     postfix += myString[:i+22]\n        postfix += \"-\"\n        postfix +=\
    \ myString[:i+23]\n        postfix += \"-\"\n        postfix += myString[:i+24]\n\
    \        postfix += \"-\"\n        postfix += myString[:i+25]\n        postfix\
    \ += \"-\"\n        postfix += myString[:i+26]\n        postfix += \"-\"\n   \
    \     postfix += myString[:i+27]\n        postfix += \"-\"\n        \nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp3xvbjsap_test.go:81:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075553
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        longestPalindromeLen := 0\n        for j := 0; j < len(myString);\
    \ j++ {\n            if myString[i] == myString[j] {\n                longestPalindromeLen\
    \ += 1\n            }\n        }\n        if longestPalindromeLen > longestPalindromeLen\
    \ {\n            longestPalindrome = myString[:longestPalindromeLen]\n       \
    \ }\n    }\n    return longestPalindrome + make_palindrome(myString[len(longestPalindrome):])\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkqhnz2tk_test.go:20:5: longestPalindromeLen declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075450
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        longestPalindromeLen := 0\n        longestPalindrome += myString[i]\n\
    \        for j := 0; j < i; j++ {\n            if myString[j] != myString[len(myString)-j-1]\
    \ {\n                longestPalindromeLen += 1\n            }\n        }\n   \
    \     if longestPalindromeLen > longestPalindromeLen {\n            longestPalindrome\
    \ = myString\n            longestPalindromeLen = len(myString)\n        }\n  \
    \  }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmptvqs4gsp_test.go:20:5: longestPalindromeLen declared but not used

    /tmp/tmptvqs4gsp_test.go:23:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075554
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm\
    \ idea is simple:\n    // - Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    var longestPalindrome string\n\
    \    var longestPalindromeLen int\n    for i := 0; i < len(myString); i++ {\n\
    \        // Find the longest postfix of supplied string that is a palindrome.\n\
    \        // Algorithm idea is simple:\n        // - Find the longest postfix of\
    \ supplied string that is a palindrome.\n        // - Append to the end of the\
    \ string reverse of a string prefix that comes before the palindromic suffix.\n\
    \        // >>> make_palindrome(\"\")\n        // \"\"\n        // >>> make_palindrome(\"\
    cat\")\n        // \"catac\"\n        // >>> make_palindrome(\"cata\")\n     \
    \   // \"catac\"\n        longestPalindromeLen := 0\n        for j := 0; j < len(myString);\
    \ j++ {\n            if myString[i] == myString[j] {\n                longestPalindromeLen\
    \ += 1\n                if longestPalindromeLen > longestPalindrome {\n      \
    \              longestPalindrome = myString[:j] + myString[j+longestPalindromeLen:]\n\
    \                    longestPalindromeLen = longestPalindromeLen\n           \
    \     }\n            }\n        }\n    }\n    return longestPalindrome\n}\n\n\
    func TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual:\
    \ candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected:\
    \ \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n    \
    \ { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0en468q5_test.go:30:9: longestPalindromeLen declared but not used

    /tmp/tmp0en468q5_test.go:46:43: invalid operation: longestPalindromeLen > longestPalindrome
    (mismatched types int and string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075554
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        longestPalindromeLen := 0\n        for j := 0; j < len(myString);\
    \ j++ {\n            if myString[i] == myString[j] {\n                longestPalindromeLen\
    \ += 1\n            }\n        }\n        if longestPalindromeLen > longestPalindromeLen\
    \ {\n            longestPalindrome = myString[:i]\n            longestPalindromeLen\
    \ = longestPalindromeLen\n        }\n    }\n    return longestPalindrome + myString[len(longestPalindrome):]\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpi_wmhzci_test.go:20:5: longestPalindromeLen declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075545
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm\
    \ idea is simple:\n    // - Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    longestPalindrome := \"\
    \"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++ {\n\
    \        postfix := myString[:i]\n        postfix += string(myString[len(myString)-i:][:len(myString)-i])\n\
    \        postfix += myString[len(myString)-i:]\n        postfix += string(myString[:i])\n\
    \        if postfix != myString {\n            longestPalindrome = postfix\n \
    \           longestPalindromeLen = len(postfix)\n        }\n    }\n    // Append\
    \ to the end of the string reverse of a string prefix that comes before the palindromic\
    \ suffix.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"\
    cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\
    \n    longestPalindrome += string(myString[:longestPalindromeLen])\n    return\
    \ longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate\
    \ := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual:\
    \ candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"\
    ), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMake_Palindrome (0.00s)\npanic: runtime error: slice bounds\
    \ out of range [:1] with length 0 [recovered]\n\tpanic: runtime error: slice bounds\
    \ out of range [:1] with length 0\n\ngoroutine 4 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.make_palindrome(...)\n\t/tmp/tmpv6vyb04b_test.go:33\n\
    command-line-arguments_test.TestMake_Palindrome(0x0?)\n\t/tmp/tmpv6vyb04b_test.go:60\
    \ +0x89d\ntesting.tRunner(0xc00019e1a0, 0x528f60)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075554
