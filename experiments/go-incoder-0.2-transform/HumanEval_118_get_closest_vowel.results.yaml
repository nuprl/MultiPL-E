language: go_test.go
name: HumanEval_118_get_closest_vowel
results:
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    for _, v := range vowels {\n        if strings.Contains(word,\
    \ v) {\n            vowelsCount++\n        }\n    }\n    if vowelsCount == 0 {\n\
    \        return \"\"\n    }\n    vowelsCount -= 1\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp5dnmitnn_test.go:98:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074642
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for _, v := range vowels\
    \ {\n        if word == v {\n            return v\n        }\n    }\n    for i\
    \ := len(word) - 1; i >= 0; i-- {\n        if word[i] == word[len(word)-1] {\n\
    \            return word[i]\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpaisteg3t_test.go:33:20: cannot use word[i] (value of type byte) as type
    string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074641
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6hf0nt82_test.go:100:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074641
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    for _, v := range vowels {\n        if word == v {\n\
    \            vowelsCount++\n        }\n    }\n    if vowelsCount == 0 {\n    \
    \    return \"\"\n    }\n    vowelsCount -= 1\n    for i := len(word) - 1; i >=\
    \ 0; i-- {\n        if word[i] == word[len(word)-1] {\n            return word[i]\n\
    \        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbx596vt9_test.go:36:20: cannot use word[i] (value of type byte) as type
    string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074787
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []rune(\"aeiouAEIOU\")\n    vowelsLen := len(vowels)\n\
    \    \n    i := len(word) - 1\n    \n    for i >= 0 {\n        if word[i] == 'a'\
    \ || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n\
    \            i -= 1\n            continue\n        }\n        \n        if word[i]\
    \ == 'A' || word[i] == 'E' || word[i] == 'I' || word[i] == 'O' || word[i] == 'U'\
    \ {\n            i -= 1\n            continue\n        }\n        \n        if\
    \ word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n   \
    \         i -= 1\n            continue\n        }\n        \n        if word[i]\
    \ == 'A' || word[i] == 'E' || word[i] == 'I' || word[i] == 'O' || word[i] == 'U'\
    \ {\n            i -= 1\n            continue\n        }\n        \n        if\
    \ word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i]\
    \ == 'u' {\n            i -= 1\n            continue\n        }\n        \n  \
    \      if word[i] == 'A' || word[i] == 'E' || word[i] == 'I' || word[i] == 'O'\
    \ || word[i] == 'U' {\n            i -= 1\n            continue\n        }\n \
    \       \n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i]\
    \ == 'o' || word[i] == 'u' {\n            i -= 1\n            continue\n     \
    \   }\n        \n        if word[i] == 'A' || word[i] == 'E' || word[i] == 'I'\
    \ || word[i] == 'O' || word[i] == 'U' {\n            i -= 1\n            continue\n\
    \        }\n        \n        if word[i] == 'a' || word[i] == 'e' || word[i] ==\
    \ 'i' || word[i] == 'o' || word[i] == 'u' {\n            i -= 1\n            continue\n\
    \        }\n        \n        if word[i] == 'A' || word[i] == 'E' || word[i] ==\
    \ 'I' || word[i] == 'O' || word[i] == 'U' {\n            i -= 1\n            continue\n\
    \        }\n        \n        if word[i] == 'a' || word[i] == 'e' || word[i] ==\
    \ 'i' || word[i] == 'o' || word[i] == 'u' {\n            i -= 1\n            continue\n\
    \        }\n        \n        if word[i] == 'A' || word[i] == 'E' || word[i] ==\
    \ 'I' || word[i] == 'O' || word[i] == 'U' {\n            i -= 1\n            continue\n\
    \        }\n        \n        if word[i] == 'a' || word[i] == 'e' || word[i] ==\
    \ 'i' || word[i] == 'o' || word\nfunc TestGet_Closest_Vowel(t *testing.T) {\n\
    \  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpdgmx3dgg_test.go:90:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074785
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphy7oiqg__test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    for _, v := range vowels {\n        if strings.Contains(word,\
    \ v) {\n            vowelsCount++\n        }\n    }\n    if vowelsCount == 0 {\n\
    \        return \"\"\n    }\n    vowelsCount -= 2\n    if vowelsCount < 0 {\n\
    \        vowelsCount = 0\n    }\n    vowelsCount += 2\n    if vowelsCount > len(vowels)-1\
    \ {\n        vowelsCount = len(vowels) - 1\n    }\n    vowelsCount -= 2\n    if\
    \ vowelsCount < 0 {\n        vowelsCount = 0\n    }\n    vowelsCount += 2\n  \
    \  if vowelsCount > len(vowels)-1 {\n        vowelsCount = len(vowels) - 1\n \
    \   }\n    vowelsCount -= 2\n    if vowelsCount < 0 {\n        vowelsCount = 0\n\
    \    }\n    vowelsCount += 2\n    if vowelsCount > len(vowels)-1 {\n        vowelsCount\
    \ = len(vowels) - 1\n    }\n    vowelsCount -= 2\n    if vowelsCount < 0 {\n \
    \       vowelsCount = 0\n    }\n    vowelsCount += 2\n    if vowelsCount > len(vowels)-1\
    \ {\n        vowelsCount = len(vowels) - 1\n    }\n    vowelsCount -= 2\n    if\
    \ vowelsCount < 0 {\n        vowelsCount = 0\n    }\n    vowelsCount += 2\n  \
    \  if vowelsCount > len(vowels)-1 {\n        vowelsCount = len(vowels) - 1\n \
    \   }\n    vowelsCount -= 2\n    if vowelsCount < 0 {\n        vowelsCount = 0\n\
    \    }\n    vowelsCount += 2\n    if vowelsCount > len(vowels)-1 {\n        vowelsCount\
    \ = len(vowels) - 1\n    }\n    vowelsCount -= 2\n    if vowelsCount < 0 {\n \
    \       vowelsCount = 0\n    }\n    vowelsCount += 2\n    if vowelsCount > len(vowels)-1\
    \ {\n        vowelsCount = len(vowels) - 1\n    }\n    vowelsCount -= 2\n    if\
    \ vowelsCount < 0 {\n        vowelsCount = 0\n    }\n    vowelsCount += 2\n  \
    \  if vowelsCount > len(vowels)-1 {\n        vowelsCount = len(vowels) - 1\n \
    \   }\n    vowelsCount -= 2\n    if vowelsCount < 0 {\n        vowelsCount = 0\n\
    \    }\n    vowelsCount += 2\n    if vowelsCount > len(vowels)-1 {\n        vowelsCount\
    \ = len(vowels) - 1\n    }\n    \nfunc TestGet_Closest_Vowel(t *testing.T) {\n\
    \  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpq9nf690t_test.go:106:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074785
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    \n    lastConsonant := len(word) - 1\n    lastConsonantLen := len(word[lastConsonant])\n\
    \    lastConsonantLen -= 1\n    lastConsonantLen /= 2\n    lastConsonantLen +=\
    \ 2\n    \n    lastConsonantVowel := word[lastConsonant]\n    \n    if lastConsonantLen\
    \ > 0 {\n        lastConsonantVowel = word[lastConsonantLen - 1]\n    }\n    \n\
    \    if lastConsonantVowel == vowels[vowelsLen] {\n        return lastConsonantVowel\n\
    \    }\n    \n    if lastConsonantVowel == vowels[vowelsLen - 1] {\n        return\
    \ lastConsonantVowel\n    }\n    \n    if lastConsonantVowel == vowels[vowelsLen\
    \ - 2] {\n        return lastConsonantVowel\n    }\n    \n    if lastConsonantVowel\
    \ == vowels[vowelsLen - 3] {\n        return lastConsonantVowel\n    }\n    \n\
    \    if lastConsonantVowel == vowels[vowelsLen - 4] {\n        return lastConsonantVowel\n\
    \    }\n    \n    if lastConsonantVowel == vowels[vowelsLen - 5] {\n        return\
    \ lastConsonantVowel\n    }\n    \n    if lastConsonantVowel == vowels[vowelsLen\
    \ - 6] {\n        return lastConsonantVowel\n    }\n    \n    if lastConsonantVowel\
    \ == vowels[vowelsLen - 7] {\n        return lastConsonantVowel\n    }\n    \n\
    \    if lastConsonantVowel == vowels[vowelsLen - 8] {\n        return lastConsonantVowel\n\
    \    }\n    \n    if lastConsonantVowel == vowels[vowelsLen - 9] {\n        return\
    \ lastConsonantVowel\n    }\n    \n    if lastConsonantVowel == vowels[vowelsLen\
    \ - 10] {\n        return lastConsonantVowel\n    }\n    \n    if lastConsonantVowel\
    \ == vowels[vowelsLen - 11] {\n        return lastCon\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpdbjgsa0l_test.go:87:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074785
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for _, v := range vowels\
    \ {\n        if word == v {\n            return v\n        }\n    }\n    for i\
    \ := len(word) - 2; i >= 0; i-- {\n        if word[i] == word[i+1] {\n       \
    \     if word[i] == \"a\" || word[i] == \"e\" || word[i] == \"i\" || word[i] ==\
    \ \"o\" || word[i] == \"u\" {\n                return word[i]\n            }\n\
    \        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3gds1bhp_test.go:33:27: invalid operation: word[i] == "a" (mismatched
    types byte and untyped string)

    /tmp/tmp3gds1bhp_test.go:33:45: invalid operation: word[i] == "e" (mismatched
    types byte and untyped string)

    /tmp/tmp3gds1bhp_test.go:33:63: invalid operation: word[i] == "i" (mismatched
    types byte and untyped string)

    /tmp/tmp3gds1bhp_test.go:33:81: invalid operation: word[i] == "o" (mismatched
    types byte and untyped string)

    /tmp/tmp3gds1bhp_test.go:33:99: invalid operation: word[i] == "u" (mismatched
    types byte and untyped string)

    /tmp/tmp3gds1bhp_test.go:34:24: cannot use word[i] (value of type byte) as type
    string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074787
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    for _, v := range vowels {\n        if word == v {\n\
    \            vowelsCount++\n        }\n    }\n    if vowelsCount == 0 {\n    \
    \    return \"\"\n    }\n    vowelsCount -= 1\n    vowelsCount /= 2\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount /= len(vowels)\n    vowelsCount %= len(vowels)\n\
    \    if vowelsCount == 0 {\n        return \"\"\n    }\n    vowelsCount /= len(vowels)\n\
    \    vowelsCount %= len(vowels)\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    if vowelsCount == 0 {\n        return \"\"\n    }\n    vowelsCount\
    \ /= len(vowels)\n    vowelsCount %= len(vowels)\n    vowelsCount /= len(vowels)\n\
    \    vowelsCount %= len(vowels)\n    if vowelsCount == 0 {\n        return \"\"\
    \n    }\n    vowelsCount /= len(vowels)\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ /= len(vowels)\n    vowelsCount %= len(vowels)\n    if vowelsCount == 0 {\n\
    \        return \"\"\n    }\n    vowelsCount /= len(vowels)\n    vowelsCount %=\
    \ len(vowels)\n    vowelsCount /= len(vowels)\n    vowelsCount %= len(vowels)\n\
    \    if vowelsCount == 0 {\n        return \"\"\n    }\n    vowelsCount /= len(vowels)\n\
    \    vowelsCount %= len(vowels)\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    if vowelsCount == 0 {\n        return \"\"\n    }\n    vowelsCount\
    \ /= len(vowels)\n    vowelsCount %= len(vowels)\n    vowelsCount /= len(vowels)\n\
    \    vowelsCount %= len(vowels)\n    if vowelsCount == 0 {\n        return \"\"\
    \n    }\n    vowelsCount /= len(vowels)\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ /= len(vowels)\n    vowelsCount %= len(vowels)\n    if vowelsCount == 0 {\n\
    \        return \"\"\n    }\n    vowelsCount /= len(vowels)\n    vowelsCount %=\
    \ len(vowels)\n    vowelsCount /= len(vowels)\n    vowelsCount %= len(vowels)\n\
    \    if vowelsCount == 0 {\n        return \"\"\n    }\n    vowelsCount /= len(vowels)\n\
    \    vowelsCount %= len(vowel\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpme8zs0xy_test.go:98:29: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074785
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphy7oiqg__test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpyvyobif7_test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowel := []rune{'a', 'e', 'i', 'o', 'u'}\n    vowel_count\
    \ := 0\n    vowel_count += len(word) - len(word[:len(word)-1])\n    for _, v :=\
    \ range vowel {\n        if word[len(word)-1:] == v {\n            vowel_count++\n\
    \        }\n    }\n    if vowel_count == 0 {\n        return \"\"\n    }\n   \
    \ vowel_count -= len(word) - len(word[:len(word)-1])\n    if vowel_count > len(vowel)-1\
    \ {\n        return \"\"\n    }\n    vowel_count -= len(word) - len(word[:len(word)-1])\n\
    \    if vowel_count < 0 {\n        return \"\"\n    }\n    return vowel[len(vowel)-vowel_count]\n\
    }\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_qu_ufq8_test.go:27:34: invalid operation: word[len(word) - 1:] == v (mismatched
    types string and rune)

    /tmp/tmp_qu_ufq8_test.go:42:12: cannot use vowel[len(vowel) - vowel_count] (variable
    of type rune) as type string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074787
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpyvyobif7_test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpjcv4si1u_test.go:100:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074643
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // Your code here\n    vowels := []string{\"a\", \"e\"\
    , \"i\", \"o\", \"u\"}\n    vowelsCount := 0\n    for _, v := range vowels {\n\
    \        if strings.Contains(word, v) {\n            vowelsCount++\n        }\n\
    \    }\n    if vowelsCount == 0 {\n        return \"\"\n    }\n    vowelsCount\
    \ -= 1\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpypj3o0mm_test.go:98:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074785
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    \n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen += 2\n   \
    \ \n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen += 2\n    \n    vowelsLen\
    \ -= 1\n    vowelsLen /= 2\n    vowelsLen += 2\n    \n    vowelsLen -= 1\n   \
    \ vowelsLen /= 2\n    vowelsLen += 2\n    \n    vowelsLen -= 1\n    vowelsLen\
    \ /= 2\n    vowelsLen += 2\n    \n    vowelsLen -= 1\n    vowelsLen /= 2\n   \
    \ vowelsLen += 2\n    \n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    \n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen += 2\n   \
    \ \n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen += 2\n    \n    vowelsLen\
    \ -= 1\n    vowelsLen /= 2\n    vowelsLen += 2\n    \n    vowelsLen -= 1\n   \
    \ vowelsLen /= 2\n    vowelsLen += 2\n    \n    vowelsLen -= 1\n    vowelsLen\
    \ /= 2\n    vowelsLen += 2\n    \n    vowelsLen -= 1\n    vowelsLen /= 2\n   \
    \ vowelsLen += 2\n    \n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    \n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen += 2\n   \
    \ \n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen += 2\n    \n    vowelsLen\
    \ -= 1\n    vowelsLen /= 2\n    vowelsLen += 2\n    \n    vowelsLen -= 1\n   \
    \ vowelsLen /= 2\n    vowelsLen += 2\n    \n    vowelsLen -= 1\n    vowelsLen\
    \ /= 2\n    vowelsLen += 2\n    \n    vowelsLen -= 1\n    vowelsLen /= 2\n   \
    \ vowelsLen += 2\n    \n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    \n    vowel\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpfeq5wq40_test.go:114:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074647
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpw4oq0vvz_test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // Your code here\n    vowels := []string{\"a\", \"e\"\
    , \"i\", \"o\", \"u\"}\n    vowelsCount := 0\n    for _, v := range vowels {\n\
    \        if word == v {\n            vowelsCount++\n        }\n    }\n    if vowelsCount\
    \ > 0 {\n        return word\n    }\n    for i := len(word) - 1; i >= 0; i-- {\n\
    \        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o'\
    \ || word[i] == 'u' {\n            return word[i]\n        }\n    }\n    return\
    \ \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmplkdyat5j_test.go:36:20: cannot use word[i] (value of type byte) as type
    string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074787
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpjcv4si1u_test.go:100:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074643
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)/2\n\
    \    vowelsCount += len(vowels)/3\n    vowelsCount += len(vowels)/4\n    vowelsCount\
    \ += len(vowels)/5\n    vowelsCount += len(vowels)/6\n    vowelsCount += len(vowels)/7\n\
    \    vowelsCount += len(vowels)/8\n    vowelsCount += len(vowels)/9\n    vowelsCount\
    \ += len(vowels)/10\n    vowelsCount += len(vowels)/11\n    vowelsCount += len(vowels)/12\n\
    \    vowelsCount += len(vowels)/13\n    vowelsCount += len(vowels)/14\n    vowelsCount\
    \ += len(vowels)/15\n    vowelsCount += len(vowels)/16\n    vowelsCount += len(vowels)/17\n\
    \    vowelsCount += len(vowels)/18\n    vowelsCount += len(vowels)/19\n    vowelsCount\
    \ += len(vowels)/20\n    vowelsCount += len(vowels)/21\n    vowelsCount += len(vowels)/22\n\
    \    vowelsCount += len(vowels)/23\n    vowelsCount += len(vowels)/24\n    vowelsCount\
    \ += len(vowels)/25\n    vowelsCount += len(vowels)/26\n    vowelsCount += len(vowels)/27\n\
    \    vowelsCount += len(vowels)/28\n    vowelsCount += len(vowels)/29\n    vowelsCount\
    \ += len(vowels)/30\n    vowelsCount += len(vowels)/31\n    vowelsCount += len(vowels)/32\n\
    \    vowelsCount += len(vowels)/33\n    vowelsCount += len(vowels)/34\n    vowelsCount\
    \ += len(vowels)/35\n    vowelsCount += len(vowels)/36\n    vowelsCount += len(vowels)/37\n\
    \    vowelsCount += len(vowels)/38\n    vowelsCount += len(vowels)/39\n    vowelsCount\
    \ += len(vowels)/40\n    vowelsCount += len(vowels)/41\n    vowelsCount += len(vowels)/42\n\
    \    vowelsCount += len(vowels)/43\n    vowelsCount += len(vowels)/44\n    vowelsCount\
    \ += len(vowels)/45\n    vowelsCount += len(vowels)/46\n    vowelsCount += len(vowels)/47\n\
    \    vowelsCount += len(vowels)/48\n    vowelsCount += len(vowels)/49\n    vowels\n\
    func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpt9m6ef6a_test.go:75:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []rune{'a', 'e', 'i', 'o', 'u'}\n    vowelsLen\
    \ := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    \n    i := len(word)\
    \ - 1\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] ==\
    \ 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u'\
    \ {\n            vowelsLen--\n        }\n        if word[i] == 'y' || word[i]\
    \ == 'o' || word[i] == 'u' {\n            vowelsLen++\n        }\n        if vowelsLen\
    \ < 0 {\n            return \"\"\n        }\n    }\n    return word[i]\n}\n\n\
    func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpahokj_fq_test.go:41:12: cannot use word[i] (value of type byte) as type
    string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074787
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowel := []rune{'a', 'e', 'i', 'o', 'u'}\n    vowel_count\
    \ := 0\n    vowel_count += len(word) - len(word[:len(word)-1])\n    for _, v :=\
    \ range vowel {\n        if word[len(word)-1:] == v {\n            vowel_count++\n\
    \        }\n    }\n    if vowel_count > 0 {\n        return word[len(word)-1:]\n\
    \    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqlugz07__test.go:27:34: invalid operation: word[len(word) - 1:] == v (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074787
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []rune(\"aeiouAEIOU\")\n    i := len(word) -\
    \ 1\n    for i >= 0 {\n        if word[i] == 'a' || word[i] == 'e' || word[i]\
    \ == 'i' || word[i] == 'o' || word[i] == 'u' {\n            i -= 1\n         \
    \   continue\n        }\n        if word[i] == 'A' || word[i] == 'E' || word[i]\
    \ == 'I' || word[i] == 'O' || word[i] == 'U' {\n            i -= 1\n         \
    \   continue\n        }\n        if word[i] == 'y' || word[i] == 'u' || word[i]\
    \ == 'Y' || word[i] == 'U' {\n            i -= 1\n            continue\n     \
    \   }\n        if word[i] == 'o' || word[i] == 'O' {\n            i -= 1\n   \
    \         continue\n        }\n        if word[i] == 'e' || word[i] == 'E' {\n\
    \            i -= 1\n            continue\n        }\n        if word[i] == 'i'\
    \ || word[i] == 'I' {\n            i -= 1\n            continue\n        }\n \
    \       if word[i] == 'a' || word[i] == 'A' {\n            i -= 1\n          \
    \  continue\n        }\n        if word[i] == 'l' || word[i] == 'L' {\n      \
    \      i -= 1\n            continue\n        }\n        if word[i] == 's' || word[i]\
    \ == 'S' {\n            i -= 1\n            continue\n        }\n        if word[i]\
    \ == 'd' || word[i] == 'D' {\n            i -= 1\n            continue\n     \
    \   }\n        if word[i] == 'f' || word[i] == 'F' {\n            i -= 1\n   \
    \         continue\n        }\n        if word[i] == 'g' || word[i] == 'G' {\n\
    \            i -= 1\n            continue\n        }\n        if word[i] == 'h'\
    \ || word[i] == 'H' {\n            i -= 1\n            continue\n        }\n \
    \       if word[i] == 'j' || word[i] == 'J' {\n            i -= 1\n          \
    \  continue\n        }\n        if word[i] == 'z' || word[i] == 'Z' {\n      \
    \      i -= 1\n            continue\n        }\n        if word[i] == 'p' || word[i]\
    \ == 'P' {\n            i -= 1\n            continue\n        }\n        if word[i]\
    \ == 'v' || word[i] == 'V' {\n            i -= 1\n            continue\n     \
    \   }\n        if word[i] == 'w' || word[i] == 'W' {\n            i -= 1\n   \
    \         continue\n        }\n        if word[i] == 't' || word[i] == 'T' {\n\
    \            i -= 1\n            continue\n        }\n        if word[i] == 'b'\
    \ || word[i] == 'B' {\n            i -= 1\n            continue\n        }\n \
    \       if word[i] == 'm' || word[i] == 'M' {\n            i -= 1\n          \
    \  continue\n        }\n        if word[i] == 'n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpxg9gd749_test.go:110:23: rune literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074785
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpyvyobif7_test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpjcv4si1u_test.go:100:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074643
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpyvyobif7_test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    for _, v := range vowels {\n        if word == v {\n\
    \            vowelsCount++\n        }\n    }\n    if vowelsCount == 0 {\n    \
    \    return \"\"\n    }\n    vowelsCount -= 1\n    vowelsCount /= 2\n    if vowelsCount\
    \ < 0 {\n        vowelsCount = 0\n    }\n    vowelsCount /= 2\n    if vowelsCount\
    \ < 0 {\n        vowelsCount = 0\n    }\n    vowelsCount /= 2\n    if vowelsCount\
    \ < 0 {\n        vowelsCount = 0\n    }\n    vowelsCount /= 2\n    if vowelsCount\
    \ < 0 {\n        vowelsCount = 0\n    }\n    vowelsCount /= 2\n    if vowelsCount\
    \ < 0 {\n        vowelsCount = 0\n    }\n    vowelsCount /= 2\n    if vowelsCount\
    \ < 0 {\n        vowelsCount = 0\n    }\n    vowelsCount /= 2\n    if vowelsCount\
    \ < 0 {\n        vowelsCount = 0\n    }\n    vowelsCount /= 2\n    if vowelsCount\
    \ < 0 {\n        vowelsCount = 0\n    }\n    vowelsCount /= 2\n    if vowelsCount\
    \ < 0 {\n        vowelsCount = 0\n    }\n    vowelsCount /= 2\n    if vowelsCount\
    \ < 0 {\n        vowelsCount = 0\n    }\n    vowelsCount /= 2\n    if vowelsCount\
    \ < 0 {\n        vowelsCount = 0\n    }\n    vowelsCount /= 2\n    if vowelsCount\
    \ < 0 {\n        vowelsCount = 0\n    }\n    vowelsCount /= 2\n    if vowelsCount\
    \ < 0 {\n        vowelsCount = 0\n    }\n    vowelsCount /= 2\n    if vowelsCount\
    \ < 0 {\n        vowelsCount = 0\n    }\n    vowelsCount /= 2\n    if vowelsCount\
    \ < 0 {\n        vowelsCount = 0\n    }\n    vowelsCount /= 2\n    if vowelsCount\
    \ < 0 {\n        vowelsCount = 0\n    }\n    vowelsCount /= 2\n    if vowelsCount\
    \ < 0 {\n        vowelsCount = 0\n    }\n    vowelsCount /= 2\n    if vowelsCount\
    \ < 0 {\n        vowelsCount = 0\n    }\n    vowelsCount /= 2\n    if vowelsCount\
    \ < 0 {\n        vowelsCount = 0\n    }\n    vowelsCount /= 2\n    if vowelsCount\
    \ < 0 {\n        vowelsCount = 0\n    }\n    vowelsCount /= 2\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp21fdi_ov_test.go:115:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074785
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphy7oiqg__test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // Your code here\n    vowel := \"\"\n    vowels := []string{\"\
    a\", \"e\", \"i\", \"o\", \"u\"}\n    for i := len(word) - 1; i >= 0; i-- {\n\
    \        if word[i] == \"a\" || word[i] == \"e\" || word[i] == \"i\" || word[i]\
    \ == \"o\" || word[i] == \"u\" {\n            vowel = word[i]\n            break\n\
    \        }\n    }\n    if vowel == \"\" {\n        return \"\"\n    }\n    for\
    \ i := len(word) - 2; i >= 0; i-- {\n        if word[i] == \"a\" || word[i] ==\
    \ \"e\" || word[i] == \"i\" || word[i] == \"o\" || word[i] == \"u\" {\n      \
    \      vowel = word[i]\n            break\n        }\n    }\n    if vowel == \"\
    \" {\n        return \"\"\n    }\n    return vowel\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpaz0pf3_z_test.go:27:23: invalid operation: word[i] == "a" (mismatched
    types byte and untyped string)

    /tmp/tmpaz0pf3_z_test.go:27:41: invalid operation: word[i] == "e" (mismatched
    types byte and untyped string)

    /tmp/tmpaz0pf3_z_test.go:27:59: invalid operation: word[i] == "i" (mismatched
    types byte and untyped string)

    /tmp/tmpaz0pf3_z_test.go:27:77: invalid operation: word[i] == "o" (mismatched
    types byte and untyped string)

    /tmp/tmpaz0pf3_z_test.go:27:95: invalid operation: word[i] == "u" (mismatched
    types byte and untyped string)

    /tmp/tmpaz0pf3_z_test.go:28:21: cannot use word[i] (value of type byte) as type
    string in assignment

    /tmp/tmpaz0pf3_z_test.go:36:23: invalid operation: word[i] == "a" (mismatched
    types byte and untyped string)

    /tmp/tmpaz0pf3_z_test.go:36:41: invalid operation: word[i] == "e" (mismatched
    types byte and untyped string)

    /tmp/tmpaz0pf3_z_test.go:36:59: invalid operation: word[i] == "i" (mismatched
    types byte and untyped string)

    /tmp/tmpaz0pf3_z_test.go:36:77: invalid operation: word[i] == "o" (mismatched
    types byte and untyped string)

    /tmp/tmpaz0pf3_z_test.go:36:77: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074787
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []rune{'a', 'e', 'i', 'o', 'u'}\n    vowelsLen\
    \ := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    i := len(word) -\
    \ 1\n    j := len(word) - 2\n    k := len(word) - 3\n    l := len(word) - 4\n\
    \    m := len(word) - 5\n    n := len(word) - 6\n    o := len(word) - 7\n    p\
    \ := len(word) - 8\n    q := len(word) - 9\n    r := len(word) - 10\n    s :=\
    \ len(word) - 11\n    t := len(word) - 12\n    u := len(word) - 13\n    v := len(word)\
    \ - 14\n    w := len(word) - 15\n    x := len(word) - 16\n    y := len(word) -\
    \ 17\n    z := len(word) - 18\n    switch {\n    case word[len(word)-1] == 'a'\
    \ || word[len(word)-1] == 'e' || word[len(word)-1] == 'i' || word[len(word)-1]\
    \ == 'o' || word[len(word)-1] == 'u':\n        return word[len(word)-1]\n    case\
    \ word[len(word)-2] == 'a' || word[len(word)-2] == 'e' || word[len(word)-2] ==\
    \ 'i' || word[len(word)-2] == 'o' || word[len(word)-2] == 'u':\n        return\
    \ word[len(word)-2]\n    case word[len(word)-3] == 'a' || word[len(word)-3] ==\
    \ 'e' || word[len(word)-3] == 'i' || word[len(word)-3] == 'o' || word[len(word)-3]\
    \ == 'u':\n        return word[len(word)-3]\n    case word[len(word)-4] == 'a'\
    \ || word[len(word)-4] == 'e' || word[len(word)-4] == 'i' || word[len(word)-4]\
    \ == 'o' || word[len(word)-4] == 'u':\n        return word[len(word)-4]\n    case\
    \ word[len(word)-5] == 'a' || word[len(word)-5] == 'e' || word[len(word)-5] ==\
    \ 'i' || word[len(word)-5] == 'o' || word[len(word)-5] == 'u':\n        return\
    \ word[len(word)-5]\n    case word[len(word)-6] == 'a' || word[len(word)-6] ==\
    \ 'e' || word[len(word)-6] == 'i' || word[len(word)-6] == 'o' || word[len(word)-6]\
    \ == 'u':\n        return word[len(word)-6]\n    case word[len(word)-7] == 'a'\
    \ || word[len(word)-7] == 'e' || word[len(word)-7] == 'i' || word[len(word)-7]\
    \ == 'o' || word[len(word)-7] == 'u':\n        return word[len(word)-7]\n    case\
    \ word[len(word)-8\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate :=\
    \ get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpnt9qjk9j_test.go:60:26: expected '']'', found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074785
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)/2\n\
    \    vowelsCount += len(vowels)/3\n    vowelsCount += len(vowels)/4\n    vowelsCount\
    \ += len(vowels)/5\n    vowelsCount += len(vowels)/6\n    vowelsCount += len(vowels)/7\n\
    \    vowelsCount += len(vowels)/8\n    vowelsCount += len(vowels)/9\n    vowelsCount\
    \ += len(vowels)/10\n    vowelsCount += len(vowels)/11\n    vowelsCount += len(vowels)/12\n\
    \    vowelsCount += len(vowels)/13\n    vowelsCount += len(vowels)/14\n    vowelsCount\
    \ += len(vowels)/15\n    vowelsCount += len(vowels)/16\n    vowelsCount += len(vowels)/17\n\
    \    vowelsCount += len(vowels)/18\n    vowelsCount += len(vowels)/19\n    vowelsCount\
    \ += len(vowels)/20\n    vowelsCount += len(vowels)/21\n    vowelsCount += len(vowels)/22\n\
    \    vowelsCount += len(vowels)/23\n    vowelsCount += len(vowels)/24\n    vowelsCount\
    \ += len(vowels)/25\n    vowelsCount += len(vowels)/26\n    vowelsCount += len(vowels)/27\n\
    \    vowelsCount += len(vowels)/28\n    vowelsCount += len(vowels)/29\n    vowelsCount\
    \ += len(vowels)/30\n    vowelsCount += len(vowels)/31\n    vowelsCount += len(vowels)/32\n\
    \    vowelsCount += len(vowels)/33\n    vowelsCount += len(vowels)/34\n    vowelsCount\
    \ += len(vowels)/35\n    vowelsCount += len(vowels)/36\n    vowelsCount += len(vowels)/37\n\
    \    vowelsCount += len(vowels)/38\n    vowelsCount += len(vowels)/39\n    vowelsCount\
    \ += len(vowels)/40\n    vowelsCount += len(vowels)/41\n    vowelsCount += len(vowels)/42\n\
    \    vowelsCount += len(vowels)/43\n    vowelsCount += len(vowels)/44\n    vowelsCount\
    \ += len(vowels)/45\n    vowelsCount += len(vowels)/46\n    vowelsCount += len(vowels)/47\n\
    \    vowelsCount += len(vowels)/48\n    vowelsCount += len(vowels)/49\n    vowels\n\
    func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpt9m6ef6a_test.go:75:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpw4oq0vvz_test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 3\n    vowelsLen -= 4\n    vowelsLen -= 5\n    vowelsLen -= 6\n    vowelsLen\
    \ -= 7\n    vowelsLen -= 8\n    vowelsLen -= 9\n    vowelsLen -= 10\n    vowelsLen\
    \ -= 11\n    vowelsLen -= 12\n    vowelsLen -= 13\n    vowelsLen -= 14\n    vowelsLen\
    \ -= 15\n    vowelsLen -= 16\n    vowelsLen -= 17\n    vowelsLen -= 18\n    vowelsLen\
    \ -= 19\n    vowelsLen -= 20\n    vowelsLen -= 21\n    vowelsLen -= 22\n    vowelsLen\
    \ -= 23\n    vowelsLen -= 24\n    vowelsLen -= 25\n    vowelsLen -= 26\n    vowelsLen\
    \ -= 27\n    vowelsLen -= 28\n    vowelsLen -= 29\n    vowelsLen -= 30\n    vowelsLen\
    \ -= 31\n    vowelsLen -= 32\n    vowelsLen -= 33\n    vowelsLen -= 34\n    vowelsLen\
    \ -= 35\n    vowelsLen -= 36\n    vowelsLen -= 37\n    vowelsLen -= 38\n    vowelsLen\
    \ -= 39\n    vowelsLen -= 40\n    vowelsLen -= 41\n    vowelsLen -= 42\n    vowelsLen\
    \ -= 43\n    vowelsLen -= 44\n    vowelsLen -= 45\n    vowelsLen -= 46\n    vowelsLen\
    \ -= 47\n    vowelsLen -= 48\n    vowelsLen -= 49\n    vowelsLen -= 50\n    vowelsLen\
    \ -= 51\n    vowelsLen -= 52\n    vowelsLen -= 53\n    vowelsLen -= 54\n    vowelsLen\
    \ -= 55\n    vowelsLen -= 56\n    vowelsLen -= 57\n    vowelsLen -= 58\n    vowelsLen\
    \ -= 59\n    vowelsLen -= 60\n    vowelsLen -= 61\n    vowelsLen -= 62\n    vowelsLen\
    \ -= 63\n    vowelsLen -= 64\n    vowelsLen -= 65\n    vowelsLen -= 66\n    vowelsLen\
    \ -= 67\n    vowelsLen -= 68\n    vowelsLen -= 69\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpt5bue015_test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074645
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphy7oiqg__test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpyvyobif7_test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    for _, v := range vowels {\n        if word == v {\n\
    \            vowelsCount++\n        }\n    }\n    if vowelsCount > 0 {\n     \
    \   for _, v := range vowels {\n            if word == v {\n                return\
    \ v\n            }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmpcoafb4p3_test.go:65: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmpcoafb4p3_test.go:65: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmpcoafb4p3_test.go:65: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmpcoafb4p3_test.go:65: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmpcoafb4p3_test.go:65:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpcoafb4p3_test.go:65: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074787
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels) - len(word) // count vowels\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i]\
    \ == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n           \
    \ vowelsCount++\n        }\n    }\n    if vowelsCount <= 0 {\n        return \"\
    \"\n    }\n    vowelsCount -= len(vowels) // count vowels\n    for i := len(word)\
    \ - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] ==\
    \ 'i' || word[i] == 'o' || word[i] == 'u' {\n            if vowelsCount < 0 {\n\
    \                return \"\"\n            }\n            if vowelsCount > 0 {\n\
    \                vowelsCount--\n            }\n        }\n    }\n    return word[len(word)-1]\n\
    }\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6sqrwej3_test.go:45:12: cannot use word[len(word) - 1] (value of type
    byte) as type string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074787
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for i := len(word)\
    \ - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] ==\
    \ 'i' || word[i] == 'o' || word[i] == 'u' {\n            vowelsCount++\n     \
    \   }\n    }\n    if vowelsCount == 0 {\n        return \"\"\n    }\n    vowelsCount\
    \ -= len(vowels)\n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i]\
    \ == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u'\
    \ {\n            if vowelsCount < 0 {\n                return \"\"\n         \
    \   }\n            vowelsCount--\n        }\n    }\n    return word[len(word)-1]\n\
    }\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvgboyxvi_test.go:43:12: cannot use word[len(word) - 1] (value of type
    byte) as type string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074787
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowel := \"a\"\n    vowelCount := 0\n    vowelCount +=\
    \ strings.Count(word[:len(word)-1], vowel)\n    vowelCount += strings.Count(word[len(word)-1:],\
    \ vowel)\n    if vowelCount > 0 {\n        return vowel\n    }\n    vowel = \"\
    e\"\n    vowelCount += strings.Count(word[:len(word)-1], vowel)\n    vowelCount\
    \ += strings.Count(word[len(word)-1:], vowel)\n    if vowelCount > 0 {\n     \
    \   return vowel\n    }\n    vowel = \"i\"\n    vowelCount += strings.Count(word[:len(word)-1],\
    \ vowel)\n    vowelCount += strings.Count(word[len(word)-1:], vowel)\n    if vowelCount\
    \ > 0 {\n        return vowel\n    }\n    vowel = \"o\"\n    vowelCount += strings.Count(word[:len(word)-1],\
    \ vowel)\n    vowelCount += strings.Count(word[len(word)-1:], vowel)\n    if vowelCount\
    \ > 0 {\n        return vowel\n    }\n    vowel = \"u\"\n    vowelCount += strings.Count(word[:len(word)-1],\
    \ vowel)\n    vowelCount += strings.Count(word[len(word)-1:], vowel)\n    if vowelCount\
    \ > 0 {\n        return vowel\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp59tnfyel_test.go:25:19: undefined: strings

    /tmp/tmp59tnfyel_test.go:26:19: undefined: strings

    /tmp/tmp59tnfyel_test.go:31:19: undefined: strings

    /tmp/tmp59tnfyel_test.go:32:19: undefined: strings

    /tmp/tmp59tnfyel_test.go:37:19: undefined: strings

    /tmp/tmp59tnfyel_test.go:38:19: undefined: strings

    /tmp/tmp59tnfyel_test.go:43:19: undefined: strings

    /tmp/tmp59tnfyel_test.go:44:19: undefined: strings

    /tmp/tmp59tnfyel_test.go:49:19: undefined: strings

    /tmp/tmp59tnfyel_test.go:50:19: undefined: strings

    /tmp/tmp59tnfyel_test.go:50:19: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074787
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)/2\n\
    \    vowelsCount += len(vowels)/3\n    vowelsCount += len(vowels)/4\n    vowelsCount\
    \ += len(vowels)/5\n    vowelsCount += len(vowels)/6\n    vowelsCount += len(vowels)/7\n\
    \    vowelsCount += len(vowels)/8\n    vowelsCount += len(vowels)/9\n    vowelsCount\
    \ += len(vowels)/10\n    vowelsCount += len(vowels)/11\n    vowelsCount += len(vowels)/12\n\
    \    vowelsCount += len(vowels)/13\n    vowelsCount += len(vowels)/14\n    vowelsCount\
    \ += len(vowels)/15\n    vowelsCount += len(vowels)/16\n    vowelsCount += len(vowels)/17\n\
    \    vowelsCount += len(vowels)/18\n    vowelsCount += len(vowels)/19\n    vowelsCount\
    \ += len(vowels)/20\n    vowelsCount += len(vowels)/21\n    vowelsCount += len(vowels)/22\n\
    \    vowelsCount += len(vowels)/23\n    vowelsCount += len(vowels)/24\n    vowelsCount\
    \ += len(vowels)/25\n    vowelsCount += len(vowels)/26\n    vowelsCount += len(vowels)/27\n\
    \    vowelsCount += len(vowels)/28\n    vowelsCount += len(vowels)/29\n    vowelsCount\
    \ += len(vowels)/30\n    vowelsCount += len(vowels)/31\n    vowelsCount += len(vowels)/32\n\
    \    vowelsCount += len(vowels)/33\n    vowelsCount += len(vowels)/34\n    vowelsCount\
    \ += len(vowels)/35\n    vowelsCount += len(vowels)/36\n    vowelsCount += len(vowels)/37\n\
    \    vowelsCount += len(vowels)/38\n    vowelsCount += len(vowels)/39\n    vowelsCount\
    \ += len(vowels)/40\n    vowelsCount += len(vowels)/41\n    vowelsCount += len(vowels)/42\n\
    \    vowelsCount += len(vowels)/43\n    vowelsCount += len(vowels)/44\n    vowelsCount\
    \ += len(vowels)/45\n    vowelsCount += len(vowels)/46\n    vowelsCount += len(vowels)/47\n\
    \    vowelsCount += len(vowels)/48\n    vowelsCount += len(vowels)/49\n    vowels\n\
    func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpt9m6ef6a_test.go:75:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for _, v := range vowels\
    \ {\n        if strings.Contains(word, v) {\n            vowelsCount++\n     \
    \   }\n    }\n    if vowelsCount == 0 {\n        return \"\"\n    }\n    vowelsCount\
    \ -= len(vowels)\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n\nfunc\
    \ TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpd_sex7vm_test.go:98:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074644
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphy7oiqg__test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // Your code here\n    vowels := []string{\"a\", \"e\"\
    , \"i\", \"o\", \"u\"}\n    vowelsLen := len(vowels)\n    vowelsLen -= 1\n   \
    \ vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n\
    \    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen +=\
    \ 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp5eu5y28m_test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074647
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpyvyobif7_test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpjcv4si1u_test.go:100:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074643
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpw4oq0vvz_test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // Your code here\n    vowels := []string{\"a\", \"e\"\
    , \"i\", \"o\", \"u\"}\n    vowelsCount := 0\n    vowelsCount += len(vowels)\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i]\
    \ == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n           \
    \ vowelsCount++\n        }\n    }\n    if vowelsCount <= 1 {\n        return \"\
    \"\n    }\n    vowelsCount -= len(vowels)\n    for i := len(word) - 1; i >= 0;\
    \ i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i]\
    \ == 'o' || word[i] == 'u' {\n            if word[i+1] == 'a' || word[i+1] ==\
    \ 'e' || word[i+1] == 'i' || word[i+1] == 'o' || word[i+1] == 'u' {\n        \
    \        return word[i]\n            }\n        }\n    }\n    return \"\"\n}\n\
    \nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmptrcr00ra_test.go:39:24: cannot use word[i] (value of type byte) as type
    string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074787
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpyvyobif7_test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphy7oiqg__test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpyvyobif7_test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpyvyobif7_test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for _, v := range vowels\
    \ {\n        if strings.Contains(word, v) {\n            vowelsCount++\n     \
    \   }\n    }\n    if vowelsCount > 0 {\n        vowelsCount -= 1\n    }\n    if\
    \ vowelsCount < 0 {\n        vowelsCount = 0\n    }\n    if vowelsCount == 0 {\n\
    \        return \"\"\n    }\n    vowelsCount -= 1\n    vowelsCount /= 2\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += (len(vowels)-1)/2\n    vowelsCount %= len(vowels)\n\
    \    vowelsCount += (len(vowels)-1)/2\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += (len(vowels)-1)/2\n    vowelsCount %= len(vowels)\n    vowelsCount += (len(vowels)-1)/2\n\
    \    vowelsCount %= len(vowels)\n    vowelsCount += (len(vowels)-1)/2\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += (len(vowels)-1)/2\n    vowelsCount %= len(vowels)\n\
    \    vowelsCount += (len(vowels)-1)/2\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += (len(vowels)-1)/2\n    vowelsCount %= len(vowels)\n    vowelsCount += (len(vowels)-1)/2\n\
    \    vowelsCount %= len(vowels)\n    vowelsCount += (len(vowels)-1)/2\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += (len(vowels)-1)/2\n    vowelsCount %= len(vowels)\n\
    \    vowelsCount += (len(vowels)-1)/2\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += (len(vowels)-1)/2\n    vowelsCount %= len(vowels)\n    vowelsCount += (len(vowels)-1)/2\n\
    \    vowelsCount %= len(vowels)\n    vowelsCount += (len(vowels)-1)/2\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += (len(vowels)-1)/2\n    vowelsCount %= len(vowels)\n\
    \    vowelsCount += (len(vowels)-1)/2\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += (len(vowels)-1)/2\n    vowelsCount %= len(vowels)\n    vowelsCount += (len(vowels)-1)/2\n\
    \    vowelsCount %= len(vowels)\n    vowelsCount += (len(vowels)-1)/2\n\nfunc\
    \ TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpbw2gike2_test.go:83:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074785
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for _, v := range vowels\
    \ {\n        if strings.Contains(word, v) {\n            vowelsCount++\n     \
    \   }\n    }\n    if vowelsCount < 2 {\n        return \"\"\n    }\n    vowelsCount\
    \ -= 2\n    vowelsCount /= 2\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += 2\n    if vowelsCount < 0 {\n        vowelsCount = 0\n    }\n    return vowels[vowelsCount]\n\
    }\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprhx526qk_test.go:27:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074787
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpw4oq0vvz_test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpjcv4si1u_test.go:100:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074643
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpyvyobif7_test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    for _, v := range vowels {\n        if word == v {\n\
    \            vowelsCount++\n        }\n    }\n    if vowelsCount > 0 {\n     \
    \   return word\n    }\n    \n    vowelsCount = 0\n    for i := len(word) - 1;\
    \ i >= 0; i-- {\n        if word[i] == word[len(word)-1] {\n            vowelsCount++\n\
    \        }\n    }\n    if vowelsCount > 0 {\n        return word\n    }\n    \n\
    \    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmpqswi8afr_test.go:72: expected 'u', got 'yogurt'\n    ---\
    \ FAIL: TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmpqswi8afr_test.go:72:\
    \ expected 'u', got 'full'\n    --- FAIL: TestGet_Closest_Vowel/test_num__2 (0.00s)\n\
    \        tmpqswi8afr_test.go:72: expected '', got 'easy'\n    --- FAIL: TestGet_Closest_Vowel/test_num__3\
    \ (0.00s)\n        tmpqswi8afr_test.go:72: expected '', got 'eAsy'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__4 (0.00s)\n        tmpqswi8afr_test.go:72: expected\
    \ '', got 'ali'\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n   \
    \     tmpqswi8afr_test.go:72: expected 'a', got 'bad'\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmpqswi8afr_test.go:72: expected 'o', got 'most'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__7 (0.00s)\n        tmpqswi8afr_test.go:72: expected\
    \ '', got 'ab'\n    --- FAIL: TestGet_Closest_Vowel/test_num__8 (0.00s)\n    \
    \    tmpqswi8afr_test.go:72: expected '', got 'ba'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9\
    \ (0.00s)\n        tmpqswi8afr_test.go:72: expected '', got 'quick'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmpqswi8afr_test.go:72:\
    \ expected 'i', got 'anime'\n    --- FAIL: TestGet_Closest_Vowel/test_num__11\
    \ (0.00s)\n        tmpqswi8afr_test.go:72: expected '', got 'Asia'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__12 (0.00s)\n        tmpqswi8afr_test.go:72:\
    \ expected 'o', got 'Above'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074787
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)/2\n\
    \    vowelsCount += len(vowels)/3\n    vowelsCount += len(vowels)/4\n    vowelsCount\
    \ += len(vowels)/5\n    vowelsCount += len(vowels)/6\n    vowelsCount += len(vowels)/7\n\
    \    vowelsCount += len(vowels)/8\n    vowelsCount += len(vowels)/9\n    vowelsCount\
    \ += len(vowels)/10\n    vowelsCount += len(vowels)/11\n    vowelsCount += len(vowels)/12\n\
    \    vowelsCount += len(vowels)/13\n    vowelsCount += len(vowels)/14\n    vowelsCount\
    \ += len(vowels)/15\n    vowelsCount += len(vowels)/16\n    vowelsCount += len(vowels)/17\n\
    \    vowelsCount += len(vowels)/18\n    vowelsCount += len(vowels)/19\n    vowelsCount\
    \ += len(vowels)/20\n    vowelsCount += len(vowels)/21\n    vowelsCount += len(vowels)/22\n\
    \    vowelsCount += len(vowels)/23\n    vowelsCount += len(vowels)/24\n    vowelsCount\
    \ += len(vowels)/25\n    vowelsCount += len(vowels)/26\n    vowelsCount += len(vowels)/27\n\
    \    vowelsCount += len(vowels)/28\n    vowelsCount += len(vowels)/29\n    vowelsCount\
    \ += len(vowels)/30\n    vowelsCount += len(vowels)/31\n    vowelsCount += len(vowels)/32\n\
    \    vowelsCount += len(vowels)/33\n    vowelsCount += len(vowels)/34\n    vowelsCount\
    \ += len(vowels)/35\n    vowelsCount += len(vowels)/36\n    vowelsCount += len(vowels)/37\n\
    \    vowelsCount += len(vowels)/38\n    vowelsCount += len(vowels)/39\n    vowelsCount\
    \ += len(vowels)/40\n    vowelsCount += len(vowels)/41\n    vowelsCount += len(vowels)/42\n\
    \    vowelsCount += len(vowels)/43\n    vowelsCount += len(vowels)/44\n    vowelsCount\
    \ += len(vowels)/45\n    vowelsCount += len(vowels)/46\n    vowelsCount += len(vowels)/47\n\
    \    vowelsCount += len(vowels)/48\n    vowelsCount += len(vowels)/49\n    vowels\n\
    func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpt9m6ef6a_test.go:75:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    for _, v := range vowels {\n        if strings.Contains(word,\
    \ v) {\n            vowelsCount++\n        }\n    }\n    if vowelsCount == 0 {\n\
    \        return \"\"\n    }\n    vowelsCount -= 1\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp5dnmitnn_test.go:98:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074642
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpyvyobif7_test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)/2\n\
    \    vowelsCount += len(vowels)/3\n    vowelsCount += len(vowels)/4\n    vowelsCount\
    \ += len(vowels)/5\n    vowelsCount += len(vowels)/6\n    vowelsCount += len(vowels)/7\n\
    \    vowelsCount += len(vowels)/8\n    vowelsCount += len(vowels)/9\n    vowelsCount\
    \ += len(vowels)/10\n    vowelsCount += len(vowels)/11\n    vowelsCount += len(vowels)/12\n\
    \    vowelsCount += len(vowels)/13\n    vowelsCount += len(vowels)/14\n    vowelsCount\
    \ += len(vowels)/15\n    vowelsCount += len(vowels)/16\n    vowelsCount += len(vowels)/17\n\
    \    vowelsCount += len(vowels)/18\n    vowelsCount += len(vowels)/19\n    vowelsCount\
    \ += len(vowels)/20\n    vowelsCount += len(vowels)/21\n    vowelsCount += len(vowels)/22\n\
    \    vowelsCount += len(vowels)/23\n    vowelsCount += len(vowels)/24\n    vowelsCount\
    \ += len(vowels)/25\n    vowelsCount += len(vowels)/26\n    vowelsCount += len(vowels)/27\n\
    \    vowelsCount += len(vowels)/28\n    vowelsCount += len(vowels)/29\n    vowelsCount\
    \ += len(vowels)/30\n    vowelsCount += len(vowels)/31\n    vowelsCount += len(vowels)/32\n\
    \    vowelsCount += len(vowels)/33\n    vowelsCount += len(vowels)/34\n    vowelsCount\
    \ += len(vowels)/35\n    vowelsCount += len(vowels)/36\n    vowelsCount += len(vowels)/37\n\
    \    vowelsCount += len(vowels)/38\n    vowelsCount += len(vowels)/39\n    vowelsCount\
    \ += len(vowels)/40\n    vowelsCount += len(vowels)/41\n    vowelsCount += len(vowels)/42\n\
    \    vowelsCount += len(vowels)/43\n    vowelsCount += len(vowels)/44\n    vowelsCount\
    \ += len(vowels)/45\n    vowelsCount += len(vowels)/46\n    vowelsCount += len(vowels)/47\n\
    \    vowelsCount += len(vowels)/48\n    vowelsCount += len(vowels)/49\n    vowels\n\
    func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpt9m6ef6a_test.go:75:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpyvyobif7_test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 3\n    vowelsLen -= 4\n    vowelsLen -= 5\n    vowelsLen -= 6\n    vowelsLen\
    \ -= 7\n    vowelsLen -= 8\n    vowelsLen -= 9\n    vowelsLen -= 10\n    vowelsLen\
    \ -= 11\n    vowelsLen -= 12\n    vowelsLen -= 13\n    vowelsLen -= 14\n    vowelsLen\
    \ -= 15\n    vowelsLen -= 16\n    vowelsLen -= 17\n    vowelsLen -= 18\n    vowelsLen\
    \ -= 19\n    vowelsLen -= 20\n    vowelsLen -= 21\n    vowelsLen -= 22\n    vowelsLen\
    \ -= 23\n    vowelsLen -= 24\n    vowelsLen -= 25\n    vowelsLen -= 26\n    vowelsLen\
    \ -= 27\n    vowelsLen -= 28\n    vowelsLen -= 29\n    vowelsLen -= 30\n    vowelsLen\
    \ -= 31\n    vowelsLen -= 32\n    vowelsLen -= 33\n    vowelsLen -= 34\n    vowelsLen\
    \ -= 35\n    vowelsLen -= 36\n    vowelsLen -= 37\n    vowelsLen -= 38\n    vowelsLen\
    \ -= 39\n    vowelsLen -= 40\n    vowelsLen -= 41\n    vowelsLen -= 42\n    vowelsLen\
    \ -= 43\n    vowelsLen -= 44\n    vowelsLen -= 45\n    vowelsLen -= 46\n    vowelsLen\
    \ -= 47\n    vowelsLen -= 48\n    vowelsLen -= 49\n    vowelsLen -= 50\n    vowelsLen\
    \ -= 51\n    vowelsLen -= 52\n    vowelsLen -= 53\n    vowelsLen -= 54\n    vowelsLen\
    \ -= 55\n    vowelsLen -= 56\n    vowelsLen -= 57\n    vowelsLen -= 58\n    vowelsLen\
    \ -= 59\n    vowelsLen -= 60\n    vowelsLen -= 61\n    vowelsLen -= 62\n    vowelsLen\
    \ -= 63\n    vowelsLen -= 64\n    vowelsLen -= 65\n    vowelsLen -= 66\n    vowelsLen\
    \ -= 67\n    vowelsLen -= 68\n    vowelsLen -= 69\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpt5bue015_test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074645
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // Your code here\n    vowels := []string{\"a\", \"e\"\
    , \"i\", \"o\", \"u\"}\n    vowelsCount := 0\n    vowelsCount += len(vowels)\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i]\
    \ == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n           \
    \ vowelsCount += 1\n        }\n    }\n    if vowelsCount < 2 {\n        return\
    \ \"\"\n    }\n    vowelsCount -= 2\n    vowelsCount /= 2\n    for i := len(word)\
    \ - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] ==\
    \ 'i' || word[i] == 'o' || word[i] == 'u' {\n            if vowelsCount > 0 {\n\
    \                vowelsCount -= 1\n                return word[i]\n          \
    \  }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbst4g8rb_test.go:41:24: cannot use word[i] (value of type byte) as type
    string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074788
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)/2\n\
    \    vowelsCount += len(vowels)/3\n    vowelsCount += len(vowels)/4\n    vowelsCount\
    \ += len(vowels)/5\n    vowelsCount += len(vowels)/6\n    vowelsCount += len(vowels)/7\n\
    \    vowelsCount += len(vowels)/8\n    vowelsCount += len(vowels)/9\n    vowelsCount\
    \ += len(vowels)/10\n    vowelsCount += len(vowels)/11\n    vowelsCount += len(vowels)/12\n\
    \    vowelsCount += len(vowels)/13\n    vowelsCount += len(vowels)/14\n    vowelsCount\
    \ += len(vowels)/15\n    vowelsCount += len(vowels)/16\n    vowelsCount += len(vowels)/17\n\
    \    vowelsCount += len(vowels)/18\n    vowelsCount += len(vowels)/19\n    vowelsCount\
    \ += len(vowels)/20\n    vowelsCount += len(vowels)/21\n    vowelsCount += len(vowels)/22\n\
    \    vowelsCount += len(vowels)/23\n    vowelsCount += len(vowels)/24\n    vowelsCount\
    \ += len(vowels)/25\n    vowelsCount += len(vowels)/26\n    vowelsCount += len(vowels)/27\n\
    \    vowelsCount += len(vowels)/28\n    vowelsCount += len(vowels)/29\n    vowelsCount\
    \ += len(vowels)/30\n    vowelsCount += len(vowels)/31\n    vowelsCount += len(vowels)/32\n\
    \    vowelsCount += len(vowels)/33\n    vowelsCount += len(vowels)/34\n    vowelsCount\
    \ += len(vowels)/35\n    vowelsCount += len(vowels)/36\n    vowelsCount += len(vowels)/37\n\
    \    vowelsCount += len(vowels)/38\n    vowelsCount += len(vowels)/39\n    vowelsCount\
    \ += len(vowels)/40\n    vowelsCount += len(vowels)/41\n    vowelsCount += len(vowels)/42\n\
    \    vowelsCount += len(vowels)/43\n    vowelsCount += len(vowels)/44\n    vowelsCount\
    \ += len(vowels)/45\n    vowelsCount += len(vowels)/46\n    vowelsCount += len(vowels)/47\n\
    \    vowelsCount += len(vowels)/48\n    vowelsCount += len(vowels)/49\n    vowels\n\
    func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpt9m6ef6a_test.go:75:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpw4oq0vvz_test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphy7oiqg__test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpw4oq0vvz_test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpyvyobif7_test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphy7oiqg__test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    for _, v := range vowels {\n        if strings.Contains(word,\
    \ v) {\n            vowelsCount++\n        }\n    }\n    if vowelsCount == 0 {\n\
    \        return \"\"\n    }\n    vowelsCount -= 2\n    vowelsCount %= len(vowels)\n\
    \    if vowelsCount == 0 {\n        return \"\"\n    }\n    vowelsCount -= len(vowels)\n\
    \    if vowelsCount == 0 {\n        return \"\"\n    }\n    vowelsCount -= len(vowels)\n\
    \    if vowelsCount == 0 {\n        return \"\"\n    }\n    vowelsCount -= len(vowels)\n\
    \    if vowelsCount == 0 {\n        return \"\"\n    }\n    vowelsCount -= len(vowels)\n\
    \    if vowelsCount == 0 {\n        return \"\"\n    }\n    vowelsCount -= len(vowels)\n\
    \    if vowelsCount == 0 {\n        return \"\"\n    }\n    vowelsCount -= len(vowels)\n\
    \    if vowelsCount == 0 {\n        return \"\"\n    }\n    vowelsCount -= len(vowels)\n\
    \    if vowelsCount == 0 {\n        return \"\"\n    }\n    vowelsCount -= len(vowels)\n\
    \    if vowelsCount == 0 {\n        return \"\"\n    }\n    vowelsCount -= len(vowels)\n\
    \    if vowelsCount == 0 {\n        return \"\"\n    }\n    vowelsCount -= len(vowels)\n\
    \    if vowelsCount == 0 {\n        return \"\"\n    }\n    vowelsCount -= len(vowels)\n\
    \    if vowelsCount == 0 {\n        return \"\"\n    }\n    vowelsCount -= len(vowels)\n\
    \    if vowelsCount == 0 {\n        return \"\"\n    }\n    vowelsCount -= len(vowels)\n\
    \    if vowelsCount == 0 {\n        return \"\"\n    }\n    vowelsCount -= len(vowels)\n\
    \    if vowelsCount == 0 {\n        return \"\"\n    }\n    vowelsCount -= len(vowels)\n\
    \    if vowelsCount == 0 {\n        return \"\"\n    }\n    vowelsCount -= len(vowels)\n\
    \    if vowelsCount == 0 {\n        return \"\"\n    }\n    vowelsCount -= len(vowels)\n\
    \    if vowelsCount == 0 {\n        return \"\"\n    }\n    vowelsCount -= len(vowels)\n\
    \    if vowelsCount == 0 {\n        return \"\"\n    }\n    vowelsCount -= len(vowels)\n\
    \    if vowelsCount == 0 {\n        return \"\"\n    }\n    vowelsCount -= len(vowels)\n\
    \    if vowelsCount == 0 {\n        return \"\"\n    }\n    vowels\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp42a3_m5f_test.go:119:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074787
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpw4oq0vvz_test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []rune{'a', 'e', 'i', 'o', 'u'}\n    vowelsLen\
    \ := len(vowels)\n    vowelsLen -= 1\n    vowelsLen -= 2\n    vowelsLen -= 3\n\
    \    vowelsLen -= 4\n    vowelsLen -= 5\n    vowelsLen -= 6\n    vowelsLen -=\
    \ 7\n    vowelsLen -= 8\n    vowelsLen -= 9\n    vowelsLen -= 10\n    vowelsLen\
    \ -= 11\n    vowelsLen -= 12\n    vowelsLen -= 13\n    vowelsLen -= 14\n    vowelsLen\
    \ -= 15\n    vowelsLen -= 16\n    vowelsLen -= 17\n    vowelsLen -= 18\n    vowelsLen\
    \ -= 19\n    vowelsLen -= 20\n    vowelsLen -= 21\n    vowelsLen -= 22\n    vowelsLen\
    \ -= 23\n    vowelsLen -= 24\n    vowelsLen -= 25\n    vowelsLen -= 26\n    vowelsLen\
    \ -= 27\n    vowelsLen -= 28\n    vowelsLen -= 29\n    vowelsLen -= 30\n    vowelsLen\
    \ -= 31\n    vowelsLen -= 32\n    vowelsLen -= 33\n    vowelsLen -= 34\n    vowelsLen\
    \ -= 35\n    vowelsLen -= 36\n    vowelsLen -= 37\n    vowelsLen -= 38\n    vowelsLen\
    \ -= 39\n    vowelsLen -= 40\n    vowelsLen -= 41\n    vowelsLen -= 42\n    vowelsLen\
    \ -= 43\n    vowelsLen -= 44\n    vowelsLen -= 45\n    vowelsLen -= 46\n    vowelsLen\
    \ -= 47\n    vowelsLen -= 48\n    vowelsLen -= 49\n    vowelsLen -= 50\n    vowelsLen\
    \ -= 51\n    vowelsLen -= 52\n    vowelsLen -= 53\n    vowelsLen -= 54\n    vowelsLen\
    \ -= 55\n    vowelsLen -= 56\n    vowelsLen -= 57\n    vowelsLen -= 58\n    vowelsLen\
    \ -= 59\n    vowelsLen -= 60\n    vowelsLen -= 61\n    vowelsLen -= 62\n    vowelsLen\
    \ -= 63\n    vowelsLen -= 64\n    vowelsLen -= 65\n    vowelsLen -= 66\n    vowelsLen\
    \ -= 67\n    vowelsLen -= 68\n    vowelsLen -= 69\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp41x9yuci_test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074787
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    for _, v := range vowels {\n        if word == v {\n\
    \            vowelsCount++\n        }\n    }\n    if vowelsCount == 0 {\n    \
    \    return \"\"\n    }\n    vowelsCount -= 1\n    vowelsCount /= 2\n    vowelsCount\
    \ %= len(vowels)\n    if vowelsCount == 0 {\n        return \"\"\n    }\n    i\
    \ := len(word) - 1\n    j := len(word) - 2\n    for {\n        if word[i] == word[j]\
    \ {\n            if j == 0 {\n                return word[i]\n            }\n\
    \            j--\n        } else {\n            if i == 0 {\n                return\
    \ word[j]\n            }\n            i--\n        }\n    }\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpzgtaeqim_test.go:44:24: cannot use word[i] (value of type byte) as type
    string in return statement

    /tmp/tmpzgtaeqim_test.go:49:24: cannot use word[j] (value of type byte) as type
    string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074788
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphy7oiqg__test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []rune{'a', 'e', 'i', 'o', 'u'}\n    vowelsLen\
    \ := len(vowels)\n    \n    i := len(word) - 1\n    \n    for i >= 0 {\n     \
    \   if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' ||\
    \ word[i] == 'u' {\n            i -= 1\n            continue\n        }\n    \
    \    \n        if word[i] == 'y' {\n            i -= 2\n            continue\n\
    \        }\n        \n        if word[i] == 'o' {\n            i -= 2\n      \
    \      continue\n        }\n        \n        if word[i] == 'u' {\n          \
    \  i -= 2\n            continue\n        }\n        \n        if word[i] == 'a'\
    \ || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n\
    \            i -= 1\n            continue\n        }\n        \n        if word[i]\
    \ == 'y' {\n            i -= 2\n            continue\n        }\n        \n  \
    \      if word[i] == 'o' {\n            i -= 2\n            continue\n       \
    \ }\n        \n        if word[i] == 'u' {\n            i -= 2\n            continue\n\
    \        }\n        \n        if word[i] == 'a' || word[i] == 'e' || word[i] ==\
    \ 'i' || word[i] == 'o' || word[i] == 'u' {\n            i -= 1\n            continue\n\
    \        }\n        \n        if word[i] == 'y' {\n            i -= 2\n      \
    \      continue\n        }\n        \n        if word[i] == 'o' {\n          \
    \  i -= 2\n            continue\n        }\n        \n        if word[i] == 'u'\
    \ {\n            i -= 2\n            continue\n        }\n        \n        if\
    \ word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i]\
    \ == 'u' {\n            i -= 1\n            continue\n        }\n        \n  \
    \      if word[i] == 'y' {\n            i -= 2\n            continue\n       \
    \ }\n        \n        if word[i] == 'o' {\n            i -= 2\n            continue\n\
    \        }\n        \n        if word[i] == 'u' {\n            i -= 2\n      \
    \      continue\n        }\n        \n        if word[i] == 'a' || word[i] ==\
    \ 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n            i -=\
    \ 1\n            continue\n        }\n        \n        if word[i] == 'y' {\n\
    \            i -= 2\n            continue\n        }\n        \n        if word[i]\
    \ == 'o' {\n            i -= 2\n            continue\n        }\n        \n  \
    \      if word[i] == 'u' {\n            i -= 2\n            continue\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpgpthg0xn_test.go:128:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074787
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphy7oiqg__test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    for _, v := range vowels {\n        if word == v {\n\
    \            vowelsCount++\n        }\n    }\n    if vowelsCount == 0 {\n    \
    \    return \"\"\n    }\n    vowelsCount -= len(word) - len(word[:len(word)-1])\n\
    \    if vowelsCount < 0 {\n        vowelsCount = 0\n    }\n    for i := len(word)\
    \ - 2; i >= 0; i-- {\n        if word[i] == word[i+1] && word[i] == word[i+2]\
    \ {\n            return word[i]\n        }\n    }\n    return \"\"\n}\n\nfunc\
    \ TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpk1lekp1l_test.go:39:20: cannot use word[i] (value of type byte) as type
    string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074788
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)/2\n\
    \    vowelsCount += len(vowels)/3\n    vowelsCount += len(vowels)/4\n    vowelsCount\
    \ += len(vowels)/5\n    vowelsCount += len(vowels)/6\n    vowelsCount += len(vowels)/7\n\
    \    vowelsCount += len(vowels)/8\n    vowelsCount += len(vowels)/9\n    vowelsCount\
    \ += len(vowels)/10\n    vowelsCount += len(vowels)/11\n    vowelsCount += len(vowels)/12\n\
    \    vowelsCount += len(vowels)/13\n    vowelsCount += len(vowels)/14\n    vowelsCount\
    \ += len(vowels)/15\n    vowelsCount += len(vowels)/16\n    vowelsCount += len(vowels)/17\n\
    \    vowelsCount += len(vowels)/18\n    vowelsCount += len(vowels)/19\n    vowelsCount\
    \ += len(vowels)/20\n    vowelsCount += len(vowels)/21\n    vowelsCount += len(vowels)/22\n\
    \    vowelsCount += len(vowels)/23\n    vowelsCount += len(vowels)/24\n    vowelsCount\
    \ += len(vowels)/25\n    vowelsCount += len(vowels)/26\n    vowelsCount += len(vowels)/27\n\
    \    vowelsCount += len(vowels)/28\n    vowelsCount += len(vowels)/29\n    vowelsCount\
    \ += len(vowels)/30\n    vowelsCount += len(vowels)/31\n    vowelsCount += len(vowels)/32\n\
    \    vowelsCount += len(vowels)/33\n    vowelsCount += len(vowels)/34\n    vowelsCount\
    \ += len(vowels)/35\n    vowelsCount += len(vowels)/36\n    vowelsCount += len(vowels)/37\n\
    \    vowelsCount += len(vowels)/38\n    vowelsCount += len(vowels)/39\n    vowelsCount\
    \ += len(vowels)/40\n    vowelsCount += len(vowels)/41\n    vowelsCount += len(vowels)/42\n\
    \    vowelsCount += len(vowels)/43\n    vowelsCount += len(vowels)/44\n    vowelsCount\
    \ += len(vowels)/45\n    vowelsCount += len(vowels)/46\n    vowelsCount += len(vowels)/47\n\
    \    vowelsCount += len(vowels)/48\n    vowelsCount += len(vowels)/49\n    vowels\n\
    func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpt9m6ef6a_test.go:75:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []rune(\"aeiou\")\n    vowelsLen := len(vowels)\n\
    \    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    \n    index :=\
    \ len(word) - 1\n    index /= 2\n    index += 1\n    \n    index %= vowelsLen\n\
    \    \n    if index >= vowelsLen {\n        return \"\"\n    }\n    \n    if word[index]\
    \ == vowels[vowelsLen] {\n        return word[index]\n    }\n    \n    if word[index]\
    \ == vowels[0] {\n        return word[index+1]\n    }\n    \n    return word[index-1]\n\
    }\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqb1jiusb_test.go:39:23: invalid operation: word[index] == vowels[vowelsLen]
    (mismatched types byte and rune)

    /tmp/tmpqb1jiusb_test.go:40:16: cannot use word[index] (value of type byte) as
    type string in return statement

    /tmp/tmpqb1jiusb_test.go:43:23: invalid operation: word[index] == vowels[0] (mismatched
    types byte and rune)

    /tmp/tmpqb1jiusb_test.go:44:16: cannot use word[index + 1] (value of type byte)
    as type string in return statement

    /tmp/tmpqb1jiusb_test.go:47:12: cannot use word[index - 1] (value of type byte)
    as type string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074788
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // Your code here\n    vowels := []rune{'a', 'e', 'i',\
    \ 'o', 'u'}\n    vowelsCount := 0\n    for _, v := range word {\n        if v\
    \ == 'a' || v == 'e' || v == 'i' || v == 'o' || v == 'u' {\n            vowelsCount++\n\
    \        }\n    }\n    if vowelsCount > 0 {\n        for _, v := range word {\n\
    \            if v == 'a' || v == 'e' || v == 'i' || v == 'o' || v == 'u' {\n \
    \               vowelsCount--\n            }\n        }\n    }\n    if vowelsCount\
    \ < 0 {\n        for _, v := range word {\n            if v == 'a' || v == 'e'\
    \ || v == 'i' || v == 'o' || v == 'u' {\n                vowelsCount++\n     \
    \       }\n        }\n    }\n    if vowelsCount == 0 {\n        return \"\"\n\
    \    }\n    if vowelsCount == 1 {\n        return word[vowelsCount:]\n    }\n\
    \    if vowelsCount == 2 {\n        return word[vowelsCount-1:vowelsCount+1]\n\
    \    }\n    if vowelsCount == 3 {\n        return word[vowelsCount-2:vowelsCount+2]\n\
    \    }\n    if vowelsCount == 4 {\n        return word[vowelsCount-3:vowelsCount+3]\n\
    \    }\n    if vowelsCount == 5 {\n        return word[vowelsCount-4:vowelsCount+4]\n\
    \    }\n    if vowelsCount == 6 {\n        return word[vowelsCount-5:vowelsCount+5]\n\
    \    }\n    if vowelsCount == 7 {\n        return word[vowelsCount-6:vowelsCount+6]\n\
    \    }\n    if vowelsCount == 8 {\n        return word[vowelsCount-7:vowelsCount+7]\n\
    \    }\n    if vowelsCount == 9 {\n        return word[vowelsCount-8:vowelsCount+8]\n\
    \    }\n    if vowelsCount == 10 {\n        return word[vowelsCount-9:vowelsCount+9]\n\
    \    }\n    if vowelsCount == 11 {\n        return word[vowelsCount-10:vowelsCount+10]\n\
    \    }\n    if vowelsCount == 12 {\n        return word[vowelsCount-11:vowelsCount+11]\n\
    \    }\n    if vowelsCount == 13 {\n        return word[vowelsCount-12:vowelsCount+12]\n\
    \    }\n    if vowelsCount == 14 {\n        return word[vowelsCount-13:vowelsCount+13]\n\
    \    }\n    if vowels\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpqltw6xf2_test.go:91:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074787
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphy7oiqg__test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpjcv4si1u_test.go:100:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074643
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)/2\n\
    \    vowelsCount += len(vowels)/3\n    vowelsCount += len(vowels)/4\n    vowelsCount\
    \ += len(vowels)/5\n    vowelsCount += len(vowels)/6\n    vowelsCount += len(vowels)/7\n\
    \    vowelsCount += len(vowels)/8\n    vowelsCount += len(vowels)/9\n    vowelsCount\
    \ += len(vowels)/10\n    vowelsCount += len(vowels)/11\n    vowelsCount += len(vowels)/12\n\
    \    vowelsCount += len(vowels)/13\n    vowelsCount += len(vowels)/14\n    vowelsCount\
    \ += len(vowels)/15\n    vowelsCount += len(vowels)/16\n    vowelsCount += len(vowels)/17\n\
    \    vowelsCount += len(vowels)/18\n    vowelsCount += len(vowels)/19\n    vowelsCount\
    \ += len(vowels)/20\n    vowelsCount += len(vowels)/21\n    vowelsCount += len(vowels)/22\n\
    \    vowelsCount += len(vowels)/23\n    vowelsCount += len(vowels)/24\n    vowelsCount\
    \ += len(vowels)/25\n    vowelsCount += len(vowels)/26\n    vowelsCount += len(vowels)/27\n\
    \    vowelsCount += len(vowels)/28\n    vowelsCount += len(vowels)/29\n    vowelsCount\
    \ += len(vowels)/30\n    vowelsCount += len(vowels)/31\n    vowelsCount += len(vowels)/32\n\
    \    vowelsCount += len(vowels)/33\n    vowelsCount += len(vowels)/34\n    vowelsCount\
    \ += len(vowels)/35\n    vowelsCount += len(vowels)/36\n    vowelsCount += len(vowels)/37\n\
    \    vowelsCount += len(vowels)/38\n    vowelsCount += len(vowels)/39\n    vowelsCount\
    \ += len(vowels)/40\n    vowelsCount += len(vowels)/41\n    vowelsCount += len(vowels)/42\n\
    \    vowelsCount += len(vowels)/43\n    vowelsCount += len(vowels)/44\n    vowelsCount\
    \ += len(vowels)/45\n    vowelsCount += len(vowels)/46\n    vowelsCount += len(vowels)/47\n\
    \    vowelsCount += len(vowels)/48\n    vowelsCount += len(vowels)/49\n    vowels\n\
    func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpt9m6ef6a_test.go:75:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphy7oiqg__test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpyvyobif7_test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels) - len(strings.Split(word,\
    \ \"\")) - 1 // count vowels\n    vowelsCount += len(strings.Split(word, \"a\"\
    )) - 1 // count vowels in a\n    vowelsCount += len(strings.Split(word, \"e\"\
    )) - 1 // count vowels in e\n    vowelsCount += len(strings.Split(word, \"i\"\
    )) - 1 // count vowels in i\n    vowelsCount += len(strings.Split(word, \"o\"\
    )) - 1 // count vowels in o\n    vowelsCount += len(strings.Split(word, \"u\"\
    )) - 1 // count vowels in u\n    vowelsCount += len(strings.Split(word, \"A\"\
    )) - 1 // count vowels in A\n    vowelsCount += len(strings.Split(word, \"E\"\
    )) - 1 // count vowels in E\n    vowelsCount += len(strings.Split(word, \"I\"\
    )) - 1 // count vowels in I\n    vowelsCount += len(strings.Split(word, \"O\"\
    )) - 1 // count vowels in O\n    vowelsCount += len(strings.Split(word, \"U\"\
    )) - 1 // count vowels in U\n    vowelsCount += len(strings.Split(word, \"a\"\
    )) - 1 // count vowels in a\n    vowelsCount += len(strings.Split(word, \"e\"\
    )) - 1 // count vowels in e\n    vowelsCount += len(strings.Split(word, \"i\"\
    )) - 1 // count vowels in i\n    vowelsCount += len(strings.Split(word, \"o\"\
    )) - 1 // count vowels in o\n    vowelsCount += len(strings.Split(word, \"u\"\
    )) - 1 // count vowels in u\n    vowelsCount += len(strings.Split(word, \"A\"\
    )) - 1 // count vowels in A\n    vowelsCount += len(strings.Split(word, \"E\"\
    )) - 1 // count vowels in E\n    vowelsCount += len(strings.Split(word, \"I\"\
    )) - 1 // count vowels in I\n    vowelsCount += len(strings.Split(word, \"O\"\
    )) - 1 // count vowels in O\n    vowelsCount += len(strings.Split(word, \"U\"\
    )) - 1 // count vowels in U\n    vowelsCount += len(strings.Split(word, \"a\"\
    )) - 1 // count vowels in a\n    vowelsCount += len(strings.Split(word, \"e\"\
    )) - 1 // count vowels in e\n    vowelsCount += len(strings.Split(word, \"i\"\
    )) - 1 // count vowels in i\n    vowelsCount += len(strings.Split(word, \"o\n\
    func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpv6ujkyjw_test.go:49:44: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074787
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // Your code here\n    vowels := []string{\"a\", \"e\"\
    , \"i\", \"o\", \"u\"}\n    vowelsLen := len(vowels)\n    vowelsLen -= 1\n   \
    \ vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n\
    \    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen +=\
    \ 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpcrxfsrki_test.go:101:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074788
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)/2\n\
    \    vowelsCount += len(vowels)/3\n    vowelsCount += len(vowels)/4\n    vowelsCount\
    \ += len(vowels)/5\n    vowelsCount += len(vowels)/6\n    vowelsCount += len(vowels)/7\n\
    \    vowelsCount += len(vowels)/8\n    vowelsCount += len(vowels)/9\n    vowelsCount\
    \ += len(vowels)/10\n    vowelsCount += len(vowels)/11\n    vowelsCount += len(vowels)/12\n\
    \    vowelsCount += len(vowels)/13\n    vowelsCount += len(vowels)/14\n    vowelsCount\
    \ += len(vowels)/15\n    vowelsCount += len(vowels)/16\n    vowelsCount += len(vowels)/17\n\
    \    vowelsCount += len(vowels)/18\n    vowelsCount += len(vowels)/19\n    vowelsCount\
    \ += len(vowels)/20\n    vowelsCount += len(vowels)/21\n    vowelsCount += len(vowels)/22\n\
    \    vowelsCount += len(vowels)/23\n    vowelsCount += len(vowels)/24\n    vowelsCount\
    \ += len(vowels)/25\n    vowelsCount += len(vowels)/26\n    vowelsCount += len(vowels)/27\n\
    \    vowelsCount += len(vowels)/28\n    vowelsCount += len(vowels)/29\n    vowelsCount\
    \ += len(vowels)/30\n    vowelsCount += len(vowels)/31\n    vowelsCount += len(vowels)/32\n\
    \    vowelsCount += len(vowels)/33\n    vowelsCount += len(vowels)/34\n    vowelsCount\
    \ += len(vowels)/35\n    vowelsCount += len(vowels)/36\n    vowelsCount += len(vowels)/37\n\
    \    vowelsCount += len(vowels)/38\n    vowelsCount += len(vowels)/39\n    vowelsCount\
    \ += len(vowels)/40\n    vowelsCount += len(vowels)/41\n    vowelsCount += len(vowels)/42\n\
    \    vowelsCount += len(vowels)/43\n    vowelsCount += len(vowels)/44\n    vowelsCount\
    \ += len(vowels)/45\n    vowelsCount += len(vowels)/46\n    vowelsCount += len(vowels)/47\n\
    \    vowelsCount += len(vowels)/48\n    vowelsCount += len(vowels)/49\n    vowels\n\
    func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpt9m6ef6a_test.go:75:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []rune(\"aeiou\")\n    vowelsLen := len(vowels)\n\
    \    \n    index := len(word) - 1\n    \n    // find the first consonant from\
    \ the right\n    for index >= 0 && word[index] != 'a' {\n        index--\n   \
    \ }\n    \n    // find the first vowel from the right\n    for index >= 0 && word[index]\
    \ != 'a' && word[index] != 'e' && word[index] != 'i' && word[index] != 'o' &&\
    \ word[index] != 'u' {\n        index--\n    }\n    \n    // find the first vowel\
    \ from the left\n    for index < 0 && word[index] != 'a' && word[index] != 'e'\
    \ && word[index] != 'i' && word[index] != 'o' && word[index] != 'u' {\n      \
    \  index++\n    }\n    \n    // find the first vowel from the left\n    for index\
    \ < 0 && word[index] != 'a' && word[index] != 'e' && word[index] != 'i' && word[index]\
    \ != 'o' && word[index] != 'u' {\n        index++\n    }\n    \n    // find the\
    \ first vowel from the left\n    for index < 0 && word[index] != 'a' && word[index]\
    \ != 'e' && word[index] != 'i' && word[index] != 'o' && word[index] != 'u' {\n\
    \        index++\n    }\n    \n    // find the first vowel from the left\n   \
    \ for index < 0 && word[index] != 'a' && word[index] != 'e' && word[index] !=\
    \ 'i' && word[index] != 'o' && word[index] != 'u' {\n        index++\n    }\n\
    \    \n    // find the first vowel from the left\n    for index < 0 && word[index]\
    \ != 'a' && word[index] != 'e' && word[index] != 'i' && word[index] != 'o' &&\
    \ word[index] != 'u' {\n        index++\n    }\n    \n    // find the first vowel\
    \ from the left\n    for index < 0 && word[index] != 'a' && word[index] != 'e'\
    \ && word[index] != 'i' && word[index] != 'o' && word[index] != 'u' {\n      \
    \  index++\n    }\n    \n    // find the first vowel from the left\n    for index\
    \ < 0 && word[index] != 'a' && word[index] != 'e' && word[index] != 'i' && word[index]\
    \ != 'o' && word[index] != 'u' {\n        index++\n    }\n    \n    // find the\
    \ first vowel from the left\n    for index < 0 && word[index] != 'a' && word[index]\
    \ != 'e' && word[index] != 'i' && word[index] != 'o' && word[index] != 'u' {\n\
    \        index++\n    }\n    \n    // \nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp80lwk219_test.go:79:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074788
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    for _, v := range vowels {\n        if strings.Contains(word,\
    \ v) {\n            vowelsCount++\n        }\n    }\n    if vowelsCount == 0 {\n\
    \        return \"\"\n    }\n    vowelsCount -= 1\n    vowelsCount /= 2\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= 2\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= 2\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= 2\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= 2\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= 2\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= 2\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= 2\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= 2\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= 2\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= 2\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= 2\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= 2\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= 2\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= 2\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= 2\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= 2\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= 2\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= 2\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= 2\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmprihclev3_test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074788
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpjcv4si1u_test.go:100:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074643
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for _, v := range vowels\
    \ {\n        if word == v {\n            return v\n        }\n    }\n    for i\
    \ := len(word) - 1; i >= 0; i-- {\n        if word[i] == word[len(word)-1] {\n\
    \            return word[len(word)-1]\n        }\n    }\n    return \"\"\n}\n\n\
    func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpk18s74u4_test.go:33:20: cannot use word[len(word) - 1] (value of type
    byte) as type string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074645
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpyvyobif7_test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowel := []rune{'a', 'e', 'i', 'o', 'u'}\n    vowel_count\
    \ := 0\n    index := len(word) - 1\n    for i := 0; i < len(word); i++ {\n   \
    \     if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o'\
    \ || word[i] == 'u' {\n            vowel_count++\n        }\n        if word[i]\
    \ == 'y' && word[i+1] == 'g' && word[i+2] == 'r' && word[i+3] == 't' {\n     \
    \       vowel_count++\n        }\n        if word[i] == 'f' && word[i+1] == 'l'\
    \ && word[i+2] == 'u' && word[i+3] == 'r' && word[i+4] == 'l' {\n            vowel_count++\n\
    \        }\n        if word[i] == 'q' && word[i+1] == 'u' && word[i+2] == 'i'\
    \ && word[i+3] == 'c' && word[i+4] == 'k' {\n            vowel_count++\n     \
    \   }\n        if word[i] == 'a' && word[i+1] == 'b' {\n            vowel_count++\n\
    \        }\n        if word[i] == 'a' && word[i+1] == 'b' && word[i+2] == 'c'\
    \ {\n            vowel_count++\n        }\n        if word[i] == 'a' && word[i+1]\
    \ == 'b' && word[i+2] == 'c' && word[i+3] == 'd' {\n            vowel_count++\n\
    \        }\n        if word[i] == 'a' && word[i+1] == 'b' && word[i+2] == 'c'\
    \ && word[i+3] == 'd' && word[i+4] == 'e' {\n            vowel_count++\n     \
    \   }\n        if word[i] == 'a' && word[i+1] == 'b' && word[i+2] == 'c' && word[i+3]\
    \ == 'd' && word[i+4] == 'e' && word[i+5] == 'f' {\n            vowel_count++\n\
    \        }\n        if word[i] == 'a' && word[i+1] == 'b' && word[i+2] == 'c'\
    \ && word[i+3] == 'd' && word[i+4] == 'e' && word[i+5] == 'f' && word[i+6] ==\
    \ 'g' {\n            vowel_count++\n        }\n        if word[i] == 'a' && word[i+1]\
    \ == 'b' && word[i+2] == 'c' && word[i+3] == 'd' && word[i+4] == 'e' && word[i+5]\
    \ == 'f' && word[i+6] == 'g' && word[i+7] == 'h' {\n            vowel_count++\n\
    \        }\n        if word[i] == 'a' && word[i+1] == 'b' && word[i+2] == 'c'\
    \ && word[i+3] == 'd' && word[i+4] == 'e' && word[i+5] == 'f' && word[i+6] ==\
    \ 'g' && word[i+7] == 'h' && word[i+8] == 'i' {\n            vowel_count++\n \
    \       }\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpt8lzg_q9_test.go:63:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074788
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpw4oq0vvz_test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphy7oiqg__test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    \n\
    \    i := len(word) - 1\n    \n    for i >= 0 {\n        if word[i] == 'a' ||\
    \ word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n   \
    \         i -= 1\n        } else {\n            i -= 1\n        }\n    }\n   \
    \ \n    for i >= 0 {\n        if word[i] == 'a' || word[i] == 'e' || word[i] ==\
    \ 'i' || word[i] == 'o' || word[i] == 'u' {\n            i -= 1\n        } else\
    \ {\n            i -= 1\n        }\n    }\n    \n    for i >= 0 {\n        if\
    \ word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i]\
    \ == 'u' {\n            i -= 1\n        } else {\n            i -= 1\n       \
    \ }\n    }\n    \n    for i >= 0 {\n        if word[i] == 'a' || word[i] == 'e'\
    \ || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n            i -= 1\n\
    \        } else {\n            i -= 1\n        }\n    }\n    \n    for i >= 0\
    \ {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i]\
    \ == 'o' || word[i] == 'u' {\n            i -= 1\n        } else {\n         \
    \   i -= 1\n        }\n    }\n    \n    for i >= 0 {\n        if word[i] == 'a'\
    \ || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n\
    \            i -= 1\n        } else {\n            i -= 1\n        }\n    }\n\
    \    \n    for i >= 0 {\n        if word[i] == 'a' || word[i] == 'e' || word[i]\
    \ == 'i' || word[i] == 'o' || word[i] == 'u' {\n            i -= 1\n        }\
    \ else {\n            i -= 1\n        }\n    }\n    \n    for i >= 0 {\n     \
    \   if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' ||\
    \ word[i] == 'u' {\n            i -= 1\n        } else {\n            i -= 1\n\
    \        }\n    }\n    \n    for i >= 0 {\n        if word[i] == 'a' || word[i]\
    \ == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n           \
    \ i -= 1\n        } else {\n            i -= 1\n        }\n    }\n    \n    for\
    \ i >= 0 {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i]\
    \ == 'o' || word[i] == 'u' \nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp73_awoc3_test.go:104:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074788
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []rune(\"aeiouAEIOU\")\n    vowelsLen := len(vowels)\n\
    \    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen -=\
    \ 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpz7qkq05y_test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074642
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []rune(\"aeiouAEIOU\")\n    vowelsLen := len(vowels)\n\
    \    vowelsLen -= 1\n    i := len(word) - 1\n    j := len(word) - 2\n    k :=\
    \ len(word) - 3\n    l := len(word) - 4\n    m := len(word) - 5\n    n := len(word)\
    \ - 6\n    o := len(word) - 7\n    p := len(word) - 8\n    q := len(word) - 9\n\
    \    r := len(word) - 10\n    s := len(word) - 11\n    t := len(word) - 12\n \
    \   u := len(word) - 13\n    v := len(word) - 14\n    w := len(word) - 15\n  \
    \  x := len(word) - 16\n    y := len(word) - 17\n    z := len(word) - 18\n   \
    \ \n    if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o'\
    \ || word[i] == 'u' || word[i] == 'y' {\n        return word[i]\n    }\n    if\
    \ word[j] == 'a' || word[j] == 'e' || word[j] == 'i' || word[j] == 'o' || word[j]\
    \ == 'u' || word[j] == 'y' {\n        return word[j]\n    }\n    if word[k] ==\
    \ 'a' || word[k] == 'e' || word[k] == 'i' || word[k] == 'o' || word[k] == 'u'\
    \ || word[k] == 'y' {\n        return word[k]\n    }\n    if word[l] == 'a' ||\
    \ word[l] == 'e' || word[l] == 'i' || word[l] == 'o' || word[l] == 'u' || word[l]\
    \ == 'y' {\n        return word[l]\n    }\n    if word[m] == 'a' || word[m] ==\
    \ 'e' || word[m] == 'i' || word[m] == 'o' || word[m] == 'u' || word[m] == 'y'\
    \ {\n        return word[m]\n    }\n    if word[n] == 'a' || word[n] == 'e' ||\
    \ word[n] == 'i' || word[n] == 'o' || word[n] == 'u' || word[n] == 'y' {\n   \
    \     return word[n]\n    }\n    if word[o] == 'a' || word[o] == 'e' || word[o]\
    \ == 'i' || word[o] == 'o' || word[o] == 'u' || word[o] == 'y' {\n        return\
    \ word[o]\n    }\n    if word[p] == 'a' || word[p] == 'e' || word[p] == 'i' ||\
    \ word[p] == 'o' || word[p] == 'u' || word[p] == 'y' {\n        return word[p]\n\
    \    }\n    if word[q] == 'a' || word[q] == 'e' || word[q] == 'i' || word\nfunc\
    \ TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpon1ffphh_test.go:70:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074788
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []rune(\"aeiou\")\n    vowelsLen := len(vowels)\n\
    \    vowelsLen -= 1\n    vowelsLen += 2\n    i := 0\n    j := len(word) - 1\n\
    \    k := 0\n    vowel := \"\"\n    vowelLen := 0\n    vowelFound = false\n  \
    \  vowelFound := false\n    for i < j {\n        if word[i] == 'a' || word[i]\
    \ == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n           \
    \ vowelFound = true\n            vowel = word[i]\n            vowelLen = 1\n \
    \       }\n        if word[i] == 'y' {\n            vowelFound = false\n     \
    \       vowel = word[i]\n            vowelLen = 1\n        }\n        if word[i]\
    \ == 'u' {\n            vowelFound = false\n            vowel = word[i]\n    \
    \        vowelLen = 1\n        }\n        if word[i] == 'o' {\n            vowelFound\
    \ = false\n            vowel = word[i]\n            vowelLen = 1\n        }\n\
    \        if word[i] == 'e' {\n            vowelFound = false\n            vowel\
    \ = word[i]\n            vowelLen = 1\n        }\n        if word[i] == 'a' {\n\
    \            vowelFound = false\n            vowel = word[i]\n            vowelLen\
    \ = 1\n        }\n        if word[i] == 'i' {\n            vowelFound = false\n\
    \            vowel = word[i]\n            vowelLen = 1\n        }\n        if\
    \ word[i] == 'u' {\n            vowelFound = false\n            vowel = word[i]\n\
    \            vowelLen = 1\n        }\n        if word[i] == 'e' {\n          \
    \  vowelFound = false\n            vowel = word[i]\n            vowelLen = 1\n\
    \        }\n        if word[i] == 'o' {\n            vowelFound = false\n    \
    \        vowel = word[i]\n            vowelLen = 1\n        }\n        if word[i]\
    \ == 'i' {\n            vowelFound = false\n            vowel = word[i]\n    \
    \        vowelLen = 1\n        }\n        if word[i] == 'a' {\n            vowelFound\
    \ = false\n            vowel = word[i]\n            vowelLen = 1\n        }\n\
    \        if word[i] == 'e' {\n            vowelFound = false\n            vowel\
    \ = word[i]\n            vowelLen = 1\n        }\n        if word[i] == 'i' {\n\
    \            vowelFound = false\n            vowel = word[i]\n            vowelLen\
    \ = 1\n        }\n        if word[i] == 'o' {\n            vowelFound = false\n\
    \            vowel = word[i]\n            vowelLen = 1\n        }\n        if\
    \ word[i] == 'u' {\n            vowelFound = false\n            vowel = word[i]\n\
    \            vowelLen = 1\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpki7lur0t_test.go:114:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074788
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphy7oiqg__test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for _, v := range vowels\
    \ {\n        if word == v {\n            return v\n        }\n    }\n    for i\
    \ := len(word) - 2; i >= 0; i-- {\n        if word[i] == word[i+1] {\n       \
    \     if word[i] == \"a\" || word[i] == \"e\" || word[i] == \"i\" || word[i] ==\
    \ \"o\" || word[i] == \"u\" {\n                return word[i]\n            }\n\
    \        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3gds1bhp_test.go:33:27: invalid operation: word[i] == "a" (mismatched
    types byte and untyped string)

    /tmp/tmp3gds1bhp_test.go:33:45: invalid operation: word[i] == "e" (mismatched
    types byte and untyped string)

    /tmp/tmp3gds1bhp_test.go:33:63: invalid operation: word[i] == "i" (mismatched
    types byte and untyped string)

    /tmp/tmp3gds1bhp_test.go:33:81: invalid operation: word[i] == "o" (mismatched
    types byte and untyped string)

    /tmp/tmp3gds1bhp_test.go:33:99: invalid operation: word[i] == "u" (mismatched
    types byte and untyped string)

    /tmp/tmp3gds1bhp_test.go:34:24: cannot use word[i] (value of type byte) as type
    string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074787
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowel := \"AEIOUaeiou\"\n    vowel_count := 0\n    vowel_count\
    \ := strings.Count(word, vowel)\n    if vowel_count > 0 {\n        vowel_count\
    \ -= 2\n    }\n    if vowel_count < 0 {\n        vowel_count += 2\n    }\n   \
    \ if vowel_count > len(word) {\n        return \"\"\n    }\n    vowel_count -=\
    \ len(word) - vowel_count\n    vowel_count -= len(word) - vowel_count\n    vowel_count\
    \ -= len(word) - vowel_count\n    vowel_count -= len(word) - vowel_count\n   \
    \ vowel_count -= len(word) - vowel_count\n    vowel_count -= len(word) - vowel_count\n\
    \    vowel_count -= len(word) - vowel_count\n    vowel_count -= len(word) - vowel_count\n\
    \    vowel_count -= len(word) - vowel_count\n    vowel_count -= len(word) - vowel_count\n\
    \    vowel_count -= len(word) - vowel_count\n    vowel_count -= len(word) - vowel_count\n\
    \    vowel_count -= len(word) - vowel_count\n    vowel_count -= len(word) - vowel_count\n\
    \    vowel_count -= len(word) - vowel_count\n    vowel_count -= len(word) - vowel_count\n\
    \    vowel_count -= len(word) - vowel_count\n    vowel_count -= len(word) - vowel_count\n\
    \    vowel_count -= len(word) - vowel_count\n    vowel_count -= len(word) - vowel_count\n\
    \    vowel_count -= len(word) - vowel_count\n    vowel_count -= len(word) - vowel_count\n\
    \    vowel_count -= len(word) - vowel_count\n    vowel_count -= len(word) - vowel_count\n\
    \    vowel_count -= len(word) - vowel_count\n    vowel_count -= len(word) - vowel_count\n\
    \    vowel_count -= len(word) - vowel_count\n    vowel_count -= len(word) - vowel_count\n\
    \    vowel_count -= len(word) - vowel_count\n    vowel_count -= len(word) - vowel_count\n\
    \    vowel_count -= len(word) - vowel_count\n    vowel_count -= len(word) - vowel_count\n\
    \    vowel_count -= len(word) - vowel_count\n    vowel_count -= len(word) - vowel_count\n\
    \    vowel_count -= len(word) - vowel_count\n    vowel_count -= len(word) - vowel_count\n\
    \    vowel_count -= len(word) - vowel_count\n    vowel_count -= len(word) - vowel_count\n\
    \    vowel_count -= len(word) - vowel_count\n    vowel_count -= len(word\nfunc\
    \ TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp28x5bndd_test.go:74:28: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074788
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels) - len(strings.Split(word,\
    \ \"e\"))\n    vowelsCount += len(vowels) - len(strings.Split(word, \"i\"))\n\
    \    vowelsCount += len(vowels) - len(strings.Split(word, \"o\"))\n    vowelsCount\
    \ += len(vowels) - len(strings.Split(word, \"u\"))\n    vowelsCount += len(strings.Split(word,\
    \ \"a\"))\n    vowelsCount += len(strings.Split(word, \"e\"))\n    vowelsCount\
    \ += len(strings.Split(word, \"i\"))\n    vowelsCount += len(strings.Split(word,\
    \ \"o\"))\n    vowelsCount += len(strings.Split(word, \"u\"))\n    vowelsCount\
    \ += len(strings.Split(word, \"A\"))\n    vowelsCount += len(strings.Split(word,\
    \ \"E\"))\n    vowelsCount += len(strings.Split(word, \"I\"))\n    vowelsCount\
    \ += len(strings.Split(word, \"O\"))\n    vowelsCount += len(strings.Split(word,\
    \ \"U\"))\n    vowelsCount += len(strings.Split(word, \"a\"))\n    vowelsCount\
    \ += len(strings.Split(word, \"e\"))\n    vowelsCount += len(strings.Split(word,\
    \ \"i\"))\n    vowelsCount += len(strings.Split(word, \"o\"))\n    vowelsCount\
    \ += len(strings.Split(word, \"u\"))\n    vowelsCount += len(strings.Split(word,\
    \ \"A\"))\n    vowelsCount += len(strings.Split(word, \"E\"))\n    vowelsCount\
    \ += len(strings.Split(word, \"I\"))\n    vowelsCount += len(strings.Split(word,\
    \ \"O\"))\n    vowelsCount += len(strings.Split(word, \"U\"))\n    vowelsCount\
    \ += len(strings.Split(word, \"a\"))\n    vowelsCount += len(strings.Split(word,\
    \ \"e\"))\n    vowelsCount += len(strings.Split(word, \"i\"))\n    vowelsCount\
    \ += len(strings.Split(word, \"o\"))\n    vowelsCount += len(strings.Split(word,\
    \ \"u\"))\n    vowelsCount += len(strings.Split(word, \"A\"))\n    vowelsCount\
    \ += len(strings.Split(word, \"E\"))\n    vowelsCount += len(strings.Split(word,\
    \ \"I\"))\n    vowelsCount += len(strings.Split(word, \"O\"))\n    vowelsCount\
    \ += len(strings.Split(word, \"U\"))\n    vowelsCount += len(strings.Split(word,\
    \ \"a\"))\n    vowelsCount += len(strings.Split(word, \"e\"))\n    vowelsCount\
    \ += len(strings.Split(\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp3bhfndji_test.go:62:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074788
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    for _, v := range vowels {\n        if strings.Contains(word,\
    \ v) {\n            vowelsCount++\n        }\n    }\n    if vowelsCount <= 1 {\n\
    \        return \"\"\n    }\n    vowelsCount -= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowels\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpdk2msovl_test.go:98:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074788
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphy7oiqg__test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []rune(\"aeiouAEIOU\")\n    vowelsLen := len(vowels)\n\
    \    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen +=\
    \ 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen\
    \ += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen\
    \ += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen\
    \ += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen\
    \ += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen\
    \ += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen\
    \ += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen\
    \ += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen\
    \ += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen\
    \ += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen\
    \ += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen\
    \ += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen\
    \ += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen\
    \ += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen\
    \ += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen\
    \ += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen\
    \ += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen\
    \ += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    \nfunc\
    \ TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpm0bda5kr_test.go:101:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074788
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)/2\n\
    \    vowelsCount += len(vowels)/3\n    vowelsCount += len(vowels)/4\n    vowelsCount\
    \ += len(vowels)/5\n    vowelsCount += len(vowels)/6\n    vowelsCount += len(vowels)/7\n\
    \    vowelsCount += len(vowels)/8\n    vowelsCount += len(vowels)/9\n    vowelsCount\
    \ += len(vowels)/10\n    vowelsCount += len(vowels)/11\n    vowelsCount += len(vowels)/12\n\
    \    vowelsCount += len(vowels)/13\n    vowelsCount += len(vowels)/14\n    vowelsCount\
    \ += len(vowels)/15\n    vowelsCount += len(vowels)/16\n    vowelsCount += len(vowels)/17\n\
    \    vowelsCount += len(vowels)/18\n    vowelsCount += len(vowels)/19\n    vowelsCount\
    \ += len(vowels)/20\n    vowelsCount += len(vowels)/21\n    vowelsCount += len(vowels)/22\n\
    \    vowelsCount += len(vowels)/23\n    vowelsCount += len(vowels)/24\n    vowelsCount\
    \ += len(vowels)/25\n    vowelsCount += len(vowels)/26\n    vowelsCount += len(vowels)/27\n\
    \    vowelsCount += len(vowels)/28\n    vowelsCount += len(vowels)/29\n    vowelsCount\
    \ += len(vowels)/30\n    vowelsCount += len(vowels)/31\n    vowelsCount += len(vowels)/32\n\
    \    vowelsCount += len(vowels)/33\n    vowelsCount += len(vowels)/34\n    vowelsCount\
    \ += len(vowels)/35\n    vowelsCount += len(vowels)/36\n    vowelsCount += len(vowels)/37\n\
    \    vowelsCount += len(vowels)/38\n    vowelsCount += len(vowels)/39\n    vowelsCount\
    \ += len(vowels)/40\n    vowelsCount += len(vowels)/41\n    vowelsCount += len(vowels)/42\n\
    \    vowelsCount += len(vowels)/43\n    vowelsCount += len(vowels)/44\n    vowelsCount\
    \ += len(vowels)/45\n    vowelsCount += len(vowels)/46\n    vowelsCount += len(vowels)/47\n\
    \    vowelsCount += len(vowels)/48\n    vowelsCount += len(vowels)/49\n    vowels\n\
    func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpt9m6ef6a_test.go:75:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphopteei4_test.go:87:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074642
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for _, v := range vowels\
    \ {\n        if word == v {\n            return v\n        }\n    }\n    for i\
    \ := len(word) - 1; i >= 0; i-- {\n        if word[i] == word[len(word)-1] {\n\
    \            return word[i]\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpaisteg3t_test.go:33:20: cannot use word[i] (value of type byte) as type
    string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074641
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    \n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen += 1\n   \
    \ \n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    \n    vowelsLen\
    \ -= 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    \n    vowelsLen -= 1\n   \
    \ vowelsLen /= 2\n    vowelsLen += 1\n    \n    vowelsLen -= 1\n    vowelsLen\
    \ /= 2\n    vowelsLen += 1\n    \n    vowelsLen -= 1\n    vowelsLen /= 2\n   \
    \ vowelsLen += 1\n    \n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    \n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen += 1\n   \
    \ \n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    \n    vowelsLen\
    \ -= 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    \n    vowelsLen -= 1\n   \
    \ vowelsLen /= 2\n    vowelsLen += 1\n    \n    vowelsLen -= 1\n    vowelsLen\
    \ /= 2\n    vowelsLen += 1\n    \n    vowelsLen -= 1\n    vowelsLen /= 2\n   \
    \ vowelsLen += 1\n    \n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    \n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen += 1\n   \
    \ \n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    \n    vowelsLen\
    \ -= 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    \n    vowelsLen -= 1\n   \
    \ vowelsLen /= 2\n    vowelsLen += 1\n    \n    vowelsLen -= 1\n    vowelsLen\
    \ /= 2\n    vowelsLen += 1\n    \n    vowelsLen -= 1\n    vowelsLen /= 2\n   \
    \ vowelsLen += 1\n    \n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    \n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen += 1\n   \
    \ \n    vowels\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmppqod9zzc_test.go:118:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowel := []rune(\"aeiou\")\n    vowelLen := len(vowel)\n\
    \    vowelPos := 0\n    vowelLen -= len(word) % vowelLen\n    \n    for i := 0;\
    \ i < len(word); i++ {\n        if word[i] == 'a' || word[i] == 'e' || word[i]\
    \ == 'i' || word[i] == 'o' || word[i] == 'u' {\n            vowelPos = i\n   \
    \         break\n        }\n    }\n    \n    if vowelPos == 0 {\n        return\
    \ \"\"\n    }\n    \n    i := 0\n    j := len(word) - 1\n    \n    for ; i < j;\
    \ i, j = i+1, j-1 {\n        if word[i] == 'a' || word[i] == 'e' || word[i] ==\
    \ 'i' || word[i] == 'o' || word[i] == 'u' {\n            if j-i < vowelLen {\n\
    \                vowelPos = j\n                break\n            }\n        }\n\
    \    }\n    \n    if j-i < vowelLen {\n        return \"\"\n    }\n    \n    for\
    \ ; i < j; i++ {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i'\
    \ || word[i] == 'o' || word[i] == 'u' {\n            if j-i < vowelLen {\n   \
    \             vowelPos = j\n                break\n            }\n        }\n\
    \    }\n    \n    return string(vowel[vowelPos:vowelPos+vowelLen])\n}\n\nfunc\
    \ TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmpvj7j0i1i_test.go:92: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmpvj7j0i1i_test.go:92: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmpvj7j0i1i_test.go:92: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmpvj7j0i1i_test.go:92: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmpvj7j0i1i_test.go:92:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpvj7j0i1i_test.go:92: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074789
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphy7oiqg__test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphy7oiqg__test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    for _, v := range vowels {\n        if strings.Contains(word,\
    \ v) {\n            vowelsCount++\n        }\n    }\n    if vowelsCount == 0 {\n\
    \        return \"\"\n    }\n    vowelsCount -= 1\n    lastConsonant := strings.LastIndex(word,\
    \ \"c\")\n    if lastConsonant == -1 {\n        return \"\"\n    }\n    lastConsonant++\n\
    \    lastConsonantIndex := strings.LastIndex(word[lastConsonant:], \"c\")\n  \
    \  if lastConsonantIndex == -1 {\n        return \"\"\n    }\n    lastConsonantIndex++\n\
    \    lastConsonantIndexIndex := strings.LastIndex(word[lastConsonantIndex:], \"\
    c\")\n    if lastConsonantIndexIndex == -1 {\n        return \"\"\n    }\n   \
    \ lastConsonantIndexIndex++\n    lastConsonantIndexIndexIndex := strings.LastIndex(word[lastConsonantIndexIndex:],\
    \ \"c\")\n    if lastConsonantIndexIndexIndex == -1 {\n        return \"\"\n \
    \   }\n    lastConsonantIndexIndexIndex++\n    lastConsonantIndexIndexIndexIndex\
    \ := strings.LastIndex(word[lastConsonantIndexIndexIndex:], \"c\")\n    if lastConsonantIndexIndexIndexIndex\
    \ == -1 {\n        return \"\"\n    }\n    lastConsonantIndexIndexIndexIndex++\n\
    \    lastConsonantIndexIndexIndexIndexIndex := strings.LastIndex(word[lastConsonantIndexIndexIndexIndex:],\
    \ \"c\")\n    if lastConsonantIndexIndexIndexIndex == -1 {\n        return \"\"\
    \n    }\n    lastConsonantIndexIndexIndexIndexIndex++\n    lastConsonantIndexIndexIndexIndexIndexIndex\
    \ := strings.LastIndex(word[lastConsonantIndexIndexIndexIndexIndex:], \"c\")\n\
    \    if lastConsonantIndexIndexIndexIndexIndexIndex == -1 {\n        return \"\
    \"\n    }\n    lastConsonantIndexIndexIndexIndexIndexIndex++\n    lastConsonantIndexIndexIndexIndexIndexIndexIndexIndex\
    \ := strings.LastIndex(word[lastConsonantIndexIndexIndexIndexIndexIndex:], \"\
    c\")\n    if lastConsonantIndexIndexIndexIndexIndexIndexIndex == -1 {\n      \
    \  return \"\"\n    }\n    lastConsonantIndexIndexIndexIndexIndexIndexIndexIndex++\n\
    \    lastConsonantIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex := strings.LastIndex(word[lastConsonantIndexIndexIndexIndexIndexIndexIndex:],\
    \ \nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmprj1eeqr7_test.go:75:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074788
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []rune(\"aeiouy\")\n    vowelsLen := len(vowels)\n\
    \    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /=\
    \ 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen\
    \ /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen\
    \ /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen\
    \ /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen\
    \ /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen\
    \ /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen\
    \ /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen\
    \ /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen\
    \ /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen\
    \ /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen\
    \ /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen\
    \ /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen\
    \ /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen\
    \ /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen\
    \ /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen\
    \ /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen\
    \ /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowel\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvyp2uhb7_test.go:96:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074789
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphopteei4_test.go:87:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074642
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpyvyobif7_test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphy7oiqg__test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    for _, v := range vowels {\n        if word == v {\n\
    \            vowelsCount++\n        }\n    }\n    if vowelsCount == 0 {\n    \
    \    return \"\"\n    }\n    vowelsCount -= 1\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpmd4x1wcm_test.go:98:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []rune(\"aeiou\")\n    vowelsLen := len(vowels)\n\
    \    vowelsLen -= 1\n    vowelsLen += 1 // add one for \"e\"\n    vowelsLen +=\
    \ 1 // add one for \"i\"\n    vowelsLen += 1 // add one for \"o\"\n    vowelsLen\
    \ += 1 // add one for \"u\"\n    vowelsLen += 1 // add one for \"y\"\n    vowelsLen\
    \ += 1 // add one for \"g\"\n    vowelsLen += 1 // add one for \"r\"\n    vowelsLen\
    \ += 1 // add one for \"t\"\n    vowelsLen += 1 // add one for \"h\"\n    vowelsLen\
    \ += 1 // add one for \"l\"\n    vowelsLen += 1 // add one for \"s\"\n    vowelsLen\
    \ += 1 // add one for \"d\"\n    vowelsLen += 1 // add one for \"c\"\n    vowelsLen\
    \ += 1 // add one for \"k\"\n    vowelsLen += 1 // add one for \"m\"\n    vowelsLen\
    \ += 1 // add one for \"p\"\n    vowelsLen += 1 // add one for \"f\"\n    vowelsLen\
    \ += 1 // add one for \"v\"\n    vowelsLen += 1 // add one for \"b\"\n    vowelsLen\
    \ += 1 // add one for \"y\"\n    vowelsLen += 1 // add one for \"g\"\n    vowelsLen\
    \ += 1 // add one for \"r\"\n    vowelsLen += 1 // add one for \"t\"\n    vowelsLen\
    \ += 1 // add one for \"h\"\n    vowelsLen += 1 // add one for \"l\"\n    vowelsLen\
    \ += 1 // add one for \"s\"\n    vowelsLen += 1 // add one for \"d\"\n    vowelsLen\
    \ += 1 // add one for \"c\"\n    vowelsLen += 1 // add one for \"k\"\n    vowelsLen\
    \ += 1 // add one for \"m\"\n    vowelsLen += 1 // add one for \"p\"\n    vowelsLen\
    \ += 1 // add one for \"f\"\n    vowelsLen += 1 // add one for \"v\"\n    vowelsLen\
    \ += 1 // add one for \"b\"\n    vowelsLen += 1 // add one for \"y\"\n    vowelsLen\
    \ += 1 // add one for \"g\"\n    vowel\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp0yso2z5j_test.go:63:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074789
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []rune(\"aeiouAEIOU\")\n    vowelsLen := len(vowels)\n\
    \    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen +=\
    \ 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen\
    \ += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen\
    \ += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen\
    \ += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen\
    \ += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen\
    \ += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen\
    \ += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen\
    \ += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen\
    \ += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen\
    \ += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen\
    \ += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen\
    \ += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen\
    \ += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen\
    \ += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen\
    \ += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen\
    \ += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen\
    \ += 2\n    vowelsLen -= 2\n    vowelsLen += 2\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpmrd_kcr4_test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074789
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpyvyobif7_test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for _, v := range vowels\
    \ {\n        if word == v {\n            return v\n        }\n    }\n    for i\
    \ := len(word) - 1; i >= 0; i-- {\n        if word[i] == word[len(word)-1] {\n\
    \            return word[i]\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpaisteg3t_test.go:33:20: cannot use word[i] (value of type byte) as type
    string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074641
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    for _, v := range vowels {\n        if word == v {\n\
    \            vowelsCount++\n        }\n    }\n    if vowelsCount > 0 {\n     \
    \   return word\n    }\n    vowelsCount = 0\n    for i := len(word) - 1; i >=\
    \ 0; i-- {\n        if word[i] == word[len(word)-1] {\n            vowelsCount++\n\
    \        }\n    }\n    if vowelsCount > 0 {\n        return word\n    }\n    return\
    \ \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmpk3rvnp09_test.go:70: expected 'u', got 'yogurt'\n    ---\
    \ FAIL: TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmpk3rvnp09_test.go:70:\
    \ expected 'u', got 'full'\n    --- FAIL: TestGet_Closest_Vowel/test_num__2 (0.00s)\n\
    \        tmpk3rvnp09_test.go:70: expected '', got 'easy'\n    --- FAIL: TestGet_Closest_Vowel/test_num__3\
    \ (0.00s)\n        tmpk3rvnp09_test.go:70: expected '', got 'eAsy'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__4 (0.00s)\n        tmpk3rvnp09_test.go:70: expected\
    \ '', got 'ali'\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n   \
    \     tmpk3rvnp09_test.go:70: expected 'a', got 'bad'\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmpk3rvnp09_test.go:70: expected 'o', got 'most'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__7 (0.00s)\n        tmpk3rvnp09_test.go:70: expected\
    \ '', got 'ab'\n    --- FAIL: TestGet_Closest_Vowel/test_num__8 (0.00s)\n    \
    \    tmpk3rvnp09_test.go:70: expected '', got 'ba'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9\
    \ (0.00s)\n        tmpk3rvnp09_test.go:70: expected '', got 'quick'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmpk3rvnp09_test.go:70:\
    \ expected 'i', got 'anime'\n    --- FAIL: TestGet_Closest_Vowel/test_num__11\
    \ (0.00s)\n        tmpk3rvnp09_test.go:70: expected '', got 'Asia'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__12 (0.00s)\n        tmpk3rvnp09_test.go:70:\
    \ expected 'o', got 'Above'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074643
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6hf0nt82_test.go:100:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074641
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for _, v := range vowels\
    \ {\n        if word == v {\n            return v\n        }\n    }\n    for i\
    \ := len(word) - 2; i >= 0; i-- {\n        if word[i] == word[i+1] {\n       \
    \     vowelsCount++\n            if vowelsCount > len(vowels)-1 {\n          \
    \      return \"\"\n            }\n        }\n    }\n    return \"\"\n}\n\nfunc\
    \ TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmp3zeqfm_o_test.go:67: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmp3zeqfm_o_test.go:67: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmp3zeqfm_o_test.go:67: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmp3zeqfm_o_test.go:67: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmp3zeqfm_o_test.go:67:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmp3zeqfm_o_test.go:67: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074643
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    \n\
    \    i := len(word) - 1\n    j := len(word) - 2\n    \n    vowelsCount := 0\n\
    \    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' ||\
    \ word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n   \
    \         vowelsCount++\n        }\n    }\n    \n    for j := len(word) - 2; j\
    \ < len(word); j++ {\n        if word[j] == 'a' || word[j] == 'e' || word[j] ==\
    \ 'i' || word[j] == 'o' || word[j] == 'u' {\n            vowelsCount++\n     \
    \   }\n    }\n    \n    if vowelsCount > vowelsLen {\n        return \"\"\n  \
    \  }\n    \n    if vowelsCount < vowelsLen {\n        return \"\"\n    }\n   \
    \ \n    if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o'\
    \ || word[i] == 'u' {\n        return vowels[i]\n    }\n    \n    if word[j] ==\
    \ 'a' || word[j] == 'e' || word[j] == 'i' || word[j] == 'o' || word[j] == 'u'\
    \ {\n        return vowels[j]\n    }\n    \n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmp1_v9d171_test.go:89: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmp1_v9d171_test.go:89: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmp1_v9d171_test.go:89: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmp1_v9d171_test.go:89: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmp1_v9d171_test.go:89:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmp1_v9d171_test.go:89: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074790
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpjcv4si1u_test.go:100:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074643
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpyvyobif7_test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpyvyobif7_test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // Your code here\n    vowels := []string{\"a\", \"e\"\
    , \"i\", \"o\", \"u\"}\n    vowelsCount := 0\n    for _, v := range vowels {\n\
    \        if word == v {\n            vowelsCount++\n        }\n    }\n    if vowelsCount\
    \ > 0 {\n        return word\n    }\n    vowelsCount = 0\n    for i := len(word)\
    \ - 1; i >= 0; i-- {\n        if word[i] == word[len(word)-1] {\n            vowelsCount++\n\
    \        }\n    }\n    if vowelsCount > 0 {\n        return word\n    }\n    return\
    \ \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmpi74bvawn_test.go:71: expected 'u', got 'yogurt'\n    ---\
    \ FAIL: TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmpi74bvawn_test.go:71:\
    \ expected 'u', got 'full'\n    --- FAIL: TestGet_Closest_Vowel/test_num__2 (0.00s)\n\
    \        tmpi74bvawn_test.go:71: expected '', got 'easy'\n    --- FAIL: TestGet_Closest_Vowel/test_num__3\
    \ (0.00s)\n        tmpi74bvawn_test.go:71: expected '', got 'eAsy'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__4 (0.00s)\n        tmpi74bvawn_test.go:71: expected\
    \ '', got 'ali'\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n   \
    \     tmpi74bvawn_test.go:71: expected 'a', got 'bad'\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmpi74bvawn_test.go:71: expected 'o', got 'most'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__7 (0.00s)\n        tmpi74bvawn_test.go:71: expected\
    \ '', got 'ab'\n    --- FAIL: TestGet_Closest_Vowel/test_num__8 (0.00s)\n    \
    \    tmpi74bvawn_test.go:71: expected '', got 'ba'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9\
    \ (0.00s)\n        tmpi74bvawn_test.go:71: expected '', got 'quick'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmpi74bvawn_test.go:71:\
    \ expected 'i', got 'anime'\n    --- FAIL: TestGet_Closest_Vowel/test_num__11\
    \ (0.00s)\n        tmpi74bvawn_test.go:71: expected '', got 'Asia'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__12 (0.00s)\n        tmpi74bvawn_test.go:71:\
    \ expected 'o', got 'Above'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074790
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpjcv4si1u_test.go:100:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074643
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    for _, v := range vowels {\n        if strings.Contains(word,\
    \ v) {\n            vowelsCount++\n        }\n    }\n    if vowelsCount == 0 {\n\
    \        return \"\"\n    }\n    vowelsCount -= 1\n    vowelsCount /= 2\n    vowelsCount\
    \ %= len(vowels)\n    lastConsonant := false\n    for _, v := range vowels {\n\
    \        if strings.Contains(word, v) {\n            vowelsCount--\n         \
    \   if lastConsonant {\n                vowelsCount++\n            }\n       \
    \     lastConsonant = true\n        }\n    }\n    if vowelsCount < 0 {\n     \
    \   return \"\"\n    }\n    return vowels[vowelsCount]\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmporsttq_4_test.go:26:12: undefined: strings

    /tmp/tmporsttq_4_test.go:38:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074789
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // Your code here\n    vowels := []string{\"a\", \"e\"\
    , \"i\", \"o\", \"u\"}\n    vowelsLen := len(vowels)\n    vowelsLen -= 1\n   \
    \ vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n\
    \    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen +=\
    \ 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp5eu5y28m_test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074647
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpjcv4si1u_test.go:100:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074643
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpyvyobif7_test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    for _, v := range vowels {\n        if word == v {\n\
    \            vowelsCount++\n        }\n    }\n    if vowelsCount == 0 {\n    \
    \    return \"\"\n    }\n    vowelsCount -= 1\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpmd4x1wcm_test.go:98:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)/2\n\
    \    vowelsCount += len(vowels)/3\n    vowelsCount += len(vowels)/4\n    vowelsCount\
    \ += len(vowels)/5\n    vowelsCount += len(vowels)/6\n    vowelsCount += len(vowels)/7\n\
    \    vowelsCount += len(vowels)/8\n    vowelsCount += len(vowels)/9\n    vowelsCount\
    \ += len(vowels)/10\n    vowelsCount += len(vowels)/11\n    vowelsCount += len(vowels)/12\n\
    \    vowelsCount += len(vowels)/13\n    vowelsCount += len(vowels)/14\n    vowelsCount\
    \ += len(vowels)/15\n    vowelsCount += len(vowels)/16\n    vowelsCount += len(vowels)/17\n\
    \    vowelsCount += len(vowels)/18\n    vowelsCount += len(vowels)/19\n    vowelsCount\
    \ += len(vowels)/20\n    vowelsCount += len(vowels)/21\n    vowelsCount += len(vowels)/22\n\
    \    vowelsCount += len(vowels)/23\n    vowelsCount += len(vowels)/24\n    vowelsCount\
    \ += len(vowels)/25\n    vowelsCount += len(vowels)/26\n    vowelsCount += len(vowels)/27\n\
    \    vowelsCount += len(vowels)/28\n    vowelsCount += len(vowels)/29\n    vowelsCount\
    \ += len(vowels)/30\n    vowelsCount += len(vowels)/31\n    vowelsCount += len(vowels)/32\n\
    \    vowelsCount += len(vowels)/33\n    vowelsCount += len(vowels)/34\n    vowelsCount\
    \ += len(vowels)/35\n    vowelsCount += len(vowels)/36\n    vowelsCount += len(vowels)/37\n\
    \    vowelsCount += len(vowels)/38\n    vowelsCount += len(vowels)/39\n    vowelsCount\
    \ += len(vowels)/40\n    vowelsCount += len(vowels)/41\n    vowelsCount += len(vowels)/42\n\
    \    vowelsCount += len(vowels)/43\n    vowelsCount += len(vowels)/44\n    vowelsCount\
    \ += len(vowels)/45\n    vowelsCount += len(vowels)/46\n    vowelsCount += len(vowels)/47\n\
    \    vowelsCount += len(vowels)/48\n    vowelsCount += len(vowels)/49\n    vowels\n\
    func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpt9m6ef6a_test.go:75:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphy7oiqg__test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for _, v := range vowels\
    \ {\n        if strings.Contains(word, v) {\n            vowelsCount++\n     \
    \   }\n    }\n    if vowelsCount < 2 {\n        return \"\"\n    }\n    vowelsCount\
    \ -= 2\n    vowelsCount /= 2\n    vowelsCount %= len(vowels)\n    if vowelsCount\
    \ == 0 {\n        return \"\"\n    }\n    i := len(word) - 1\n    for ; i >= 0;\
    \ i-- {\n        if word[i] == word[i+1] {\n            return word[i]\n     \
    \   }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n\
    \  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpnsv4q27i_test.go:27:12: undefined: strings

    /tmp/tmpnsv4q27i_test.go:43:20: cannot use word[i] (value of type byte) as type
    string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074790
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphy7oiqg__test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphopteei4_test.go:87:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074642
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    for _, v := range vowels {\n        if strings.Contains(word,\
    \ v) {\n            vowelsCount++\n        }\n    }\n    if vowelsCount < 2 {\n\
    \        return \"\"\n    }\n    vowelsCount -= 2\n    vowelsCount %= len(vowels)\n\
    \    vowelsCount += 2\n    vowelsCount %= len(vowels)\n    vowelsCount += 2\n\
    \    vowelsCount %= len(vowels)\n    vowelsCount += 2\n    vowelsCount %= len(vowels)\n\
    \    vowelsCount += 2\n    vowelsCount %= len(vowels)\n    vowelsCount += 2\n\
    \    vowelsCount %= len(vowels)\n    vowelsCount += 2\n    vowelsCount %= len(vowels)\n\
    \    vowelsCount += 2\n    vowelsCount %= len(vowels)\n    vowelsCount += 2\n\
    \    vowelsCount %= len(vowels)\n    vowelsCount += 2\n    vowelsCount %= len(vowels)\n\
    \    vowelsCount += 2\n    vowelsCount %= len(vowels)\n    vowelsCount += 2\n\
    \    vowelsCount %= len(vowels)\n    vowelsCount += 2\n    vowelsCount %= len(vowels)\n\
    \    vowelsCount += 2\n    vowelsCount %= len(vowels)\n    vowelsCount += 2\n\
    \    vowelsCount %= len(vowels)\n    vowelsCount += 2\n    vowelsCount %= len(vowels)\n\
    \    vowelsCount += 2\n    vowelsCount %= len(vowels)\n    vowelsCount += 2\n\
    \    vowelsCount %= len(vowels)\n    vowelsCount += 2\n    vowelsCount %= len(vowels)\n\
    \    vowelsCount += 2\n    vowelsCount %= len(vowels)\n    vowelsCount += 2\n\
    \    vowelsCount %= len(vowels)\n    vowelsCount += 2\n    vowelsCount %= len(vowels)\n\
    \    vowelsCount += 2\n    vowelsCount %= len(vowels)\n    vowelsCount += 2\n\
    \    vowelsCount %= len(vowels)\n    vowelsCount += 2\n    vowelsCount %= len(vowels)\n\
    \    vowelsCount += 2\n    vowelsCount %= len(vowels)\n    vowelsCount += 2\n\
    \    vowelsCount %= len(vowels)\n    vowelsCount += 2\n    vowelsCount %= len(vowels)\n\
    \    vowels\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpztvxvb4j_test.go:90:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074789
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)/2\n\
    \    vowelsCount += len(vowels)/3\n    vowelsCount += len(vowels)/4\n    vowelsCount\
    \ += len(vowels)/5\n    vowelsCount += len(vowels)/6\n    vowelsCount += len(vowels)/7\n\
    \    vowelsCount += len(vowels)/8\n    vowelsCount += len(vowels)/9\n    vowelsCount\
    \ += len(vowels)/10\n    vowelsCount += len(vowels)/11\n    vowelsCount += len(vowels)/12\n\
    \    vowelsCount += len(vowels)/13\n    vowelsCount += len(vowels)/14\n    vowelsCount\
    \ += len(vowels)/15\n    vowelsCount += len(vowels)/16\n    vowelsCount += len(vowels)/17\n\
    \    vowelsCount += len(vowels)/18\n    vowelsCount += len(vowels)/19\n    vowelsCount\
    \ += len(vowels)/20\n    vowelsCount += len(vowels)/21\n    vowelsCount += len(vowels)/22\n\
    \    vowelsCount += len(vowels)/23\n    vowelsCount += len(vowels)/24\n    vowelsCount\
    \ += len(vowels)/25\n    vowelsCount += len(vowels)/26\n    vowelsCount += len(vowels)/27\n\
    \    vowelsCount += len(vowels)/28\n    vowelsCount += len(vowels)/29\n    vowelsCount\
    \ += len(vowels)/30\n    vowelsCount += len(vowels)/31\n    vowelsCount += len(vowels)/32\n\
    \    vowelsCount += len(vowels)/33\n    vowelsCount += len(vowels)/34\n    vowelsCount\
    \ += len(vowels)/35\n    vowelsCount += len(vowels)/36\n    vowelsCount += len(vowels)/37\n\
    \    vowelsCount += len(vowels)/38\n    vowelsCount += len(vowels)/39\n    vowelsCount\
    \ += len(vowels)/40\n    vowelsCount += len(vowels)/41\n    vowelsCount += len(vowels)/42\n\
    \    vowelsCount += len(vowels)/43\n    vowelsCount += len(vowels)/44\n    vowelsCount\
    \ += len(vowels)/45\n    vowelsCount += len(vowels)/46\n    vowelsCount += len(vowels)/47\n\
    \    vowelsCount += len(vowels)/48\n    vowelsCount += len(vowels)/49\n    vowels\n\
    func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpt9m6ef6a_test.go:75:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    for _, v := range vowels {\n        if word == v {\n\
    \            vowelsCount++\n        }\n    }\n    if vowelsCount > 0 {\n     \
    \   return word\n    }\n    vowelsCount = 0\n    for i := len(word) - 1; i >=\
    \ 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i]\
    \ == 'o' || word[i] == 'u' {\n            vowelsCount++\n        }\n    }\n  \
    \  if vowelsCount > 0 {\n        return word\n    }\n    return \"\"\n}\n\nfunc\
    \ TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmp2yfib2eu_test.go:70: expected 'u', got 'yogurt'\n    ---\
    \ FAIL: TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmp2yfib2eu_test.go:70:\
    \ expected 'u', got 'full'\n    --- FAIL: TestGet_Closest_Vowel/test_num__2 (0.00s)\n\
    \        tmp2yfib2eu_test.go:70: expected '', got 'easy'\n    --- FAIL: TestGet_Closest_Vowel/test_num__3\
    \ (0.00s)\n        tmp2yfib2eu_test.go:70: expected '', got 'eAsy'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__4 (0.00s)\n        tmp2yfib2eu_test.go:70: expected\
    \ '', got 'ali'\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n   \
    \     tmp2yfib2eu_test.go:70: expected 'a', got 'bad'\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmp2yfib2eu_test.go:70: expected 'o', got 'most'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__7 (0.00s)\n        tmp2yfib2eu_test.go:70: expected\
    \ '', got 'ab'\n    --- FAIL: TestGet_Closest_Vowel/test_num__8 (0.00s)\n    \
    \    tmp2yfib2eu_test.go:70: expected '', got 'ba'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9\
    \ (0.00s)\n        tmp2yfib2eu_test.go:70: expected '', got 'quick'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmp2yfib2eu_test.go:70:\
    \ expected 'i', got 'anime'\n    --- FAIL: TestGet_Closest_Vowel/test_num__11\
    \ (0.00s)\n        tmp2yfib2eu_test.go:70: expected '', got 'Asia'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__12 (0.00s)\n        tmp2yfib2eu_test.go:70:\
    \ expected 'o', got 'Above'\nFAIL\nFAIL\tcommand-line-arguments\t0.008s\nFAIL\n"
  timestamp: 1660074790
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    for _, v := range vowels {\n        if word == v {\n\
    \            vowelsCount++\n        }\n    }\n    if vowelsCount == 0 {\n    \
    \    return \"\"\n    }\n    vowelsCount -= 1\n    for i := len(word) - 1; i >=\
    \ 0; i-- {\n        if word[i] == word[len(word)-1] {\n            vowelsCount++\n\
    \        }\n    }\n    if vowelsCount == 0 {\n        return \"\"\n    }\n   \
    \ for i := len(word) - 1; i >= 0; i-- {\n        if word[i] != word[len(word)-1]\
    \ {\n            vowelsCount++\n        }\n    }\n    if vowelsCount == 0 {\n\
    \        return \"\"\n    }\n    return vowels[len(vowels)-vowelsCount]\n}\n\n\
    func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmprm38o4cg_test.go:78: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmprm38o4cg_test.go:78: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmprm38o4cg_test.go:78: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmprm38o4cg_test.go:78: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmprm38o4cg_test.go:78:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmprm38o4cg_test.go:78: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.006s\nFAIL\n"
  timestamp: 1660074790
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    \n    vowelsLen /= 2\n    \n    vowelsLen -= 2\n    \n    vowelsLen\
    \ /= 2\n    \n    vowelsLen -= 2\n    \n    vowelsLen /= 2\n    \n    vowelsLen\
    \ -= 2\n    \n    vowelsLen /= 2\n    \n    vowelsLen -= 2\n    \n    vowelsLen\
    \ /= 2\n    \n    vowelsLen -= 2\n    \n    vowelsLen /= 2\n    \n    vowelsLen\
    \ -= 2\n    \n    vowelsLen /= 2\n    \n    vowelsLen -= 2\n    \n    vowelsLen\
    \ /= 2\n    \n    vowelsLen -= 2\n    \n    vowelsLen /= 2\n    \n    vowelsLen\
    \ -= 2\n    \n    vowelsLen /= 2\n    \n    vowelsLen -= 2\n    \n    vowelsLen\
    \ /= 2\n    \n    vowelsLen -= 2\n    \n    vowelsLen /= 2\n    \n    vowelsLen\
    \ -= 2\n    \n    vowelsLen /= 2\n    \n    vowelsLen -= 2\n    \n    vowelsLen\
    \ /= 2\n    \n    vowelsLen -= 2\n    \n    vowelsLen /= 2\n    \n    vowelsLen\
    \ -= 2\n    \n    vowelsLen /= 2\n    \n    vowelsLen -= 2\n    \n    vowelsLen\
    \ /= 2\n    \n    vowelsLen -= 2\n    \n    vowelsLen /= 2\n    \n    vowelsLen\
    \ -= 2\n    \n    vowelsLen /= 2\n    \n    vowelsLen -= 2\n    \n    vowelsLen\
    \ /= 2\n    \n    vowelsLen -= 2\n    \n    vowelsLen /= 2\n    \n    vowelsLen\
    \ -= 2\n    \n    vowelsLen /= 2\n    \n    vowelsLen -= 2\n    \n    vowelsLen\
    \ /= 2\n    \n    vowelsLen -= 2\n    \n    vowelsLen /= 2\n    \n    vowelsLen\
    \ -= 2\n    \n    vowelsLen /= 2\n    \n    vowelsLen -= 2\n    \n    vowelsLen\
    \ /= 2\n    \n    vowelsLen -= \nfunc TestGet_Closest_Vowel(t *testing.T) {\n\
    \  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpyd8s5i28_test.go:132:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074790
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowel := \"aeiouAEIOU\"\n    vowelLen := len(vowel)\n\
    \    \n    i := len(word) - 1\n    \n    for i >= 0 {\n        if word[i] == vowel[0]\
    \ {\n            i -= vowelLen\n        } else {\n            i -= 1\n       \
    \ }\n    }\n    \n    return word[i]\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_oxq_sfv_test.go:36:12: cannot use word[i] (value of type byte) as type
    string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074790
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)/2\n\
    \    vowelsCount += len(vowels)/3\n    vowelsCount += len(vowels)/4\n    vowelsCount\
    \ += len(vowels)/5\n    vowelsCount += len(vowels)/6\n    vowelsCount += len(vowels)/7\n\
    \    vowelsCount += len(vowels)/8\n    vowelsCount += len(vowels)/9\n    vowelsCount\
    \ += len(vowels)/10\n    vowelsCount += len(vowels)/11\n    vowelsCount += len(vowels)/12\n\
    \    vowelsCount += len(vowels)/13\n    vowelsCount += len(vowels)/14\n    vowelsCount\
    \ += len(vowels)/15\n    vowelsCount += len(vowels)/16\n    vowelsCount += len(vowels)/17\n\
    \    vowelsCount += len(vowels)/18\n    vowelsCount += len(vowels)/19\n    vowelsCount\
    \ += len(vowels)/20\n    vowelsCount += len(vowels)/21\n    vowelsCount += len(vowels)/22\n\
    \    vowelsCount += len(vowels)/23\n    vowelsCount += len(vowels)/24\n    vowelsCount\
    \ += len(vowels)/25\n    vowelsCount += len(vowels)/26\n    vowelsCount += len(vowels)/27\n\
    \    vowelsCount += len(vowels)/28\n    vowelsCount += len(vowels)/29\n    vowelsCount\
    \ += len(vowels)/30\n    vowelsCount += len(vowels)/31\n    vowelsCount += len(vowels)/32\n\
    \    vowelsCount += len(vowels)/33\n    vowelsCount += len(vowels)/34\n    vowelsCount\
    \ += len(vowels)/35\n    vowelsCount += len(vowels)/36\n    vowelsCount += len(vowels)/37\n\
    \    vowelsCount += len(vowels)/38\n    vowelsCount += len(vowels)/39\n    vowelsCount\
    \ += len(vowels)/40\n    vowelsCount += len(vowels)/41\n    vowelsCount += len(vowels)/42\n\
    \    vowelsCount += len(vowels)/43\n    vowelsCount += len(vowels)/44\n    vowelsCount\
    \ += len(vowels)/45\n    vowelsCount += len(vowels)/46\n    vowelsCount += len(vowels)/47\n\
    \    vowelsCount += len(vowels)/48\n    vowelsCount += len(vowels)/49\n    vowels\n\
    func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpt9m6ef6a_test.go:75:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpyvyobif7_test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // Your code here\n    vowels := []rune{'a', 'e', 'i',\
    \ 'o', 'u'}\n    vowelsCount := 0\n    for _, v := range word {\n        if v\
    \ == 'a' || v == 'e' || v == 'i' || v == 'o' || v == 'u' {\n            vowelsCount++\n\
    \        }\n    }\n    if vowelsCount > 0 {\n        for _, v := range word {\n\
    \            if v == 'a' || v == 'e' || v == 'i' || v == 'o' || v == 'u' {\n \
    \               vowelsCount--\n            }\n        }\n    }\n    if vowelsCount\
    \ == 0 {\n        return \"\"\n    }\n    vowelsCount /= 2\n    vowelsCount %=\
    \ len(vowels)\n    return vowels[vowelsCount]\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpl4mksm6l_test.go:43:12: cannot use vowels[vowelsCount] (variable of type
    rune) as type string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074790
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for _, v := range vowels\
    \ {\n        if strings.Contains(word, v) {\n            vowelsCount++\n     \
    \   }\n    }\n    if vowelsCount > 0 {\n        i := len(word) - 1\n        for\
    \ {\n            if i >= 0 {\n                if strings.Contains(word, vowels[i])\
    \ {\n                    return vowels[i]\n                }\n               \
    \ i--\n            } else {\n                break\n            }\n        }\n\
    \    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1tjvaa12_test.go:27:12: undefined: strings

    /tmp/tmp1tjvaa12_test.go:35:20: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074790
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for i := len(word)\
    \ - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] ==\
    \ 'i' || word[i] == 'o' || word[i] == 'u' {\n            vowelsCount++\n     \
    \   }\n    }\n    if vowelsCount <= 0 {\n        return \"\"\n    }\n    vowelsCount\
    \ -= len(vowels)\n    vowelsCount /= 2\n    if vowelsCount < 0 {\n        vowelsCount\
    \ = 0\n    }\n    if vowelsCount > len(vowels)-1 {\n        vowelsCount = len(vowels)-1\n\
    \    }\n    return vowels[vowelsCount]\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmp7wo2_zsd_test.go:70: expected 'u', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmp7wo2_zsd_test.go:70: expected\
    \ 'u', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__2 (0.00s)\n    \
    \    tmp7wo2_zsd_test.go:70: expected '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__3\
    \ (0.00s)\n        tmp7wo2_zsd_test.go:70: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__4 (0.00s)\n        tmp7wo2_zsd_test.go:70: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__6 (0.00s)\n     \
    \   tmp7wo2_zsd_test.go:70: expected 'o', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmp7wo2_zsd_test.go:70: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmp7wo2_zsd_test.go:70: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmp7wo2_zsd_test.go:70: expected '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmp7wo2_zsd_test.go:70: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmp7wo2_zsd_test.go:70:\
    \ expected '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmp7wo2_zsd_test.go:70: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074790
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)/2\n\
    \    vowelsCount += len(vowels)/3\n    vowelsCount += len(vowels)/4\n    vowelsCount\
    \ += len(vowels)/5\n    vowelsCount += len(vowels)/6\n    vowelsCount += len(vowels)/7\n\
    \    vowelsCount += len(vowels)/8\n    vowelsCount += len(vowels)/9\n    vowelsCount\
    \ += len(vowels)/10\n    vowelsCount += len(vowels)/11\n    vowelsCount += len(vowels)/12\n\
    \    vowelsCount += len(vowels)/13\n    vowelsCount += len(vowels)/14\n    vowelsCount\
    \ += len(vowels)/15\n    vowelsCount += len(vowels)/16\n    vowelsCount += len(vowels)/17\n\
    \    vowelsCount += len(vowels)/18\n    vowelsCount += len(vowels)/19\n    vowelsCount\
    \ += len(vowels)/20\n    vowelsCount += len(vowels)/21\n    vowelsCount += len(vowels)/22\n\
    \    vowelsCount += len(vowels)/23\n    vowelsCount += len(vowels)/24\n    vowelsCount\
    \ += len(vowels)/25\n    vowelsCount += len(vowels)/26\n    vowelsCount += len(vowels)/27\n\
    \    vowelsCount += len(vowels)/28\n    vowelsCount += len(vowels)/29\n    vowelsCount\
    \ += len(vowels)/30\n    vowelsCount += len(vowels)/31\n    vowelsCount += len(vowels)/32\n\
    \    vowelsCount += len(vowels)/33\n    vowelsCount += len(vowels)/34\n    vowelsCount\
    \ += len(vowels)/35\n    vowelsCount += len(vowels)/36\n    vowelsCount += len(vowels)/37\n\
    \    vowelsCount += len(vowels)/38\n    vowelsCount += len(vowels)/39\n    vowelsCount\
    \ += len(vowels)/40\n    vowelsCount += len(vowels)/41\n    vowelsCount += len(vowels)/42\n\
    \    vowelsCount += len(vowels)/43\n    vowelsCount += len(vowels)/44\n    vowelsCount\
    \ += len(vowels)/45\n    vowelsCount += len(vowels)/46\n    vowelsCount += len(vowels)/47\n\
    \    vowelsCount += len(vowels)/48\n    vowelsCount += len(vowels)/49\n    vowels\n\
    func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpt9m6ef6a_test.go:75:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpyvyobif7_test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    \n    i := len(word) - 1\n    j := len(word) - 2\n    \n    vowelsCount\
    \ := 0\n    \n    for {\n        if word[i] == 'a' || word[i] == 'e' || word[i]\
    \ == 'i' || word[i] == 'o' || word[i] == 'u' {\n            vowelsCount++\n  \
    \      }\n        \n        if word[j] == 'a' || word[j] == 'e' || word[j] ==\
    \ 'i' || word[j] == 'o' || word[j] == 'u' {\n            vowelsCount++\n     \
    \   }\n        \n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i'\
    \ || word[i] == 'o' || word[i] == 'u' {\n            vowelsCount++\n        }\n\
    \        \n        if word[j] == 'a' || word[j] == 'e' || word[j] == 'i' || word[j]\
    \ == 'o' || word[j] == 'u' {\n            vowelsCount++\n        }\n        \n\
    \        if word[i] == word[j] {\n            vowelsCount++\n        }\n     \
    \   \n        if word[i] == word[j] {\n            vowelsCount++\n        }\n\
    \        \n        if word[i] == word[j] {\n            vowelsCount++\n      \
    \  }\n        \n        if word[i] == word[j] {\n            vowelsCount++\n \
    \       }\n        \n        if word[i] == word[j] {\n            vowelsCount++\n\
    \        }\n        \n        if word[i] == word[j] {\n            vowelsCount++\n\
    \        }\n        \n        if word[i] == word[j] {\n            vowelsCount++\n\
    \        }\n        \n        if word[i] == word[j] {\n            vowelsCount++\n\
    \        }\n        \n        if word[i] == word[j] {\n            vowelsCount++\n\
    \        }\n        \n        if word[i] == word[j] {\n            vowelsCount++\n\
    \        }\n        \n        if word[i] == word[j] {\n            vowelsCount++\n\
    \        }\n        \n        if word[i] == word[j] {\n            vowelsCount++\n\
    \        }\n        \n        if word[i] == word[j] {\n            vowelsCount++\n\
    \        }\n        \n        if word[i] == word[j] {\n            vowelsCount++\n\
    \        }\n        \n        if word[i] == word[j] {\n            vowelsCount++\n\
    \        }\n        \n        if word[i] == word[j] {\n            vowelsCount++\n\
    \        }\n        \n        if word[i] == word[j] {\n            vowelsCount\n\
    func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvhckzb3__test.go:117:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074790
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for _, v := range vowels\
    \ {\n        if strings.Contains(word, v) {\n            vowelsCount++\n     \
    \   }\n    }\n    if vowelsCount == 0 {\n        return \"\"\n    }\n    vowelsCount\
    \ -= 1\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowels\nfunc\
    \ TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp4zeub3xb_test.go:98:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074790
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpjcv4si1u_test.go:100:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074643
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphy7oiqg__test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)/2\n\
    \    vowelsCount += len(vowels)/3\n    vowelsCount += len(vowels)/4\n    vowelsCount\
    \ += len(vowels)/5\n    vowelsCount += len(vowels)/6\n    vowelsCount += len(vowels)/7\n\
    \    vowelsCount += len(vowels)/8\n    vowelsCount += len(vowels)/9\n    vowelsCount\
    \ += len(vowels)/10\n    vowelsCount += len(vowels)/11\n    vowelsCount += len(vowels)/12\n\
    \    vowelsCount += len(vowels)/13\n    vowelsCount += len(vowels)/14\n    vowelsCount\
    \ += len(vowels)/15\n    vowelsCount += len(vowels)/16\n    vowelsCount += len(vowels)/17\n\
    \    vowelsCount += len(vowels)/18\n    vowelsCount += len(vowels)/19\n    vowelsCount\
    \ += len(vowels)/20\n    vowelsCount += len(vowels)/21\n    vowelsCount += len(vowels)/22\n\
    \    vowelsCount += len(vowels)/23\n    vowelsCount += len(vowels)/24\n    vowelsCount\
    \ += len(vowels)/25\n    vowelsCount += len(vowels)/26\n    vowelsCount += len(vowels)/27\n\
    \    vowelsCount += len(vowels)/28\n    vowelsCount += len(vowels)/29\n    vowelsCount\
    \ += len(vowels)/30\n    vowelsCount += len(vowels)/31\n    vowelsCount += len(vowels)/32\n\
    \    vowelsCount += len(vowels)/33\n    vowelsCount += len(vowels)/34\n    vowelsCount\
    \ += len(vowels)/35\n    vowelsCount += len(vowels)/36\n    vowelsCount += len(vowels)/37\n\
    \    vowelsCount += len(vowels)/38\n    vowelsCount += len(vowels)/39\n    vowelsCount\
    \ += len(vowels)/40\n    vowelsCount += len(vowels)/41\n    vowelsCount += len(vowels)/42\n\
    \    vowelsCount += len(vowels)/43\n    vowelsCount += len(vowels)/44\n    vowelsCount\
    \ += len(vowels)/45\n    vowelsCount += len(vowels)/46\n    vowelsCount += len(vowels)/47\n\
    \    vowelsCount += len(vowels)/48\n    vowelsCount += len(vowels)/49\n    vowels\n\
    func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpt9m6ef6a_test.go:75:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    \n    i := len(word) - 1\n    \n    for {\n        if word[i] == 'a'\
    \ || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n\
    \            i -= 1\n            break\n        }\n        i -= 1\n    }\n   \
    \ \n    for {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' ||\
    \ word[i] == 'o' || word[i] == 'u' {\n            i -= 1\n            break\n\
    \        }\n        i -= 1\n    }\n    \n    for {\n        if word[i] == 'a'\
    \ || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n\
    \            i -= 1\n            break\n        }\n        i -= 1\n    }\n   \
    \ \n    for {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' ||\
    \ word[i] == 'o' || word[i] == 'u' {\n            i -= 1\n            break\n\
    \        }\n        i -= 1\n    }\n    \n    for {\n        if word[i] == 'a'\
    \ || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n\
    \            i -= 1\n            break\n        }\n        i -= 1\n    }\n   \
    \ \n    for {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' ||\
    \ word[i] == 'o' || word[i] == 'u' {\n            i -= 1\n            break\n\
    \        }\n        i -= 1\n    }\n    \n    for {\n        if word[i] == 'a'\
    \ || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n\
    \            i -= 1\n            break\n        }\n        i -= 1\n    }\n   \
    \ \n    for {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' ||\
    \ word[i] == 'o' || word[i] == 'u' {\n            i -= 1\n            break\n\
    \        }\n        i -= 1\n    }\n    \n    for {\n        if word[i] == 'a'\
    \ || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n\
    \            i -= 1\n            break\n        }\n        i -= 1\n    }\n   \
    \ \n    for {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' ||\
    \ word[i] == 'o' || word[i] == 'u' {\n            \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp2jdo8v6j_test.go:106:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074790
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphopteei4_test.go:87:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074642
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    for _, v := range vowels {\n        if strings.Contains(word,\
    \ v) {\n            vowelsCount++\n        }\n    }\n    if vowelsCount == 0 {\n\
    \        return \"\"\n    }\n    vowelsCount -= 1\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp5dnmitnn_test.go:98:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074642
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for _, v := range vowels\
    \ {\n        if strings.Contains(word, v) {\n            vowelsCount++\n     \
    \   }\n    }\n    if vowelsCount < 2 {\n        return \"\"\n    }\n    vowelsCount\
    \ -= 2\n    for i := len(word) - 1; i >= 0; i-- {\n        if strings.Contains(word,\
    \ vowels[vowelsCount]) {\n            return vowels[vowelsCount]\n        }\n\
    \        vowelsCount--\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpat6stilj_test.go:27:12: undefined: strings

    /tmp/tmpat6stilj_test.go:36:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074790
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpw4oq0vvz_test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpyvyobif7_test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphy7oiqg__test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)/2\n\
    \    vowelsCount += len(vowels)/3\n    vowelsCount += len(vowels)/4\n    vowelsCount\
    \ += len(vowels)/5\n    vowelsCount += len(vowels)/6\n    vowelsCount += len(vowels)/7\n\
    \    vowelsCount += len(vowels)/8\n    vowelsCount += len(vowels)/9\n    vowelsCount\
    \ += len(vowels)/10\n    vowelsCount += len(vowels)/11\n    vowelsCount += len(vowels)/12\n\
    \    vowelsCount += len(vowels)/13\n    vowelsCount += len(vowels)/14\n    vowelsCount\
    \ += len(vowels)/15\n    vowelsCount += len(vowels)/16\n    vowelsCount += len(vowels)/17\n\
    \    vowelsCount += len(vowels)/18\n    vowelsCount += len(vowels)/19\n    vowelsCount\
    \ += len(vowels)/20\n    vowelsCount += len(vowels)/21\n    vowelsCount += len(vowels)/22\n\
    \    vowelsCount += len(vowels)/23\n    vowelsCount += len(vowels)/24\n    vowelsCount\
    \ += len(vowels)/25\n    vowelsCount += len(vowels)/26\n    vowelsCount += len(vowels)/27\n\
    \    vowelsCount += len(vowels)/28\n    vowelsCount += len(vowels)/29\n    vowelsCount\
    \ += len(vowels)/30\n    vowelsCount += len(vowels)/31\n    vowelsCount += len(vowels)/32\n\
    \    vowelsCount += len(vowels)/33\n    vowelsCount += len(vowels)/34\n    vowelsCount\
    \ += len(vowels)/35\n    vowelsCount += len(vowels)/36\n    vowelsCount += len(vowels)/37\n\
    \    vowelsCount += len(vowels)/38\n    vowelsCount += len(vowels)/39\n    vowelsCount\
    \ += len(vowels)/40\n    vowelsCount += len(vowels)/41\n    vowelsCount += len(vowels)/42\n\
    \    vowelsCount += len(vowels)/43\n    vowelsCount += len(vowels)/44\n    vowelsCount\
    \ += len(vowels)/45\n    vowelsCount += len(vowels)/46\n    vowelsCount += len(vowels)/47\n\
    \    vowelsCount += len(vowels)/48\n    vowelsCount += len(vowels)/49\n    vowels\n\
    func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpt9m6ef6a_test.go:75:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpjcv4si1u_test.go:100:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074643
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for _, v := range vowels\
    \ {\n        if strings.Contains(word, v) {\n            vowelsCount++\n     \
    \   }\n    }\n    if vowelsCount == 0 {\n        return \"\"\n    }\n    vowelsCount\
    \ -= len(vowels)\n    for _, v := range vowels {\n        if strings.Contains(word,\
    \ v) {\n            vowelsCount--\n        }\n    }\n    if vowelsCount < 0 {\n\
    \        return \"\"\n    }\n    vowelsCount /= 2\n    if strings.Contains(word[vowelsCount:],\
    \ \"a\") {\n        return word[vowelsCount:]\n    }\n    if strings.Contains(word[vowelsCount:],\
    \ \"e\") {\n        return word[vowelsCount:]\n    }\n    if strings.Contains(word[vowelsCount:],\
    \ \"i\") {\n        return word[vowelsCount:]\n    }\n    if strings.Contains(word[vowelsCount:],\
    \ \"o\") {\n        return word[vowelsCount:]\n    }\n    if strings.Contains(word[vowelsCount:],\
    \ \"u\") {\n        return word[vowelsCount:]\n    }\n    return \"\"\n}\n\nfunc\
    \ TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp22idumq__test.go:27:12: undefined: strings

    /tmp/tmp22idumq__test.go:36:12: undefined: strings

    /tmp/tmp22idumq__test.go:44:8: undefined: strings

    /tmp/tmp22idumq__test.go:47:8: undefined: strings

    /tmp/tmp22idumq__test.go:50:8: undefined: strings

    /tmp/tmp22idumq__test.go:53:8: undefined: strings

    /tmp/tmp22idumq__test.go:56:8: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074790
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphy7oiqg__test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowel := []rune{'a', 'e', 'i', 'o', 'u'}\n    vowel_count\
    \ := 0\n    vowel_count += len(word) - len(word[:len(word)-1])\n    for _, v :=\
    \ range vowel {\n        if word[len(word)-1:] == v {\n            vowel_count++\n\
    \        }\n    }\n    if vowel_count > 0 {\n        return word[len(word)-1:]\n\
    \    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqlugz07__test.go:27:34: invalid operation: word[len(word) - 1:] == v (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074787
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowel := \"aeiouAEIOU\"\n    vowelLen := len(vowel)\n\
    \    vowelIndex := 0\n    vowelLen := len(word)\n    vowelIndex = 0\n    for i\
    \ := 0; i < len(word); i++ {\n        if word[i] == 'a' || word[i] == 'e' || word[i]\
    \ == 'i' || word[i] == 'o' || word[i] == 'u' {\n            vowelIndex++\n   \
    \     }\n    }\n    if vowelIndex == 0 {\n        return \"\"\n    }\n    vowelIndex--\n\
    \    vowelIndex--\n    vowelIndex--\n    vowelIndex--\n    vowelIndex--\n    vowelIndex--\n\
    \    vowelIndex--\n    vowelIndex--\n    vowelIndex--\n    vowelIndex--\n    vowelIndex--\n\
    \    vowelIndex--\n    vowelIndex--\n    vowelIndex--\n    vowelIndex--\n    vowelIndex--\n\
    \    vowelIndex--\n    vowelIndex--\n    vowelIndex--\n    vowelIndex--\n    vowelIndex--\n\
    \    vowelIndex--\n    vowelIndex--\n    vowelIndex--\n    vowelIndex--\n    vowelIndex--\n\
    \    vowelIndex--\n    vowelIndex--\n    vowelIndex--\n    vowelIndex--\n    vowelIndex--\n\
    \    vowelIndex--\n    vowelIndex--\n    vowelIndex--\n    vowelIndex--\n    vowelIndex--\n\
    \    vowelIndex--\n    vowelIndex--\n    vowelIndex--\n    vowelIndex--\n    vowelIndex--\n\
    \    vowelIndex--\n    vowelIndex--\n    vowelIndex--\n    vowelIndex--\n    vowelIndex--\n\
    \    vowelIndex--\n    vowelIndex--\n    vowelIndex--\n    vowelIndex--\n    vowelIndex--\n\
    \    vowelIndex--\n    vowelIndex--\n    vowelIndex--\n    vowelIndex--\n    vowelIndex--\n\
    \    vowelIndex--\n    vowelIndex--\n    vowelIndex--\n    vowelIndex--\n    vowelIndex--\n\
    \    vowelIndex--\n    vowelIndex--\n    vowelIndex--\n    vowelIndex--\n    vowelIndex--\n\
    \    vowelIndex--\n    vowelIndex--\n    vowelIndex--\n    vowelIndex--\n    vowelIndex--\n\
    \    vowelIndex--\n    vowelIndex--\n    vowelIndex--\n    vowelIndex--\n    vowelIndex--\n\
    \    vowelIndex--\n    vowelIndex--\n    vowelIndex--\n    vowelIndex--\n    vowelIndex--\n\
    \    vowelIndex--\n    vowelIndex--\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpg0uun9vo_test.go:120:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074790
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // Your code here\n    vowels := []string{\"a\", \"e\"\
    , \"i\", \"o\", \"u\"}\n    vowelsLen := len(vowels)\n    vowelsLen -= 1\n   \
    \ vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n\
    \    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen +=\
    \ 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp5eu5y28m_test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074647
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpyvyobif7_test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowel := []rune(\"aeiou\")\n    vowelLen := len(vowel)\n\
    \    vowelPos := 0\n    vowelLen -= len(word) % vowelLen\n    \n    for i := 0;\
    \ i < len(word); i++ {\n        if word[i] == 'a' || word[i] == 'e' || word[i]\
    \ == 'i' || word[i] == 'o' || word[i] == 'u' {\n            vowelPos = i\n   \
    \         break\n        }\n    }\n    \n    if vowelPos == 0 {\n        return\
    \ \"\"\n    }\n    \n    vowelPos += vowelLen\n    \n    for i := 0; i < len(word);\
    \ i++ {\n        if word[i] == vowel[vowelPos] {\n            vowelPos++\n   \
    \         if vowelPos == vowelLen {\n                return word[i]\n        \
    \    }\n        }\n    }\n    \n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7ze7jjti_test.go:42:23: invalid operation: word[i] == vowel[vowelPos]
    (mismatched types byte and rune)

    /tmp/tmp7ze7jjti_test.go:45:24: cannot use word[i] (value of type byte) as type
    string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074790
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // write your code here\n    vowels := []string{\"a\"\
    , \"e\", \"i\", \"o\", \"u\"}\n    vowelsLen := len(vowels)\n    vowelsLen -=\
    \ 1\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpxg39qdze_test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074790
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpyvyobif7_test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpyvyobif7_test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpw4oq0vvz_test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels) - len(word) - 2\n    for\
    \ _, v := range vowels {\n        if word == v {\n            return v\n     \
    \   }\n    }\n    for _, v := range word {\n        if v == 'a' || v == 'e' ||\
    \ v == 'i' || v == 'o' || v == 'u' {\n            vowelsCount++\n        }\n \
    \   }\n    if vowelsCount > 0 {\n        return \"\"\n    }\n    return word[len(word)-1]\n\
    }\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpuhvmnxke_test.go:39:12: cannot use word[len(word) - 1] (value of type
    byte) as type string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074790
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)/2\n\
    \    vowelsCount += len(vowels)/3\n    vowelsCount += len(vowels)/4\n    vowelsCount\
    \ += len(vowels)/5\n    vowelsCount += len(vowels)/6\n    vowelsCount += len(vowels)/7\n\
    \    vowelsCount += len(vowels)/8\n    vowelsCount += len(vowels)/9\n    vowelsCount\
    \ += len(vowels)/10\n    vowelsCount += len(vowels)/11\n    vowelsCount += len(vowels)/12\n\
    \    vowelsCount += len(vowels)/13\n    vowelsCount += len(vowels)/14\n    vowelsCount\
    \ += len(vowels)/15\n    vowelsCount += len(vowels)/16\n    vowelsCount += len(vowels)/17\n\
    \    vowelsCount += len(vowels)/18\n    vowelsCount += len(vowels)/19\n    vowelsCount\
    \ += len(vowels)/20\n    vowelsCount += len(vowels)/21\n    vowelsCount += len(vowels)/22\n\
    \    vowelsCount += len(vowels)/23\n    vowelsCount += len(vowels)/24\n    vowelsCount\
    \ += len(vowels)/25\n    vowelsCount += len(vowels)/26\n    vowelsCount += len(vowels)/27\n\
    \    vowelsCount += len(vowels)/28\n    vowelsCount += len(vowels)/29\n    vowelsCount\
    \ += len(vowels)/30\n    vowelsCount += len(vowels)/31\n    vowelsCount += len(vowels)/32\n\
    \    vowelsCount += len(vowels)/33\n    vowelsCount += len(vowels)/34\n    vowelsCount\
    \ += len(vowels)/35\n    vowelsCount += len(vowels)/36\n    vowelsCount += len(vowels)/37\n\
    \    vowelsCount += len(vowels)/38\n    vowelsCount += len(vowels)/39\n    vowelsCount\
    \ += len(vowels)/40\n    vowelsCount += len(vowels)/41\n    vowelsCount += len(vowels)/42\n\
    \    vowelsCount += len(vowels)/43\n    vowelsCount += len(vowels)/44\n    vowelsCount\
    \ += len(vowels)/45\n    vowelsCount += len(vowels)/46\n    vowelsCount += len(vowels)/47\n\
    \    vowelsCount += len(vowels)/48\n    vowelsCount += len(vowels)/49\n    vowels\n\
    func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpt9m6ef6a_test.go:75:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)/2\n\
    \    vowelsCount += len(vowels)/3\n    vowelsCount += len(vowels)/4\n    vowelsCount\
    \ += len(vowels)/5\n    vowelsCount += len(vowels)/6\n    vowelsCount += len(vowels)/7\n\
    \    vowelsCount += len(vowels)/8\n    vowelsCount += len(vowels)/9\n    vowelsCount\
    \ += len(vowels)/10\n    vowelsCount += len(vowels)/11\n    vowelsCount += len(vowels)/12\n\
    \    vowelsCount += len(vowels)/13\n    vowelsCount += len(vowels)/14\n    vowelsCount\
    \ += len(vowels)/15\n    vowelsCount += len(vowels)/16\n    vowelsCount += len(vowels)/17\n\
    \    vowelsCount += len(vowels)/18\n    vowelsCount += len(vowels)/19\n    vowelsCount\
    \ += len(vowels)/20\n    vowelsCount += len(vowels)/21\n    vowelsCount += len(vowels)/22\n\
    \    vowelsCount += len(vowels)/23\n    vowelsCount += len(vowels)/24\n    vowelsCount\
    \ += len(vowels)/25\n    vowelsCount += len(vowels)/26\n    vowelsCount += len(vowels)/27\n\
    \    vowelsCount += len(vowels)/28\n    vowelsCount += len(vowels)/29\n    vowelsCount\
    \ += len(vowels)/30\n    vowelsCount += len(vowels)/31\n    vowelsCount += len(vowels)/32\n\
    \    vowelsCount += len(vowels)/33\n    vowelsCount += len(vowels)/34\n    vowelsCount\
    \ += len(vowels)/35\n    vowelsCount += len(vowels)/36\n    vowelsCount += len(vowels)/37\n\
    \    vowelsCount += len(vowels)/38\n    vowelsCount += len(vowels)/39\n    vowelsCount\
    \ += len(vowels)/40\n    vowelsCount += len(vowels)/41\n    vowelsCount += len(vowels)/42\n\
    \    vowelsCount += len(vowels)/43\n    vowelsCount += len(vowels)/44\n    vowelsCount\
    \ += len(vowels)/45\n    vowelsCount += len(vowels)/46\n    vowelsCount += len(vowels)/47\n\
    \    vowelsCount += len(vowels)/48\n    vowelsCount += len(vowels)/49\n    vowels\n\
    func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpt9m6ef6a_test.go:75:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphy7oiqg__test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpyvyobif7_test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []rune{'a', 'e', 'i', 'o', 'u'}\n    vowelsLen\
    \ := len(vowels)\n    \n    i := len(word) - 1\n    \n    for i >= 0 && word[i]\
    \ != vowels[vowelsLen] {\n        i--\n    }\n    \n    if i == -1 {\n       \
    \ return \"\"\n    }\n    \n    j := len(word) - 1\n    \n    for j >= 0 && word[j]\
    \ != vowels[vowelsLen] {\n        j--\n    }\n    \n    if j == -1 {\n       \
    \ return \"\"\n    }\n    \n    return word[i+1 : j+1]\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpb86qr5su_test.go:28:30: invalid operation: word[i] != vowels[vowelsLen]
    (mismatched types byte and rune)

    /tmp/tmpb86qr5su_test.go:38:30: invalid operation: word[j] != vowels[vowelsLen]
    (mismatched types byte and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074790
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpjcv4si1u_test.go:100:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074643
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for _, v := range vowels\
    \ {\n        if strings.Contains(word, v) {\n            vowelsCount++\n     \
    \   }\n    }\n    if vowelsCount < 2 {\n        return \"\"\n    }\n    vowelsCount\
    \ -= 2\n    lastConsonant := 0\n    for i := len(word) - 1; i >= 0; i-- {\n  \
    \      if word[i] == word[len(word)-1] {\n            lastConsonant = i\n    \
    \        break\n        }\n    }\n    if lastConsonant == 0 {\n        return\
    \ \"\"\n    }\n    lastConsonant++\n    lastConsonantLen := len(word) - lastConsonant\
    \ - 1\n    lastConsonantLen -= len(vowels)\n    lastConsonantLen -= lastConsonantLen\
    \ % len(vowels)\n    lastConsonantLen /= len(vowels)\n    lastConsonantLen +=\
    \ 2\n    lastConsonantLen -= lastConsonantLen % len(vowels)\n    lastConsonantLen\
    \ /= len(vowels)\n    lastConsonantLen += 2\n    lastConsonantLen -= lastConsonantLen\
    \ % len(vowels)\n    lastConsonantLen /= len(vowels)\n    lastConsonantLen +=\
    \ 2\n    lastConsonantLen -= lastConsonantLen % len(vowels)\n    lastConsonantLen\
    \ /= len(vowels)\n    lastConsonantLen += 2\n    lastConsonantLen -= lastConsonantLen\
    \ % len(vowels)\n    lastConsonantLen /= len(vowels)\n    lastConsonantLen +=\
    \ 2\n    lastConsonantLen -= lastConsonantLen % len(vowels)\n    lastConsonantLen\
    \ /= len(vowels)\n    lastConsonantLen += 2\n    lastConsonantLen -= lastConsonantLen\
    \ % len(vowels)\n    lastConsonantLen /= len(vowels)\n    lastConsonantLen +=\
    \ 2\n    lastConsonantLen -= lastConsonantLen % len(vowels)\n    lastConsonantLen\
    \ /= len(vowels)\n    lastConsonantLen += 2\n    lastConsonantLen -= lastConsonantLen\
    \ % len(vowels)\n    lastConsonantLen /= len(vowels)\n    lastConsonantLen +=\
    \ 2\n    lastConsonantLen -= lastConsonantLen % \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpluvrlcm__test.go:76:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074790
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowel := []rune{'a', 'e', 'i', 'o', 'u'}\n    vowel_count\
    \ := 0\n    vowel_count += len(word) - len(word[:len(word)-1])\n    for _, v :=\
    \ range vowel {\n        if word[len(word)-1:] == v {\n            vowel_count++\n\
    \        }\n    }\n    if vowel_count > 0 {\n        return word[len(word)-1:]\n\
    \    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqlugz07__test.go:27:34: invalid operation: word[len(word) - 1:] == v (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074787
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    for _, v := range vowels {\n        if strings.Contains(word,\
    \ v) {\n            vowelsCount++\n        }\n    }\n    if vowelsCount == 0 {\n\
    \        return \"\"\n    }\n    vowelsCount -= 1\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp5dnmitnn_test.go:98:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074642
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpyvyobif7_test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6hf0nt82_test.go:100:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074641
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []rune(\"aeiou\")\n    vowelsLen := len(vowels)\n\
    \    \n    index := len(word) - 1\n    \n    vowel := \"\"\n    \n    for i :=\
    \ 0; i < vowelsLen; i++ {\n        if index >= 0 {\n            if word[index]\
    \ == vowels[i] {\n                vowel = vowels[i]\n                break\n \
    \           }\n            index--\n        }\n    }\n    \n    return vowel\n\
    }\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpzhp1rmc7_test.go:32:31: invalid operation: word[index] == vowels[i] (mismatched
    types byte and rune)

    /tmp/tmpzhp1rmc7_test.go:33:25: cannot use vowels[i] (variable of type rune) as
    type string in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074790
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6hf0nt82_test.go:100:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074641
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpyvyobif7_test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpw4oq0vvz_test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []rune{'a', 'e', 'i', 'o', 'u'}\n    vowelsLen\
    \ := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen += 2\n\
    \    \n    i := len(word) - 1\n    j := len(word) - 2\n    \n    vowelsCount :=\
    \ 0\n    \n    for ; i >= 0; i-- {\n        if word[i] == vowels[j] {\n      \
    \      vowelsCount++\n        }\n        j--\n    }\n    \n    if vowelsCount\
    \ > vowelsLen {\n        return \"\"\n    }\n    \n    for ; i < len(word); i++\
    \ {\n        if word[i] == vowels[j] {\n            vowelsCount++\n        }\n\
    \        j++\n    }\n    \n    if vowelsCount > vowelsLen {\n        return \"\
    \"\n    }\n    \n    return word[i]\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp77mzfdwn_test.go:35:23: invalid operation: word[i] == vowels[j] (mismatched
    types byte and rune)

    /tmp/tmp77mzfdwn_test.go:46:23: invalid operation: word[i] == vowels[j] (mismatched
    types byte and rune)

    /tmp/tmp77mzfdwn_test.go:56:12: cannot use word[i] (value of type byte) as type
    string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074790
