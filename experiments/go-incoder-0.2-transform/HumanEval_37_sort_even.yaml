name: HumanEval_37_sort_even
language: go_test.go
prompt: "package sort_even_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
  \ This function takes a list l and returns a list l' such that\n// l' is identical\
  \ to l in the odd indicies, while its values at the even indicies are equal\n//\
  \ to the values of the even indicies of l, but sorted.\n// >>> sort_even([]int{1,\
  \ 2, 3})\n// []int{1, 2, 3}\n// >>> sort_even([]int{5, 6, 3, 4})\n// []int{3, 6,\
  \ 5, 4}\nfunc sort_even(l []int) []int {\n"
tests: "func TestSort_Even(t *testing.T) {\n  candidate := sort_even\n\ttype test\
  \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests :=\
  \ []test{\n     { actual: candidate([]int{1, 2, 3}), expected: []int{1, 2, 3} },\n\
  \     { actual: candidate([]int{5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10}), expected:\
  \ []int{-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123} },\n     { actual: candidate([]int{5,\
  \ 8, -12, 4, 23, 2, 3, 11, 12, -10}), expected: []int{-12, 8, 3, 4, 5, 2, 12, 11,\
  \ 23, -10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
  \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
  \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
  , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
completions: ["    evens := make([]int, len(l))\n    evens = l\n    for i := 0; i\
    \ < len(l); i++ {\n        if i%2 == 0 {\n            evens[i] = l[i]\n      \
    \  }\n    }\n    sort.Sort(evens)\n    return evens\n}\n", "    l := make([]int,\
    \ len(l))\n    copy(l, l)\n    for i := 0; i < len(l); i++ {\n        if i%2 ==\
    \ 0 {\n            l[i] = l[i]\n        } else {\n            l[i] = l[i] + l[i-1]\n\
    \        }\n    }\n    return l\n}\n", "    evens := make([]int, len(l))\n   \
    \ odds := make([]int, len(l))\n    for i := range l {\n        if i%2 == 0 {\n\
    \            evens[i] = l[i]\n        } else {\n            odds[i] = l[i]\n \
    \       }\n    }\n    sort.Ints(evens)\n    sort.Ints(odds)\n    for i := range\
    \ l {\n        if i%2 == 0 {\n            l[i] = evens[i]\n        } else {\n\
    \            l[i] = odds[i]\n        }\n    }\n    return l\n}\n", "    evens\
    \ := make([]int, len(l))\n    odds := make([]int, len(l))\n    for i, v := range\
    \ l {\n        if i%2 == 0 {\n            evens[i] = v\n        } else {\n   \
    \         odds[i] = v\n        }\n    }\n    return append(sort_even(evens), sort_even(odds)...)\n\
    }\n", "    evens := make([]int, len(l))\n    for i := 0; i < len(l); i++ {\n \
    \       if i%2 == 0 {\n            evens[i] = l[i]\n        } else {\n       \
    \     evens[i] = l[i]\n        }\n    }\n    return evens\n}\n", "    evens :=\
    \ make([]int, len(l))\n    odds := make([]int, len(l))\n    evens = evens[:0]\n\
    \    odds = odds[:0]\n    for i, v := range l {\n        if i % 2 == 0 {\n   \
    \         evens = append(evens, v)\n        } else {\n            odds = append(odds,\
    \ v)\n        }\n    }\n    return append(evens, odds...)\n}\n", "    evens :=\
    \ make([]int, len(l))\n    for i := 0; i < len(l); i++ {\n        if i%2 == 0\
    \ {\n            evens[i] = l[i]\n        } else {\n            evens[i] = l[i]\n\
    \        }\n    }\n    return evens\n}\n", "    evens := make([]int, len(l))\n\
    \    odds := make([]int, len(l))\n    evens := make([]int, len(l))\n    for i\
    \ := 0; i < len(l); i++ {\n        if i % 2 == 0 {\n            evens[i] = l[i]\n\
    \        } else {\n            odds[i] = l[i]\n        }\n    }\n    sort.Sort(sort.Reverse(sort.IntSlice(evens)))\n\
    \    sort.Sort(sort.Reverse(sort.IntSlice(odds)))\n    for i := 0; i < len(l);\
    \ i++ {\n        if i % 2 == 0 {\n            l[i] = evens[i]\n        } else\
    \ {\n            l[i] = odds[i]\n        }\n    }\n    return l\n}\n", "    evens\
    \ := make([]int, len(l))\n    evens := evens[:0]\n    for i := 0; i < len(l);\
    \ i++ {\n        if i%2 == 0 {\n            evens = append(evens, l[i])\n    \
    \    } else {\n            evens = append(evens, l[i])\n            evens = append(evens,\
    \ l[i])\n        }\n    }\n    return evens\n}\n", "    l := make([]int, len(l))\n\
    \    copy(l, l)\n    sort.Sort(sort.Reverse(sort.IntSlice(l)))\n    return l\n\
    }\n", "    evens := make([]int, len(l))\n    for i := 0; i < len(l); i++ {\n \
    \       if i%2 == 0 {\n            evens[i] = l[i]\n        } else {\n       \
    \     evens[i] = l[i]\n        }\n    }\n    return evens\n}\n", "    evens :=\
    \ make([]int, len(l))\n    for i := 0; i < len(l); i++ {\n        if i%2 == 0\
    \ {\n            evens[i] = l[i]\n        } else {\n            evens[i] = l[i]\n\
    \        }\n    }\n    return evens\n}\n", "    evens := make([]int, len(l))\n\
    \    odds := make([]int, len(l))\n    evens = append(evens, l...)\n    odds =\
    \ append(odds, l...)\n    sort.Ints(evens)\n    sort.Ints(odds)\n    evens = append(evens,\
    \ evens...)\n    odds = append(odds, odds...)\n    return evens\n}\n", "    l\
    \ := make([]int, len(l))\n    copy(l, l)\n    sort.Sort(sort.Reverse(sort.IntSlice(l)))\n\
    \    return l\n}\n", "    evens := make([]int, len(l))\n    for i := 0; i < len(l);\
    \ i++ {\n        if i%2 == 0 {\n            evens[i] = l[i]\n        } else {\n\
    \            evens[i] = l[(i+1)/2]\n        }\n    }\n    return evens\n}\n",
  "    evens := make([]int, len(l))\n    odds := make([]int, len(l))\n    for i, v\
    \ := range l {\n        if i%2 == 0 {\n            evens[i] = v\n        } else\
    \ {\n            odds[i] = v\n        }\n    }\n    return append(sort_even(evens),\
    \ sort_even(odds)...)\n}\n", "    evens := make([]int, len(l))\n    odds := make([]int,\
    \ len(l))\n    i := 0\n    for _, v := range l {\n        if i%2 == 0 {\n    \
    \        evens[i] = v\n        } else {\n            odds[i] = v\n        }\n\
    \        i++\n    }\n    return append(odds, evens...)\n}\n", "    evens := make([]int,\
    \ len(l))\n    for i := 0; i < len(l); i++ {\n        if i%2 == 0 {\n        \
    \    evens[i] = l[i]\n        } else {\n            evens[i] = l[i]\n        }\n\
    \    }\n    return evens\n}\n", "    evens := make([]int, len(l))\n    for i :=\
    \ 0; i < len(l); i++ {\n        if i%2 == 0 {\n            evens[i] = l[i]\n \
    \       }\n    }\n    for i := 0; i < len(l); i++ {\n        if i%2 == 1 {\n \
    \           evens[i] = l[i]\n        }\n    }\n    return evens\n}\n", "    evens\
    \ := make([]int, len(l))\n    odds := make([]int, len(l))\n    for i, v := range\
    \ l {\n        if i%2 == 0 {\n            evens[i] = v\n        } else {\n   \
    \         odds[i] = v\n        }\n    }\n    return append(sort_even(evens), sort_even(odds)...)\n\
    }\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
