language: go_test.go
name: HumanEval_148_bf
results:
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2\
    \ = planet1, planet2\n    \n    planet1Orbit, planet2Orbit, sunOrbit := getOrbits(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1,\
    \ planet2)\n    \n    plan\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpx0jvrbh9_test.go:62:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074483
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2\
    \ = planet1, planet2\n    planet1Planet, planet2Planet, sun, planet1Orbit, planet2Orbit\
    \ := planet1, planet2, sun, planet1Orbit, planet2Orbit\n    planet1Planet, planet2Planet,\
    \ sun, planet1Orbit, planet2Orbit = planet1, planet2, sun, planet1Orbit, planet2Orbit\n\
    \    planet1Planet, planet2Planet, sun, planet1Orbit, planet2Orbit = planet1,\
    \ planet2, sun, planet1Orbit, planet2Orbit\n    planet1Planet, planet2Planet,\
    \ sun, planet1Orbit, planet2Orbit = planet1, planet2, sun, planet1Orbit, planet2Orbit\n\
    \    planet1Planet, planet2Planet, sun, planet1Orbit, planet2Orbit = planet1,\
    \ planet2, sun, planet1Orbit, planet2Orbit\n    planet1Planet, planet2Planet,\
    \ sun, planet1Orbit, planet2Orbit = planet1, planet2, sun, planet1Orbit, planet2Orbit\n\
    \    planet1Planet, planet2Planet, sun, planet1Orbit, planet2Orbit = planet1,\
    \ planet2, sun, planet1Orbit, planet2Orbit\n    planet1Planet, planet2Planet,\
    \ sun, planet1Orbit, planet2Orbit = planet1, planet2, sun, planet1Orbit, planet2Orbit\n\
    \    planet1Planet, planet2Planet, sun, planet1Orbit, planet2Orbit = planet1,\
    \ planet2, sun, planet1Orbit, planet2Orbit\n    planet1Planet, planet2Planet,\
    \ sun, planet1Orbit, planet2Orbit = planet1, planet2, sun, planet1Orbit, planet2Orbit\n\
    \    planet1Planet, planet2Planet, sun, planet1Orbit, planet2Orbit = plan\nfunc\
    \ TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp5ye7ul5q_test.go:37:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074483
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2\
    \ = planet1, planet2\n    planet1Planet, planet2Planet := planet1, planet2\n \
    \   planet1Planet, planet2Planet = planet1Planet, planet2Planet\n    planet1Planet,\
    \ planet2Planet = planet1Planet, planet2Planet\n    planet1Planet, planet2Planet\
    \ = planet1Planet, planet2Planet\n    planet1Planet, planet2Planet = planet1Planet,\
    \ planet2Planet\n    planet1Planet, planet2Planet = planet1Planet, planet2Planet\n\
    \    planet1Planet, planet2Planet = planet1Planet, planet2Planet\n    planet1Planet,\
    \ planet2Planet = planet1Planet, planet2Planet\n    planet1Planet, planet2Planet\
    \ = planet1Planet, planet2Planet\n    planet1Planet, planet2Planet = planet1Planet,\
    \ planet2Planet\n    planet1Planet, planet2Planet = planet1Planet, planet2Planet\n\
    \    planet1Planet, planet2Planet = planet1Planet, planet2Planet\n    planet1Planet,\
    \ planet2Planet = planet1Planet, planet2Planet\n    planet1Planet, planet2Planet\
    \ = planet1Planet, planet2Planet\n    planet1Planet, planet2Planet = planet1Planet,\
    \ planet2Planet\n    planet1Planet, planet2Planet = planet1Planet, planet2Planet\n\
    \    planet1Planet, planet2Planet = planet1Planet, planet2Planet\n    planet1Planet,\
    \ planet2Planet = planet1Planet, planet2Planet\n    planet1Planet, planet2Planet\
    \ = planet1Planet, planet2Planet\n    planet1Planet, planet2Planet = planet1Planet,\
    \ planet2Planet\n    planet\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpxu81skre_test.go:47:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074483
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit = getOrbits(planet2,\
    \ planet1)\n    planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n   \
    \ planet1Orbit, planet2Orbit = getOrbits(planet2, planet1)\n    planet1Orbit,\
    \ planet2Orbit = getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit =\
    \ getOrbits(planet2, planet1)\n    planet1Orbit, planet2Orbit = getOrbits(planet1,\
    \ planet2)\n    planet1Orbit, planet2Orbit = getOrbits(planet2, planet1)\n   \
    \ planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n    planet1Orbit,\
    \ planet2Orbit = getOrbits(planet2, planet1)\n    planet1Orbit, planet2Orbit =\
    \ getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit = getOrbits(planet2,\
    \ planet1)\n    planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n   \
    \ planet1Orbit, planet2Orbit = getOrbits(planet2, planet1)\n    planet1Orbit,\
    \ planet2Orbit = getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit =\
    \ getOrbits(planet2, planet1)\n    planet1Orbit, planet2Orbit = getOrbits(planet1,\
    \ planet2)\n    planet1Orbit, planet2Orbit = getOrbits(planet2, planet1)\n   \
    \ planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n    planet1Orbit,\
    \ planet2Orbit = getOrbits(planet2, planet1)\n    planet1Orbit, planet2Orbit =\
    \ getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit = getOrbits(planet2,\
    \ planet1)\n    planet1Or\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpbmgyh1vj_test.go:48:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074483
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit := planet1\n\
    \    planet2Orbit := planet2\n    planet1OrbitOrbit := planet1Orbit\n    planet2OrbitOrbit\
    \ := planet2Orbit\n    planet1OrbitOrbitOrbit := planet1OrbitOrbit\n    planet2OrbitOrbitOrbit\
    \ := planet2OrbitOrbit\n    planet1OrbitOrbitOrbitOrbit := planet1OrbitOrbitOrbit\n\
    \    planet2OrbitOrbitOrbitOrbit := planet2OrbitOrbitOrbit\n    planet1OrbitOrbitOrbitOrbitOrbit\
    \ := planet1OrbitOrbitOrbitOrbit\n    planet2OrbitOrbitOrbitOrbitOrbit := planet2OrbitOrbitOrbitOrbit\n\
    \    planet1OrbitOrbitOrbitOrbitOrbitOrbit := planet1OrbitOrbitOrbitOrbitOrbit\n\
    \    planet2OrbitOrbitOrbitOrbitOrbitOrbit := planet2OrbitOrbitOrbitOrbitOrbitOrbit\n\
    \    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\n\
    \    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\n\
    \    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\n\
    \    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\n\
    \    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpykhfapw6_test.go:42:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074483
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit, planet2Orbit := planet1, planet2\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp7p3xn0u6_test.go:51:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074483
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit := orbit(planet1)\n\
    \    planet2Orbit := orbit(planet2)\n    \n    planet1Sun := sun(planet1)\n  \
    \  planet2Sun := sun(planet2)\n    \n    planet1OrbitSun := orbit(planet1, planet1Sun)\n\
    \    planet2OrbitSun := orbit(planet2, planet2Sun)\n    \n    planet1OrbitSunSun\
    \ := orbit(planet1, planet1Sun, planet2Sun)\n    planet2OrbitSunSun := orbit(planet2,\
    \ planet2Sun, planet1Sun)\n    \n    planet1OrbitSunSunSun := orbit(planet1, planet1Sun,\
    \ planet2Sun, planet1SunSun)\n    planet2OrbitSunSunSun := orbit(planet2, planet2Sun,\
    \ planet1Sun, planet2SunSun)\n    \n    planet1OrbitSunSunSunSun := orbit(planet1,\
    \ planet1Sun, planet2Sun, planet1SunSunSun, planet2SunSunSun)\n    planet2OrbitSunSunSunSun\
    \ := orbit(planet2, planet2Sun, planet1Sun, planet2SunSunSun, planet1OrbitSunSunSunSun)\n\
    \    \n    planet1OrbitSunSunSunSun := orbit(planet1, planet1Sun, planet2Sun,\
    \ planet1SunSunSun, planet2OrbitSunSunSunSun)\n    planet2OrbitSunSunSunSun :=\
    \ orbit(planet2, planet2Sun, planet1Sun, planet2SunSunSun, planet2OrbitSunSunSunSun)\n\
    \    \n    planet1OrbitSunSunSunSun := orbit(planet1, planet1Sun, planet2Sun,\
    \ planet1SunSunSun, planet2OrbitSunSunSunSun)\n    planet2OrbitSunSunSunSun :=\
    \ orbit(planet2, planet2Sun, planet1Sun, planet2SunSunSun, planet2OrbitSunSunSunSun)\n\
    \    \n    planet1OrbitSunSunSunSun := orbit(planet1, planet\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpb22y7jcs_test.go:49:54: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074483
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit := planet1\n    planet2Orbit :=\
    \ planet2\n    \n    planet1OrbitOrbit := planet1\n    planet2OrbitOrbit := planet2\n\
    \    \n    planet1OrbitOrbitOrbit := planet1\n    planet2OrbitOrbitOrbit := planet2\n\
    \    \n    planet1OrbitOrbitOrbitOrbit := planet1\n    planet2OrbitOrbitOrbitOrbit\
    \ := planet2\n    \n    planet1OrbitOrbitOrbitOrbitOrbit := planet1\n    planet2OrbitOrbitOrbitOrbitOrbit\
    \ := planet2\n    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbit := planet1\n   \
    \ planet2OrbitOrbitOrbitOrbitOrbitOrbit := planet2\n    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2\n\
    \    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet1\n \
    \   planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2\n   \
    \ \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit :=\
    \ planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet2\n    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet2\n    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbit\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp7dp86xxe_test.go:59:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074483
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1\
    \ := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n\
    \    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2\
    \ := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n\
    \    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1\
    \ := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n\
    \    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2\
    \ := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n\
    \    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1\
    \ := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n\
    \    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2\
    \ := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n\
    \    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1\
    \ := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n\
    \    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2\
    \ := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp7i4ipxby_test.go:82:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074483
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit, planet2Orbit := planet1, planet2\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp7p3xn0u6_test.go:51:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074483
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit, err := getOrbit(planet1)\n  \
    \  if err != nil {\n        fmt.Println(err)\n    }\n    planet2Orbit, err :=\
    \ getOrbit(planet2)\n    if err != nil {\n        fmt.Println(err)\n    }\n  \
    \  \n    planet1Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet2Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    \n    planet1SunDistance := planet1Sun.Distance(planet1Orbit)\n  \
    \  planet2SunDistance := planet2Sun.Distance(planet2Orbit)\n    \n    planet1OrbitDistance\
    \ := planet1Orbit.Distance(planet1Sun)\n    planet2OrbitDistance := planet2Orbit.Distance(planet2Sun)\n\
    \    \n    planet1OrbitDistance /= planet1OrbitDistance\n    planet2OrbitDistance\
    \ /= planet2OrbitDistance\n    \n    planet1OrbitDistance *= planet1SunDistance\n\
    \    planet2OrbitDistance *= planet2SunDistance\n    \n    planet1OrbitDistance\
    \ /= planet1OrbitDistance\n    planet2OrbitDistance /= planet2OrbitDistance\n\
    \    \n    planet1OrbitDistance *= planet1OrbitDistance\n    planet2OrbitDistance\
    \ *= planet2OrbitDistance\n    \n    planet1OrbitDistance /= planet1OrbitDistance\n\
    \    planet2OrbitDistance /= planet2OrbitDistance\n    \n    planet1OrbitDistance\
    \ *= planet1OrbitDistance\n    planet2OrbitDistance *= planet2OrbitDistance\n\
    \    \n    planet1OrbitDistance /= planet1OrbitDistance\n    planet2OrbitDistance\
    \ /= planet2OrbitDistance\n    \n    planet1OrbitDistance *= planet1OrbitDistance\n\
    \    planet2OrbitDistance *= planet2OrbitDistance\n    \n    planet1OrbitDistance\
    \ /= planet1OrbitDistance\n    planet2OrbitDistance /= planet2OrbitDistance\n\
    \    \n    plan\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp63nohq55_test.go:80:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074483
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, err\
    \ := getOrbit(planet1)\n    if err != nil {\n        fmt.Println(err)\n    }\n\
    \    planet2Orbit, err := getOrbit(planet2)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet1Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet2Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet1OrbitSun := getOrbit(planet1)\n    planet2OrbitSun := getOrbit(planet2)\n\
    \    planet1SunSun := getSun()\n    planet2SunSun := getSun()\n    planet1OrbitSunSun\
    \ := getOrbit(planet1)\n    planet2OrbitSunSun := getOrbit(planet2)\n    planet1OrbitSunSun\
    \ := getOrbit(planet1)\n    planet2OrbitSunSun := getOrbit(planet2)\n    planet1OrbitSunSun\
    \ := getOrbit(planet1)\n    planet2OrbitSunSun := getOrbit(planet2)\n    planet1OrbitSunSun\
    \ := getOrbit(planet1)\n    planet2OrbitSunSun := getOrbit(planet2)\n    planet1OrbitSunSun\
    \ := getOrbit(planet1)\n    planet2OrbitSunSun := getOrbit(planet2)\n    planet1OrbitSunSun\
    \ := getOrbit(planet1)\n    planet2OrbitSunSun := getOrbit(planet2)\n    planet1OrbitSunSun\
    \ := getOrbit(planet1)\n    planet2OrbitSunSun := getOrbit(planet2)\n    planet1OrbitSunSun\
    \ := getOrbit(planet1)\n    planet2OrbitSunSun := getOrbit(planet2)\n    planet1OrbitSunSun\
    \ := getOrbit(planet1)\n    planet2OrbitSunSun := getOrbit(planet2)\n    planet1OrbitSunSun\
    \ := getOrbit(planet1)\n    plan\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpl7hpxg8g_test.go:65:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074483
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit := planet1Orbit(planet1)\n\
    \    planet2Orbit := planet2Orbit(planet2)\n    planet1Orbit.sort()\n    planet2Orbit.sort()\n\
    \    \n    planet1Orbit.intersect(planet2Orbit)\n    \n    return planet1Orbit.slice()\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpp29zcfyd_test.go:25:21: undefined: planet1Orbit

    /tmp/tmpp29zcfyd_test.go:26:21: undefined: planet2Orbit

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074484
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit = sortByProximity(planet1Orbit,\
    \ planet2Orbit)\n    return planet1Orbit\n}\n\nfunc TestBf(t *testing.T) {\n \
    \ candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpumwg0x5y_test.go:25:35: undefined: getOrbits

    /tmp/tmpumwg0x5y_test.go:26:34: undefined: sortByProximity

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074484
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := orbit(planet1, planet2)\n    planet1Orbit.sort()\n    planet2Orbit.sort()\n\
    \    \n    planet1Orbit.Intersection(planet2Orbit)\n    return planet1Orbit\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmppollkw_8_test.go:25:35: undefined: orbit

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074484
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := orbit(planet1, planet2)\n    planet1Orbit, planet2Orbit = sortByProximity(planet1Orbit,\
    \ planet2Orbit)\n    return planet1Orbit\n}\n\nfunc TestBf(t *testing.T) {\n \
    \ candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpsi4kvowt_test.go:25:35: undefined: orbit

    /tmp/tmpsi4kvowt_test.go:26:34: undefined: sortByProximity

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074484
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit := planet1Orbit(planet1)\n\
    \    planet2Orbit := planet2Orbit(planet2)\n    planet1Orbit.sort()\n    planet2Orbit.sort()\n\
    \    \n    result := []interface{}{}\n    \n    for i := 0; i < len(planet1Orbit)-1;\
    \ i++ {\n        if planet1Orbit[i] < planet2Orbit[i+1] {\n            result\
    \ = append(result, planet1Orbit[i])\n        }\n    }\n    \n    for i := 0; i\
    \ < len(planet2Orbit)-1; i++ {\n        if planet2Orbit[i] < planet1Orbit[i+1]\
    \ {\n            result = append(result, planet2Orbit[i])\n        }\n    }\n\
    \    \n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpb2ogfcni_test.go:25:21: undefined: planet1Orbit

    /tmp/tmpb2ogfcni_test.go:26:21: undefined: planet2Orbit

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074484
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := planet1, planet2\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6c773qfu_test.go:38:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074483
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, err\
    \ := getOrbit(planet1)\n    if err != nil {\n        fmt.Println(err)\n      \
    \  return nil\n    }\n    planet2Orbit, err := getOrbit(planet2)\n    if err !=\
    \ nil {\n        fmt.Println(err)\n        return nil\n    }\n    planet1Sun,\
    \ err := getSun()\n    if err != nil {\n        fmt.Println(err)\n        return\
    \ nil\n    }\n    planet2Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \        return nil\n    }\n    planet1SunDistance := planet1Orbit.Distance(planet1Sun)\n\
    \    planet2SunDistance := planet2Orbit.Distance(planet2Sun)\n    planet1SunDistance\
    \ += planet1Orbit.Distance(planet2Orbit)\n    planet2SunDistance += planet2Orbit.Distance(planet1Orbit)\n\
    \    planet1SunDistance += planet1Orbit.Distance(planet2Orbit)\n    planet2SunDistance\
    \ += planet2Orbit.Distance(planet1Orbit)\n    planet1SunDistance += planet1Orbit.Distance(planet2Orbit)\n\
    \    planet2SunDistance += planet2Orbit.Distance(planet1Orbit)\n    planet1SunDistance\
    \ += planet1Orbit.Distance(planet2Orbit)\n    planet2SunDistance += planet2Orbit.Distance(planet1Orbit)\n\
    \    planet1SunDistance += planet1Orbit.Distance(planet2Orbit)\n    planet2SunDistance\
    \ += planet2Orbit.Distance(planet1Orbit)\n    planet1SunDistance += planet1Orbit.Distance(planet2Orbit)\n\
    \    planet2SunDistance += planet2Orbit.Distance(planet1Orbit)\n    planet1SunDistance\
    \ += planet1Orbit.Distance(planet2Orbit)\n    planet2SunDistance += planet2Orbit.Distance(planet1Orbit)\n\
    \    planet1SunDistance += planet1Orbit.Distance(planet2Orbit)\n    planet2SunDistance\
    \ += planet2Orbit.Distance(planet1\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_8nbiaxq_test.go:62:56: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074483
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit := planet1\n    planet2Orbit :=\
    \ planet2\n    \n    planet1OrbitOrbit := planet1Orbit\n    planet2OrbitOrbit\
    \ := planet2Orbit\n    \n    planet1OrbitOrbitOrbit := planet1OrbitOrbit\n   \
    \ planet2OrbitOrbitOrbit := planet2OrbitOrbit\n    \n    planet1OrbitOrbitOrbitOrbit\
    \ := planet1OrbitOrbitOrbit\n    planet2OrbitOrbitOrbitOrbitOrbit := planet2OrbitOrbitOrbitOrbit\n\
    \    \n    planet1OrbitOrbitOrbitOrbitOrbit := planet1OrbitOrbitOrbitOrbit\n \
    \   planet2OrbitOrbitOrbitOrbitOrbitOrbit := planet2OrbitOrbitOrbitOrbitOrbit\n\
    \    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbit := planet1OrbitOrbitOrbitOrbitOrbitOrbit\n\
    \    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbit\n\
    \    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\n\
    \    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\n\
    \    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\n\
    \    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\n\
    \    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet1Orbit\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmplcck9dtd_test.go:53:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074483
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2\
    \ = planet1, planet2\n    \n    planet1Orbit, planet2Orbit := planet1, planet2\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Or\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp9ezkbm56_test.go:49:61: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074483
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := planet1Orbit(planet1, planet2)\n    planet1Orbit, planet2Orbit = planet2Orbit(planet1,\
    \ planet2)\n    planet1Orbit, planet2Orbit = planet1Orbit(planet1, planet2)\n\
    \    planet1Orbit, planet2Orbit = planet2Orbit(planet1, planet2)\n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit(planet1, planet2)\n    planet1Orbit, planet2Orbit\
    \ = planet2Orbit(planet1, planet2)\n    planet1Orbit, planet2Orbit = planet1Orbit(planet1,\
    \ planet2)\n    planet1Orbit, planet2Orbit = planet2Orbit(planet1, planet2)\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit(planet1, planet2)\n    planet1Orbit,\
    \ planet2Orbit = planet2Orbit(planet1, planet2)\n    planet1Orbit, planet2Orbit\
    \ = planet1Orbit(planet1, planet2)\n    planet1Orbit, planet2Orbit = planet2Orbit(planet1,\
    \ planet2)\n    planet1Orbit, planet2Orbit = planet1Orbit(planet1, planet2)\n\
    \    planet1Orbit, planet2Orbit = planet2Orbit(planet1, planet2)\n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit(planet1, planet2)\n    planet1Orbit, planet2Orbit\
    \ = planet2Orbit(planet1, planet2)\n    planet1Orbit, planet2Orbit = planet1Orbit(planet1,\
    \ planet2)\n    planet1Orbit, planet2Orbit = planet2Orbit(planet1, planet2)\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit(planet1, planet2)\n    planet1Orbit,\
    \ planet2Orbit = planet2Orbit\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp1m0uebbs_test.go:45:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074483
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit = sortByProximity(planet1Orbit,\
    \ planet2Orbit)\n    return planet1Orbit\n}\n\nfunc TestBf(t *testing.T) {\n \
    \ candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpumwg0x5y_test.go:25:35: undefined: getOrbits

    /tmp/tmpumwg0x5y_test.go:26:34: undefined: sortByProximity

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074484
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit := getOrbit(planet1)\n\
    \    planet2Orbit := getOrbit(planet2)\n    planet1Orbit.sort()\n    planet2Orbit.sort()\n\
    \    \n    result := []interface{}{}\n    \n    for _, planet1OrbitItem := range\
    \ planet1Orbit {\n        for _, planet2OrbitItem := range planet2Orbit {\n  \
    \          if planet1OrbitItem == planet2OrbitItem {\n                continue\
    \ // skip the planets themselves\n            }\n            if planet1OrbitItem.distance(planet2OrbitItem)\
    \ < planet1OrbitItem.distance(planet2OrbitItem) + planet2OrbitItem.distance(planet1OrbitItem)\
    \ {\n                result = append(result, planet1OrbitItem)\n            }\n\
    \        }\n    }\n    \n    return result\n}\n\nfunc TestBf(t *testing.T) {\n\
    \  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmnet9vs4_test.go:25:21: undefined: getOrbit

    /tmp/tmpmnet9vs4_test.go:26:21: undefined: getOrbit

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074484
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit, err := getOrbit(planet1)\n  \
    \  if err != nil {\n        fmt.Println(err)\n    }\n    planet2Orbit, err :=\
    \ getOrbit(planet2)\n    if err != nil {\n        fmt.Println(err)\n    }\n  \
    \  \n    planet1Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet2Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    \n    planet1SunDistance := planet1Sun.Distance(planet1Orbit)\n  \
    \  planet2SunDistance := planet2Sun.Distance(planet2Orbit)\n    \n    planet1OrbitDistance\
    \ := planet1Orbit.Distance(planet1Sun)\n    planet2OrbitDistance := planet2Orbit.Distance(planet2Sun)\n\
    \    \n    planet1OrbitDistance /= planet1OrbitDistance\n    planet2OrbitDistance\
    \ /= planet2OrbitDistance\n    \n    planet1OrbitDistance /= planet1SunDistance\n\
    \    planet2OrbitDistance /= planet2SunDistance\n    \n    planet1OrbitDistance\
    \ /= planet1Orbit.Distance(planet2Orbit)\n    planet2OrbitDistance /= planet2Orbit.Distance(planet1Orbit)\n\
    \    \n    planet1OrbitDistance /= planet1Orbit.Distance(planet1Sun)\n    planet2OrbitDistance\
    \ /= planet2Orbit.Distance(planet2Sun)\n    \n    planet1OrbitDistance /= planet1Orbit.Distance(planet1Orbit)\n\
    \    planet2OrbitDistance /= planet2Orbit.Distance(planet2Orbit)\n    \n    planet1OrbitDistance\
    \ /= planet1SunDistance\n    planet2OrbitDistance /= planet2SunDistance\n    \n\
    \    planet1OrbitDistance /= planet1Orbit.Distance(planet2Orbit)\n    planet2OrbitDistance\
    \ /= planet2Orbit.Distance(planet1Orbit)\n    \n    planet1Orbit\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp60qtrxky_test.go:74:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074483
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    planet1Orbit := planet1\n    planet2Orbit := planet2\n\
    \    planet1OrbitOrbit := planet1\n    planet2OrbitOrbit := planet2\n    planet1OrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbit := planet2\n    planet1OrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbit := planet2\n    planet1OrbitOrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbitOrbit := planet2\n    planet1OrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbit := planet2\n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2\n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2\n\
    \    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet2\n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit :=\
    \ planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet2\n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet2\n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbit\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmph1qphwbn_test.go:50:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074485
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, err\
    \ := planetOrbit(planet1)\n    if err != nil {\n        fmt.Println(err)\n   \
    \ }\n    planet2Orbit, err := planetOrbit(planet2)\n    if err != nil {\n    \
    \    fmt.Println(err)\n    }\n    planet1Sun, err := sunOrbit()\n    if err !=\
    \ nil {\n        fmt.Println(err)\n    }\n    planet2Sun, err := sunOrbit()\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    planet1SunProximity,\
    \ err := planetProximity(planet1Orbit, planet1Sun)\n    if err != nil {\n    \
    \    fmt.Println(err)\n    }\n    planet2SunProximity, err := planetProximity(planet2Orbit,\
    \ planet2Sun)\n    if err != nil {\n        fmt.Println(err)\n    }\n    planet1OrbitProximity,\
    \ err := planetProximity(planet1Orbit, planet2Orbit)\n    if err != nil {\n  \
    \      fmt.Println(err)\n    }\n    planet2OrbitProximity, err := planetProximity(planet2Orbit,\
    \ planet1Orbit)\n    if err != nil {\n        fmt.Println(err)\n    }\n    planet1OrbitProximity,\
    \ err := planetProximity(planet1Orbit, planet2Orbit)\n    if err != nil {\n  \
    \      fmt.Println(err)\n    }\n    planet2OrbitProximity, err := planetProximity(planet2Orbit,\
    \ planet1Orbit)\n    if err != nil {\n        fmt.Println(err)\n    }\n    planet1OrbitProximity,\
    \ err := planetProximity(planet1Orbit, planet2Orbit)\n    if err != nil {\n  \
    \      fmt.Println(err)\n    }\n    planet2OrbitProximity, err := planetProximity(planet2Orbit,\
    \ planet1Orbit)\n    if err != nil {\n        fmt.Println(err)\n    }\n    planet1OrbitProximity,\
    \ err := planetProximity(planet1Orbit, planet2Orbit)\n    if err != nil {\n  \
    \      fmt.Println(err)\n    }\n    planet2Orbit\nfunc TestBf(t *testing.T) {\n\
    \  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpjdmcmbnn_test.go:78:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074485
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit := orbit(planet1)\n\
    \    planet2Orbit := orbit(planet2)\n    \n    planet1Sun := sun(planet1)\n  \
    \  planet2Sun := sun(planet2)\n    \n    planet1OrbitSun := orbit(planet1, planet1Sun)\n\
    \    planet2OrbitSun := orbit(planet2, planet2Sun)\n    \n    planet1OrbitSunAndPlanet2Orbit\
    \ := planet1OrbitSun + planet2Orbit\n    \n    planet1OrbitSunAndPlanet2OrbitSun\
    \ := planet1OrbitSun + planet2OrbitSun\n    \n    planet1OrbitSunAndPlanet2OrbitSunAndPlanet2Orbit\
    \ := planet1OrbitSun + planet2OrbitSun + planet2Orbit\n    \n    planet1OrbitSunAndPlanet2OrbitSunAndPlanet2OrbitSun\
    \ := planet1OrbitSun + planet2OrbitSun + planet2OrbitSun + planet2Orbit\n    \n\
    \    planet1OrbitSunAndPlanet2OrbitSunAndPlanet2OrbitSunAndPlanet2Orbit := planet1OrbitSun\
    \ + planet2OrbitSun + planet2OrbitSun + planet2OrbitSun + planet2Orbit\n    \n\
    \    planet1OrbitSunAndPlanet2OrbitSunAndPlanet2OrbitSunAndPlanet2OrbitSun :=\
    \ planet1OrbitSun + planet2OrbitSun + planet2OrbitSun + planet2OrbitSun + planet2OrbitSun\
    \ + planet2Orbit\n    \n    planet1OrbitSunAndPlanet2OrbitSunAndPlanet2OrbitSunAndPlanet2OrbitSunAndPlanet2Orbit\
    \ := planet1OrbitSun + planet2OrbitSun + planet2OrbitSun + planet2OrbitSun + planet2OrbitSun\
    \ + planet2OrbitSun + planet2Orbit\n    \n    planet1OrbitSunAndPlanet2OrbitSunAndPlanet2OrbitSunAndPlanet2OrbitSunAndPlanet2OrbitSun\
    \ \nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp40fgyhr7_test.go:49:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074485
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := planet1, planet2\n    planet1Orbit, planet2Orbit = planet2Orbit, planet1Orbit\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit, planet2Orbit\n    planet1Orbit, planet2Orbit =\
    \ planet1Orbit, planet2Orbit\n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit, planet2Orbit\n    planet1Orbit, planet2Orbit =\
    \ planet1Orbit, planet2Orbit\n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit, planet2Orbit\n    planet1Orbit, planet2Orbit =\
    \ planet1Orbit, planet2Orbit\n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit, planet2Orbit\n    planet1Orbit, planet2Orbit =\
    \ planet1Orbit, planet2Orbit\n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit, planet2Orbit\n    planet1Orbit, planet2Orbit =\
    \ planet1Or\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpx95z_x0x_test.go:46:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074485
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1\
    \ := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n\
    \    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2\
    \ := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n\
    \    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1\
    \ := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n\
    \    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2\
    \ := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n\
    \    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1\
    \ := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n\
    \    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2\
    \ := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n\
    \    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1\
    \ := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n\
    \    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2\
    \ := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp7i4ipxby_test.go:82:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074483
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := orbit(planet1, planet2)\n    planet1Sun, planet2Sun := sun(planet1Orbit,\
    \ planet2Orbit)\n    planet1OrbitSun := orbit(planet1Orbit, planet1Sun)\n    planet2OrbitSun\
    \ := orbit(planet2Orbit, planet2Sun)\n    planet1OrbitSunSun := orbit(planet1OrbitSun,\
    \ planet2OrbitSun)\n    planet1OrbitSunSunSun := orbit(planet1OrbitSunSun, planet2OrbitSunSun)\n\
    \    planet1OrbitSunSunSunSun := orbit(planet1OrbitSunSunSun, planet2OrbitSunSunSun)\n\
    \    planet1OrbitSunSunSunSunSun := orbit(planet1OrbitSunSunSunSun, planet2OrbitSunSunSunSun)\n\
    \    planet1OrbitSunSunSunSunSunSun := orbit(planet1OrbitSunSunSunSunSun, planet2OrbitSunSunSunSunSun)\n\
    \    planet1OrbitSunSunSunSunSunSunSun := orbit(planet1OrbitSunSunSunSunSunSun,\
    \ planet2OrbitSunSunSunSunSun)\n    planet1OrbitSunSunSunSunSunSunSun := orbit(planet1OrbitSunSunSunSunSunSunSun,\
    \ planet2OrbitSunSunSunSunSunSun)\n    planet1OrbitSunSunSunSunSunSunSunSun :=\
    \ orbit(planet1OrbitSunSunSunSunSunSunSunSun, planet2OrbitSunSunSunSunSunSunSun)\n\
    \    planet1OrbitSunSunSunSunSunSunSunSunSun := orbit(planet1OrbitSunSunSunSunSunSunSunSunSun,\
    \ planet2OrbitSunSunSunSunSunSunSun)\n    planet1OrbitSunSunSunSunSunSunSunSunSun\
    \ := orbit(planet1OrbitSunSunSunSunSunSunSunSunSunSun, planet2OrbitSunSunSunSunSunSunSunSun)\n\
    \    planet1OrbitSunSunSunSunSunSunSunSunSunSun := orbit(planet1Or\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpgkdr0yh5_test.go:39:66: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074485
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := planet1Orbit(planet1, planet2)\n    planet1Orbit, planet2Orbit = planet2Orbit(planet1,\
    \ planet2)\n    planet1Orbit, planet2Orbit = planet1Orbit(planet1, planet2)\n\
    \    planet1Orbit, planet2Orbit = planet2Orbit(planet1, planet2)\n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit(planet1, planet2)\n    planet1Orbit, planet2Orbit\
    \ = planet2Orbit(planet1, planet2)\n    planet1Orbit, planet2Orbit = planet1Orbit(planet1,\
    \ planet2)\n    planet1Orbit, planet2Orbit = planet2Orbit(planet1, planet2)\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit(planet1, planet2)\n    planet1Orbit,\
    \ planet2Orbit = planet2Orbit(planet1, planet2)\n    planet1Orbit, planet2Orbit\
    \ = planet1Orbit(planet1, planet2)\n    planet1Orbit, planet2Orbit = planet2Orbit(planet1,\
    \ planet2)\n    planet1Orbit, planet2Orbit = planet1Orbit(planet1, planet2)\n\
    \    planet1Orbit, planet2Orbit = planet2Orbit(planet1, planet2)\n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit(planet1, planet2)\n    planet1Orbit, planet2Orbit\
    \ = planet2Orbit(planet1, planet2)\n    planet1Orbit, planet2Orbit = planet1Orbit(planet1,\
    \ planet2)\n    planet1Orbit, planet2Orbit = planet2Orbit(planet1, planet2)\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit(planet1, planet2)\n    planet1Orbit,\
    \ planet2Orbit = planet2Orbit\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp1m0uebbs_test.go:45:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074483
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit, err := getOrbit(planet1)\n  \
    \  if err != nil {\n        fmt.Println(err)\n    }\n    planet2Orbit, err :=\
    \ getOrbit(planet2)\n    if err != nil {\n        fmt.Println(err)\n    }\n  \
    \  \n    planet1Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet2Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    \n    planet1SunDistance := getDistance(planet1Orbit, planet1Sun)\n\
    \    planet2SunDistance := getDistance(planet2Orbit, planet2Sun)\n    \n    planet1SunDistance\
    \ += getDistance(planet1Orbit, planet2Orbit)\n    planet2SunDistance += getDistance(planet2Orbit,\
    \ planet1Orbit)\n    \n    planet1SunDistance += getDistance(planet1Orbit, planet2Orbit)\n\
    \    planet2SunDistance += getDistance(planet2Orbit, planet1Orbit)\n    \n   \
    \ planet1SunDistance += getDistance(planet1Orbit, planet2Orbit)\n    planet2SunDistance\
    \ += getDistance(planet2Orbit, planet1Orbit)\n    \n    planet1SunDistance +=\
    \ getDistance(planet1Orbit, planet2Orbit)\n    planet2SunDistance += getDistance(planet2Orbit,\
    \ planet1Orbit)\n    \n    planet1SunDistance += getDistance(planet1Orbit, planet2Orbit)\n\
    \    planet2SunDistance += getDistance(planet2Orbit, planet1Orbit)\n    \n   \
    \ planet1SunDistance += getDistance(planet1Orbit, planet2Orbit)\n    planet2SunDistance\
    \ += getDistance(planet2Orbit, planet1Orbit)\n    \n    planet1SunDistance +=\
    \ getDistance(planet1Orbit, planet2Orbit)\n    planet2SunDistance += getDistance(planet2Orbit,\
    \ planet1Orbit\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp0s6l_8ct_test.go:68:65: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074485
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    // Your code here\n\
    \    planet1Orbit, err := getOrbit(planet1)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet2Orbit, err := getOrbit(planet2)\n    if err != nil {\n    \
    \    fmt.Println(err)\n    }\n    planet1OrbitSun, err := getOrbitSun(planet1)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    planet2OrbitSun, err\
    \ := getOrbitSun(planet2)\n    if err != nil {\n        fmt.Println(err)\n   \
    \ }\n    planet1OrbitSunProximity, err := getOrbitSunProximity(planet1Orbit, planet1OrbitSun)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    planet2OrbitSunProximity,\
    \ err := getOrbitSunProximity(planet2Orbit, planet2OrbitSun)\n    if err != nil\
    \ {\n        fmt.Println(err)\n    }\n    planet1OrbitSunProximitySorted, err\
    \ := sortByProximity(planet1OrbitSunProximity)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet2OrbitSunProximitySorted, err := sortByProximity(planet2OrbitSunProximity)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    planet1OrbitSunProximitySortedSorted,\
    \ err := sortByProximity(planet1OrbitSunProximitySorted)\n    if err != nil {\n\
    \        fmt.Println(err)\n    }\n    planet2OrbitSunProximitySortedSorted, err\
    \ := sortByProximity(planet2OrbitSunProximitySorted)\n    if err != nil {\n  \
    \      fmt.Println(err)\n    }\n    planet1OrbitSunProximitySortedSortedSorted,\
    \ err := sortByProximity(planet1OrbitSunProximitySortedSorted)\n    if err !=\
    \ nil {\n        fmt.Println(err)\n    }\n    planet2OrbitSunProximitySortedSortedSorted,\
    \ err := sortByProximity(planet2OrbitSunProximitySortedSorted)\n    if err !=\
    \ nil {\n        fmt.Println(err)\n    }\n    planet1OrbitSunProximitySorted\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpbzwwlk4w_test.go:75:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074485
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, err\
    \ := getOrbit(planet1)\n    if err != nil {\n        return nil\n    }\n    planet2Orbit,\
    \ err := getOrbit(planet2)\n    if err != nil {\n        return nil\n    }\n \
    \   planet1Sun, err := getSun()\n    if err != nil {\n        return nil\n   \
    \ }\n    planet2Sun, err := getSun()\n    if err != nil {\n        return nil\n\
    \    }\n    planet1SunDistance := planet1Sun.Distance(planet1Orbit)\n    planet2SunDistance\
    \ := planet2Sun.Distance(planet2Orbit)\n    planet1OrbitDistance := planet1Orbit.Distance(planet1Sun)\n\
    \    planet2OrbitDistance := planet2Orbit.Distance(planet2Sun)\n    planet1OrbitDistance\
    \ /= planet1OrbitDistance\n    planet2OrbitDistance /= planet2OrbitDistance\n\
    \    planet1OrbitDistance /= planet1OrbitDistance\n    planet2OrbitDistance /=\
    \ planet2OrbitDistance\n    planet1OrbitDistance /= planet1OrbitDistance\n   \
    \ planet2OrbitDistance /= planet2OrbitDistance\n    planet1OrbitDistance /= planet1OrbitDistance\n\
    \    planet2OrbitDistance /= planet2OrbitDistance\n    planet1OrbitDistance /=\
    \ planet1OrbitDistance\n    planet2OrbitDistance /= planet2OrbitDistance\n   \
    \ planet1OrbitDistance /= planet1OrbitDistance\n    planet2OrbitDistance /= planet2OrbitDistance\n\
    \    planet1OrbitDistance /= planet1OrbitDistance\n    planet2OrbitDistance /=\
    \ planet2OrbitDistance\n    planet1OrbitDistance /= planet1OrbitDistance\n   \
    \ planet2OrbitDistance /= planet2OrbitDistance\n    planet1OrbitDistance /= planet1OrbitDistance\n\
    \    planet2OrbitDistance /= planet2OrbitDistance\n    planet1OrbitDistance /=\
    \ planet1OrbitDistance\n    planet2OrbitDistance /= planet2OrbitDistance\n   \
    \ planet1OrbitDistance /= planet1OrbitDistance\n    planet2OrbitDistance /= planet2Orbit\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp7kse99cc_test.go:67:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074485
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit := orbit(planet1)\n\
    \    planet2Orbit := orbit(planet2)\n    planet1Orbit.sort()\n    planet2Orbit.sort()\n\
    \    result := []interface{}{}\n    for _, planet1 := range planet1Orbit {\n \
    \       for _, planet2 := range planet2Orbit {\n            if planet1 == planet2\
    \ {\n                continue\n            }\n            distance := distance(planet1,\
    \ planet2)\n            if distance < 0 {\n                distance = -distance\n\
    \            }\n            if distance < planet1Orbit.Len() && distance < planet2Orbit.Len()\
    \ {\n                result = append(result, planet1)\n                break\n\
    \            }\n        }\n    }\n    return result\n}\n\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1y1m_oh0_test.go:25:21: undefined: orbit

    /tmp/tmp1y1m_oh0_test.go:26:21: undefined: orbit

    /tmp/tmp1y1m_oh0_test.go:35:25: undefined: distance

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074485
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := strings.ToLower(planet1)\n\
    \    planet2 := strings.ToLower(planet2)\n    planet1Orbit, err := getOrbit(planet1)\n\
    \    if err != nil {\n        fmt.Println(err)\n        return nil\n    }\n  \
    \  planet2Orbit, err := getOrbit(planet2)\n    if err != nil {\n        fmt.Println(err)\n\
    \        return nil\n    }\n    planet1Sun, err := getSun()\n    if err != nil\
    \ {\n        fmt.Println(err)\n        return nil\n    }\n    planet2Sun, err\
    \ := getSun()\n    if err != nil {\n        fmt.Println(err)\n        return nil\n\
    \    }\n    planet1SunDistance := planet1Sun.Distance(planet1Orbit)\n    planet2SunDistance\
    \ := planet2Sun.Distance(planet2Orbit)\n    planet1SunDistance += planet1Orbit.Distance(planet1Orbit)\n\
    \    planet2SunDistance += planet2Orbit.Distance(planet2Orbit)\n    planet1SunDistance\
    \ += planet1Orbit.Distance(planet2Orbit)\n    planet2SunDistance += planet2Orbit.Distance(planet1Orbit)\n\
    \    if planet1SunDistance < planet2SunDistance {\n        return append(planet1Orbit,\
    \ planet2Orbit)\n    }\n    return append(planet2Orbit, planet1Orbit)\n}\n\nfunc\
    \ TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp808qcv8n_test.go:25:13: no new variables on left side of :=

    /tmp/tmp808qcv8n_test.go:25:16: undefined: strings

    /tmp/tmp808qcv8n_test.go:26:13: no new variables on left side of :=

    /tmp/tmp808qcv8n_test.go:26:16: undefined: strings

    /tmp/tmp808qcv8n_test.go:27:26: undefined: getOrbit

    /tmp/tmp808qcv8n_test.go:32:26: undefined: getOrbit

    /tmp/tmp808qcv8n_test.go:37:24: undefined: getSun

    /tmp/tmp808qcv8n_test.go:42:24: undefined: getSun

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074485
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := planet1, planet2\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6c773qfu_test.go:38:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074483
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := getOrbits(planet1, planet2)\n    planet1Sun, planet2Sun := getSun(planet1,\
    \ planet2)\n    planet1SunProximity := getProximity(planet1Orbit, planet1Sun)\n\
    \    planet2SunProximity := getProximity(planet2Orbit, planet2Sun)\n    planet1Proximity\
    \ := getProximity(planet1Orbit, planet1Orbit)\n    planet2Proximity := getProximity(planet2Orbit,\
    \ planet2Orbit)\n    planet1ProximityProximity := getProximity(planet1Proximity,\
    \ planet1Proximity)\n    planet2ProximityProximity := getProximity(planet2Proximity,\
    \ planet2Proximity)\n    planet1ProximityProximityProximity := getProximity(planet1ProximityProximity,\
    \ planet1ProximityProximity)\n    planet2ProximityProximityProximity := getProximity(planet2ProximityProximity,\
    \ planet2ProximityProximity)\n    planet1ProximityProximityProximityProximity\
    \ := getProximity(planet1ProximityProximityProximity, planet1ProximityProximityProximity)\n\
    \    planet2ProximityProximityProximityProximity := getProximity(planet2ProximityProximityProximity,\
    \ planet2ProximityProximityProximity)\n    planet1ProximityProximityProximityProximityProximity\
    \ := getProximity(planet1ProximityProximityProximityProximity, planet1ProximityProximityProximityProximity)\n\
    \    planet2ProximityProximityProximityProximityProximity := getProximity(planet2ProximityProximityProximityProximity,\
    \ planet2ProximityProximityProximityProximity)\n    planet1Proxim\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp63hm9uj5_test.go:40:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074485
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit = getOrbits(planet2,\
    \ planet1)\n    planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n   \
    \ planet1Orbit, planet2Orbit = getOrbits(planet2, planet1)\n    planet1Orbit,\
    \ planet2Orbit = getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit =\
    \ getOrbits(planet2, planet1)\n    planet1Orbit, planet2Orbit = getOrbits(planet1,\
    \ planet2)\n    planet1Orbit, planet2Orbit = getOrbits(planet2, planet1)\n   \
    \ planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n    planet1Orbit,\
    \ planet2Orbit = getOrbits(planet2, planet1)\n    planet1Orbit, planet2Orbit =\
    \ getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit = getOrbits(planet2,\
    \ planet1)\n    planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n   \
    \ planet1Orbit, planet2Orbit = getOrbits(planet2, planet1)\n    planet1Orbit,\
    \ planet2Orbit = getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit =\
    \ getOrbits(planet2, planet1)\n    planet1Orbit, planet2Orbit = getOrbits(planet1,\
    \ planet2)\n    planet1Orbit, planet2Orbit = getOrbits(planet2, planet1)\n   \
    \ planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n    planet1Orbit,\
    \ planet2Orbit = getOrbits(planet2, planet1)\n    planet1Orbit, planet2Orbit =\
    \ getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit = getOrbits(planet2,\
    \ planet1)\n    planet1Or\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpbmgyh1vj_test.go:48:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074483
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit := orbit(planet1)\n\
    \    planet2Orbit := orbit(planet2)\n    \n    planet1Orbit.sort()\n    planet2Orbit.sort()\n\
    \    \n    result := []interface{}{}\n    \n    for _, planet := range planet1Orbit\
    \ {\n        if planet == planet2 {\n            result = append(result, planet)\n\
    \        }\n    }\n    \n    for _, planet := range planet2Orbit {\n        if\
    \ planet == planet1 {\n            result = append(result, planet)\n        }\n\
    \    }\n    \n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfudw2q6b_test.go:25:21: undefined: orbit

    /tmp/tmpfudw2q6b_test.go:26:21: undefined: orbit

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074485
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := planet1, planet2\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6c773qfu_test.go:38:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074483
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit = sortByProximity(planet1Orbit,\
    \ planet2Orbit)\n    return planet1Orbit\n}\n\nfunc TestBf(t *testing.T) {\n \
    \ candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpumwg0x5y_test.go:25:35: undefined: getOrbits

    /tmp/tmpumwg0x5y_test.go:26:34: undefined: sortByProximity

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074484
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2\
    \ = planet1, planet2\n    planet1Planet, planet2Planet := planet1, planet2\n \
    \   \n    planet1Planet = strings.ToLower(planet1Planet)\n    planet2Planet =\
    \ strings.ToLower(planet2Planet)\n    \n    planet1Planet = strings.Replace(planet1Planet,\
    \ \"_\", \" \", -1)\n    planet2Planet = strings.Replace(planet2Planet, \"_\"\
    , \" \", -1)\n    \n    planet1Planet = strings.Replace(planet1Planet, \" \",\
    \ \"-\", -1)\n    planet2Planet = strings.Replace(planet2Planet, \" \", \"-\"\
    , -1)\n    \n    planet1Planet = strings.Replace(planet1Planet, \"-\", \" \",\
    \ -1)\n    planet2Planet = strings.Replace(planet2Planet, \"-\", \" \", -1)\n\
    \    \n    planet1Planet = strings.Replace(planet1Planet, \".\", \" \", -1)\n\
    \    planet2Planet = strings.Replace(planet2Planet, \".\", \" \", -1)\n    \n\
    \    planet1Planet = strings.Replace(planet1Planet, \"/\", \" \", -1)\n    planet2Planet\
    \ = strings.Replace(planet2Planet, \"/\", \" \", -1)\n    \n    planet1Planet\
    \ = strings.Replace(planet1Planet, \"\\\\\", \" \", -1)\n    planet2Planet = strings.Replace(planet2Planet,\
    \ \"\\\\\", \" \", -1)\n    \n    planet1Planet = strings.Replace(planet1Planet,\
    \ \"*\", \" \", -1)\n    planet2Planet = strings.Replace(planet2Planet, \"*\"\
    , \" \", -1)\n    \n    planet1Planet = strings.Replace(planet1Planet, \"?\",\
    \ \" \", -1)\n    planet2Planet = strings.Replace(planet2Planet, \"?\", \" \"\
    , -1)\n    \n    planet1Planet = strings.Replace(planet1Planet, \"!\", \" \",\
    \ -1)\n    planet2Planet = strings.Replace(planet2Planet, \"!\", \" \", -1)\n\
    \    \n    planet1Planet = strings.Replace(planet1Planet, \"<\", \" \", -1)\n\
    \    planet2\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8k3broxq_test.go:60:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074485
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit = getOrbits(planet2,\
    \ planet1)\n    planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n   \
    \ planet1Orbit, planet2Orbit = getOrbits(planet2, planet1)\n    planet1Orbit,\
    \ planet2Orbit = getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit =\
    \ getOrbits(planet2, planet1)\n    planet1Orbit, planet2Orbit = getOrbits(planet1,\
    \ planet2)\n    planet1Orbit, planet2Orbit = getOrbits(planet2, planet1)\n   \
    \ planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n    planet1Orbit,\
    \ planet2Orbit = getOrbits(planet2, planet1)\n    planet1Orbit, planet2Orbit =\
    \ getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit = getOrbits(planet2,\
    \ planet1)\n    planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n   \
    \ planet1Orbit, planet2Orbit = getOrbits(planet2, planet1)\n    planet1Orbit,\
    \ planet2Orbit = getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit =\
    \ getOrbits(planet2, planet1)\n    planet1Orbit, planet2Orbit = getOrbits(planet1,\
    \ planet2)\n    planet1Orbit, planet2Orbit = getOrbits(planet2, planet1)\n   \
    \ planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n    planet1Orbit,\
    \ planet2Orbit = getOrbits(planet2, planet1)\n    planet1Orbit, planet2Orbit =\
    \ getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit = getOrbits(planet2,\
    \ planet1)\n    planet1Or\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpbmgyh1vj_test.go:48:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074483
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, err\
    \ := getOrbit(planet1)\n    if err != nil {\n        fmt.Println(err)\n    }\n\
    \    planet2Orbit, err := getOrbit(planet2)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet1OrbitSun, err := getOrbitSun(planet1)\n    if err != nil {\n\
    \        fmt.Println(err)\n    }\n    planet2OrbitSun, err := getOrbitSun(planet2)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    planet1OrbitSunSun\
    \ := getOrbitSunSun(planet1)\n    planet2OrbitSunSun := getOrbitSunSun(planet2)\n\
    \    planet1OrbitSunSunSun := getOrbitSunSunSun(planet1)\n    planet2OrbitSunSunSun\
    \ := getOrbitSunSunSun(planet2)\n    planet1OrbitSunSunSunSun := getOrbitSunSunSunSun(planet1)\n\
    \    planet2OrbitSunSunSunSun := getOrbitSunSunSunSun(planet2)\n    planet1OrbitSunSunSunSun\
    \ := getOrbitSunSunSunSun(planet1)\n    planet2OrbitSunSunSunSun := getOrbitSunSunSunSun(planet2)\n\
    \    planet1OrbitSunSunSunSun := getOrbitSunSunSunSun(planet1)\n    planet2OrbitSunSunSunSun\
    \ := getOrbitSunSunSunSun(planet2)\n    planet1OrbitSunSunSunSun := getOrbitSunSunSunSun(planet1)\n\
    \    planet2OrbitSunSunSunSun := getOrbitSunSunSunSun(planet2)\n    planet1OrbitSunSunSunSun\
    \ := getOrbitSunSunSunSun(planet1)\n    planet2OrbitSunSunSunSun := getOrbitSunSunSunSun(planet2)\n\
    \    planet1OrbitSunSunSunSun := getOrbitSunSunSunSun(planet1)\n    planet2OrbitSunSunSunSun\
    \ := getOrbitSunSunSunSun(planet2)\n    planet1OrbitSunSunSunSun := getOrbitSun\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6c093_pp_test.go:58:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074485
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, err\
    \ := getOrbit(planet1)\n    if err != nil {\n        return nil\n    }\n    planet2Orbit,\
    \ err := getOrbit(planet2)\n    if err != nil {\n        return nil\n    }\n \
    \   planet1Sun, err := getSun()\n    if err != nil {\n        return nil\n   \
    \ }\n    planet2Sun, err := getSun()\n    if err != nil {\n        return nil\n\
    \    }\n    planet1SunDistance := planet1Orbit.Distance(planet1Sun)\n    planet2SunDistance\
    \ := planet2Orbit.Distance(planet2Sun)\n    if planet1SunDistance < planet2SunDistance\
    \ {\n        planet1Orbit, planet2Orbit = planet2Orbit, planet1Orbit\n    }\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    planet1Orbit.Next(planet1Orbit)\n\
    \    planet2Orbit.Next(planet2Orbit)\n    planet1Orbit.Next(planet1Orbit)\n  \
    \  planet2Orbit.Next(planet2Orbit)\n    planet1Orbit.Next(planet1Orbit)\n    planet2Orbit.Next(planet2Orbit)\n\
    \    planet1Orbit.Next(planet1Orbit)\n    planet2Orbit.Next(planet2Orbit)\n  \
    \  planet1Orbit.Next(planet1Orbit)\n    planet2Orbit.Next(planet2Orbit)\n    planet1Orbit.Next(planet1Orbit)\n\
    \    planet2Orbit.Next(planet2Orbit)\n    planet1Orbit.Next(planet1Orbit)\n  \
    \  planet2Orbit.Next(planet2Orbit)\n    planet1Orbit.Next(planet1Orbit)\n    planet2Orbit.Next(planet2Orbit)\n\
    \    planet1Orbit.Next(planet1Orbit)\n    planet2Orbit.Next(planet2Orbit)\n  \
    \  planet1Orbit.Next(planet1Orbit)\n    planet2Orbit.Next(planet2Orbit)\n    planet1Orbit\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpqhvzjoeo_test.go:68:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074485
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit := orbit(planet1)\n\
    \    planet2Orbit := orbit(planet2)\n    \n    planet1Orbit.sort()\n    planet2Orbit.sort()\n\
    \    \n    result := []interface{}{}\n    \n    for _, planet := range planet1Orbit\
    \ {\n        if planet == planet2 {\n            result = append(result, planet)\n\
    \        }\n    }\n    \n    for _, planet := range planet2Orbit {\n        if\
    \ planet == planet1 {\n            result = append(result, planet)\n        }\n\
    \    }\n    \n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfudw2q6b_test.go:25:21: undefined: orbit

    /tmp/tmpfudw2q6b_test.go:26:21: undefined: orbit

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074485
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, err\
    \ := getOrbit(planet1)\n    if err != nil {\n        fmt.Println(err)\n    }\n\
    \    planet2Orbit, err := getOrbit(planet2)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet1Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet2Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet1SunDistance := planet1Sun.Distance(planet1Orbit)\n    planet2SunDistance\
    \ := planet2Sun.Distance(planet2Orbit)\n    planet1OrbitDistance := planet1Orbit.Distance(planet1Sun)\n\
    \    planet2OrbitDistance := planet2Orbit.Distance(planet2Sun)\n    planet1OrbitDistance\
    \ /= planet1OrbitDistance\n    planet2OrbitDistance /= planet2OrbitDistance\n\
    \    planet1OrbitDistance /= planet1OrbitDistance\n    planet2OrbitDistance /=\
    \ planet2OrbitDistance\n    planet1OrbitDistance /= planet1OrbitDistance\n   \
    \ planet2OrbitDistance /= planet2OrbitDistance\n    planet1OrbitDistance /= planet1OrbitDistance\n\
    \    planet2OrbitDistance /= planet2OrbitDistance\n    planet1OrbitDistance /=\
    \ planet1OrbitDistance\n    planet2OrbitDistance /= planet2OrbitDistance\n   \
    \ planet1OrbitDistance /= planet1OrbitDistance\n    planet2OrbitDistance /= planet2OrbitDistance\n\
    \    planet1OrbitDistance /= planet1OrbitDistance\n    planet2OrbitDistance /=\
    \ planet2OrbitDistance\n    planet1OrbitDistance /= planet1OrbitDistance\n   \
    \ planet2OrbitDistance /= planet2OrbitDistance\n    planet1OrbitDistance /= planet1OrbitDistance\n\
    \    planet2OrbitDistance /= planet2OrbitDistance\n    planet1OrbitDistance /=\
    \ planet1OrbitDistance\n    planet2OrbitDistance /= planet2OrbitDistance\n   \
    \ planet1OrbitDistance /= planet1OrbitDistance\n    \nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp131i1oco_test.go:67:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074485
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := planet1, planet2\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6c773qfu_test.go:38:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074483
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, err\
    \ := getOrbit(planet1)\n    if err != nil {\n        fmt.Println(err)\n    }\n\
    \    planet2Orbit, err := getOrbit(planet2)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet1Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet2Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet1SunDistance := planet1Orbit.Distance(planet1Sun)\n    planet2SunDistance\
    \ := planet2Orbit.Distance(planet2Sun)\n    planet1OrbitDistance := planet1Orbit.Distance(planet2Orbit)\n\
    \    planet2OrbitDistance := planet2Orbit.Distance(planet1Orbit)\n    planet1SunDistance\
    \ += planet1OrbitDistance\n    planet2SunDistance += planet2OrbitDistance\n  \
    \  planet1OrbitDistance += planet1SunDistance\n    planet2OrbitDistance += planet2SunDistance\n\
    \    planet1OrbitDistance /= 2\n    planet2OrbitDistance /= 2\n    planet1OrbitDistance\
    \ += planet1SunDistance\n    planet2OrbitDistance += planet2SunDistance\n    planet1OrbitDistance\
    \ /= 2\n    planet2OrbitDistance /= 2\n    planet1OrbitDistance += planet1SunDistance\n\
    \    planet2OrbitDistance += planet2SunDistance\n    planet1OrbitDistance /= 2\n\
    \    planet2OrbitDistance /= 2\n    planet1OrbitDistance += planet1SunDistance\n\
    \    planet2OrbitDistance += planet2SunDistance\n    planet1OrbitDistance /= 2\n\
    \    planet2OrbitDistance /= 2\n    planet1OrbitDistance += planet1SunDistance\n\
    \    planet2OrbitDistance += planet2SunDistance\n    planet1OrbitDistance /= 2\n\
    \    planet2OrbitDistance /= 2\n    planet1OrbitDistance += planet1SunDistance\n\
    \    planet2OrbitDistance += planet2SunDistance\n    planet1OrbitDistance /= 2\n\
    \    planet2OrbitDistance /= \nfunc TestBf(t *testing.T) {\n  candidate := bf\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphl3rlyvs_test.go:71:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074485
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit := orbit(planet1)\n\
    \    planet2Orbit := orbit(planet2)\n    \n    planet1Sun := sun(planet1)\n  \
    \  planet2Sun := sun(planet2)\n    \n    planet1OrbitSun := orbit(planet1, planet1Sun)\n\
    \    planet2OrbitSun := orbit(planet2, planet2Sun)\n    \n    planet1OrbitSunSun\
    \ := orbit(planet1, planet1Sun, planet2Sun)\n    planet2OrbitSunSun := orbit(planet2,\
    \ planet2Sun, planet1Sun)\n    \n    planet1OrbitSunSunSun := orbit(planet1, planet1Sun,\
    \ planet2Sun, planet1Sun)\n    planet2OrbitSunSunSun := orbit(planet2, planet2Sun,\
    \ planet1Sun, planet2Sun)\n    \n    planet1OrbitSunSunSunSun := orbit(planet1,\
    \ planet1Sun, planet2Sun, planet1Sun, planet2Sun)\n    planet2OrbitSunSunSunSun\
    \ := orbit(planet2, planet2Sun, planet1Sun, planet2Sun, planet1Sun)\n    \n  \
    \  planet1OrbitSunSunSunSun := orbit(planet1, planet1Sun, planet2Sun, planet1Sun,\
    \ planet2Sun, planet1Sun)\n    planet2OrbitSunSunSunSun := orbit(planet2, planet2Sun,\
    \ planet1Sun, planet2Sun, planet1Sun, planet2Sun)\n    \n    planet1OrbitSunSunSunSunSun\
    \ := orbit(planet1, planet1Sun, planet2Sun, planet1Sun, planet2Sun, planet1Sun,\
    \ planet2Sun)\n    planet2OrbitSunSunSunSunSun := orbit(planet2, planet2Sun, planet1Sun,\
    \ planet2Sun, planet1Sun, planet2Sun, planet1Sun)\n    \n    planet1OrbitSunSunSunSunSun\
    \ := orbit(planet1, planet1Sun, planet2Sun, \nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpxfu2ovt4_test.go:50:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074485
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := orbit(planet1, planet2)\n    planet1Orbit.sort()\n    planet2Orbit.sort()\n\
    \    planet1Orbit.intersect(planet2Orbit)\n    return planet1Orbit\n}\n\nfunc\
    \ TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpg6but6yt_test.go:25:35: undefined: orbit

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074486
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit, planet2Orbit := planet1, planet2\n\
    \    \n    planet1Orbit = planet1Orbit[:len(planet1Orbit)-1]\n    planet2Orbit\
    \ = planet2Orbit[:len(planet2Orbit)-1]\n    \n    planet1Orbit = planet1Orbit[:len(planet1Orbit)-1]\n\
    \    planet2Orbit = planet2Orbit[:len(planet2Orbit)-1]\n    \n    planet1Orbit\
    \ = planet1Orbit[:len(planet1Orbit)-1]\n    planet2Orbit = planet2Orbit[:len(planet2Orbit)-1]\n\
    \    \n    planet1Orbit = planet1Orbit[:len(planet1Orbit)-1]\n    planet2Orbit\
    \ = planet2Orbit[:len(planet2Orbit)-1]\n    \n    planet1Orbit = planet1Orbit[:len(planet1Orbit)-1]\n\
    \    planet2Orbit = planet2Orbit[:len(planet2Orbit)-1]\n    \n    planet1Orbit\
    \ = planet1Orbit[:len(planet1Orbit)-1]\n    planet2Orbit = planet2Orbit[:len(planet2Orbit)-1]\n\
    \    \n    planet1Orbit = planet1Orbit[:len(planet1Orbit)-1]\n    planet2Orbit\
    \ = planet2Orbit[:len(planet2Orbit)-1]\n    \n    planet1Orbit = planet1Orbit[:len(planet1Orbit)-1]\n\
    \    planet2Orbit = planet2Orbit[:len(planet2Orbit)-1]\n    \n    planet1Orbit\
    \ = planet1Orbit[:len(planet1Orbit)-1]\n    planet2Orbit = planet2Orbit[:len(planet2Orbit)-1]\n\
    \    \n    planet1Orbit = planet1Orbit[:len(planet1Orbit)-1]\n    planet2Orbit\
    \ = planet2Orbit[:len(planet2Orbit)-1]\n    \n    planet1Orbit = planet1\nfunc\
    \ TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp91ikm7m0_test.go:61:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074485
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit, planet1OrbitRadius := getOrbit(planet1)\n\
    \    planet2Orbit, planet2OrbitRadius := getOrbit(planet2)\n    \n    planet1SunRadius\
    \ := getSunRadius(planet1)\n    planet2SunRadius := getSunRadius(planet2)\n  \
    \  \n    planet1OrbitRadius += planet1SunRadius\n    planet2OrbitRadius += planet2SunRadius\n\
    \    \n    planet1OrbitRadius /= 2\n    planet2OrbitRadius /= 2\n    \n    planet1OrbitRadius\
    \ *= getDistance(planet1Orbit, planet2Orbit)\n    planet2OrbitRadius *= getDistance(planet2Orbit,\
    \ planet1Orbit)\n    \n    planet1OrbitRadius /= getDistance(planet1Orbit, planet2Orbit)\n\
    \    planet2OrbitRadius /= getDistance(planet2Orbit, planet1Orbit)\n    \n   \
    \ planet1OrbitRadius += planet1OrbitRadius\n    planet2OrbitRadius += planet2OrbitRadius\n\
    \    \n    planet1OrbitRadius /= 2\n    planet2OrbitRadius /= 2\n    \n    planet1OrbitRadius\
    \ *= getDistance(planet1Orbit, planet2Orbit)\n    planet2OrbitRadius *= getDistance(planet2Orbit,\
    \ planet1Orbit)\n    \n    planet1OrbitRadius /= getDistance(planet1Orbit, planet2Orbit)\n\
    \    planet2OrbitRadius /= getDistance(planet2Orbit, planet1Orbit)\n    \n   \
    \ planet1OrbitRadius += planet1OrbitRadius\n    planet2OrbitRadius += planet2OrbitRadius\n\
    \    \n    planet1OrbitRadius /= 2\n    planet2OrbitRadius /= 2\n    \n    planet1OrbitRadius\
    \ *= getDistance(planet1Orbit, planet2Orbit)\n    planet2Or\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp14un3xxi_test.go:66:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074485
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit = sortPlanets(planet1Orbit,\
    \ planet2Orbit)\n    return planet1Orbit\n}\n\nfunc TestBf(t *testing.T) {\n \
    \ candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0l1jkt5o_test.go:25:35: undefined: getOrbits

    /tmp/tmp0l1jkt5o_test.go:26:34: undefined: sortPlanets

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074486
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    // Your code here\n\
    \    planet1 := planet1\n    planet2 := planet2\n    planet1Orbit, planet2Orbit\
    \ := planet1, planet2\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit = planet1Orbit[:len(planet1Orbit)-1]\n\
    \    planet2Orbit = planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit = planet1Orbit[:len(planet1Orbit)-1]\n\
    \    planet2Orbit = planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit = planet1Orbit[:len(planet1Orbit)-1]\n\
    \    planet2Orbit = planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit = planet1Orbit[:len(planet1Orbit)-1]\n\
    \    planet2Orbit = planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit = planet1Orbit[:len(planet1Orbit)-1]\n\
    \    planet2Orbit = planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit = planet1Orbit[:len(planet1Orbit)-1]\n\
    \    planet2Orbit = planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit = planet1Orbit[:len(planet1Orbit)-1]\n\
    \    planet2Orbit = planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit = planet1Orbit[:len(planet1Orbit)-1]\n\
    \    planet2Orbit = planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit = planet1Orbit[:len(planet1Orbit)-1]\n\
    \    planet2Orbit = planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit = planet1Orbit[:len(planet1Orbit)-1]\n\
    \    planet2Orbit = plan\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvj6im_br_test.go:50:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074485
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit := orbit(planet1)\n\
    \    planet2Orbit := orbit(planet2)\n    \n    planet1Orbit.sort()\n    planet2Orbit.sort()\n\
    \    \n    result := []interface{}{}\n    \n    for _, planet := range planet1Orbit\
    \ {\n        for _, planet2 := range planet2Orbit {\n            if planet1 ==\
    \ planet2 {\n                continue\n            }\n            if planet1 ==\
    \ planet {\n                continue\n            }\n            if planet2 ==\
    \ planet {\n                continue\n            }\n            if planet1 >\
    \ planet2 {\n                planet1, planet2 = planet2, planet1\n           \
    \ }\n            if planet1 > planet2 {\n                planet1, planet2 = planet2,\
    \ planet1\n            }\n            if planet1 == planet2 {\n              \
    \  continue\n            }\n            if planet1 > planet2 {\n             \
    \   planet1, planet2 = planet2, planet1\n            }\n            if planet1\
    \ > planet2 {\n                planet1, planet2 = planet2, planet1\n         \
    \   }\n            if planet1 == planet2 {\n                continue\n       \
    \     }\n            if planet1 > planet2 {\n                planet1, planet2\
    \ = planet2, planet1\n            }\n            if planet1 > planet2 {\n    \
    \            planet1, planet2 = planet2, planet1\n            }\n            if\
    \ planet1 == planet2 {\n                continue\n            }\n            if\
    \ planet1 > planet2 {\n                planet1, planet2 = planet2, planet1\n \
    \           }\n            if planet1 > planet2 {\n                planet1, planet2\
    \ = planet2, planet1\n            }\n            if planet1 == planet2 {\n   \
    \             continue\n            }\n            if planet1 > planet2 {\n  \
    \              planet1, planet2 = planet2, planet1\n            }\n          \
    \  if planet1 > planet2 {\n                planet1, planet2 = planet2, planet1\n\
    \            }\n            if planet1 == planet2 {\n                continue\n\
    \            }\n            if planet1 > planet2 {\n                planet1, planet2\
    \ = planet2, planet1\n            }\n            if planet1 > planet2 {\n    \
    \            planet1, planet2 = planet2, planet1\n            }\n            if\
    \ planet1 == planet2 {\n                continue\n            }\n            if\
    \ planet1 > planet2 {\n                planet1, planet2 = planet2, planet1\n \
    \           }\n            if planet1 > planet2 {\nfunc TestBf(t *testing.T) {\n\
    \  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvf4hdmx1_test.go:102:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074486
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := planet1Orbit(planet1), planet2Orbit(planet2)\n    planet1Orbit, planet2Orbit\
    \ = planet1Orbit.([]interface{}), planet2Orbit.([]interface{})\n    \n    planet1Orbit\
    \ = append(planet1Orbit, planet2Orbit...)\n    planet2Orbit = append(planet2Orbit,\
    \ planet1Orbit...)\n    \n    sort.SliceStable(planet1Orbit, func(i, j int) bool\
    \ {\n        return planet1Orbit[i].(float64) - planet1Orbit[j].(float64) < 0\n\
    \    })\n    sort.SliceStable(planet2Orbit, func(i, j int) bool {\n        return\
    \ planet2Orbit[i].(float64) - planet2Orbit[j].(float64) < 0\n    })\n    \n  \
    \  return planet1Orbit\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkwtj2gm3_test.go:25:35: undefined: planet1Orbit

    /tmp/tmpkwtj2gm3_test.go:25:58: undefined: planet2Orbit

    /tmp/tmpkwtj2gm3_test.go:31:5: undefined: sort

    /tmp/tmpkwtj2gm3_test.go:34:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074486
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit = sortPlanets(planet1Orbit,\
    \ planet2Orbit)\n    return planet1Orbit\n}\n\nfunc TestBf(t *testing.T) {\n \
    \ candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0l1jkt5o_test.go:25:35: undefined: getOrbits

    /tmp/tmp0l1jkt5o_test.go:26:34: undefined: sortPlanets

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074486
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := strings.ToLower(planet1)\n\
    \    planet2 := strings.ToLower(planet2)\n    \n    planet1Orbit, err := getOrbit(planet1)\n\
    \    if err != nil {\n        return nil\n    }\n    planet2Orbit, err := getOrbit(planet2)\n\
    \    if err != nil {\n        return nil\n    }\n    \n    planet1Sun, err :=\
    \ getSun()\n    if err != nil {\n        return nil\n    }\n    planet2Sun, err\
    \ := getSun()\n    if err != nil {\n        return nil\n    }\n    \n    planet1SunDistance\
    \ := planet1Sun.Distance(planet1Orbit)\n    planet2SunDistance := planet2Sun.Distance(planet2Orbit)\n\
    \    \n    planet1OrbitDistance := planet1Orbit.Distance(planet1Sun)\n    planet2OrbitDistance\
    \ := planet2Orbit.Distance(planet2Sun)\n    \n    planet1OrbitDistance /= planet1OrbitDistance\n\
    \    planet2OrbitDistance /= planet2OrbitDistance\n    \n    planet1OrbitDistance\
    \ *= planet1OrbitDistance\n    planet2OrbitDistance *= planet2OrbitDistance\n\
    \    \n    planet1OrbitDistance /= planet1OrbitDistance\n    planet2OrbitDistance\
    \ /= planet2OrbitDistance\n    \n    planet1OrbitDistance *= planet1OrbitDistance\n\
    \    planet2OrbitDistance *= planet2OrbitDistance\n    \n    planet1OrbitDistance\
    \ /= planet1OrbitDistance\n    planet2OrbitDistance /= planet2OrbitDistance\n\
    \    \n    planet1OrbitDistance *= planet1OrbitDistance\n    planet2OrbitDistance\
    \ *= planet2OrbitDistance\n    \n    planet1OrbitDistance /= planet1OrbitDistance\n\
    \    planet2OrbitDistance /= planet2OrbitDistance\n    \n    planet1OrbitDistance\
    \ *= planet1OrbitDistance\n    planet2OrbitDistance *= planet2OrbitDistance\n\
    \    \n    planet1OrbitDistance /= planet1OrbitDistance\n    planet2OrbitDistance\
    \ /= planet2OrbitDistance\n    \n    planet1\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpskft3tkj_test.go:80:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074486
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    planet1Orbit, err := getOrbit(planet1)\n    if err\
    \ != nil {\n        fmt.Println(err)\n    }\n    planet2Orbit, err := getOrbit(planet2)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    planet1Sun, err :=\
    \ getSun(planet1)\n    if err != nil {\n        fmt.Println(err)\n    }\n    planet2Sun,\
    \ err := getSun(planet2)\n    if err != nil {\n        fmt.Println(err)\n    }\n\
    \    planet1SunDistance, err := getDistance(planet1Orbit, planet1Sun)\n    if\
    \ err != nil {\n        fmt.Println(err)\n    }\n    planet2SunDistance, err :=\
    \ getDistance(planet2Orbit, planet2Sun)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    if planet1SunDistance < planet2SunDistance {\n        planet1Orbit,\
    \ err := getOrbit(planet2)\n        if err != nil {\n            fmt.Println(err)\n\
    \        }\n        planet2Orbit, err := getOrbit(planet1)\n        if err !=\
    \ nil {\n            fmt.Println(err)\n        }\n        planet1Sun, err := getSun(planet1)\n\
    \        if err != nil {\n            fmt.Println(err)\n        }\n        planet2Sun,\
    \ err := getSun(planet2)\n        if err != nil {\n            fmt.Println(err)\n\
    \        }\n        planet1SunDistance, err := getDistance(planet1Orbit, planet1Sun)\n\
    \        if err != nil {\n            fmt.Println(err)\n        }\n        planet2SunDistance,\
    \ err := getDistance(planet2Orbit, planet2Sun)\n        if err != nil {\n    \
    \        fmt.Println(err)\n        }\n        if planet1SunDistance < planet2SunDistance\
    \ {\n            planet1Orbit, err := getOrbit(planet1)\n            if err !=\
    \ nil {\n                fmt.Println(err)\n            }\n            planet2Orbit,\
    \ err := getOrbit(planet2)\n            if err != nil {\n                fmt.Println(err)\n\
    \            }\n            planet1Sun, err := getSun(planet1)\n            if\
    \ err != nil {\n                fmt.Println(err)\n\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpwaju06jm_test.go:89:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074486
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := planet1Orbit(planet1), planet2Orbit(planet2)\n    planet1Orbit, planet2Orbit\
    \ = planet1Orbit.([]string), planet2Orbit.([]string)\n    \n    planet1Orbit,\
    \ planet2Orbit = sort.StringSlice(planet1Orbit), sort.StringSlice(planet2Orbit)\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit[1:], planet2Orbit[1:]\n \
    \   \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit[1:], planet2Orbit[1:]\n \
    \   \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit[1:], planet2Orbit[1:]\n \
    \   \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit[1:], planet2Orbit[1:]\n \
    \   \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit[1:], planet2Orbit[1:]\n \
    \   \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpy5ya0v07_test.go:50:94: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074486
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit = sortByProximity(planet1Orbit,\
    \ planet2Orbit)\n    return planet1Orbit\n}\n\nfunc TestBf(t *testing.T) {\n \
    \ candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpumwg0x5y_test.go:25:35: undefined: getOrbits

    /tmp/tmpumwg0x5y_test.go:26:34: undefined: sortByProximity

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074484
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, err\
    \ := getOrbit(planet1)\n    if err != nil {\n        return nil\n    }\n    planet2Orbit,\
    \ err := getOrbit(planet2)\n    if err != nil {\n        return nil\n    }\n \
    \   planet1Sun, err := getSun()\n    if err != nil {\n        return nil\n   \
    \ }\n    planet2Sun, err := getSun()\n    if err != nil {\n        return nil\n\
    \    }\n    planet1SunDistance := planet1Orbit.Distance(planet1Sun)\n    planet2SunDistance\
    \ := planet2Orbit.Distance(planet2Sun)\n    planet1SunDistance += planet1Orbit.Distance(planet2Orbit)\n\
    \    planet2SunDistance += planet2Orbit.Distance(planet1Orbit)\n    if planet1SunDistance\
    \ < planet2SunDistance {\n        return append([]interface{}{planet1}, bf2(planet1,\
    \ planet2)...)\n    }\n    return append([]interface{}{planet2}, bf2(planet2,\
    \ planet1)...)\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_vx_lxgr_test.go:25:26: undefined: getOrbit

    /tmp/tmp_vx_lxgr_test.go:29:26: undefined: getOrbit

    /tmp/tmp_vx_lxgr_test.go:33:24: undefined: getSun

    /tmp/tmp_vx_lxgr_test.go:37:24: undefined: getSun

    /tmp/tmp_vx_lxgr_test.go:46:47: undefined: bf2

    /tmp/tmp_vx_lxgr_test.go:48:43: undefined: bf2

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074487
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := strings.ToLower(planet1)\n\
    \    planet2 := strings.ToLower(planet2)\n    \n    planet1Orbit, err := getOrbit(planet1)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    planet2Orbit, err :=\
    \ getOrbit(planet2)\n    if err != nil {\n        fmt.Println(err)\n    }\n  \
    \  \n    planet1Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet2Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    \n    planet1SunDistance := getDistance(planet1Orbit, planet1Sun)\n\
    \    planet2SunDistance := getDistance(planet2Orbit, planet2Sun)\n    \n    planet1SunDistance\
    \ += getDistance(planet1Orbit, planet2Orbit)\n    planet2SunDistance += getDistance(planet2Orbit,\
    \ planet1Orbit)\n    \n    planet1SunDistance += getDistance(planet1Orbit, planet2Orbit)\n\
    \    planet2SunDistance += getDistance(planet2Orbit, planet1Orbit)\n    \n   \
    \ planet1SunDistance += getDistance(planet1Orbit, planet2Orbit)\n    planet2SunDistance\
    \ += getDistance(planet2Orbit, planet1Orbit)\n    \n    planet1SunDistance +=\
    \ getDistance(planet1Orbit, planet2Orbit)\n    planet2SunDistance += getDistance(planet2Orbit,\
    \ planet1Orbit)\n    \n    planet1SunDistance += getDistance(planet1Orbit, planet2Orbit)\n\
    \    planet2SunDistance += getDistance(planet2Orbit, planet1Orbit)\n    \n   \
    \ planet1SunDistance += getDistance(planet1Orbit, planet2Orbit)\n    planet2SunDistance\
    \ += getDistance(planet2Orbit, planet1Orbit)\n    \n    planet1SunDistance +=\
    \ getDistance(planet1Orbit, planet2Orbit)\n    planet2SunDistance += getDistance(planet2\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp0q8lqc49_test.go:68:46: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074486
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := getOrbits(planet1, planet2)\n    planet1Sun, planet2Sun := getSun(planet1)\n\
    \    planet1Sun, planet2Sun := getSun(planet2)\n    planet1Sun, planet2Sun :=\
    \ getSun(planet1)\n    planet1Sun, planet2Sun := getSun(planet2)\n    planet1Sun,\
    \ planet2Sun := getSun(planet1)\n    planet1Sun, planet2Sun := getSun(planet2)\n\
    \    planet1Sun, planet2Sun := getSun(planet1)\n    planet1Sun, planet2Sun :=\
    \ getSun(planet2)\n    planet1Sun, planet2Sun := getSun(planet1)\n    planet1Sun,\
    \ planet2Sun := getSun(planet2)\n    planet1Sun, planet2Sun := getSun(planet1)\n\
    \    planet1Sun, planet2Sun := getSun(planet2)\n    planet1Sun, planet2Sun :=\
    \ getSun(planet1)\n    planet1Sun, planet2Sun := getSun(planet2)\n    planet1Sun,\
    \ planet2Sun := getSun(planet1)\n    planet1Sun, planet2Sun := getSun(planet2)\n\
    \    planet1Sun, planet2Sun := getSun(planet1)\n    planet1Sun, planet2Sun :=\
    \ getSun(planet2)\n    planet1Sun, planet2Sun := getSun(planet1)\n    planet1Sun,\
    \ planet2Sun := getSun(planet2)\n    planet1Sun, planet2Sun := getSun(planet1)\n\
    \    planet1Sun, planet2Sun := getSun(planet2)\n    planet1Sun, planet2Sun :=\
    \ getSun(planet1)\n    planet1Sun, planet2Sun := getSun(planet2)\n    planet1Sun,\
    \ planet2Sun := getSun(planet1)\n    planet1Sun, planet2Sun := get\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpfn9pcbr7_test.go:52:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074486
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := strings.ToLower(planet1)\n\
    \    planet2 := strings.ToLower(planet2)\n    planet1Orbit, err := getPlanetOrbit(planet1)\n\
    \    if err != nil {\n        return nil\n    }\n    planet2Orbit, err := getPlanetOrbit(planet2)\n\
    \    if err != nil {\n        return nil\n    }\n    planet1Sun, err := getPlanetOrbit(\"\
    Sun\")\n    if err != nil {\n        return nil\n    }\n    planet2Sun, err :=\
    \ getPlanetOrbit(\"Sun\")\n    if err != nil {\n        return nil\n    }\n  \
    \  planet1SunDistance := planet1Sun.Distance(planet1Orbit)\n    planet2SunDistance\
    \ := planet2Sun.Distance(planet2Orbit)\n    planet1OrbitDistance := planet1Orbit.Distance(planet1Sun)\n\
    \    planet2OrbitDistance := planet2Orbit.Distance(planet2Sun)\n    if planet1OrbitDistance\
    \ < planet2OrbitDistance {\n        planet1Orbit, planet2Orbit = planet2Orbit,\
    \ planet1Orbit\n    }\n    if planet1OrbitDistance < planet2SunDistance {\n  \
    \      planet1Sun, planet2Sun = planet2Sun, planet1Sun\n    }\n    if planet1SunDistance\
    \ < planet2OrbitDistance {\n        planet1Sun, planet2Sun = planet2Sun, planet1Sun\n\
    \    }\n    if planet1OrbitDistance < planet1SunDistance {\n        planet1Sun,\
    \ planet1Orbit = planet1Orbit, planet1Sun\n    }\n    if planet2OrbitDistance\
    \ < planet2SunDistance {\n        planet2Sun, planet2Orbit = planet2Sun, planet2Orbit\n\
    \    }\n    if planet1OrbitDistance < planet2OrbitDistance {\n        planet1Sun,\
    \ planet2Sun = planet2Sun, planet1Sun\n    }\n    if planet1OrbitDistance < planet1SunDistance\
    \ {\n        planet1Sun, planet1Orbit = planet1Orbit, planet1Sun\n    }\n    if\
    \ planet2OrbitDistance < planet\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpyg8ansua_test.go:69:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074486
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit := planet1\n\
    \    planet2Orbit := planet2\n    \n    if planet1 == \"Mercury\" || planet1 ==\
    \ \"Venus\" || planet1 == \"Earth\" || planet1 == \"Mars\" || planet1 == \"Jupiter\"\
    \ || planet1 == \"Saturn\" || planet1 == \"Uranus\" || planet1 == \"Neptune\"\
    \ {\n        planet1Orbit = planet1\n    }\n    if planet2 == \"Mercury\" || planet2\
    \ == \"Venus\" || planet2 == \"Earth\" || planet2 == \"Mars\" || planet2 == \"\
    Jupiter\" || planet2 == \"Saturn\" || planet2 == \"Uranus\" || planet2 == \"Neptune\"\
    \ {\n        planet2Orbit = planet2\n    }\n    \n    planet1OrbitOrbit := planet1Orbit\
    \ + \"Orbit\"\n    planet2OrbitOrbit := planet2Orbit + \"Orbit\"\n    \n    planet1OrbitSun\
    \ := planet1Orbit + \"Sun\"\n    planet2OrbitSun := planet2Orbit + \"Sun\"\n \
    \   \n    planet1OrbitSunOrbit := planet1OrbitSun + \"Orbit\"\n    planet2OrbitSunOrbit\
    \ := planet2OrbitSun + \"Orbit\"\n    \n    planet1OrbitSunSun := planet1OrbitSun\
    \ + \"Sun\"\n    planet2OrbitSunSun := planet2OrbitSun + \"Sun\"\n    \n    planet1OrbitSunSunOrbit\
    \ := planet1OrbitSunSun + \"Orbit\"\n    planet2OrbitSunSunOrbit := planet2OrbitSunSun\
    \ + \"Orbit\"\n    \n    planet1OrbitSunSunSun := planet1OrbitSunSun + \"Sun\"\
    \n    planet2OrbitSunSunSun := planet2OrbitSunSun + \"Sun\"\n    \n    planet1OrbitSunSunSunOrbit\
    \ := planet1OrbitSunSunSun + \"Orbit\"\n    planet2OrbitSunSunSunOrbit := planet2OrbitSunSunSun\
    \ + \"Orbit\"\n    \n    planet1OrbitSunSunSunSun := planet1OrbitSunSunSun + \"\
    Sun\"\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvv6nyjcp_test.go:58:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074486
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit = sortPlanets(planet1Orbit,\
    \ planet2Orbit)\n    planet1Orbit, planet2Orbit = removeDuplicates(planet1Orbit,\
    \ planet2Orbit)\n    return planet1Orbit\n}\n\nfunc TestBf(t *testing.T) {\n \
    \ candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpki_f_2m0_test.go:25:35: undefined: getOrbits

    /tmp/tmpki_f_2m0_test.go:26:34: undefined: sortPlanets

    /tmp/tmpki_f_2m0_test.go:27:34: undefined: removeDuplicates

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074487
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    planet1Orbit, planet2Orbit := orbit(planet1, planet2)\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit, planet2Orbit\n    planet1Orbit, planet2Orbit =\
    \ planet1Orbit, planet2Orbit\n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit, planet2Orbit\n    planet1Orbit, planet2Orbit =\
    \ planet1Orbit, planet2Orbit\n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit, planet2Orbit\n    planet1Orbit, planet2Orbit =\
    \ planet1Orbit, planet2Orbit\n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit, planet2Orbit\n    planet1Orbit, planet2Orbit =\
    \ planet1Orbit, planet2Orbit\n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit, planet2Orbit\n    planet1Orbit, planet2Orbit =\
    \ planet1Orbit, planet2\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpucziltzy_test.go:47:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074486
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := orbit(planet1, planet2)\n    planet1Orbit, planet2Orbit = sortPlanets(planet1Orbit,\
    \ planet2Orbit)\n    return planet1Orbit\n}\n\nfunc TestBf(t *testing.T) {\n \
    \ candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5qhf8zf__test.go:25:35: undefined: orbit

    /tmp/tmp5qhf8zf__test.go:26:34: undefined: sortPlanets

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074487
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := orbit(planet1, planet2)\n    planet1Orbit, planet2Orbit = sortByProximity(planet1Orbit,\
    \ planet2Orbit)\n    return planet1Orbit\n}\n\nfunc TestBf(t *testing.T) {\n \
    \ candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpsi4kvowt_test.go:25:35: undefined: orbit

    /tmp/tmpsi4kvowt_test.go:26:34: undefined: sortByProximity

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074484
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := planet1Orbit(planet1, planet2)\n    planet1Orbit, planet2Orbit = planet2Orbit(planet1,\
    \ planet2)\n    planet1Orbit, planet2Orbit = planet1Orbit(planet2, planet1)\n\
    \    planet1Orbit, planet2Orbit = planet2Orbit(planet2, planet1)\n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit(planet1, planet2)\n    planet1Orbit, planet2Orbit\
    \ = planet2Orbit(planet1, planet2)\n    planet1Orbit, planet2Orbit = planet1Orbit(planet2,\
    \ planet1)\n    planet1Orbit, planet2Orbit = planet2Orbit(planet2, planet1)\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit(planet1, planet2)\n    planet1Orbit,\
    \ planet2Orbit = planet2Orbit(planet1, planet2)\n    planet1Orbit, planet2Orbit\
    \ = planet1Orbit(planet2, planet1)\n    planet1Orbit, planet2Orbit = planet2Orbit(planet2,\
    \ planet1)\n    planet1Orbit, planet2Orbit = planet1Orbit(planet1, planet2)\n\
    \    planet1Orbit, planet2Orbit = planet2Orbit(planet1, planet2)\n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit(planet2, planet1)\n    planet1Orbit, planet2Orbit\
    \ = planet2Orbit(planet2, planet1)\n    planet1Orbit, planet2Orbit = planet1Orbit(planet1,\
    \ planet2)\n    planet1Orbit, planet2Orbit = planet2Orbit(planet1, planet2)\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit(planet2, planet1)\n    planet1Orbit,\
    \ planet2Orbit = planet2Orbit\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpykw8h4hn_test.go:45:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074486
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit, planet2Orbit := planet1Orbit(planet1,\
    \ planet2)\n    planet1Orbit2, planet2Orbit2 := planet1Orbit(planet2, planet1)\n\
    \    \n    planet1Orbit, planet2Orbit, planet1Orbit2, planet2Orbit2 := planet1Orbit(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit, planet1Orbit2, planet2Orbit2\
    \ := planet1Orbit(planet1, planet2)\n    \n    planet1Orbit, planet2Orbit, planet1Orbit2,\
    \ planet2Orbit2 := planet1Orbit(planet1, planet2)\n    \n    planet1Orbit, planet2Orbit,\
    \ planet1Orbit2, planet2Orbit2 := planet1Orbit(planet1, planet2)\n    \n    planet1Orbit,\
    \ planet2Orbit, planet1Orbit2, planet2Orbit2 := planet1Orbit(planet1, planet2)\n\
    \    \n    planet1Orbit, planet2Orbit, planet1Orbit2, planet2Orbit2 := planet1Orbit(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit, planet1Orbit2, planet2Orbit2\
    \ := planet1Orbit(planet1, planet2)\n    \n    planet1Orbit, planet2Orbit, planet1Orbit2,\
    \ planet2Orbit2 := planet1Orbit(planet1, planet2)\n    \n    planet1Orbit, planet2Orbit,\
    \ planet1Orbit2, planet2Orbit2 := planet1Orbit(planet1, planet2)\n    \n    planet1Orbit,\
    \ planet2Orbit, planet1Orbit2, planet2Orbit2 := planet1Orbit(planet1, planet2)\n\
    \    \n    planet1Orbit, planet2Orbit, planet1Orbit2, planet2Orbit2 := plan\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpz8rwfkun_test.go:52:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074487
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    planet1Orbit, planet2Orbit := planet1, planet2\n\
    \    planet1Orbit, planet2Orbit = planet2, planet1\n    planet1Orbit, planet2Orbit\
    \ = planet1, planet2\n    planet1Orbit, planet2Orbit = planet2, planet1\n    planet1Orbit,\
    \ planet2Orbit = planet1, planet2\n    planet1Orbit, planet2Orbit = planet2, planet1\n\
    \    planet1Orbit, planet2Orbit = planet1, planet2\n    planet1Orbit, planet2Orbit\
    \ = planet2, planet1\n    planet1Orbit, planet2Orbit = planet1, planet2\n    planet1Orbit,\
    \ planet2Orbit = planet2, planet1\n    planet1Orbit, planet2Orbit = planet1, planet2\n\
    \    planet1Orbit, planet2Orbit = planet2, planet1\n    planet1Orbit, planet2Orbit\
    \ = planet1, planet2\n    planet1Orbit, planet2Orbit = planet2, planet1\n    planet1Orbit,\
    \ planet2Orbit = planet1, planet2\n    planet1Orbit, planet2Orbit = planet2, planet1\n\
    \    planet1Orbit, planet2Orbit = planet1, planet2\n    planet1Orbit, planet2Orbit\
    \ = planet2, planet1\n    planet1Orbit, planet2Orbit = planet1, planet2\n    planet1Orbit,\
    \ planet2Orbit = planet2, planet1\n    planet1Orbit, planet2Orbit = planet1, planet2\n\
    \    planet1Orbit, planet2Orbit = planet2, planet1\n    planet1Orbit, planet2Orbit\
    \ = planet1, planet2\n    planet1Orbit, planet2Orbit = planet2, planet1\n    planet1Orbit,\
    \ planet2Orbit = plan\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpo4m6ve0r_test.go:52:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074487
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    planet1 := strings.ToLower(planet1)\n    planet2\
    \ := strings.ToLower(planet2)\n    planet1 := strings.Trim(planet1, \" \")\n \
    \   planet2 := strings.Trim(planet2, \" \")\n    planet1 := strings.ToUpper(planet1)\n\
    \    planet2 := strings.ToUpper(planet2)\n    planet1 := strings.Replace(planet1,\
    \ \" \", \"_\", -1)\n    planet2 := strings.Replace(planet2, \" \", \"_\", -1)\n\
    \    planet1 := strings.Replace(planet1, \"_\", \" \", -1)\n    planet2 := strings.Replace(planet2,\
    \ \"_\", \" \", -1)\n    planet1 := strings.Replace(planet1, \"-\", \" \", -1)\n\
    \    planet2 := strings.Replace(planet2, \"-\", \" \", -1)\n    planet1 := strings.Replace(planet1,\
    \ \"/\", \" \", -1)\n    planet2 := strings.Replace(planet2, \"/\", \" \", -1)\n\
    \    planet1 := strings.Replace(planet1, \"\\\\\", \" \", -1)\n    planet2 :=\
    \ strings.Replace(planet2, \"\\\\\", \" \", -1)\n    planet1 := strings.Replace(planet1,\
    \ \"@\", \" \", -1)\n    planet2 := strings.Replace(planet2, \"@\", \" \", -1)\n\
    \    planet1 := strings.Replace(planet1, \"#\", \" \", -1)\n    planet2 := strings.Replace(planet2,\
    \ \"#\", \" \", -1)\n    planet1 := strings.Replace(planet1, \"$\", \" \", -1)\n\
    \    planet2 := strings.Replace(planet2, \"$\", \" \", -1)\n    planet1 := strings.Replace(planet1,\
    \ \"%\", \" \", -1)\n    planet2 := strings.Replace(planet2, \"%\", \" \", -1)\n\
    \    planet1 := strings.Replace(planet1, \"^\", \" \", -1)\n    planet2 := strings.Replace(planet2,\
    \ \"^\", \" \", -1)\n    planet1 := strings.Replace(planet1, \"&\", \" \", -1)\n\
    \    planet2 := strings.Replace(planet2, \"&\", \" \", -1)\n    planet1 := strings.Replace(planet1,\
    \ \"*\", \" \", -1)\n    planet2 := strings.Replace(planet2, \"*\", \" \", -1)\n\
    \    planet1 := strings.Replace(\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpazbogm5f_test.go:58:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074487
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := planet1Orbit(planet1), planet2Orbit(planet2)\n    planet1Orbit.sort()\n \
    \   planet2Orbit.sort()\n    planet1Orbit.intersect(planet2Orbit)\n    return\
    \ planet1Orbit\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1v728xxx_test.go:25:35: undefined: planet1Orbit

    /tmp/tmp1v728xxx_test.go:25:58: undefined: planet2Orbit

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074487
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := orbit(planet1, planet2)\n    planet1Orbit, planet2Orbit = sortByProximity(planet1Orbit,\
    \ planet2Orbit)\n    return planet1Orbit\n}\n\nfunc TestBf(t *testing.T) {\n \
    \ candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpsi4kvowt_test.go:25:35: undefined: orbit

    /tmp/tmpsi4kvowt_test.go:26:34: undefined: sortByProximity

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074484
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit := planet1\n\
    \    planet2Orbit := planet2\n    \n    planet1OrbitOrbit := planet1Orbit\n  \
    \  planet2OrbitOrbit := planet2Orbit\n    \n    planet1OrbitOrbitOrbit := planet1OrbitOrbit\n\
    \    planet2OrbitOrbitOrbit := planet2OrbitOrbit\n    \n    planet1OrbitOrbitOrbitOrbit\
    \ := planet1OrbitOrbitOrbit\n    planet2OrbitOrbitOrbitOrbit := planet2OrbitOrbitOrbit\n\
    \    \n    planet1OrbitOrbitOrbitOrbitOrbit := planet1OrbitOrbitOrbitOrbit\n \
    \   planet2OrbitOrbitOrbitOrbitOrbit := planet2OrbitOrbitOrbitOrbit\n    \n  \
    \  planet1OrbitOrbitOrbitOrbitOrbitOrbit := planet1OrbitOrbitOrbitOrbitOrbit\n\
    \    planet2OrbitOrbitOrbitOrbitOrbitOrbit := planet2OrbitOrbitOrbitOrbitOrbitOrbit\n\
    \    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbit\n\
    \    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\n\
    \    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\n\
    \    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\n\
    \    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpme0srrfi_test.go:50:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074487
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit = getOrbits(planet2,\
    \ planet1)\n    planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n   \
    \ planet1Orbit, planet2Orbit = getOrbits(planet2, planet1)\n    planet1Orbit,\
    \ planet2Orbit = getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit =\
    \ getOrbits(planet2, planet1)\n    planet1Orbit, planet2Orbit = getOrbits(planet1,\
    \ planet2)\n    planet1Orbit, planet2Orbit = getOrbits(planet2, planet1)\n   \
    \ planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n    planet1Orbit,\
    \ planet2Orbit = getOrbits(planet2, planet1)\n    planet1Orbit, planet2Orbit =\
    \ getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit = getOrbits(planet2,\
    \ planet1)\n    planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n   \
    \ planet1Orbit, planet2Orbit = getOrbits(planet2, planet1)\n    planet1Orbit,\
    \ planet2Orbit = getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit =\
    \ getOrbits(planet2, planet1)\n    planet1Orbit, planet2Orbit = getOrbits(planet1,\
    \ planet2)\n    planet1Orbit, planet2Orbit = getOrbits(planet2, planet1)\n   \
    \ planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n    planet1Orbit,\
    \ planet2Orbit = getOrbits(planet2, planet1)\n    planet1Orbit, planet2Orbit =\
    \ getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit = getOrbits(planet2,\
    \ planet1)\n    planet1Or\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpbmgyh1vj_test.go:48:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074483
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := planet1Orbit(planet1, planet2), planet2Orbit(planet1, planet2)\n    if planet1Orbit\
    \ == \"\" {\n        return nil\n    }\n    if planet2Orbit == \"\" {\n      \
    \  return nil\n    }\n    planet1Orbit, planet2Orbit = planet1Orbit.([]interface{}),\
    \ planet2Orbit.([]interface{})\n    planet1Orbit, planet2Orbit = append(planet1Orbit,\
    \ planet1), append(planet1Orbit, planet2)\n    planet1Orbit, planet2Orbit = append(planet1Orbit,\
    \ planet2), append(planet1Orbit, planet1)\n    planet1Orbit, planet2Orbit = append(planet1Orbit,\
    \ planet1), append(planet1Orbit, planet2)\n    planet1Orbit, planet2Orbit = append(planet1Orbit,\
    \ planet2), append(planet1Orbit, planet1)\n    planet1Orbit, planet2Orbit = append(planet1Orbit,\
    \ planet1), append(planet1Orbit, planet2)\n    planet1Orbit, planet2Orbit = append(planet1Orbit,\
    \ planet2), append(planet1Orbit, planet1)\n    planet1Orbit, planet2Orbit = append(planet1Orbit,\
    \ planet1), append(planet1Orbit, planet2)\n    planet1Orbit, planet2Orbit = append(planet1Orbit,\
    \ planet2), append(planet1Orbit, planet1)\n    planet1Orbit, planet2Orbit = append(planet1Orbit,\
    \ planet1), append(planet1Orbit, planet2)\n    planet1Orbit, planet2Orbit = append(planet1Orbit,\
    \ planet2), append(planet1Orbit, planet1)\n    planet1Orbit, planet2Orbit = append(planet1Orbit,\
    \ planet2), append(planet1Orbit, planet1)\n    planet1Orbit, planet2Orbit = append(planet1Orbit,\
    \ planet1), append(planet1Orbit, planet2)\n    \nfunc TestBf(t *testing.T) {\n\
    \  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpnm_pvtbl_test.go:46:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074487
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1.ToLower(), planet2.ToLower()\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpkc03pxac_test.go:54:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074487
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, err\
    \ := getOrbit(planet1)\n    if err != nil {\n        fmt.Println(err)\n      \
    \  return nil\n    }\n    planet2Orbit, err := getOrbit(planet2)\n    if err !=\
    \ nil {\n        fmt.Println(err)\n        return nil\n    }\n    planet1Sun,\
    \ err := getSun()\n    if err != nil {\n        fmt.Println(err)\n        return\
    \ nil\n    }\n    planet2Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \        return nil\n    }\n    planet1SunDistance := getDistance(planet1Orbit,\
    \ planet1Sun)\n    planet2SunDistance := getDistance(planet2Orbit, planet2Sun)\n\
    \    planet1OrbitDistance := getDistance(planet1Orbit, planet2Orbit)\n    planet2OrbitDistance\
    \ := getDistance(planet2Orbit, planet1Orbit)\n    planet1OrbitDistance /= getDistance(planet1Sun,\
    \ planet1Orbit)\n    planet2OrbitDistance /= getDistance(planet2Sun, planet2Orbit)\n\
    \    planet1OrbitDistance /= getDistance(planet1Sun, planet2Orbit)\n    planet2OrbitDistance\
    \ /= getDistance(planet2Sun, planet1Orbit)\n    planet1OrbitDistance /= getDistance(planet1Sun,\
    \ planet1Orbit)\n    planet2OrbitDistance /= getDistance(planet2Sun, planet2Orbit)\n\
    \    planet1OrbitDistance /= getDistance(planet1Sun, planet1Orbit)\n    planet2OrbitDistance\
    \ /= getDistance(planet2Sun, planet2Orbit)\n    planet1OrbitDistance /= getDistance(planet1Sun,\
    \ planet1Orbit)\n    planet2OrbitDistance /= getDistance(planet2Sun, planet2Orbit)\n\
    \    planet1OrbitDistance /= getDistance(planet1Sun, planet1Orbit)\n    planet2OrbitDistance\
    \ /= getDistance(planet2Sun, planet2Orbit)\n    planet1OrbitDistance /= getDistance(planet1Sun,\
    \ planet1Orbit)\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphn317_g2_test.go:62:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074487
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit := planet1\n    planet2Orbit :=\
    \ planet2\n    \n    planet1Orbit, planet2Orbit = planet1Orbit.(string), planet2Orbit.(string)\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit.(string), planet2Orbit.(string)\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit.(string), planet2Orbit.(string)\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit.(string), planet2Orbit.(string)\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit.(string), planet2Orbit.(string)\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit.(string), planet2Orbit.(string)\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit.(string), planet2Orbit.(string)\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit.(string), planet2Orbit.(string)\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit.(string), planet2Orbit.(string)\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit.(string), planet2Orbit.(string)\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit.(string), planet2Orbit.(string)\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit.(string), planet2Orbit.(string)\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit.(string), planet2Orbit.(string)\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit.(string), planet2Orbit.(string)\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit.(string\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmplxp518wz_test.go:59:54: expected '')'', found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074487
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit := getOrbit(planet1)\n\
    \    planet2Orbit := getOrbit(planet2)\n    planet1Orbit.sort()\n    planet2Orbit.sort()\n\
    \    planet1Orbit.sort()\n    planet2Orbit.sort()\n    result := []interface{}{}\n\
    \    for i := 0; i < len(planet1Orbit)-1; i++ {\n        if planet1Orbit[i] <\
    \ planet2Orbit[i] {\n            planet1Orbit[i+1] = planet1Orbit[i+1] + 1\n \
    \       } else {\n            planet2Orbit[i+1] = planet2Orbit[i+1] + 1\n    \
    \    }\n    }\n    for i := 0; i < len(planet1Orbit)-1; i++ {\n        if planet1Orbit[i]\
    \ < planet2Orbit[i] {\n            planet1Orbit[i+1] = planet1Orbit[i+1] - 1\n\
    \        } else {\n            planet2Orbit[i+1] = planet2Orbit[i+1] - 1\n   \
    \     }\n    }\n    for i := 0; i < len(planet1Orbit)-1; i++ {\n        if planet1Orbit[i]\
    \ < planet2Orbit[i] {\n            planet1Orbit[i+1] = planet1Orbit[i+1] + 1\n\
    \        } else {\n            planet2Orbit[i+1] = planet2Orbit[i+1] + 1\n   \
    \     }\n    }\n    for i := 0; i < len(planet1Orbit)-1; i++ {\n        if planet1Orbit[i]\
    \ < planet2Orbit[i] {\n            planet1Orbit[i+1] = planet1Orbit[i+1] - 1\n\
    \        } else {\n            planet2Orbit[i+1] = planet2Orbit[i+1] - 1\n   \
    \     }\n    }\n    for i := 0; i < len(planet1Orbit)-1; i++ {\n        if planet1Orbit[i]\
    \ < planet2Orbit[i] {\n            planet1Orbit[i+1] = planet1Orbit[i+1] + 1\n\
    \        } else {\n            planet2Orbit[i+1] = planet2Orbit[i+1] + 1\n   \
    \     }\n    }\n    for i := 0; i < len(planet1Orbit)-1; i++ {\n        if planet1Orbit[i]\
    \ < planet2Orbit[i] {\n            planet1Orbit[i+1] = planet1Orbit[i+1] - 1\n\
    \        } else {\n            planet2Orbit[i+1] = planet2Orbit[i+1] - 1\n   \
    \     }\n    }\n    for i := 0; i < len(planet1Orbit)\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpu52pugvu_test.go:75:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074487
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit := orbit(planet1)\n\
    \    planet2Orbit := orbit(planet2)\n    planet1Sun := sun(planet1)\n    planet2Sun\
    \ := sun(planet2)\n    planet1OrbitSun := orbit(planet1, planet1Sun)\n    planet2OrbitSun\
    \ := orbit(planet2, planet2Sun)\n    planet1OrbitSunOrbit := orbit(planet1, planet1Sun,\
    \ planet2Sun)\n    planet2OrbitSunOrbit := orbit(planet2, planet2Sun, planet1Sun)\n\
    \    planet1OrbitSunOrbitSun := orbit(planet1, planet1Sun, planet2Sun, planet1OrbitSun)\n\
    \    planet2OrbitSunOrbitSun := orbit(planet2, planet2Sun, planet1Sun, planet2OrbitSun)\n\
    \    planet1OrbitSunOrbitSunOrbit := orbit(planet1, planet1Sun, planet2Sun, planet1OrbitSun,\
    \ planet2OrbitSun)\n    planet2OrbitSunOrbitSunOrbit := orbit(planet2, planet2Sun,\
    \ planet1Sun, planet2OrbitSun, planet1OrbitSun)\n    planet1OrbitSunOrbitSunOrbitSun\
    \ := orbit(planet1, planet1Sun, planet2Sun, planet1OrbitSun, planet2OrbitSun,\
    \ planet1OrbitSun)\n    planet2OrbitSunOrbitSunOrbitSun := orbit(planet2, planet2Sun,\
    \ planet1Sun, planet2OrbitSun, planet1OrbitSun, planet2OrbitSun)\n    planet1OrbitSunOrbitSunOrbitSunOrbit\
    \ := orbit(planet1, planet1Sun, planet2Sun, planet1OrbitSun, planet2OrbitSun,\
    \ planet1OrbitSun, planet2OrbitSun)\n    planet2OrbitSunOrbitSunOrbitSunOrbitSun\
    \ := orbit(planet2, planet2Sun, planet1Sun, planet2OrbitSun, planet1OrbitSun,\
    \ plan\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpkz0jskqp_test.go:40:125: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074487
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    // Your code here\n\
    \    planet1Orbit := orbit(planet1)\n    planet2Orbit := orbit(planet2)\n    planet1Orbit.sort()\n\
    \    planet2Orbit.sort()\n    result := []interface{}{}\n    for i := 0; i < len(planet1Orbit);\
    \ i++ {\n        for j := 0; j < len(planet2Orbit); j++ {\n            if planet1Orbit[i].distance\
    \ < planet2Orbit[j].distance {\n                result := append(result, planet1Orbit[i])\n\
    \            }\n        }\n    }\n    return result\n}\n\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5gc4sa3w_test.go:26:21: undefined: orbit

    /tmp/tmp5gc4sa3w_test.go:27:21: undefined: orbit

    /tmp/tmp5gc4sa3w_test.go:34:17: result declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074488
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit := planet1Orbit(planet1)\n\
    \    planet2Orbit := planet2Orbit(planet2)\n    planet1Orbit.sort()\n    planet2Orbit.sort()\n\
    \    \n    result := []interface{}{}\n    \n    for _, planet1 := range planet1Orbit\
    \ {\n        for _, planet2 := range planet2Orbit {\n            if planet1 ==\
    \ planet2 {\n                continue\n            }\n            \n         \
    \   distance := planet1Orbit.distance(planet2)\n            if distance < planet1Orbit.sunDistance\
    \ {\n                planet1Orbit.remove(planet1)\n                planet2Orbit.remove(planet2)\n\
    \                \n                planet1Orbit.sort()\n                planet2Orbit.sort()\n\
    \                \n                distance := planet1Orbit.distance(planet2)\n\
    \                if distance < planet1Orbit.sunDistance {\n                  \
    \  result = append(result, planet1)\n                    result = append(result,\
    \ planet2)\n                }\n            }\n        }\n    }\n    \n    return\
    \ result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvi0j8q1h_test.go:25:21: undefined: planet1Orbit

    /tmp/tmpvi0j8q1h_test.go:26:21: undefined: planet2Orbit

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074488
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit := orbit(planet1)\n\
    \    planet2Orbit := orbit(planet2)\n    planet1Sun := sun(planet1)\n    planet2Sun\
    \ := sun(planet2)\n    planet1OrbitSun := orbit(planet1, planet1Sun)\n    planet2OrbitSun\
    \ := orbit(planet2, planet2Sun)\n    planet1OrbitSunOrbit := orbit(planet1, planet1Sun,\
    \ planet2OrbitSun)\n    planet2OrbitSunOrbit := orbit(planet2, planet2Sun, planet1OrbitSun)\n\
    \    planet1OrbitSunOrbitSun := orbit(planet1, planet1Sun, planet2OrbitSun, planet1OrbitSun)\n\
    \    planet2OrbitSunOrbitSun := orbit(planet2, planet2Sun, planet1OrbitSun, planet2OrbitSun)\n\
    \    planet1OrbitSunOrbitSunOrbit := orbit(planet1, planet1Sun, planet2OrbitSun,\
    \ planet1OrbitSun, planet2OrbitSun)\n    planet2OrbitSunOrbitSunOrbitSun := orbit(planet2,\
    \ planet2Sun, planet1OrbitSun, planet2OrbitSun, planet1OrbitSunOrbit)\n    planet1OrbitSunOrbitSunOrbitSun\
    \ := orbit(planet1, planet1Sun, planet2OrbitSun, planet1OrbitSun, planet2OrbitSun,\
    \ planet1OrbitSunOrbitSun)\n    planet2OrbitSunOrbitSunOrbitSun := orbit(planet2,\
    \ planet2Sun, planet1OrbitSun, planet2OrbitSun, planet1OrbitSunOrbitSun, planet2OrbitSunOrbitSun)\n\
    \    planet1OrbitSunOrbitSunOrbitSun := orbit(planet1, planet1Sun, planet2OrbitSun,\
    \ planet1OrbitSun, planet2OrbitSun, planet1OrbitSunOrbitSun, planet2OrbitSunOrbitSun)\n\
    \    planet2OrbitSunOrbitSunOrbit\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpil4945hy_test.go:41:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074487
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit = sortByProximity(planet1Orbit,\
    \ planet2Orbit)\n    return planet1Orbit\n}\n\nfunc TestBf(t *testing.T) {\n \
    \ candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpumwg0x5y_test.go:25:35: undefined: getOrbits

    /tmp/tmpumwg0x5y_test.go:26:34: undefined: sortByProximity

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074484
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1.ToLower(), planet2.ToLower()\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpkc03pxac_test.go:54:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074487
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit := orbit(planet1)\n\
    \    planet2Orbit := orbit(planet2)\n    planet1Orbit.sort()\n    planet2Orbit.sort()\n\
    \    \n    result := []interface{}{}\n    \n    for _, planet1OrbitElement :=\
    \ range planet1Orbit {\n        for _, planet2OrbitElement := range planet2Orbit\
    \ {\n            if planet1OrbitElement < planet2OrbitElement {\n            \
    \    result <- planet1OrbitElement\n            } else {\n                result\
    \ <- planet2OrbitElement\n            }\n        }\n    }\n    \n    return result\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpirdbqrhc_test.go:25:21: undefined: orbit

    /tmp/tmpirdbqrhc_test.go:26:21: undefined: orbit

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074488
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := strings.ToLower(planet1)\n\
    \    planet2 := strings.ToLower(planet2)\n    \n    planet1Orbit := planet1\n\
    \    planet2Orbit := planet2\n    \n    planet1Orbit, planet2Orbit = orbit(planet1Orbit,\
    \ planet2Orbit)\n    \n    planet1Orbit, planet2Orbit = orbit(planet1Orbit, planet2Orbit)\n\
    \    \n    planet1Orbit, planet2Orbit = orbit(planet1Orbit, planet2Orbit)\n  \
    \  \n    planet1Orbit, planet2Orbit = orbit(planet1Orbit, planet2Orbit)\n    \n\
    \    planet1Orbit, planet2Orbit = orbit(planet1Orbit, planet2Orbit)\n    \n  \
    \  planet1Orbit, planet2Orbit = orbit(planet1Orbit, planet2Orbit)\n    \n    planet1Orbit,\
    \ planet2Orbit = orbit(planet1Orbit, planet2Orbit)\n    \n    planet1Orbit, planet2Orbit\
    \ = orbit(planet1Orbit, planet2Orbit)\n    \n    planet1Orbit, planet2Orbit =\
    \ orbit(planet1Orbit, planet2Orbit)\n    \n    planet1Orbit, planet2Orbit = orbit(planet1Orbit,\
    \ planet2Orbit)\n    \n    planet1Orbit, planet2Orbit = orbit(planet1Orbit, planet2Orbit)\n\
    \    \n    planet1Orbit, planet2Orbit = orbit(planet1Orbit, planet2Orbit)\n  \
    \  \n    planet1Orbit, planet2Orbit = orbit(planet1Orbit, planet2Orbit)\n    \n\
    \    planet1Orbit, planet2Orbit = orbit(planet1Orbit, planet2Orbit)\n    \n  \
    \  planet1Orbit, planet2Orbit = orbit(planet1Orbit, planet2Orbit)\n    \n    planet1Orbit,\
    \ planet2\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpcxc4i0hy_test.go:61:5: expected 1 expression

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074487
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit := orbit(planet1)\n\
    \    planet2Orbit := orbit(planet2)\n    \n    planet1Orbit.sort()\n    planet2Orbit.sort()\n\
    \    \n    result := []interface{}{}\n    \n    for _, planet := range planet1Orbit\
    \ {\n        for _, planet2 := range planet2Orbit {\n            if planet ==\
    \ planet2 {\n                result = append(result, planet)\n            }\n\
    \        }\n    }\n    \n    return result\n}\n\nfunc TestBf(t *testing.T) {\n\
    \  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpgl6qmnck_test.go:25:21: undefined: orbit

    /tmp/tmpgl6qmnck_test.go:26:21: undefined: orbit

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074488
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    planet1Orbit, planet2Orbit := planet1, planet2\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    \nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpdt7ter8__test.go:40:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074487
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := planet1Orbit(planet1, planet2), planet2Orbit(planet1, planet2)\n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit.([]string), planet2Orbit.([]string)\n    \n    planet1Orbit\
    \ = append(planet1Orbit, \"Sun\")\n    planet2Orbit = append(planet2Orbit, \"\
    Sun\")\n    \n    planet1Orbit = append(planet1Orbit, planet1Orbit...)\n    planet2Orbit\
    \ = append(planet2Orbit, planet2Orbit...)\n    \n    planet1Orbit = append(planet1Orbit,\
    \ \"Sun\")\n    planet2Orbit = append(planet2Orbit, \"Sun\")\n    \n    planet1Orbit\
    \ = append(planet1Orbit, planet1Orbit...)\n    planet2Orbit = append(planet2Orbit,\
    \ planet2Orbit...)\n    \n    planet1Orbit = append(planet1Orbit, \"Sun\")\n \
    \   planet2Orbit = append(planet2Orbit, \"Sun\")\n    \n    planet1Orbit = append(planet1Orbit,\
    \ planet1Orbit...)\n    planet2Orbit = append(planet2Orbit, planet2Orbit...)\n\
    \    \n    planet1Orbit = append(planet1Orbit, \"Sun\")\n    planet2Orbit = append(planet2Orbit,\
    \ \"Sun\")\n    \n    planet1Orbit = append(planet1Orbit, planet1Orbit...)\n \
    \   planet2Orbit = append(planet2Orbit, planet2Orbit...)\n    \n    planet1Orbit\
    \ = append(planet1Orbit, \"Sun\")\n    planet2Orbit = append(planet2Orbit, \"\
    Sun\")\n    \n    planet1Orbit = append(planet1Orbit, planet1Orbit...)\n    planet2Orbit\
    \ = append(planet2Orbit, planet2Orbit...)\n    \n    planet1Orbit = append(planet1Orbit,\
    \ \"Sun\")\n    planet2Orbit = append(planet2Orbit, \"Sun\")\n    \n    planet\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp0c6lt2f__test.go:62:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074487
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, err\
    \ := getOrbit(planet1)\n    if err != nil {\n        fmt.Println(err)\n    }\n\
    \    planet2Orbit, err := getOrbit(planet2)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet1OrbitSun, err := getOrbitSun(planet1)\n    if err != nil {\n\
    \        fmt.Println(err)\n    }\n    planet2OrbitSun, err := getOrbitSun(planet2)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    planet1SunDistance,\
    \ err := getDistance(planet1OrbitSun, planet2OrbitSun)\n    if err != nil {\n\
    \        fmt.Println(err)\n    }\n    planet2SunDistance, err := getDistance(planet1OrbitSun,\
    \ planet2OrbitSun)\n    if err != nil {\n        fmt.Println(err)\n    }\n   \
    \ planet1OrbitSun, planet2OrbitSun := planet1OrbitSun, planet2OrbitSun\n    planet1Orbit,\
    \ planet2Orbit := planet1Orbit, planet2Orbit\n    planet1SunDistance, planet2SunDistance\
    \ := planet1SunDistance, planet2SunDistance\n    planet1OrbitSun, planet2OrbitSun\
    \ := planet1OrbitSun, planet2OrbitSun\n    planet1Orbit, planet2Orbit := planet1Orbit,\
    \ planet2Orbit\n    planet1SunDistance, planet2SunDistance := planet1SunDistance,\
    \ planet2SunDistance\n    planet1OrbitSun, planet2OrbitSun := planet1OrbitSun,\
    \ planet2OrbitSun\n    planet1Orbit, planet2Orbit := planet1Orbit, planet2Orbit\n\
    \    planet1SunDistance, planet2SunDistance := planet1SunDistance, planet2SunDistance\n\
    \    planet1OrbitSun, planet2OrbitSun := planet1OrbitSun, planet2OrbitSun\n  \
    \  planet1Orbit, planet2Orbit := planet1Orbit, planet2Orbit\n    planet1SunDistance,\
    \ planet2SunDistance := \nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpqsz9eit5_test.go:61:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074488
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := orbit(planet1, planet2)\n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit, planet2Orbit\n    planet1Orbit, planet2Orbit =\
    \ planet1Orbit, planet2Orbit\n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit, planet2Orbit\n    planet1Orbit, planet2Orbit =\
    \ planet1Orbit, planet2Orbit\n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit, planet2Orbit\n    planet1Orbit, planet2Orbit =\
    \ planet1Orbit, planet2Orbit\n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit, planet2Orbit\n    planet1Orbit, planet2Orbit =\
    \ planet1Orbit, planet2Orbit\n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit, planet2Orbit\n    planet1Orbit, planet2Orbit =\
    \ planet\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpft792_zg_test.go:46:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074488
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit = sortByProximity(planet1Orbit,\
    \ planet2Orbit)\n    return planet1Orbit\n}\n\nfunc TestBf(t *testing.T) {\n \
    \ candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpumwg0x5y_test.go:25:35: undefined: getOrbits

    /tmp/tmpumwg0x5y_test.go:26:34: undefined: sortByProximity

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074484
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit = getOrbits(planet2,\
    \ planet1)\n    planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n   \
    \ planet1Orbit, planet2Orbit = getOrbits(planet2, planet1)\n    planet1Orbit,\
    \ planet2Orbit = getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit =\
    \ getOrbits(planet2, planet1)\n    planet1Orbit, planet2Orbit = getOrbits(planet1,\
    \ planet2)\n    planet1Orbit, planet2Orbit = getOrbits(planet2, planet1)\n   \
    \ planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n    planet1Orbit,\
    \ planet2Orbit = getOrbits(planet2, planet1)\n    planet1Orbit, planet2Orbit =\
    \ getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit = getOrbits(planet2,\
    \ planet1)\n    planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n   \
    \ planet1Orbit, planet2Orbit = getOrbits(planet2, planet1)\n    planet1Orbit,\
    \ planet2Orbit = getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit =\
    \ getOrbits(planet2, planet1)\n    planet1Orbit, planet2Orbit = getOrbits(planet1,\
    \ planet2)\n    planet1Orbit, planet2Orbit = getOrbits(planet2, planet1)\n   \
    \ planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n    planet1Orbit,\
    \ planet2Orbit = getOrbits(planet2, planet1)\n    planet1Orbit, planet2Orbit =\
    \ getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit = getOrbits(planet2,\
    \ planet1)\n    planet1Or\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpbmgyh1vj_test.go:48:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074483
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1\
    \ := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n\
    \    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2\
    \ := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n\
    \    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1\
    \ := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n\
    \    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2\
    \ := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n\
    \    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1\
    \ := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n\
    \    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2\
    \ := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n\
    \    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1\
    \ := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n\
    \    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2\
    \ := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp7i4ipxby_test.go:82:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074483
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit = sortByProximity(planet1Orbit,\
    \ planet2Orbit)\n    return planet1Orbit\n}\n\nfunc TestBf(t *testing.T) {\n \
    \ candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpumwg0x5y_test.go:25:35: undefined: getOrbits

    /tmp/tmpumwg0x5y_test.go:26:34: undefined: sortByProximity

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074484
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2\
    \ = planet1, planet2\n    planet1Planet2 := planet1 + \" \" + planet2\n    planet1Planet2Planet1\
    \ := planet1 + \" \" + planet2 + \" \" + planet1\n    planet1Planet2Planet1Planet2\
    \ := planet1 + \" \" + planet2 + \" \" + planet1 + \" \" + planet2\n    planet1Planet2Planet1Planet2Planet1\
    \ := planet1 + \" \" + planet2 + \" \" + planet1 + \" \" + planet2 + \" \" + planet1\n\
    \    planet1Planet2Planet1Planet2Planet1Planet2 := planet1 + \" \" + planet2 +\
    \ \" \" + planet1 + \" \" + planet2 + \" \" + planet1 + \" \" + planet2\n    planet1Planet2Planet1Planet2Planet1Planet2Planet1\
    \ := planet1 + \" \" + planet2 + \" \" + planet1 + \" \" + planet2 + \" \" + planet1\
    \ + \" \" + planet2 + \" \" + planet1\n    planet1Planet2Planet1Planet2Planet1Planet2Planet1Planet2\
    \ := planet1 + \" \" + planet2 + \" \" + planet1 + \" \" + planet2 + \" \" + planet1\
    \ + \" \" + planet2 + \" \" + planet1 + \" \" + planet2\n    planet1Planet2Planet1Planet2Planet1Planet2Planet1Planet2Planet1\
    \ := planet1 + \" \" + planet2 + \" \" + planet1 + \" \" + planet2 + \" \" + planet1\
    \ + \" \" + planet2 + \" \" + planet1 + \" \" + planet2 + \" \" + planet1\n  \
    \  planet1Planet2Planet1Planet2Planet1Planet2Planet1Planet2Planet1Planet2 := planet1\
    \ + \" \" + planet2 + \" \" + planet1 + \" \" + planet2 + \" \" + planet1 + \"\
    \ \" + planet2 + \" \" + planet1 + \" \" + planet2 + \" \" + planet1 + \" \" +\
    \ planet2\n    planet1Planet2Planet1Planet2Planet1Planet2Planet1Planet2Planet1Planet2Planet1\
    \ := planet1 + \" \" + planet2 + \" \" + planet1 + \" \" + planet2 + \" \" + planet1\
    \ + \" \" + planet2 + \" \" + planet1 + \" \" + planet2 + \" \" + planet1 + \"\
    \ \" + planet2 + \" \" + planet1\n    planet1Planet2Planet1Planet2Planet1Planet2Planet1Plan\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpobuuh7j__test.go:37:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074488
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit = sortPlanets(planet1Orbit,\
    \ planet2Orbit)\n    return planet1Orbit\n}\n\nfunc TestBf(t *testing.T) {\n \
    \ candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0l1jkt5o_test.go:25:35: undefined: getOrbits

    /tmp/tmp0l1jkt5o_test.go:26:34: undefined: sortPlanets

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074486
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    planet1 := planet1[:len(planet1)-1]\n    planet2\
    \ := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\n    planet2\
    \ := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\n    planet2\
    \ := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\n    planet2\
    \ := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\n    planet2\
    \ := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\n    planet2\
    \ := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\n    planet2\
    \ := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\n    planet2\
    \ := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\n    planet2\
    \ := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\n    planet2\
    \ := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\n    planet2\
    \ := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\n    planet2\
    \ := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\n    planet2\
    \ := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\n    planet2\
    \ := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\n    planet2\
    \ := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\n    planet2\
    \ := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpmwhx7kvi_test.go:60:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074488
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit := orbit(planet1)\n\
    \    planet2Orbit := orbit(planet2)\n    \n    planet1Orbit.sort()\n    planet2Orbit.sort()\n\
    \    \n    planet1Orbit.intersect(planet2Orbit)\n    \n    return planet1Orbit.slice()\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqc5x_xty_test.go:25:21: undefined: orbit

    /tmp/tmpqc5x_xty_test.go:26:21: undefined: orbit

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074489
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := getOrbits(planet1, planet2)\n    planet1Sun, planet2Sun := getSun(planet1,\
    \ planet2)\n    planet1SunProximity := getProximity(planet1Orbit, planet1Sun)\n\
    \    planet2SunProximity := getProximity(planet2Orbit, planet2Sun)\n    planet1OrbitProximity\
    \ := getProximity(planet1Orbit, planet2Orbit)\n    planet2OrbitProximity := getProximity(planet2Orbit,\
    \ planet1Orbit)\n    planet1OrbitProximitySorted := sortByProximity(planet1OrbitProximity)\n\
    \    planet2OrbitProximitySorted := sortByProximity(planet2OrbitProximity)\n \
    \   planet1OrbitProximitySortedSorted := sortByProximity(planet1OrbitProximitySorted)\n\
    \    planet2OrbitProximitySortedSorted := sortByProximity(planet2OrbitProximitySorted)\n\
    \    planet1OrbitProximitySortedSortedSorted := sortByProximity(planet1OrbitProximitySortedSorted)\n\
    \    planet2OrbitProximitySortedSortedSorted := sortByProximity(planet2OrbitProximitySortedSorted)\n\
    \    planet1OrbitProximitySortedSortedSortedSorted := sortByProximity(planet1OrbitProximitySortedSortedSorted)\n\
    \    planet2OrbitProximitySortedSortedSortedSorted := sortByProximity(planet2OrbitProximitySortedSortedSorted)\n\
    \    planet1OrbitProximitySortedSortedSortedSortedSorted := sortByProximity(planet1OrbitProximitySortedSortedSortedSorted)\n\
    \    planet2OrbitProximitySortedSortedSortedSortedSorted := sortByProximity(planet2OrbitProximitySortedSortedSortedSorted)\n\
    \    planet1OrbitProximitySortedSortedSortedSortedSortedSorted := sortByProximity(planet1OrbitProximitySortedSortedSortedSortedSorted)\n\
    \nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpqey_wi5f_test.go:43:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074488
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    // Your code here\n\
    \    planet1Orbit, planet2Orbit := orbit(planet1, planet2)\n    planet1Orbit.sort()\n\
    \    planet2Orbit.sort()\n    \n    planet1Orbit.intersect(planet2Orbit)\n   \
    \ \n    return planet1Orbit\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpp93brth6_test.go:26:35: undefined: orbit

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074489
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2\
    \ = planet1, planet2\n    \n    planet1Orbit, planet2Orbit := planet1, planet2\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    \n   \
    \ planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    \n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit, planet2Orbit\n    \n    planet1Orbit, planet2Orbit\
    \ = planet1Orbit, planet2Orbit\n    \n    planet1Orbit, planet2Orbit = planet1Orbit,\
    \ planet2Orbit\n    \n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    \n   \
    \ planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    \n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit, planet2Orbit\n    \n    planet1Orbit, planet2Orbit\
    \ = planet1Orbit, planet2Orbit\n    \n    planet1Orbit, planet2Orbit = planet1Orbit,\
    \ planet2Orbit\n    \n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    \n   \
    \ planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    \n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit, planet2Orbit\n    \n    planet1Orbit, planet2Orbit\
    \ = planet1Orbit, planet2Orbit\n    \n    planet1Orbit, planet2Orbit = planet1Orbit,\
    \ planet2Orbit\n    \n    planet1Orbit, planet2Orbit = planet\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpglip0rps_test.go:64:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074488
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    // Your code here\n\
    \    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1[:len(planet1)-1]\n\
    \    planet2 := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\n\
    \    planet2 := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\n\
    \    planet2 := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\n\
    \    planet2 := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\n\
    \    planet2 := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\n\
    \    planet2 := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\n\
    \    planet2 := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\n\
    \    planet2 := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\n\
    \    planet2 := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\n\
    \    planet2 := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\n\
    \    planet2 := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\n\
    \    planet2 := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\n\
    \    planet2 := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\n\
    \    planet2 := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\n\
    \    planet2 := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\n\
    \    planet2 := planet2[:len(planet2)-1]\n    planet1 := planet1[:\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp1segqeke_test.go:61:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074488
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    // Your code here\n\
    \    planet1 := planet1\n    planet2 := planet2\n    planet1Orbit, planet2Orbit\
    \ := getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit = getOrbits(planet2,\
    \ planet1)\n    planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n   \
    \ planet1Orbit, planet2Orbit = getOrbits(planet2, planet1)\n    planet1Orbit,\
    \ planet2Orbit = getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit =\
    \ getOrbits(planet2, planet1)\n    planet1Orbit, planet2Orbit = getOrbits(planet1,\
    \ planet2)\n    planet1Orbit, planet2Orbit = getOrbits(planet2, planet1)\n   \
    \ planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n    planet1Orbit,\
    \ planet2Orbit = getOrbits(planet2, planet1)\n    planet1Orbit, planet2Orbit =\
    \ getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit = getOrbits(planet2,\
    \ planet1)\n    planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n   \
    \ planet1Orbit, planet2Orbit = getOrbits(planet2, planet1)\n    planet1Orbit,\
    \ planet2Orbit = getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit =\
    \ getOrbits(planet2, planet1)\n    planet1Orbit, planet2Orbit = getOrbits(planet1,\
    \ planet2)\n    planet1Orbit, planet2Orbit = getOrbits(planet2, planet1)\n   \
    \ planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n    planet1Orbit,\
    \ planet2Orbit = getOrbits(planet2, planet1)\n    planet1Orbit, planet2Orbit =\
    \ getOrbits(planet1, planet2)\n    planet1Or\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmptdrcyaxm_test.go:50:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074488
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit := planet1\n    planet2Orbit :=\
    \ planet2\n    \n    planet1Orbit, planet2Orbit = orbit(planet1, planet2)\n  \
    \  \n    planet1Orbit, planet2Orbit = orbit(planet2, planet1)\n    \n    planet1Orbit,\
    \ planet2Orbit = orbit(planet1, planet2)\n    \n    planet1Orbit, planet2Orbit\
    \ = orbit(planet2, planet1)\n    \n    planet1Orbit, planet2Orbit = orbit(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit = orbit(planet2, planet1)\n \
    \   \n    planet1Orbit, planet2Orbit = orbit(planet1, planet2)\n    \n    planet1Orbit,\
    \ planet2Orbit = orbit(planet2, planet1)\n    \n    planet1Orbit, planet2Orbit\
    \ = orbit(planet1, planet2)\n    \n    planet1Orbit, planet2Orbit = orbit(planet2,\
    \ planet1)\n    \n    planet1Orbit, planet2Orbit = orbit(planet1, planet2)\n \
    \   \n    planet1Orbit, planet2Orbit = orbit(planet2, planet1)\n    \n    planet1Orbit,\
    \ planet2Orbit = orbit(planet1, planet2)\n    \n    planet1Orbit, planet2Orbit\
    \ = orbit(planet2, planet1)\n    \n    planet1Orbit, planet2Orbit = orbit(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit = orbit(planet2, planet1)\n \
    \   \n    planet1Orbit, planet2Orbit = orbit(planet1, planet2)\n    \n    planet1Orbit,\
    \ planet2Orbit = orbit(planet2, planet1)\n    \n    planet1Orbit, planet2Orbit\
    \ = orbit(planet1, planet2)\n    \n    planet1Orbit, planet2Orbit\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpcnlmuh98_test.go:69:5: expected 1 expression

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074489
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    planet1Orbit := planet1\n    planet2Orbit := planet2\n\
    \    planet1OrbitOrbit := planet1Orbit\n    planet2OrbitOrbit := planet2Orbit\n\
    \    planet1OrbitOrbitOrbit := planet1OrbitOrbit\n    planet2OrbitOrbitOrbit :=\
    \ planet2OrbitOrbit\n    planet1OrbitOrbitOrbitOrbit := planet1OrbitOrbitOrbit\n\
    \    planet2OrbitOrbitOrbitOrbit := planet2OrbitOrbitOrbit\n    planet1OrbitOrbitOrbitOrbitOrbit\
    \ := planet1OrbitOrbitOrbitOrbit\n    planet2OrbitOrbitOrbitOrbitOrbit := planet2OrbitOrbitOrbitOrbit\n\
    \    planet1OrbitOrbitOrbitOrbitOrbitOrbit := planet1OrbitOrbitOrbitOrbitOrbit\n\
    \    planet2OrbitOrbitOrbitOrbitOrbitOrbit := planet2OrbitOrbitOrbitOrbitOrbitOrbit\n\
    \    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbit\n\
    \    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbit\n\
    \    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\n\
    \    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\n\
    \    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\n\
    \    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2OrbitOrbitOrbitOr\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp03naltq6_test.go:45:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074489
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2\
    \ = planet1, planet2\n    planet1Orbit, planet2Orbit, sunOrbit, planet1OrbitSun,\
    \ planet2OrbitSun := getOrbits(planet1, planet2)\n    planet1OrbitSun, planet2OrbitSun,\
    \ sunOrbit, planet1OrbitSun, planet2OrbitSun := getOrbits(planet1, planet2)\n\
    \    planet1OrbitSun, planet2OrbitSun, sunOrbit, planet1OrbitSun, planet2OrbitSun\
    \ := getOrbits(planet1, planet2)\n    planet1OrbitSun, planet2OrbitSun, sunOrbit,\
    \ planet1OrbitSun, planet2OrbitSun := getOrbits(planet1, planet2)\n    planet1OrbitSun,\
    \ planet2OrbitSun, sunOrbit, planet1OrbitSun, planet2OrbitSun := getOrbits(planet1,\
    \ planet2)\n    planet1OrbitSun, planet2OrbitSun, sunOrbit, planet1OrbitSun, planet2OrbitSun\
    \ := getOrbits(planet1, planet2)\n    planet1OrbitSun, planet2OrbitSun, sunOrbit,\
    \ planet1OrbitSun, planet2OrbitSun := getOrbits(planet1, planet2)\n    planet1OrbitSun,\
    \ planet2OrbitSun, sunOrbit, planet1OrbitSun, planet2OrbitSun := getOrbits(planet1,\
    \ planet2)\n    planet1OrbitSun, planet2OrbitSun, sunOrbit, planet1OrbitSun, planet2OrbitSun\
    \ := getOrbits(planet1, planet2)\n    planet1OrbitSun, planet2OrbitSun, sunOrbit,\
    \ planet1OrbitSun, planet2OrbitSun := getOrbits(planet1, planet2)\n    planet1OrbitSun,\
    \ planet2OrbitSun, sunOrbit, planet1OrbitSun, planet2OrbitSun := getOrbits(planet1,\
    \ planet2)\n    planet1Or\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp0733wlud_test.go:38:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074489
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit, err := getPlanetOrbit(planet1)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    planet2Orbit, err :=\
    \ getPlanetOrbit(planet2)\n    if err != nil {\n        fmt.Println(err)\n   \
    \ }\n    \n    planet1OrbitSun, err := getPlanetOrbitSun(planet1)\n    if err\
    \ != nil {\n        fmt.Println(err)\n    }\n    planet2OrbitSun, err := getPlanetOrbitSun(planet2)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    \n    planet1SunDistance,\
    \ err := getPlanetSunDistance(planet1)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet2SunDistance, err := getPlanetSunDistance(planet2)\n    if err\
    \ != nil {\n        fmt.Println(err)\n    }\n    \n    planet1OrbitSunDistance,\
    \ err := getPlanetOrbitSunDistance(planet1)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet2OrbitSunDistance, err := getPlanetOrbitSunDistance(planet2)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    \n    planet1OrbitSunDistance,\
    \ err := getPlanetOrbitSunDistance(planet1)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet2OrbitSunDistance, err := getPlanetOrbitSunDistance(planet2)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    \n    planet1OrbitSunDistance,\
    \ err := getPlanetOrbitSunDistance(planet1)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet2OrbitSunDistance, err := getPlanetOrbitSunDistance(planet2)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    \n    planet1OrbitSunDistance,\
    \ err := getPlanetOrbitSunDistance(planet1)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet2OrbitSunDistance, err := getPlanetOrbitSunDistance(planet2)\n\
    \    if err != nil {\n        fmt.Println(\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpxoet00df_test.go:89:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074489
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    planet1 := strings.ToLower(planet1)\n    planet2\
    \ := strings.ToLower(planet2)\n    planet1 := strings.Trim(planet1, \" \")\n \
    \   planet2 := strings.Trim(planet2, \" \")\n    planet1 := strings.ToUpper(planet1)\n\
    \    planet2 := strings.ToUpper(planet2)\n    planet1 := strings.Replace(planet1,\
    \ \" \", \"\", -1)\n    planet2 := strings.Replace(planet2, \" \", \"\", -1)\n\
    \    planet1 := strings.Replace(planet1, \"-\", \"\", -1)\n    planet2 := strings.Replace(planet2,\
    \ \"-\", \"\", -1)\n    planet1 := strings.Replace(planet1, \"/\", \"\", -1)\n\
    \    planet2 := strings.Replace(planet2, \"/\", \"\", -1)\n    planet1 := strings.Replace(planet1,\
    \ \"\\\\\", \"\", -1)\n    planet2 := strings.Replace(planet2, \"\\\\\", \"\"\
    , -1)\n    planet1 := strings.Replace(planet1, \"'\", \"\", -1)\n    planet2 :=\
    \ strings.Replace(planet2, \"'\", \"\", -1)\n    planet1 := strings.Replace(planet1,\
    \ \"-\", \"\", -1)\n    planet2 := strings.Replace(planet2, \"-\", \"\", -1)\n\
    \    planet1 := strings.Replace(planet1, \"(\", \"\", -1)\n    planet2 := strings.Replace(planet2,\
    \ \")\", \"\", -1)\n    planet1 := strings.Replace(planet1, \")\", \"\", -1)\n\
    \    planet2 := strings.Replace(planet2, \")\", \"\", -1)\n    planet1 := strings.Replace(planet1,\
    \ \"+\", \"\", -1)\n    planet2 := strings.Replace(planet2, \"+\", \"\", -1)\n\
    \    planet1 := strings.Replace(planet1, \"-\", \"\", -1)\n    planet2 := strings.Replace(planet2,\
    \ \"-\", \"\", -1)\n    planet1 := strings.Replace(planet1, \"=\", \"\", -1)\n\
    \    planet2 := strings.Replace(planet2, \"=\", \"\", -1)\n    planet1 := strings.Replace(planet1,\
    \ \";\", \"\", -1)\n    planet2 := strings.Replace(planet2, \";\", \"\", -1)\n\
    \    planet1 := strings.Replace(planet1, \"&\", \"\", -1)\n    planet2 := strings.Replace(planet2,\
    \ \"&\", \"\", -1)\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpot3x2fvo_test.go:60:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074489
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    // Your code here\n\
    \    planet1 := planet1\n    planet2 := planet2\n    planet1Orbit := planet1\n\
    \    planet2Orbit := planet2\n    planet1Orbit = planet1Orbit[:len(planet1Orbit)-3]\n\
    \    planet2Orbit = planet2Orbit[:len(planet2Orbit)-3]\n    planet1Orbit = planet1Orbit[:len(planet1Orbit)-3]\n\
    \    planet2Orbit = planet2Orbit[:len(planet2Orbit)-3]\n    planet1Orbit = planet1Orbit[:len(planet1Orbit)-3]\n\
    \    planet2Orbit = planet2Orbit[:len(planet2Orbit)-3]\n    planet1Orbit = planet1Orbit[:len(planet1Orbit)-3]\n\
    \    planet2Orbit = planet2Orbit[:len(planet2Orbit)-3]\n    planet1Orbit = planet1Orbit[:len(planet1Orbit)-3]\n\
    \    planet2Orbit = planet2Orbit[:len(planet2Orbit)-3]\n    planet1Orbit = planet1Orbit[:len(planet1Orbit)-3]\n\
    \    planet2Orbit = planet2Orbit[:len(planet2Orbit)-3]\n    planet1Orbit = planet1Orbit[:len(planet1Orbit)-3]\n\
    \    planet2Orbit = planet2Orbit[:len(planet2Orbit)-3]\n    planet1Orbit = planet1Orbit[:len(planet1Orbit)-3]\n\
    \    planet2Orbit = planet2Orbit[:len(planet2Orbit)-3]\n    planet1Orbit = planet1Orbit[:len(planet1Orbit)-3]\n\
    \    planet2Orbit = planet2Orbit[:len(planet2Orbit)-3]\n    planet1Orbit = planet1Orbit[:len(planet1Orbit)-3]\n\
    \    planet2Orbit = planet2Orbit[:len(planet2Orbit)-3]\n    planet1Orbit = \n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpcppo7a1w_test.go:51:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074489
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit := orbit(planet1)\n\
    \    planet2Orbit := orbit(planet2)\n    \n    planet1Orbit.sort()\n    planet2Orbit.sort()\n\
    \    \n    result := []interface{}{}\n    \n    for _, planet1 := range planet1Orbit\
    \ {\n        for _, planet2 := range planet2Orbit {\n            if planet1 ==\
    \ planet2 {\n                continue\n            }\n            \n         \
    \   distance := distance(planet1, planet2)\n            \n            if distance\
    \ < planet1Orbit.distance(planet2Orbit) {\n                result = append(result,\
    \ planet1)\n            }\n        }\n    }\n    \n    return result\n}\n\nfunc\
    \ TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpo4fxn_cy_test.go:25:21: undefined: orbit

    /tmp/tmpo4fxn_cy_test.go:26:21: undefined: orbit

    /tmp/tmpo4fxn_cy_test.go:39:25: undefined: distance

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074489
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := strings.ToLower(planet1)\n\
    \    planet2 := strings.ToLower(planet2)\n    \n    planet1Orbit, err := getOrbit(planet1)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    planet2Orbit, err :=\
    \ getOrbit(planet2)\n    if err != nil {\n        fmt.Println(err)\n    }\n  \
    \  \n    planet1OrbitSun, err := getSunOrbit(planet1)\n    if err != nil {\n \
    \       fmt.Println(err)\n    }\n    planet2OrbitSun, err := getSunOrbit(planet2)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    \n    planet1OrbitSunProximity\
    \ := getProximity(planet1OrbitSun, planet1Orbit)\n    planet2OrbitSunProximity\
    \ := getProximity(planet2OrbitSun, planet2Orbit)\n    \n    planet1OrbitSunProximitySorted\
    \ := sortByProximity(planet1OrbitSunProximity)\n    planet2OrbitSunProximitySorted\
    \ := sortByProximity(planet2OrbitSunProximity)\n    \n    planet1OrbitSunProximitySortedList\
    \ := make([]string, len(planet1OrbitSunProximitySorted))\n    for i, planet1OrbitSunProximitySortedElement\
    \ := range planet1OrbitSunProximitySorted {\n        planet1OrbitSunProximitySortedList[i]\
    \ = planet1OrbitSunProximitySortedElement\n    }\n    \n    planet2OrbitSunProximitySortedList\
    \ := make([]string, len(planet2OrbitSunProximitySorted))\n    for i, planet2OrbitSunProximitySortedElement\
    \ := range planet2OrbitSunProximitySorted {\n        planet2OrbitSunProximitySortedList[i]\
    \ = planet2OrbitSunProximitySortedElement\n    }\n    \n    planet1OrbitSunProximitySortedList\
    \ := append(planet1OrbitSunProximitySortedList, planet1Orbit)\n    planet2OrbitSunProximitySortedList\
    \ := append(planet2OrbitSunProximitySortedList, planet2\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpklxd8xjl_test.go:63:93: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074489
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := planet1, planet2\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6c773qfu_test.go:38:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074483
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2\
    \ = planet1, planet2\n    \n    planet1Orbit, planet2Orbit, sunOrbit := getOrbits(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1,\
    \ planet2)\n    \n    plan\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpx0jvrbh9_test.go:62:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074483
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := orbit(planet1, planet2)\n    planet1Sun, planet2Sun := sun(planet1Orbit,\
    \ planet2Orbit)\n    planet1SunProximity := proximity(planet1Orbit, planet1Sun)\n\
    \    planet2SunProximity := proximity(planet2Orbit, planet2Sun)\n    planet1Proximity\
    \ := proximity(planet1Orbit, planet1Orbit)\n    planet2Proximity := proximity(planet2Orbit,\
    \ planet2Orbit)\n    planet1OrbitProximity := proximity(planet1Orbit, planet1Orbit)\n\
    \    planet2OrbitProximity := proximity(planet2Orbit, planet2Orbit)\n    planet1OrbitProximityProximity\
    \ := proximity(planet1OrbitProximity, planet1OrbitProximity)\n    planet2OrbitProximityProximity\
    \ := proximity(planet2OrbitProximity, planet2OrbitProximity)\n    planet1OrbitProximityProximityProximity\
    \ := proximity(planet1OrbitProximityProximityProximity, planet1OrbitProximityProximity)\n\
    \    planet2OrbitProximityProximityProximity := proximity(planet2OrbitProximityProximityProximity,\
    \ planet2OrbitProximityProximity)\n    planet1OrbitProximityProximityProximityProximity\
    \ := proximity(planet1OrbitProximityProximityProximityProximityProximity, planet1OrbitProximityProximityProximityProximity)\n\
    \    planet2OrbitProximityProximityProximityProximity := proximity(planet2OrbitProximityProximityProximityProximityProximity,\
    \ planet2OrbitProximityProximityProximityProximity)\n    planet1OrbitProximityProximityProximityProximityProximity\
    \ := proximity(planet\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpnx5kkw09_test.go:39:82: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074489
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit = sortByProximity(planet1Orbit,\
    \ planet2Orbit)\n    return planet1Orbit\n}\n\nfunc TestBf(t *testing.T) {\n \
    \ candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpumwg0x5y_test.go:25:35: undefined: getOrbits

    /tmp/tmpumwg0x5y_test.go:26:34: undefined: sortByProximity

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074484
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit, planet2Orbit := orbit(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    \n   \
    \ planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    \n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit, planet2Orbit\n    \n    planet1Orbit, planet2Orbit\
    \ = planet1Orbit, planet2Orbit\n    \n    planet1Orbit, planet2Orbit = planet1Orbit,\
    \ planet2Orbit\n    \n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    \n   \
    \ planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    \n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit, planet2Orbit\n    \n    planet1Orbit, planet2Orbit\
    \ = planet1Orbit, planet2Orbit\n    \n    planet1Orbit, planet2Orbit = planet1Orbit,\
    \ planet2Orbit\n    \n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    \n   \
    \ planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    \n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit, planet2Orbit\n    \n    planet1Orbit, planet2Orbit\
    \ = planet1Orbit, planet2Orbit\n    \n    planet1Orbit, planet\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpzxiacqwe_test.go:64:5: expected 1 expression

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074489
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := planet1, planet2\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6c773qfu_test.go:38:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074483
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    // Your code here\n\
    \    planet1Orbit := orbit(planet1)\n    planet2Orbit := orbit(planet2)\n    \n\
    \    planet1Orbit.sort()\n    planet2Orbit.sort()\n    \n    planet1Orbit.intersect(planet2Orbit)\n\
    \    \n    return planet1Orbit.slice()\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3fvviq_3_test.go:26:21: undefined: orbit

    /tmp/tmp3fvviq_3_test.go:27:21: undefined: orbit

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074490
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    // Your code here\n\
    \    planet1Orbit := orbit(planet1)\n    planet2Orbit := orbit(planet2)\n    planet1Orbit.sort()\n\
    \    planet2Orbit.sort()\n    \n    \n    \n    \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpc17e80mc_test.go:262:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074489
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := getOrbits(planet1, planet2)\n    planet1Orbit.sort()\n    planet2Orbit.sort()\n\
    \    \n    if planet1Orbit[0] == planet2Orbit[0] {\n        return []interface{}{planet1Orbit[0]}\n\
    \    }\n    \n    if planet1Orbit[0] < planet2Orbit[0] {\n        return bf(\"\
    Earth\", planet1) + bf(\"Mars\", planet2)\n    }\n    \n    return bf(\"Earth\"\
    , planet2) + bf(\"Mars\", planet1)\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpibw7ytfx_test.go:25:35: undefined: getOrbits

    /tmp/tmpibw7ytfx_test.go:34:16: invalid operation: operator + not defined on bf("Earth",
    planet1) (value of type []interface{})

    /tmp/tmpibw7ytfx_test.go:37:12: invalid operation: operator + not defined on bf("Earth",
    planet2) (value of type []interface{})

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074490
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit = sortByProximity(planet1Orbit,\
    \ planet2Orbit)\n    return planet1Orbit\n}\n\nfunc TestBf(t *testing.T) {\n \
    \ candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpumwg0x5y_test.go:25:35: undefined: getOrbits

    /tmp/tmpumwg0x5y_test.go:26:34: undefined: sortByProximity

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074484
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit = sortByProximity(planet1Orbit,\
    \ planet2Orbit)\n    return planet1Orbit\n}\n\nfunc TestBf(t *testing.T) {\n \
    \ candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpumwg0x5y_test.go:25:35: undefined: getOrbits

    /tmp/tmpumwg0x5y_test.go:26:34: undefined: sortByProximity

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074484
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := getOrbits(planet1, planet2)\n    planet1Orbit.sort()\n    planet2Orbit.sort()\n\
    \    \n    planet1Orbit = append(planet1Orbit, planet2)\n    planet2Orbit = append(planet2Orbit,\
    \ planet1)\n    \n    planet1Orbit.sort()\n    planet2Orbit.sort()\n    \n   \
    \ planet1Orbit = append(planet1Orbit, planet1)\n    planet2Orbit = append(planet2Orbit,\
    \ planet2)\n    \n    planet1Orbit.sort()\n    planet2Orbit.sort()\n    \n   \
    \ planet1Orbit = append(planet1Orbit, planet2)\n    planet2Orbit = append(planet2Orbit,\
    \ planet1)\n    \n    planet1Orbit.sort()\n    planet2Orbit.sort()\n    \n   \
    \ planet1Orbit = append(planet1Orbit, planet1)\n    planet2Orbit = append(planet2Orbit,\
    \ planet2)\n    \n    planet1Orbit.sort()\n    planet2Orbit.sort()\n    \n   \
    \ planet1Orbit = append(planet1Orbit, planet2)\n    planet2Orbit = append(planet2Orbit,\
    \ planet1)\n    \n    planet1Orbit.sort()\n    planet2Orbit.sort()\n    \n   \
    \ planet1Orbit = append(planet1Orbit, planet1)\n    planet2Orbit = append(planet2Orbit,\
    \ planet2)\n    \n    planet1Orbit.sort()\n    planet2Orbit.sort()\n    \n   \
    \ planet1Orbit = append(planet1Orbit, planet2)\n    planet2Orbit = append(planet2Orbit,\
    \ planet1)\n    \n    planet1Orbit.sort()\n    planet2Orbit.sort()\n    \n   \
    \ planet1Orbit = append(planet1Orbit, planet1)\n    planet2Orbit = append(planet2Orbit,\
    \ planet2)\n    \n    planet1Orbit.sort()\n    planet2Orbit.sort()\n    \n   \
    \ planet1\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpnfm65c68_test.go:78:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074489
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, err\
    \ := getOrbit(planet1)\n    if err != nil {\n        fmt.Println(err)\n      \
    \  return nil\n    }\n    planet2Orbit, err := getOrbit(planet2)\n    if err !=\
    \ nil {\n        fmt.Println(err)\n        return nil\n    }\n    planet1Sun,\
    \ err := getSun()\n    if err != nil {\n        fmt.Println(err)\n        return\
    \ nil\n    }\n    planet2Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \        return nil\n    }\n    planet1SunDistance := getDistance(planet1Orbit,\
    \ planet1Sun)\n    planet2SunDistance := getDistance(planet2Orbit, planet2Sun)\n\
    \    if planet1SunDistance < planet2SunDistance {\n        return append([]interface{}{planet1},\
    \ bf(planet2, planet1))\n    }\n    return append([]interface{}{planet2}, bf(planet1,\
    \ planet2))\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkzxdbdou_test.go:25:26: undefined: getOrbit

    /tmp/tmpkzxdbdou_test.go:30:26: undefined: getOrbit

    /tmp/tmpkzxdbdou_test.go:35:24: undefined: getSun

    /tmp/tmpkzxdbdou_test.go:40:24: undefined: getSun

    /tmp/tmpkzxdbdou_test.go:45:27: undefined: getDistance

    /tmp/tmpkzxdbdou_test.go:46:27: undefined: getDistance

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074490
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit := orbit(planet1)\n\
    \    planet2Orbit := orbit(planet2)\n    \n    planet1Orbit.sort()\n    planet2Orbit.sort()\n\
    \    \n    result := []interface{}{}\n    \n    for i := 0; i < len(planet1Orbit);\
    \ i++ {\n        if planet1Orbit[i] == planet2Orbit[i] {\n            result =\
    \ append(result, planet1Orbit[i])\n        }\n    }\n    \n    return result\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpnrw3j9ok_test.go:25:21: undefined: orbit

    /tmp/tmpnrw3j9ok_test.go:26:21: undefined: orbit

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074490
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := planet1, planet2\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6c773qfu_test.go:38:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074483
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := planet1Orbit(planet1, planet2), planet2Orbit(planet1, planet2)\n    if planet1Orbit\
    \ == \"\" || planet2Orbit == \"\" {\n        return nil\n    }\n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit.([]interface{}), planet2Orbit.([]interface{})\n\
    \    planet1Orbit, planet2Orbit = sort.SliceStable(planet1Orbit, planet2Orbit,\
    \ func(i, j int) bool {\n        return planet1Orbit[i].(float64) < planet2Orbit[j].(float64)\n\
    \    })\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)], planet2Orbit[:len(planet2Orbit)]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit.([]string), planet2Orbit.([]string)\n\
    \    planet1Orbit, planet2Orbit = sort.SliceStable(planet1Orbit, planet2Orbit,\
    \ func(i, j int) bool {\n        return planet1Orbit[i].(float64) < planet2Orbit[j].(float64)\n\
    \    })\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)], planet2Orbit[:len(planet2Orbit)]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit.([]string), planet2Orbit.([]string)\n\
    \    planet1Orbit, planet2Orbit = sort.SliceStable(planet1Orbit, planet2Orbit,\
    \ func(i, j int) bool {\n        return planet1Orbit[i].(float64) < planet2Orbit[j].(float64)\n\
    \    })\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)], planet2Orbit[:len(planet2Orbit)]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit.([]string), planet2Orbit.([]string)\n\
    \    planet1Orbit, planet2Orbit = sor\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpou0rykd3_test.go:46:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074489
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := orbit(planet1, planet2)\n    planet1Orbit.sort()\n    planet2Orbit.sort()\n\
    \    \n    planet1Orbit.intersect(planet2Orbit)\n    return planet1Orbit\n}\n\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkpcyvasn_test.go:25:35: undefined: orbit

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074490
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    planet1 := strings.ToLower(planet1)\n    planet2\
    \ := strings.ToLower(planet2)\n    planet1 := strings.Trim(planet1, \" \")\n \
    \   planet2 := strings.Trim(planet2, \" \")\n    planet1 := strings.Replace(planet1,\
    \ \" \", \"-\", -1)\n    planet2 := strings.Replace(planet2, \" \", \"-\", -1)\n\
    \    planet1 := strings.Replace(planet1, \"-\", \"-\", -1)\n    planet2 := strings.Replace(planet2,\
    \ \"-\", \"-\", -1)\n    planet1 := strings.Replace(planet1, \"_\", \"-\", -1)\n\
    \    planet2 := strings.Replace(planet2, \"_\", \"-\", -1)\n    planet1 := strings.Replace(planet1,\
    \ \"/\", \"-\", -1)\n    planet2 := strings.Replace(planet2, \"/\", \"-\", -1)\n\
    \    planet1 := strings.Replace(planet1, \"\\\\\", \"-\", -1)\n    planet2 :=\
    \ strings.Replace(planet2, \"\\\\\", \"-\", -1)\n    planet1 := strings.Replace(planet1,\
    \ \"-\", \"-\", -1)\n    planet2 := strings.Replace(planet2, \"-\", \"-\", -1)\n\
    \    planet1 := strings.Replace(planet1, \"_\", \"-\", -1)\n    planet2 := strings.Replace(planet2,\
    \ \"_\", \"-\", -1)\n    planet1 := strings.Replace(planet1, \"/\", \"-\", -1)\n\
    \    planet2 := strings.Replace(planet2, \"/\", \"-\", -1)\n    planet1 := strings.Replace(planet1,\
    \ \"\\\\\", \"-\", -1)\n    planet2 := strings.Replace(planet2, \"\\\\\", \"-\"\
    , -1)\n    planet1 := strings.Replace(planet1, \"-\", \"-\", -1)\n    planet2\
    \ := strings.Replace(planet2, \"-\", \"-\", -1)\n    planet1 := strings.Replace(planet1,\
    \ \"_\", \"-\", -1)\n    planet2 := strings.Replace(planet2, \"_\", \"-\", -1)\n\
    \    planet1 := strings.Replace(planet1, \"/\", \"-\", -1)\n    planet2 := strings.Replace(planet2,\
    \ \"/\", \"-\", -1)\n    planet1 := strings.Replace(planet1, \"\\\\\", \"-\",\
    \ -1)\n    planet2 := strings.Replace(planet2, \"\\\\\", \"-\", -1)\n    planet1\
    \ := strings.Replace(planet1, \"-\", \"-\", -1)\n    planet2 := strings.Replace(planet\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpauyrkuka_test.go:58:38: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074489
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1.ToUpper(), planet2.ToUpper()\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvuq3h8im_test.go:54:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074489
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := orbit(planet1, planet2)\n    planet1OrbitSun, planet2OrbitSun := sun(planet1Orbit),\
    \ sun(planet2Orbit)\n    planet1OrbitSunSun := sun(planet1OrbitSun)\n    planet2OrbitSunSun\
    \ := sun(planet2OrbitSun)\n    planet1OrbitSunSunSun := sun(planet1OrbitSunSun)\n\
    \    planet2OrbitSunSunSun := sun(planet2OrbitSunSun)\n    planet1OrbitSunSunSunSun\
    \ := sun(planet1OrbitSunSunSun)\n    planet2OrbitSunSunSunSun := sun(planet2OrbitSunSunSun)\n\
    \    planet1OrbitSunSunSunSunSun := sun(planet1OrbitSunSunSunSun)\n    planet2OrbitSunSunSunSunSun\
    \ := sun(planet2OrbitSunSunSunSun)\n    planet1OrbitSunSunSunSunSunSun := sun(planet1OrbitSunSunSunSunSun)\n\
    \    planet2OrbitSunSunSunSunSunSun := sun(planet2OrbitSunSunSunSunSun)\n    planet1OrbitSunSunSunSunSunSunSun\
    \ := sun(planet1OrbitSunSunSunSunSunSun)\n    planet2OrbitSunSunSunSunSunSunSun\
    \ := sun(planet2OrbitSunSunSunSunSunSun)\n    planet1OrbitSunSunSunSunSunSunSunSun\
    \ := sun(planet1OrbitSunSunSunSunSunSunSunSun)\n    planet2OrbitSunSunSunSunSunSunSunSunSun\
    \ := sun(planet2OrbitSunSunSunSunSunSunSunSun)\n    planet1OrbitSunSunSunSunSunSunSunSunSun\
    \ := sun(planet1OrbitSunSunSunSunSunSunSunSunSun)\n    planet2OrbitSunSunSunSunSunSunSunSunSun\
    \ := sun(planet2OrbitSunSunSunSunSunSunSunSunSunSun)\n    planet1OrbitSunSunSunSunSunSunSunSunSunSun\
    \ := sun\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpx_j26woy_test.go:44:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074489
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := planetOrbit(planet1, planet2)\n    planet1Orbit.sort()\n    planet2Orbit.sort()\n\
    \    \n    planet1Orbit.intersect(planet2Orbit)\n    \n    return planet1Orbit\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfszmhfcx_test.go:25:35: undefined: planetOrbit

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074491
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit, err := getOrbit(planet1)\n  \
    \  if err != nil {\n        fmt.Println(err)\n    }\n    planet2Orbit, err :=\
    \ getOrbit(planet2)\n    if err != nil {\n        fmt.Println(err)\n    }\n  \
    \  \n    planet1Sun, err := getSun(planet1)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet2Sun, err := getSun(planet2)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    \n    planet1SunDistance := planet1Sun.Distance(planet1Orbit)\n  \
    \  planet2SunDistance := planet2Sun.Distance(planet2Orbit)\n    \n    planet1SunDistance\
    \ += planet1Orbit.Distance(planet1Sun)\n    planet2SunDistance += planet2Orbit.Distance(planet2Sun)\n\
    \    \n    planet1SunDistance += planet1Orbit.Distance(planet1Orbit)\n    planet2SunDistance\
    \ += planet2Orbit.Distance(planet2Orbit)\n    \n    planet1SunDistance += planet1Orbit.Distance(planet1Orbit)\n\
    \    planet2SunDistance += planet2Orbit.Distance(planet2Orbit)\n    \n    planet1SunDistance\
    \ += planet1Orbit.Distance(planet1Orbit)\n    planet2SunDistance += planet2Orbit.Distance(planet2Orbit)\n\
    \    \n    planet1SunDistance += planet1Orbit.Distance(planet1Orbit)\n    planet2SunDistance\
    \ += planet2Orbit.Distance(planet2Orbit)\n    \n    planet1SunDistance += planet1Orbit.Distance(planet1Orbit)\n\
    \    planet2SunDistance += planet2Orbit.Distance(planet2Orbit)\n    \n    planet1SunDistance\
    \ += planet1Orbit.Distance(planet1Orbit)\n    planet2SunDistance += planet2Orbit.Distance(planet2Orbit)\n\
    \    \n    planet1SunDistance += plan\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp3gcpjuso_test.go:71:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074490
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit := orbit(planet1)\n\
    \    planet2Orbit := orbit(planet2)\n    \n    planet1Orbit.sort()\n    planet2Orbit.sort()\n\
    \    \n    planet1Orbit.intersect(planet2Orbit)\n    \n    return planet1Orbit\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpe0lul313_test.go:25:21: undefined: orbit

    /tmp/tmpe0lul313_test.go:26:21: undefined: orbit

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074491
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2\
    \ = planet1, planet2\n    \n    planet1Orbit, planet2Orbit, sunOrbit := getOrbits(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1,\
    \ planet2)\n    \n    plan\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpx0jvrbh9_test.go:62:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074483
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit := orbit(planet1)\n\
    \    planet2Orbit := orbit(planet2)\n    \n    planet1Orbit.sort()\n    planet2Orbit.sort()\n\
    \    \n    planet1Orbit.intersect(planet2Orbit)\n    \n    return planet1Orbit\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpe0lul313_test.go:25:21: undefined: orbit

    /tmp/tmpe0lul313_test.go:26:21: undefined: orbit

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074491
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := orbit(planet1, planet2)\n    planet1Orbit = append(planet1Orbit, planet2Orbit...)\n\
    \    planet2Orbit = append(planet2Orbit, planet1Orbit...)\n    planet1Orbit =\
    \ append(planet1Orbit, planet2Orbit...)\n    planet2Orbit = append(planet2Orbit,\
    \ planet1Orbit...)\n    planet1Orbit = append(planet1Orbit, planet2Orbit...)\n\
    \    planet2Orbit = append(planet2Orbit, planet1Orbit...)\n    planet1Orbit =\
    \ append(planet1Orbit, planet2Orbit...)\n    planet2Orbit = append(planet2Orbit,\
    \ planet1Orbit...)\n    planet1Orbit = append(planet1Orbit, planet2Orbit...)\n\
    \    planet2Orbit = append(planet2Orbit, planet1Orbit...)\n    planet1Orbit =\
    \ append(planet1Orbit, planet2Orbit...)\n    planet2Orbit = append(planet2Orbit,\
    \ planet1Orbit...)\n    planet1Orbit = append(planet1Orbit, planet2Orbit...)\n\
    \    planet2Orbit = append(planet2Orbit, planet1Orbit...)\n    planet1Orbit =\
    \ append(planet1Orbit, planet2Orbit...)\n    planet2Orbit = append(planet2Orbit,\
    \ planet1Orbit...)\n    planet1Orbit = append(planet1Orbit, planet2Orbit...)\n\
    \    planet2Orbit = append(planet2Orbit, planet1Orbit...)\n    planet1Orbit =\
    \ append(planet1Orbit, planet2Orbit...)\n    planet2Orbit = append(planet2Orbit,\
    \ planet1Orbit...)\n    planet1Orbit = append(planet1Orbit, planet2Orbit...)\n\
    \    planet2Orbit = append(planet2Orbit, planet1Orbit...)\n    planet1Orbit =\
    \ append(planet1Orbit, planet2Orbit...)\n    planet2Orbit = \nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvbpaqexe_test.go:50:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074490
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := orbit(planet1, planet2)\n    planet1OrbitSun, planet2OrbitSun := orbit(planet1,\
    \ planet2)\n    planet1OrbitSun, planet2OrbitSun := orbit(planet1, planet2)\n\
    \    planet1OrbitSun, planet2OrbitSun := orbit(planet1, planet2)\n    planet1OrbitSun,\
    \ planet2OrbitSun := orbit(planet1, planet2)\n    planet1OrbitSun, planet2OrbitSun\
    \ := orbit(planet1, planet2)\n    planet1OrbitSun, planet2OrbitSun := orbit(planet1,\
    \ planet2)\n    planet1OrbitSun, planet2OrbitSun := orbit(planet1, planet2)\n\
    \    planet1OrbitSun, planet2OrbitSun := orbit(planet1, planet2)\n    planet1OrbitSun,\
    \ planet2OrbitSun := orbit(planet1, planet2)\n    planet1OrbitSun, planet2OrbitSun\
    \ := orbit(planet1, planet2)\n    planet1OrbitSun, planet2OrbitSun := orbit(planet1,\
    \ planet2)\n    planet1OrbitSun, planet2OrbitSun := orbit(planet1, planet2)\n\
    \    planet1OrbitSun, planet2OrbitSun := orbit(planet1, planet2)\n    planet1OrbitSun,\
    \ planet2OrbitSun := orbit(planet1, planet2)\n    planet1OrbitSun, planet2OrbitSun\
    \ := orbit(planet1, planet2)\n    planet1OrbitSun, planet2OrbitSun := orbit(planet1,\
    \ planet2)\n    planet1OrbitSun, planet2OrbitSun := orbit(planet1, planet2)\n\
    \    planet1OrbitSun, planet2OrbitSun := orbit(planet1, planet2)\n    planet1OrbitSun,\
    \ planet2OrbitSun := orbit(planet1, planet2)\n    planet1OrbitSun, planet2OrbitSun\
    \ \nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpgavkdadm_test.go:45:5: expected 1 expression

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074490
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := orbit(planet1, planet2)\n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit, planet2Orbit\n    planet1Orbit, planet2Orbit =\
    \ planet1Orbit, planet2Orbit\n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit, planet2Orbit\n    planet1Orbit, planet2Orbit =\
    \ planet1Orbit, planet2Orbit\n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit, planet2Orbit\n    planet1Orbit, planet2Orbit =\
    \ planet1Orbit, planet2Orbit\n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit, planet2Orbit\n    planet1Orbit, planet2Orbit =\
    \ planet1Orbit, planet2Orbit\n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit, planet2Orbit\n    planet1Orbit, planet2Orbit =\
    \ planet\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpft792_zg_test.go:46:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074488
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := planet1, planet2\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6c773qfu_test.go:38:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074483
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    planet1Orbit := planet1\n    planet2Orbit := planet2\n\
    \    planet1OrbitOrbit := planet1\n    planet2OrbitOrbit := planet2\n    planet1OrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbit := planet2\n    planet1OrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbit := planet2\n    planet1OrbitOrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbitOrbit := planet2\n    planet1OrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbit := planet2\n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2\n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2\n\
    \    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet2\n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit :=\
    \ planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet2\n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet2\n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpqdkxilpy_test.go:50:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074490
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit := orbit(planet1)\n\
    \    planet2Orbit := orbit(planet2)\n    \n    planet1Orbit.sort()\n    planet2Orbit.sort()\n\
    \    \n    planet1Orbit.intersect(planet2Orbit)\n    \n    return planet1Orbit.elements\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_pb4ok3__test.go:25:21: undefined: orbit

    /tmp/tmp_pb4ok3__test.go:26:21: undefined: orbit

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074491
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit, err := getPlanetOrbit(planet1)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    planet2Orbit, err :=\
    \ getPlanetOrbit(planet2)\n    if err != nil {\n        fmt.Println(err)\n   \
    \ }\n    \n    planet1Sun, err := getPlanetOrbit(\"Sun\")\n    if err != nil {\n\
    \        fmt.Println(err)\n    }\n    planet2Sun, err := getPlanetOrbit(\"Sun\"\
    )\n    if err != nil {\n        fmt.Println(err)\n    }\n    \n    planet1SunProximity\
    \ := getPlanetProximity(planet1Orbit, planet1Sun)\n    planet2SunProximity :=\
    \ getPlanetProximity(planet2Orbit, planet2Sun)\n    \n    planet1Proximity :=\
    \ getPlanetProximity(planet1Orbit, planet1Orbit)\n    planet2Proximity := getPlanetProximity(planet2Orbit,\
    \ planet2Orbit)\n    \n    planet1ProximityProximity := getPlanetProximity(planet1Proximity,\
    \ planet1SunProximity)\n    planet2ProximityProximity := getPlanetProximity(planet2Proximity,\
    \ planet2SunProximity)\n    \n    planet1ProximityProximityProximity := getPlanetProximity(planet1ProximityProximity,\
    \ planet1ProximityProximity)\n    planet2ProximityProximityProximity := getPlanetProximity(planet2ProximityProximity,\
    \ planet2ProximityProximity)\n    \n    planet1ProximityProximityProximityProximity\
    \ := getPlanetProximity(planet1ProximityProximityProximityProximity, planet1ProximityProximityProximityProximity)\n\
    \    planet2ProximityProximityProximityProximity := getPlanetProximity(planet2ProximityProximityProxim\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpscy2bz5u_test.go:59:102: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074490
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2\
    \ = planet1, planet2\n    \n    planet1Orbit, planet2Orbit := planet1, planet2\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Or\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp9ezkbm56_test.go:49:61: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074483
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    planet1Orbit, planet2Orbit := getOrbits(planet1,\
    \ planet2)\n    planet1Sun, planet2Sun := getSun(planet1, planet2)\n    planet1SunDistance\
    \ := getDistance(planet1Orbit, planet1Sun)\n    planet2SunDistance := getDistance(planet2Orbit,\
    \ planet2Sun)\n    planet1SunDistance += planet1SunDistance\n    planet2SunDistance\
    \ += planet2SunDistance\n    planet1SunDistance /= 2\n    planet2SunDistance /=\
    \ 2\n    planet1SunDistance += planet2SunDistance\n    planet2SunDistance += planet1SunDistance\n\
    \    planet1SunDistance /= 2\n    planet2SunDistance /= 2\n    planet1SunDistance\
    \ += planet2SunDistance\n    planet2SunDistance += planet1SunDistance\n    planet1SunDistance\
    \ /= 2\n    planet2SunDistance /= 2\n    planet1SunDistance += planet2SunDistance\n\
    \    planet2SunDistance += planet1SunDistance\n    planet1SunDistance /= 2\n \
    \   planet2SunDistance /= 2\n    planet1SunDistance += planet2SunDistance\n  \
    \  planet2SunDistance += planet1SunDistance\n    planet1SunDistance /= 2\n   \
    \ planet2SunDistance /= 2\n    planet1SunDistance += planet2SunDistance\n    planet2SunDistance\
    \ += planet1SunDistance\n    planet1SunDistance /= 2\n    planet2SunDistance /=\
    \ 2\n    planet1SunDistance += planet2SunDistance\n    planet2SunDistance += planet1SunDistance\n\
    \    planet1SunDistance /= 2\n    planet2SunDistance /= 2\n    planet1SunDistance\
    \ += planet2SunDistance\n    planet2SunDistance += planet1SunDistance\n    planet1SunDistance\
    \ /= 2\n    planet2SunDistance /= 2\n    planet1SunDistance += planet2SunDistance\n\
    \    planet2SunDistance += planet1SunDistance\n    planet1SunDistance /= 2\n \
    \   planet2SunDistance /= 2\n    planet1SunDistance += plan\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpo2z3obub_test.go:68:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074490
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1.ToLower(), planet2.ToLower()\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpkc03pxac_test.go:54:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074487
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    planet1Orbit := planet1\n    planet2Orbit := planet2\n\
    \    planet1OrbitOrbit := planet1\n    planet2OrbitOrbit := planet2\n    planet1OrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbit := planet2\n    planet1OrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbit := planet2\n    planet1OrbitOrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbitOrbit := planet2\n    planet1OrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbit := planet2\n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2\n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2\n\
    \    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet2\n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit :=\
    \ planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet2\n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet2\n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpqdkxilpy_test.go:50:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074490
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit := orbit(planet1)\n\
    \    planet2Orbit := orbit(planet2)\n    \n    planet1Orbit.sort()\n    planet2Orbit.sort()\n\
    \    \n    result := []interface{}{}\n    \n    for _, planet := range planet1Orbit\
    \ {\n        for _, planet2 := range planet2Orbit {\n            if planet ==\
    \ planet2 {\n                result = append(result, planet)\n            }\n\
    \        }\n    }\n    \n    return result\n}\n\nfunc TestBf(t *testing.T) {\n\
    \  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpgl6qmnck_test.go:25:21: undefined: orbit

    /tmp/tmpgl6qmnck_test.go:26:21: undefined: orbit

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074488
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2\
    \ = planet1, planet2\n    \n    planet1Orbit, planet2Orbit := planet1, planet2\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    \n   \
    \ planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    \n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit, planet2Orbit\n    \n    planet1Orbit, planet2Orbit\
    \ = planet1Orbit, planet2Orbit\n    \n    planet1Orbit, planet2Orbit = planet1Orbit,\
    \ planet2Orbit\n    \n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    \n   \
    \ planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    \n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit, planet2Orbit\n    \n    planet1Orbit, planet2Orbit\
    \ = planet1Orbit, planet2Orbit\n    \n    planet1Orbit, planet2Orbit = planet1Orbit,\
    \ planet2Orbit\n    \n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    \n   \
    \ planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    \n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit, planet2Orbit\n    \n    planet1Orbit, planet2Orbit\
    \ = planet1Orbit, planet2Orbit\n    \n    planet1Orbit, planet2Orbit = planet1Orbit,\
    \ planet2Orbit\n    \n    planet1Orbit, planet2Orbit = planet\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpglip0rps_test.go:64:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074488
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2\
    \ = planet1, planet2\n    planet1Planet2, err := planet2Planet(planet1, planet2)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    planet1Planet2, err\
    \ = planet2Planet(planet1, planet2)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet1Planet2, err = planet2Planet(planet1, planet2)\n    if err\
    \ != nil {\n        fmt.Println(err)\n    }\n    planet1Planet2, err = planet2Planet(planet1,\
    \ planet2)\n    if err != nil {\n        fmt.Println(err)\n    }\n    planet1Planet2,\
    \ err = planet2Planet(planet1, planet2)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet1Planet2, err = planet2Planet(planet1, planet2)\n    if err\
    \ != nil {\n        fmt.Println(err)\n    }\n    planet1Planet2, err = planet2Planet(planet1,\
    \ planet2)\n    if err != nil {\n        fmt.Println(err)\n    }\n    planet1Planet2,\
    \ err = planet2Planet(planet1, planet2)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet1Planet2, err = planet2Planet(planet1, planet2)\n    if err\
    \ != nil {\n        fmt.Println(err)\n    }\n    planet1Planet2, err = planet2Planet(planet1,\
    \ planet2)\n    if err != nil {\n        fmt.Println(err)\n    }\n    planet1Planet2,\
    \ err = planet2Planet(planet1, planet2)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet1Planet2, err = planet2Planet(planet1, planet2)\n    if err\
    \ != nil {\n        fmt.Println(err)\n    }\n    planet1Planet2, err = planet2Planet(planet1,\
    \ planet2)\n    if err != nil {\n        fmt.Println(err)\n    }\n    planet1Planet2,\
    \ err = planet2Planet(planet1, planet2)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet1Planet2, err = planet2Planet(planet1, planet2)\n\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpmk1f6spp_test.go:84:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074490
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := orbit(planet1, planet2)\n    planet1Orbit.sort()\n    planet2Orbit.sort()\n\
    \    \n    planet1Orbit.intersect(planet2Orbit)\n    return planet1Orbit\n}\n\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkpcyvasn_test.go:25:35: undefined: orbit

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074490
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit := orbit(planet1)\n\
    \    planet2Orbit := orbit(planet2)\n    planet1Orbit.sort()\n    planet2Orbit.sort()\n\
    \    \n    planet1Orbit.intersect(planet2Orbit)\n    \n    return planet1Orbit.planets\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkwdzy6un_test.go:25:21: undefined: orbit

    /tmp/tmpkwdzy6un_test.go:26:21: undefined: orbit

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074491
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit := orbit(planet1)\n\
    \    planet2Orbit := orbit(planet2)\n    planet1Orbit.sort()\n    planet2Orbit.sort()\n\
    \    \n    planet1Orbit.intersect(planet2Orbit)\n    return planet1Orbit.slice()\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpebdv_a3f_test.go:25:21: undefined: orbit

    /tmp/tmpebdv_a3f_test.go:26:21: undefined: orbit

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074491
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit := planet1\n    planet2Orbit :=\
    \ planet2\n    \n    planet1OrbitOrbit := planet1\n    planet2OrbitOrbit := planet2\n\
    \    \n    planet1OrbitOrbitOrbit := planet1\n    planet2OrbitOrbitOrbit := planet2\n\
    \    \n    planet1OrbitOrbitOrbitOrbit := planet1\n    planet2OrbitOrbitOrbitOrbit\
    \ := planet2\n    \n    planet1OrbitOrbitOrbitOrbitOrbit := planet1\n    planet2OrbitOrbitOrbitOrbitOrbit\
    \ := planet2\n    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbit := planet1\n   \
    \ planet2OrbitOrbitOrbitOrbitOrbitOrbit := planet2\n    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2\n\
    \    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet1\n \
    \   planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2\n   \
    \ \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp2960_ryc_test.go:53:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074491
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit = getOrbits(planet2,\
    \ planet1)\n    planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n   \
    \ planet1Orbit, planet2Orbit = getOrbits(planet2, planet1)\n    planet1Orbit,\
    \ planet2Orbit = getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit =\
    \ getOrbits(planet2, planet1)\n    planet1Orbit, planet2Orbit = getOrbits(planet1,\
    \ planet2)\n    planet1Orbit, planet2Orbit = getOrbits(planet2, planet1)\n   \
    \ planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n    planet1Orbit,\
    \ planet2Orbit = getOrbits(planet2, planet1)\n    planet1Orbit, planet2Orbit =\
    \ getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit = getOrbits(planet2,\
    \ planet1)\n    planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n   \
    \ planet1Orbit, planet2Orbit = getOrbits(planet2, planet1)\n    planet1Orbit,\
    \ planet2Orbit = getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit =\
    \ getOrbits(planet2, planet1)\n    planet1Orbit, planet2Orbit = getOrbits(planet1,\
    \ planet2)\n    planet1Orbit, planet2Orbit = getOrbits(planet2, planet1)\n   \
    \ planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n    planet1Orbit,\
    \ planet2Orbit = getOrbits(planet2, planet1)\n    planet1Orbit, planet2Orbit =\
    \ getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit = getOrbits(planet2,\
    \ planet1)\n    planet1Or\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpbmgyh1vj_test.go:48:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074483
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, err\
    \ := getOrbit(planet1)\n    if err != nil {\n        fmt.Println(err)\n    }\n\
    \    planet2Orbit, err := getOrbit(planet2)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet1OrbitSun, err := getOrbitSun(planet1)\n    if err != nil {\n\
    \        fmt.Println(err)\n    }\n    planet2OrbitSun, err := getOrbitSun(planet2)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    planet1OrbitSunSun,\
    \ err := getOrbitSunSun(planet1)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet2OrbitSunSun, err := getOrbitSunSun(planet2)\n    if err !=\
    \ nil {\n        fmt.Println(err)\n    }\n    planet1OrbitSunSunSun, err := getOrbitSunSunSun(planet1)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    planet2OrbitSunSunSun,\
    \ err := getOrbitSunSunSun(planet2)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet1OrbitSunSunSunSun, err := getOrbitSunSunSunSun(planet1)\n \
    \   if err != nil {\n        fmt.Println(err)\n    }\n    planet2OrbitSunSunSunSun,\
    \ err := getOrbitSunSunSunSun(planet2)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet1OrbitSunSunSunSunSun, err := getOrbitSunSunSunSunSun(planet1)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    planet2OrbitSunSunSunSunSun,\
    \ err := getOrbitSunSunSunSunSun(planet2)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet1OrbitSunSunSunSunSunSun, err := getOrbitSunSunSunSunSunSun(planet1)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    planet2OrbitSunSunSunSunSunSun,\
    \ err := getOrbitSunSunSunSunSunSunSun(planet2)\n    if err != nil {\n       \
    \ fmt.Println(err)\n    }\n    planet1OrbitSun\nfunc TestBf(t *testing.T) {\n\
    \  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp7u8b5z0u_test.go:82:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074491
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit := orbit(planet1)\n\
    \    planet2Orbit := orbit(planet2)\n    \n    planet1Sun := sun(planet1)\n  \
    \  planet2Sun := sun(planet2)\n    \n    planet1SunDistance := distance(planet1Orbit,\
    \ planet1Sun)\n    planet2SunDistance := distance(planet2Orbit, planet2Sun)\n\
    \    \n    planet1SunDistance += planet1Orbit.DistanceTo(planet2Orbit)\n    planet2SunDistance\
    \ += planet2Orbit.DistanceTo(planet1Orbit)\n    \n    planet1SunDistance += planet1Orbit.DistanceTo(planet2Orbit)\n\
    \    planet2SunDistance += planet2Orbit.DistanceTo(planet1Orbit)\n    \n    planet1SunDistance\
    \ += planet1Orbit.DistanceTo(planet2Orbit)\n    planet2SunDistance += planet2Orbit.DistanceTo(planet1Orbit)\n\
    \    \n    planet1SunDistance += planet1Orbit.DistanceTo(planet2Orbit)\n    planet2SunDistance\
    \ += planet2Orbit.DistanceTo(planet1Orbit)\n    \n    planet1SunDistance += planet1Orbit.DistanceTo(planet2Orbit)\n\
    \    planet2SunDistance += planet2Orbit.DistanceTo(planet1Orbit)\n    \n    planet1SunDistance\
    \ += planet1Orbit.DistanceTo(planet2Orbit)\n    planet2SunDistance += planet2Orbit.DistanceTo(planet1Orbit)\n\
    \    \n    planet1SunDistance += planet1Orbit.DistanceTo(planet2Orbit)\n    planet2SunDistance\
    \ += planet2Orbit.DistanceTo(planet1Orbit)\n    \n    planet1SunDistance += planet1Orbit.DistanceTo(planet2Orbit)\n\
    \    planet2SunDistance += planet2Orbit.DistanceTo(planet1Orbit)\n    \n    planet1SunDistance\
    \ += planet1Orbit.DistanceTo(planet2Orbit)\n    planet2SunDistance += planet2Orbit.DistanceTo(planet1Orbit)\n\
    \    \n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmps2frryxk_test.go:62:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074491
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2\
    \ = strings.ToLower(planet1), strings.ToLower(planet2)\n    planet1Planet2 :=\
    \ planet1 + \" \" + planet2\n    planet1Planet2Planet1 := planet1 + \" \" + planet2\
    \ + \" \" + planet1\n    planet1Planet2Planet1Planet2 := planet1 + \" \" + planet2\
    \ + \" \" + planet1 + \" \" + planet2\n    planet1Planet2Planet1Planet2Planet1\
    \ := planet1 + \" \" + planet2 + \" \" + planet1 + \" \" + planet2 + \" \" + planet1\n\
    \    planet1Planet2Planet1Planet2Planet1Planet2 := planet1 + \" \" + planet2 +\
    \ \" \" + planet1 + \" \" + planet2 + \" \" + planet1 + \" \" + planet2\n    planet1Planet2Planet1Planet2Planet1Planet2Planet1\
    \ := planet1 + \" \" + planet2 + \" \" + planet1 + \" \" + planet2 + \" \" + planet1\
    \ + \" \" + planet2 + \" \" + planet1 + \" \" + planet2\n    planet1Planet2Planet1Planet2Planet1Planet2Planet1Planet2\
    \ := planet1 + \" \" + planet2 + \" \" + planet1 + \" \" + planet2 + \" \" + planet1\
    \ + \" \" + planet2 + \" \" + planet1 + \" \" + planet2 + \" \" + planet1\n  \
    \  planet1Planet2Planet1Planet2Planet1Planet2Planet1Planet2Planet1 := planet1\
    \ + \" \" + planet2 + \" \" + planet1 + \" \" + planet2 + \" \" + planet1 + \"\
    \ \" + planet2 + \" \" + planet1 + \" \" + planet2 + \" \" + planet1 + \" \" +\
    \ planet2\n    planet1Planet2Planet1Planet2Planet1Planet2Planet1Planet2Planet1Planet2\
    \ := planet1 + \" \" + planet2 + \" \" + planet1 + \" \" + planet2 + \" \" + planet1\
    \ + \" \" + planet2 + \" \" + planet1 + \" \" + planet2 + \" \" + planet1 + \"\
    \ \" + planet2\n    planet1Planet2Planet1Planet2Planet1Planet2Planet1Planet2Planet1Planet2Planet1\
    \ := planet1 + \" \" + planet2 + \" \" + planet1 + \" \" + planet2 + \" \" + planet1\
    \ + \" \" + planet2 + \" \" + planet1 + \" \" + planet2 + \" \" + planet1 + \"\
    \ \" + planet2 + \" \" + planet1\n    planet\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpet2f3i5__test.go:37:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074491
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit := orbit(planet1)\n\
    \    planet2Orbit := orbit(planet2)\n    planet1Sun := sun(planet1)\n    planet2Sun\
    \ := sun(planet2)\n    planet1SunDistance := distance(planet1Sun, planet1Orbit)\n\
    \    planet2SunDistance := distance(planet2Sun, planet2Orbit)\n    planet1SunDistance\
    \ += planet1Orbit.DistanceTo(planet2Orbit)\n    planet2SunDistance += planet2Orbit.DistanceTo(planet1Orbit)\n\
    \    planet1SunDistance += planet1Orbit.DistanceTo(planet2Orbit)\n    planet2SunDistance\
    \ += planet2Orbit.DistanceTo(planet1Orbit)\n    planet1SunDistance += planet1Orbit.DistanceTo(planet2Orbit)\n\
    \    planet2SunDistance += planet2Orbit.DistanceTo(planet1Orbit)\n    planet1SunDistance\
    \ += planet1Orbit.DistanceTo(planet2Orbit)\n    planet2SunDistance += planet2Orbit.DistanceTo(planet1Orbit)\n\
    \    planet1SunDistance += planet1Orbit.DistanceTo(planet2Orbit)\n    planet2SunDistance\
    \ += planet2Orbit.DistanceTo(planet1Orbit)\n    planet1SunDistance += planet1Orbit.DistanceTo(planet2Orbit)\n\
    \    planet2SunDistance += planet2Orbit.DistanceTo(planet1Orbit)\n    planet1SunDistance\
    \ += planet1Orbit.DistanceTo(planet2Orbit)\n    planet2SunDistance += planet2Orbit.DistanceTo(planet1Orbit)\n\
    \    planet1SunDistance += planet1Orbit.DistanceTo(planet2Orbit)\n    planet2SunDistance\
    \ += planet2Orbit.DistanceTo(planet1Orbit)\n    planet1SunDistance += planet1Orbit.DistanceTo(planet2Orbit)\n\
    \    planet2SunDistance += planet2Orbit.DistanceTo(planet1Orbit)\n    planet1SunDistance\
    \ += planet1Orbit.DistanceTo(planet2Orbit)\n    plan\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpqillvjlh_test.go:51:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074491
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit, err := getPlanetOrbit(planet1)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    planet2Orbit, err :=\
    \ getPlanetOrbit(planet2)\n    if err != nil {\n        fmt.Println(err)\n   \
    \ }\n    \n    planet1Sun, err := getPlanetOrbit(\"Sun\")\n    if err != nil {\n\
    \        fmt.Println(err)\n    }\n    planet2Sun, err := getPlanetOrbit(\"Sun\"\
    )\n    if err != nil {\n        fmt.Println(err)\n    }\n    \n    planet1SunDistance\
    \ := planet1Orbit.Distance(planet1Sun)\n    planet2SunDistance := planet2Orbit.Distance(planet2Sun)\n\
    \    \n    planet1OrbitDistance := planet1Orbit.Distance(planet1Orbit)\n    planet2OrbitDistance\
    \ := planet2Orbit.Distance(planet2Orbit)\n    \n    planet1OrbitDistance /= planet1OrbitDistance\n\
    \    planet2OrbitDistance /= planet2OrbitDistance\n    \n    planet1OrbitDistance\
    \ /= planet1SunDistance\n    planet2OrbitDistance /= planet2SunDistance\n    \n\
    \    planet1OrbitDistance /= planet1Orbit.Distance(planet1Orbit)\n    planet2OrbitDistance\
    \ /= planet2Orbit.Distance(planet2Orbit)\n    \n    planet1OrbitDistance /= planet1Orbit.Distance(planet1Sun)\n\
    \    planet2OrbitDistance /= planet2SunDistance\n    \n    planet1OrbitDistance\
    \ /= planet1Orbit.Distance(planet1Orbit)\n    planet2OrbitDistance /= planet2Orbit.Distance(planet2Orbit)\n\
    \    \n    planet1OrbitDistance /= planet1Orbit.Distance(planet1Sun)\n    planet2OrbitDistance\
    \ /= planet2SunDistance\n    \n    planet1OrbitDistance /= planet1Orbit.Distance(planet1Orbit)\n\
    \    planet2OrbitDistance /= planet2Orbit.Distance\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp3tmgvpvp_test.go:72:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074491
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    // Your code here\n\
    \    planet1Orbit := planet1\n    planet2Orbit := planet2\n    planet1OrbitOrbit\
    \ := planet1Orbit\n    planet2OrbitOrbit := planet2Orbit\n    planet1OrbitOrbitOrbit\
    \ := planet1OrbitOrbit\n    planet2OrbitOrbitOrbit := planet2OrbitOrbit\n    planet1OrbitOrbitOrbitOrbit\
    \ := planet1OrbitOrbitOrbit\n    planet2OrbitOrbitOrbitOrbit := planet2OrbitOrbitOrbit\n\
    \    planet1OrbitOrbitOrbitOrbitOrbit := planet1OrbitOrbitOrbitOrbit\n    planet2OrbitOrbitOrbitOrbitOrbit\
    \ := planet2OrbitOrbitOrbitOrbit\n    planet1OrbitOrbitOrbitOrbitOrbitOrbit :=\
    \ planet1OrbitOrbitOrbitOrbitOrbit\n    planet2OrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet2OrbitOrbitOrbitOrbitOrbitOrbit\n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbit\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbit\n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpcvkc9fix_test.go:44:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074491
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit = sortByProximity(planet1Orbit,\
    \ planet2Orbit)\n    return planet1Orbit\n}\n\nfunc TestBf(t *testing.T) {\n \
    \ candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpumwg0x5y_test.go:25:35: undefined: getOrbits

    /tmp/tmpumwg0x5y_test.go:26:34: undefined: sortByProximity

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074484
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit, err := getOrbit(planet1)\n  \
    \  if err != nil {\n        fmt.Println(err)\n    }\n    planet2Orbit, err :=\
    \ getOrbit(planet2)\n    if err != nil {\n        fmt.Println(err)\n    }\n  \
    \  \n    planet1Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet2Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    \n    planet1SunDistance := planet1Sun.Distance(planet1Orbit)\n  \
    \  planet2SunDistance := planet2Sun.Distance(planet2Orbit)\n    \n    planet1OrbitDistance\
    \ := planet1Orbit.Distance(planet1Sun)\n    planet2OrbitDistance := planet2Orbit.Distance(planet2Sun)\n\
    \    \n    planet1OrbitDistance /= planet1OrbitDistance\n    planet2OrbitDistance\
    \ /= planet2OrbitDistance\n    \n    planet1OrbitDistance *= planet1OrbitDistance\n\
    \    planet2OrbitDistance *= planet2OrbitDistance\n    \n    planet1OrbitDistance\
    \ /= planet1OrbitDistance\n    planet2OrbitDistance /= planet2OrbitDistance\n\
    \    \n    planet1OrbitDistance *= planet1OrbitDistance\n    planet2OrbitDistance\
    \ *= planet2OrbitDistance\n    \n    planet1OrbitDistance /= planet1OrbitDistance\n\
    \    planet2OrbitDistance /= planet2OrbitDistance\n    \n    planet1OrbitDistance\
    \ *= planet1OrbitDistance\n    planet2OrbitDistance *= planet2OrbitDistance\n\
    \    \n    planet1OrbitDistance /= planet1OrbitDistance\n    planet2OrbitDistance\
    \ /= planet2OrbitDistance\n    \n    planet1OrbitDistance *= planet1OrbitDistance\n\
    \    planet2OrbitDistance *= planet2OrbitDistance\n    \n    planet1OrbitDistance\
    \ /= planet1OrbitDistance\n    planet2OrbitDistance /= planet2OrbitDistance\n\
    \    \n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp3cr7lqak_test.go:80:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074491
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, err\
    \ := getOrbit(planet1)\n    if err != nil {\n        fmt.Println(err)\n    }\n\
    \    planet2Orbit, err := getOrbit(planet2)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet1Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet2Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet1SunDistance := planet1Orbit.Distance(planet1Sun)\n    planet2SunDistance\
    \ := planet2Orbit.Distance(planet2Sun)\n    planet1SunDistance += planet1Orbit.Distance(planet2Orbit)\n\
    \    planet2SunDistance += planet2Orbit.Distance(planet1Orbit)\n    planet1SunDistance\
    \ += planet1Orbit.Distance(planet2Orbit)\n    planet2SunDistance += planet2Orbit.Distance(planet1Orbit)\n\
    \    planet1SunDistance += planet1Orbit.Distance(planet2Orbit)\n    planet2SunDistance\
    \ += planet2Orbit.Distance(planet1Orbit)\n    planet1SunDistance += planet1Orbit.Distance(planet2Orbit)\n\
    \    planet2SunDistance += planet2Orbit.Distance(planet1Orbit)\n    planet1SunDistance\
    \ += planet1Orbit.Distance(planet2Orbit)\n    planet2SunDistance += planet2Orbit.Distance(planet1Orbit)\n\
    \    planet1SunDistance += planet1Orbit.Distance(planet2Orbit)\n    planet2SunDistance\
    \ += planet2Orbit.Distance(planet1Orbit)\n    planet1SunDistance += planet1Orbit.Distance(planet2Orbit)\n\
    \    planet2SunDistance += planet2Orbit.Distance(planet1Orbit)\n    planet1SunDistance\
    \ += planet1Orbit.Distance(planet2Orbit)\n    planet2SunDistance += planet2Orbit.Distance(planet1Orbit)\n\
    \    planet1SunDistance += plan\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpessf19w1_test.go:60:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074491
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit := orbit(planet1)\n\
    \    planet2Orbit := orbit(planet2)\n    \n    planet1Orbit.sort()\n    planet2Orbit.sort()\n\
    \    \n    planet1Orbit.intersect(planet2Orbit)\n    \n    return planet1Orbit.elements\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_pb4ok3__test.go:25:21: undefined: orbit

    /tmp/tmp_pb4ok3__test.go:26:21: undefined: orbit

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074491
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    planet1Orbit := planet1\n    planet2Orbit := planet2\n\
    \    planet1OrbitOrbit := planet1Orbit\n    planet2OrbitOrbit := planet2Orbit\n\
    \    planet1OrbitOrbitOrbit := planet1OrbitOrbit\n    planet2OrbitOrbitOrbit :=\
    \ planet2OrbitOrbit\n    planet1OrbitOrbitOrbitOrbit := planet1OrbitOrbitOrbit\n\
    \    planet2OrbitOrbitOrbitOrbit := planet2OrbitOrbitOrbit\n    planet1OrbitOrbitOrbitOrbitOrbit\
    \ := planet1OrbitOrbitOrbitOrbit\n    planet2OrbitOrbitOrbitOrbitOrbit := planet2OrbitOrbitOrbitOrbit\n\
    \    planet1OrbitOrbitOrbitOrbitOrbitOrbit := planet1OrbitOrbitOrbitOrbitOrbit\n\
    \    planet2OrbitOrbitOrbitOrbitOrbitOrbit := planet2OrbitOrbitOrbitOrbitOrbitOrbit\n\
    \    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbit\n\
    \    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbit\n\
    \    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\n\
    \    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\n\
    \    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\n\
    \    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2OrbitOrbitOrbitOrbitOr\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp5xim9yri_test.go:45:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074491
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := getOrbits(planet1, planet2)\n    planet1Orbit.sort()\n    planet2Orbit.sort()\n\
    \    \n    result := []interface{}{}\n    for _, planet := range planet1Orbit\
    \ {\n        if planet == planet2 {\n            result = append(result, planet)\n\
    \        }\n    }\n    for _, planet := range planet2Orbit {\n        if planet\
    \ == planet1 {\n            result = append(result, planet)\n        }\n    }\n\
    \    \n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpf0v9hqlz_test.go:25:35: undefined: getOrbits

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074491
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := planet1Orbit(planet1, planet2)\n    planet1Orbit, planet2Orbit = planet2Orbit(planet1,\
    \ planet2)\n    planet1Orbit, planet2Orbit = planet1Orbit(planet2, planet1)\n\
    \    planet1Orbit, planet2Orbit = planet2Orbit(planet2, planet1)\n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit(planet1, planet2)\n    planet1Orbit, planet2Orbit\
    \ = planet2Orbit(planet1, planet2)\n    planet1Orbit, planet2Orbit = planet1Orbit(planet2,\
    \ planet1)\n    planet1Orbit, planet2Orbit = planet2Orbit(planet2, planet1)\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit(planet1, planet2)\n    planet1Orbit,\
    \ planet2Orbit = planet2Orbit(planet1, planet2)\n    planet1Orbit, planet2Orbit\
    \ = planet1Orbit(planet2, planet1)\n    planet1Orbit, planet2Orbit = planet2Orbit(planet2,\
    \ planet1)\n    planet1Orbit, planet2Orbit = planet1Orbit(planet1, planet2)\n\
    \    planet1Orbit, planet2Orbit = planet2Orbit(planet1, planet2)\n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit(planet2, planet1)\n    planet1Orbit, planet2Orbit\
    \ = planet2Orbit(planet2, planet1)\n    planet1Orbit, planet2Orbit = planet1Orbit(planet1,\
    \ planet2)\n    planet1Orbit, planet2Orbit = planet2Orbit(planet1, planet2)\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit(planet2, planet1)\n    planet1Orbit,\
    \ planet2Orbit = planet2Orbit\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpykw8h4hn_test.go:45:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074486
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit = sortByProximity(planet1Orbit,\
    \ planet2Orbit)\n    return planet1Orbit\n}\n\nfunc TestBf(t *testing.T) {\n \
    \ candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpumwg0x5y_test.go:25:35: undefined: getOrbits

    /tmp/tmpumwg0x5y_test.go:26:34: undefined: sortByProximity

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074484
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit, err := getPlanetOrbit(planet1)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    planet2Orbit, err :=\
    \ getPlanetOrbit(planet2)\n    if err != nil {\n        fmt.Println(err)\n   \
    \ }\n    \n    planet1Sun, err := getPlanetOrbit(\"Sun\")\n    if err != nil {\n\
    \        fmt.Println(err)\n    }\n    planet2Sun, err := getPlanetOrbit(\"Sun\"\
    )\n    if err != nil {\n        fmt.Println(err)\n    }\n    \n    planet1SunProximity\
    \ := getPlanetProximity(planet1Orbit, planet1Sun)\n    planet2SunProximity :=\
    \ getPlanetProximity(planet2Orbit, planet2Sun)\n    \n    planet1Proximity, err\
    \ := getPlanetProximity(planet1Orbit, planet1Orbit)\n    if err != nil {\n   \
    \     fmt.Println(err)\n    }\n    planet2Proximity, err := getPlanetProximity(planet2Orbit,\
    \ planet2Orbit)\n    if err != nil {\n        fmt.Println(err)\n    }\n    \n\
    \    planet1Proximity, err := getPlanetProximity(planet1Orbit, planet1Orbit)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    planet2Proximity, err\
    \ := getPlanetProximity(planet2Orbit, planet2Orbit)\n    if err != nil {\n   \
    \     fmt.Println(err)\n    }\n    \n    planet1Proximity, err := getPlanetProximity(planet1Orbit,\
    \ planet1Orbit)\n    if err != nil {\n        fmt.Println(err)\n    }\n    planet2Proximity,\
    \ err := getPlanetProximity(planet2Orbit, planet2Orbit)\n    if err != nil {\n\
    \        fmt.Println(err)\n    }\n    \n    planet1Proximity, err := getPlanetProximity(planet1Orbit,\
    \ planet1Orbit)\n    if err != nil {\n        fmt.Println(err)\n    }\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpyz526glh_test.go:80:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074491
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit = sortByProximity(planet1Orbit,\
    \ planet2Orbit)\n    return planet1Orbit\n}\n\nfunc TestBf(t *testing.T) {\n \
    \ candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpumwg0x5y_test.go:25:35: undefined: getOrbits

    /tmp/tmpumwg0x5y_test.go:26:34: undefined: sortByProximity

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074484
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit = sortPlanets(planet1Orbit,\
    \ planet2Orbit)\n    return planet1Orbit\n}\n\nfunc TestBf(t *testing.T) {\n \
    \ candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0l1jkt5o_test.go:25:35: undefined: getOrbits

    /tmp/tmp0l1jkt5o_test.go:26:34: undefined: sortPlanets

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074486
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit := getOrbit(planet1)\n\
    \    planet2Orbit := getOrbit(planet2)\n    \n    planet1Orbit.sort()\n    planet2Orbit.sort()\n\
    \    \n    result := []interface{}{}\n    \n    for _, planet1OrbitElement :=\
    \ range planet1Orbit {\n        for _, planet2OrbitElement := range planet2Orbit\
    \ {\n            if planet1OrbitElement < planet2OrbitElement {\n            \
    \    planet1OrbitElement = planet1OrbitElement + 1\n            } else {\n   \
    \             planet2OrbitElement = planet2OrbitElement + 1\n            }\n \
    \           \n            if planet1OrbitElement < planet2OrbitElement {\n   \
    \             planet1OrbitElement = planet1OrbitElement + 1\n            } else\
    \ {\n                planet2OrbitElement = planet2OrbitElement + 1\n         \
    \   }\n            \n            if planet1OrbitElement < planet2OrbitElement\
    \ {\n                planet1OrbitElement = planet1OrbitElement + 1\n         \
    \   } else {\n                planet2OrbitElement = planet2OrbitElement + 1\n\
    \            }\n            \n            if planet1OrbitElement < planet2OrbitElement\
    \ {\n                planet1OrbitElement = planet1OrbitElement + 1\n         \
    \   } else {\n                planet2OrbitElement = planet2OrbitElement + 1\n\
    \            }\n            \n            if planet1OrbitElement < planet2OrbitElement\
    \ {\n                planet1OrbitElement = planet1OrbitElement + 1\n         \
    \   } else {\n                planet2OrbitElement = planet2OrbitElement + 1\n\
    \            }\n            \n            if planet1OrbitElement < planet2OrbitElement\
    \ {\n                planet1OrbitElement = planet1OrbitElement + 1\n         \
    \   } else {\n                planet2OrbitElement = planet2OrbitElement + 1\n\
    \            }\n            \n            if planet1OrbitElement < planet2OrbitElement\
    \ {\n                planet1OrbitElement = planet1OrbitElement + 1\n         \
    \   } else {\n                planet2OrbitElement = planet2OrbitElement + 1\n\
    \            }\n            \n            if planet1OrbitElement < planet2OrbitElement\
    \ {\n                planet1OrbitElement = planet1OrbitElement + 1\n         \
    \   } else {\n                planet2\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpoac5rcd3_test.go:81:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074491
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := orbit(planet1, planet2)\n    planet1Orbit, planet2Orbit = sortByProximity(planet1Orbit,\
    \ planet2Orbit)\n    return planet1Orbit\n}\n\nfunc TestBf(t *testing.T) {\n \
    \ candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpsi4kvowt_test.go:25:35: undefined: orbit

    /tmp/tmpsi4kvowt_test.go:26:34: undefined: sortByProximity

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074484
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit = sortByProximity(planet1Orbit,\
    \ planet2Orbit)\n    return planet1Orbit\n}\n\nfunc TestBf(t *testing.T) {\n \
    \ candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpumwg0x5y_test.go:25:35: undefined: getOrbits

    /tmp/tmpumwg0x5y_test.go:26:34: undefined: sortByProximity

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074484
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit := planet1\n    planet2Orbit :=\
    \ planet2\n    \n    planet1OrbitOrbit := planet1\n    planet2OrbitOrbit := planet2\n\
    \    \n    planet1OrbitOrbitOrbit := planet1\n    planet2OrbitOrbitOrbit := planet2\n\
    \    \n    planet1OrbitOrbitOrbitOrbit := planet1\n    planet2OrbitOrbitOrbitOrbit\
    \ := planet2\n    \n    planet1OrbitOrbitOrbitOrbitOrbit := planet1\n    planet2OrbitOrbitOrbitOrbitOrbit\
    \ := planet2\n    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbit := planet1\n   \
    \ planet2OrbitOrbitOrbitOrbitOrbitOrbit := planet2\n    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2\n\
    \    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet1\n \
    \   planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2\n   \
    \ \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet1\n\
    \    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet2\n    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet2\n    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpp5791o9__test.go:59:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074491
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1.ToUpper(), planet2.ToUpper()\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvuq3h8im_test.go:54:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074489
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit := orbit(planet1)\n\
    \    planet2Orbit := orbit(planet2)\n    planet1Sun := sun(planet1)\n    planet2Sun\
    \ := sun(planet2)\n    planet1SunDistance := distance(planet1Sun, planet1Orbit)\n\
    \    planet2SunDistance := distance(planet2Sun, planet2Orbit)\n    planet1SunDistance\
    \ += planet1Orbit.Radius\n    planet2SunDistance += planet2Orbit.Radius\n    planet1SunDistance\
    \ += planet1Orbit.Eccentricity\n    planet2SunDistance += planet2Orbit.Eccentricity\n\
    \    planet1SunDistance += planet1Orbit.Inclination\n    planet2SunDistance +=\
    \ planet2Orbit.Inclination\n    planet1SunDistance += planet1Orbit.Period\n  \
    \  planet2SunDistance += planet2Orbit.Period\n    planet1SunDistance += planet1Orbit.Perihelion\n\
    \    planet2SunDistance += planet2Orbit.Perihelion\n    planet1SunDistance +=\
    \ planet1Orbit.MeanAnomaly\n    planet2SunDistance += planet2Orbit.MeanAnomaly\n\
    \    planet1SunDistance += planet1Orbit.MeanMotion\n    planet2SunDistance +=\
    \ planet2Orbit.MeanMotion\n    planet1SunDistance += planet1Orbit.MeanAnomaly\n\
    \    planet2SunDistance += planet2Orbit.MeanAnomaly\n    planet1SunDistance +=\
    \ planet1Orbit.MeanMotion\n    planet2SunDistance += planet2Orbit.MeanMotion\n\
    \    planet1SunDistance += planet1Orbit.MeanAnomaly\n    planet2SunDistance +=\
    \ planet2Orbit.MeanAnomaly\n    planet1SunDistance += planet1Orbit.MeanMotion\n\
    \    planet2SunDistance += planet2Orbit.MeanMotion\n    planet1SunDistance +=\
    \ planet1Orbit.MeanAnomaly\n    planet2SunDistance += planet2Orbit.MeanAnomaly\n\
    \    planet1SunDistance += planet1Orbit.Mean\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpst50t_tx_test.go:56:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074491
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit, err := getPlanetOrbit(planet1)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    planet2Orbit, err :=\
    \ getPlanetOrbit(planet2)\n    if err != nil {\n        fmt.Println(err)\n   \
    \ }\n    \n    planet1Sun, err := getPlanetOrbit(\"Sun\")\n    if err != nil {\n\
    \        fmt.Println(err)\n    }\n    planet2Sun, err := getPlanetOrbit(\"Sun\"\
    )\n    if err != nil {\n        fmt.Println(err)\n    }\n    \n    planet1SunDistance\
    \ := planet1Sun.Distance(planet1Orbit)\n    planet2SunDistance := planet2Sun.Distance(planet2Orbit)\n\
    \    \n    planet1OrbitDistance := planet1Orbit.Distance(planet1Sun)\n    planet2OrbitDistance\
    \ := planet2Orbit.Distance(planet2Sun)\n    \n    planet1OrbitDistance /= planet1OrbitDistance\n\
    \    planet2OrbitDistance /= planet2OrbitDistance\n    \n    planet1OrbitDistance\
    \ *= planet1SunDistance\n    planet2OrbitDistance *= planet2SunDistance\n    \n\
    \    planet1OrbitDistance /= planet1OrbitDistance\n    planet2OrbitDistance /=\
    \ planet2OrbitDistance\n    \n    planet1OrbitDistance *= planet1Orbit.Distance(planet2Orbit)\n\
    \    planet2OrbitDistance *= planet2Orbit.Distance(planet1Orbit)\n    \n    planet1OrbitDistance\
    \ /= planet1OrbitDistance\n    planet2OrbitDistance /= planet2OrbitDistance\n\
    \    \n    planet1OrbitDistance *= planet1Orbit.Distance(planet2Orbit)\n    planet2OrbitDistance\
    \ *= planet2Orbit.Distance(planet1Orbit)\n    \n    planet1OrbitDistance /= planet1OrbitDistance\n\
    \    planet2OrbitDistance /= planet2OrbitDistance\n    \n    planet1OrbitDistance\
    \ *= planet1Orbit.Distance(planet2Or\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpl5d7vuj5_test.go:73:60: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074491
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit = sortPlanets(planet1Orbit,\
    \ planet2Orbit)\n    planet1Orbit, planet2Orbit = removePlanets(planet1Orbit,\
    \ planet2Orbit)\n    return planet1Orbit\n}\n\nfunc TestBf(t *testing.T) {\n \
    \ candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmft0x405_test.go:25:35: undefined: getOrbits

    /tmp/tmpmft0x405_test.go:26:34: undefined: sortPlanets

    /tmp/tmpmft0x405_test.go:27:34: undefined: removePlanets

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074491
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2\
    \ = planet1, planet2\n    planet1Orbit, planet2Orbit, sunOrbit := getOrbits(planet1,\
    \ planet2)\n    planet1Orbit, planet2Orbit, sunOrbit = sortPlanets(planet1Orbit,\
    \ planet2Orbit, sunOrbit)\n    return planet1Orbit\n}\n\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp60gtenkk_test.go:26:45: undefined: getOrbits

    /tmp/tmp60gtenkk_test.go:27:44: undefined: sortPlanets

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074491
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2\
    \ = planet1, planet2\n    planet1Orbit, planet2Orbit := planet1, planet2\n   \
    \ planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Or\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_v_b4aai_test.go:39:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074491
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    planet1Orbit, planet2Orbit := orbit(planet1, planet2)\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit, planet2Orbit\n    planet1Orbit, planet2Orbit =\
    \ planet1Orbit, planet2Orbit\n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit, planet2Orbit\n    planet1Orbit, planet2Orbit =\
    \ planet1Orbit, planet2Orbit\n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit, planet2Orbit\n    planet1Orbit, planet2Orbit =\
    \ planet1Orbit, planet2Orbit\n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit, planet2Orbit\n    planet1Orbit, planet2Orbit =\
    \ planet1Orbit, planet2Orbit\n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit, planet2Orbit\n    planet1Orbit, planet2Orbit =\
    \ planet1Orbit, planet2\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpucziltzy_test.go:47:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074486
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit, planet2Orbit := getOrbits(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n\
    \    \n    planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n    \n  \
    \  planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n    \n    planet1Orbit,\
    \ planet2Orbit = getOrbits(planet1, planet2)\n    \n    planet1Orbit, planet2Orbit\
    \ = getOrbits(planet1, planet2)\n    \n    planet1Orbit, planet2Orbit = getOrbits(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n\
    \    \n    planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n    \n  \
    \  planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n    \n    planet1Orbit,\
    \ planet2Orbit = getOrbits(planet1, planet2)\n    \n    planet1Orbit, planet2Orbit\
    \ = getOrbits(planet1, planet2)\n    \n    planet1Orbit, planet2Orbit = getOrbits(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n\
    \    \n    planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n    \n  \
    \  planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n    \n    planet1Orbit,\
    \ planet2Orbit = getOrbits(planet1, planet2)\n    \n    planet1Orbit, planet2Orbit\
    \ = getOrbits(planet1, planet2)\n    \n    planet1Orbit, planet2Orbit = getOrbits(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit = getOrbits(\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpbokc1pvk_test.go:67:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074491
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit := orbit(planet1)\n\
    \    planet2Orbit := orbit(planet2)\n    planet1Orbit.sort()\n    planet2Orbit.sort()\n\
    \    \n    result := []interface{}{}\n    \n    for _, planet := range planet1Orbit\
    \ {\n        if planet == planet2 {\n            result = append(result, planet)\n\
    \        }\n    }\n    \n    for _, planet := range planet2Orbit {\n        if\
    \ planet == planet1 {\n            result = append(result, planet)\n        }\n\
    \    }\n    \n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpphd7gvj7_test.go:25:21: undefined: orbit

    /tmp/tmpphd7gvj7_test.go:26:21: undefined: orbit

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074491
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := strings.ToLower(planet1)\n\
    \    planet2 := strings.ToLower(planet2)\n    planet1Orbit, planet2Orbit := getOrbits(planet1,\
    \ planet2)\n    planet1Sun, planet2Sun := getSun(planet1, planet2)\n    planet1SunProximity,\
    \ planet2SunProximity := getSunProximity(planet1, planet2)\n    planet1OrbitProximity,\
    \ planet2OrbitProximity := getOrbitProximity(planet1, planet2)\n    planet1OrbitProximity,\
    \ planet2OrbitProximity = sortPlanets(planet1OrbitProximity, planet2OrbitProximity)\n\
    \    planet1OrbitProximity, planet2OrbitProximity = sortPlanets(planet1OrbitProximity,\
    \ planet2OrbitProximity)\n    planet1OrbitProximity, planet2OrbitProximity = sortPlanets(planet1OrbitProximity,\
    \ planet2OrbitProximity)\n    planet1OrbitProximity, planet2OrbitProximity = sortPlanets(planet1OrbitProximity,\
    \ planet2OrbitProximity)\n    planet1OrbitProximity, planet2OrbitProximity = sortPlanets(planet1OrbitProximity,\
    \ planet2OrbitProximity)\n    planet1OrbitProximity, planet2OrbitProximity = sortPlanets(planet1OrbitProximity,\
    \ planet2OrbitProximity)\n    planet1OrbitProximity, planet2OrbitProximity = sortPlanets(planet1OrbitProximity,\
    \ planet2OrbitProximity)\n    planet1OrbitProximity, planet2OrbitProximity = sortPlanets(planet1OrbitProximity,\
    \ planet2OrbitProximity)\n    planet1OrbitProximity, planet2OrbitProximity = sortPlanets(planet1OrbitProximity,\
    \ planet2OrbitProximity)\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpp79dpxzy_test.go:40:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074491
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := orbit(planet1, planet2)\n    planet1Orbit, planet2Orbit = sortByProximity(planet1Orbit,\
    \ planet2Orbit)\n    return planet1Orbit\n}\n\nfunc TestBf(t *testing.T) {\n \
    \ candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpsi4kvowt_test.go:25:35: undefined: orbit

    /tmp/tmpsi4kvowt_test.go:26:34: undefined: sortByProximity

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074484
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit, planet2Orbit := getOrbits(planet1,\
    \ planet2)\n    \n    planet1Sun, planet2Sun := getSun(planet1, planet2)\n   \
    \ \n    planet1SunProximity := getProximity(planet1Orbit, planet1Sun)\n    planet2SunProximity\
    \ := getProximity(planet2Orbit, planet2Sun)\n    \n    planet1Proximity := getProximity(planet1Orbit,\
    \ planet1)\n    planet2Proximity := getProximity(planet2Orbit, planet2)\n    \n\
    \    planet1ProximityList := getProximityList(planet1Proximity)\n    planet2ProximityList\
    \ := getProximityList(planet2Proximity)\n    \n    planet1ProximityListSorted\
    \ := sortProximityList(planet1ProximityList)\n    planet2ProximityListSorted :=\
    \ sortProximityList(planet2ProximityList)\n    \n    planet1ProximityListSorted2\
    \ := sortProximityList(planet1ProximityListSorted)\n    planet2ProximityListSorted2\
    \ := sortProximityList(planet2ProximityListSorted)\n    \n    planet1ProximityListSorted3\
    \ := sortProximityList(planet1ProximityListSorted2)\n    planet2ProximityListSorted3\
    \ := sortProximityList(planet2ProximityListSorted2)\n    \n    planet1ProximityListSorted4\
    \ := sortProximityList(planet1ProximityListSorted3)\n    planet2ProximityListSorted4\
    \ := sortProximityList(planet2ProximityListSorted3)\n    \n    planet1ProximityListSorted5\
    \ := sortProximityList(planet1ProximityListSorted4)\n    planet2ProximityListSorted5\
    \ := sortProximityList(planet2ProximityListSorted4)\n    \n    planet1ProximityListSorted6\
    \ := sortProximityList(planet1ProximityListSorted5)\n    plan\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpm22wuasd_test.go:58:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074491
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit = getOrbits(planet2,\
    \ planet1)\n    planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n   \
    \ planet1Orbit, planet2Orbit = getOrbits(planet2, planet1)\n    planet1Orbit,\
    \ planet2Orbit = getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit =\
    \ getOrbits(planet2, planet1)\n    planet1Orbit, planet2Orbit = getOrbits(planet1,\
    \ planet2)\n    planet1Orbit, planet2Orbit = getOrbits(planet2, planet1)\n   \
    \ planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n    planet1Orbit,\
    \ planet2Orbit = getOrbits(planet2, planet1)\n    planet1Orbit, planet2Orbit =\
    \ getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit = getOrbits(planet2,\
    \ planet1)\n    planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n   \
    \ planet1Orbit, planet2Orbit = getOrbits(planet2, planet1)\n    planet1Orbit,\
    \ planet2Orbit = getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit =\
    \ getOrbits(planet2, planet1)\n    planet1Orbit, planet2Orbit = getOrbits(planet1,\
    \ planet2)\n    planet1Orbit, planet2Orbit = getOrbits(planet2, planet1)\n   \
    \ planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n    planet1Orbit,\
    \ planet2Orbit = getOrbits(planet2, planet1)\n    planet1Orbit, planet2Orbit =\
    \ getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit = getOrbits(planet2,\
    \ planet1)\n    planet1Or\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpbmgyh1vj_test.go:48:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074483
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1.ToLower(), planet2.ToLower()\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpkc03pxac_test.go:54:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074487
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := orbit(planet1, planet2)\n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit, planet2Orbit\n    planet1Orbit, planet2Orbit =\
    \ planet1Orbit, planet2Orbit\n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit, planet2Orbit\n    planet1Orbit, planet2Orbit =\
    \ planet1Orbit, planet2Orbit\n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit, planet2Orbit\n    planet1Orbit, planet2Orbit =\
    \ planet1Orbit, planet2Orbit\n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit, planet2Orbit\n    planet1Orbit, planet2Orbit =\
    \ planet1Orbit, planet2Orbit\n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit, planet2Orbit\n    planet1Orbit, planet2Orbit =\
    \ planet\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpft792_zg_test.go:46:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074488
