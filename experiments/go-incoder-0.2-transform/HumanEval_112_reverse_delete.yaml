name: HumanEval_112_reverse_delete
language: go_test.go
prompt: "package reverse_delete_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
  \n// Task\n// We are given two strings s and c, you have to deleted all the characters\
  \ in s that are equal to any character in c\n// then check if the result string\
  \ is palindrome.\n// A string is called palindrome if it reads the same backward\
  \ as forward.\n// You should return a tuple containing the result string and True/False\
  \ for the check.\n// Example\n// >>> reverse_delete(\"abcde\", \"ae\")\n// []interface{}{\"\
  bcd\", false}\n// >>> reverse_delete(\"abcdef\", \"b\")\n// []interface{}{\"acdef\"\
  , false}\n// >>> reverse_delete(\"abcdedcba\", \"ab\")\n// []interface{}{\"cdedc\"\
  , true}\nfunc reverse_delete(s string, c string) []interface{} {\n"
tests: "func TestReverse_Delete(t *testing.T) {\n  candidate := reverse_delete\n\t\
  type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n  \
  \ tests := []test{\n     { actual: candidate(\"abcde\", \"ae\"), expected: []interface{}{\"\
  bcd\", false} },\n     { actual: candidate(\"abcdef\", \"b\"), expected: []interface{}{\"\
  acdef\", false} },\n     { actual: candidate(\"abcdedcba\", \"ab\"), expected: []interface{}{\"\
  cdedc\", true} },\n     { actual: candidate(\"dwik\", \"w\"), expected: []interface{}{\"\
  dik\", false} },\n     { actual: candidate(\"a\", \"a\"), expected: []interface{}{\"\
  \", true} },\n     { actual: candidate(\"abcdedcba\", \"\"), expected: []interface{}{\"\
  abcdedcba\", true} },\n     { actual: candidate(\"abcdedcba\", \"v\"), expected:\
  \ []interface{}{\"abcdedcba\", true} },\n     { actual: candidate(\"vabba\", \"\
  v\"), expected: []interface{}{\"abba\", true} },\n     { actual: candidate(\"mamma\"\
  , \"mia\"), expected: []interface{}{\"\", true} },\n   }\n\n\tfor i, tc := range\
  \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\
  \tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
  \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\
  \t}\n}\n"
completions: ["    result := make([]interface{}, 0)\n    i := 0\n    for i < len(s)\
    \ {\n        if s[i] == c {\n            result = append(result, s[i])\n     \
    \       i++\n        }\n    }\n    if i == len(s) {\n        return nil\n    }\n\
    \    for i < len(s) {\n        if s[i] != s[len(s)-i-1] {\n            result\
    \ = append(result, s[len(s)-i-1])\n        }\n        i++\n    }\n    return []interface{}{string(result),\
    \ true}\n}\n", "    result := make([]interface{}, 0)\n    i := 0\n    for i <\
    \ len(s) {\n        if s[i] == c {\n            result = append(result, s[i])\n\
    \            i++\n        }\n    }\n    if i == len(s) {\n        return nil\n\
    \    }\n    for i < len(s) {\n        if s[i] != result[len(result)-1] {\n   \
    \         result = append(result, s[i])\n        }\n        i++\n    }\n    return\
    \ []interface{}{string(result), true}\n}\n", "    result := make([]interface{},\
    \ 0)\n    i := 0\n    for i < len(s) {\n        if s[i] == c {\n            result\
    \ = append(result, s[i])\n            i++\n        }\n    }\n    for i < len(s)\
    \ {\n        if s[i] != s[len(s)-i-1] {\n            result = append(result, s[len(s)-i-1])\n\
    \        }\n    }\n    return append(result, true)\n}\n", "    result := make([]interface{},\
    \ 0)\n    for i := 0; i < len(s); i++ {\n        if s[i] == c {\n            result\
    \ = append(result, s[i])\n        }\n    }\n    return append(result, s[len(s)-1])\n\
    }\n", "    result := make([]interface{}, 0)\n    i := 0\n    j := len(s) - 1\n\
    \    for i < len(s) {\n        if s[i] != c[j] {\n            result = append(result,\
    \ s[i])\n        }\n        i++\n        j--\n    }\n    return append(result,\
    \ c[:len(c)-len(result)]...)\n}\n", "    result := make([]interface{}, 0)\n  \
    \  i := 0\n    for i < len(s) {\n        if s[i] == c {\n            i++\n   \
    \     } else {\n            result = append(result, s[i])\n            i = 0\n\
    \        }\n    }\n    if i == len(s) {\n        result = append(result, s[i])\n\
    \    }\n    return result\n}\n", "    result := make([]interface{}, 0)\n    i\
    \ := 0\n    for i < len(s) {\n        if s[i] == c {\n            result = append(result,\
    \ s[i])\n            i++\n        }\n    }\n    if i == len(s) {\n        return\
    \ nil\n    }\n    for i < len(s) {\n        if s[i] != s[len(s)-i-1] {\n     \
    \       result = append(result, s[len(s)-i-1])\n        }\n        i++\n    }\n\
    \    return []interface{}{string(result), true}\n}\n", "    result := make([]interface{},\
    \ 0)\n    i := 0\n    j := len(s) - 1\n    for i < len(s) {\n        if s[i] !=\
    \ c[j] {\n            result = append(result, s[i])\n        }\n        i++\n\
    \        j--\n    }\n    return append(result, c[j])\n}\n", "    result := make([]interface{},\
    \ 0)\n    i := 0\n    for i < len(s) {\n        if s[i] == c {\n            i++\n\
    \        } else {\n            result = append(result, s[i])\n            i++\n\
    \        }\n    }\n    if i == len(s) {\n        result = append(result, s[i])\n\
    \    }\n    return append(result, false)\n}\n", "    result := make([]interface{},\
    \ 0)\n    i := 0\n    j := len(s) - 1\n    for i < len(s) {\n        if s[i] ==\
    \ c {\n            result = append(result, s[i])\n            i++\n          \
    \  j--\n        } else {\n            if j >= 0 {\n                result = append(result,\
    \ s[j])\n                j--\n            }\n        }\n    }\n    return append(result,\
    \ s[j])\n}\n", "    result := make([]interface{}, 0)\n    i := 0\n    j := len(s)\
    \ - 1\n    for i < j {\n        if s[i] == c {\n            result = append(result,\
    \ s[i])\n            i++\n            j--\n        } else {\n            if s[i]\
    \ == s[j] {\n                result = append(result, s[i])\n                i++\n\
    \                j--\n            } else {\n                result = append(result,\
    \ s[i])\n                j--\n            }\n        }\n    }\n    return append(result,\
    \ s[j])\n}\n", "    result := make([]interface{}, 0)\n    for i := 0; i < len(s);\
    \ i++ {\n        if s[i] == c {\n            result = append(result, s[i])\n \
    \       }\n    }\n    if result == nil {\n        return nil\n    }\n    result\
    \ := append(result, s[len(s)-1])\n    return []interface{}{result, true}\n}\n",
  "    result := make([]interface{}, 0)\n    for i := 0; i < len(s); i++ {\n     \
    \   if s[i] != c {\n            result = append(result, s[i])\n        }\n   \
    \ }\n    if result == nil {\n        return nil\n    }\n    return append(result,\
    \ false)\n}\n", "    result := make([]interface{}, 0)\n    i := 0\n    j := len(s)\
    \ - 1\n    for i < len(s) {\n        if s[i] == c[j] {\n            i++\n    \
    \        j--\n        } else {\n            result = append(result, s[i])\n  \
    \          i++\n        }\n    }\n    if i == len(s) {\n        result = append(result,\
    \ s[i])\n    }\n    return append(result, false)\n}\n", "    result := make([]interface{},\
    \ 0)\n    i := 0\n    for i < len(s) {\n        if s[i] == c {\n            result\
    \ = append(result, s[i])\n            i++\n        }\n    }\n    for i < len(s)\
    \ {\n        if s[i] != s[len(s)-i-1] {\n            result = append(result, s[len(s)-i-1])\n\
    \        }\n    }\n    return append(result, true)\n}\n", "    result := make([]interface{},\
    \ 0)\n    i := 0\n    j := len(s) - 1\n    for i < len(s) && j < len(c) {\n  \
    \      if s[i] == c[j] {\n            i++\n            j--\n        } else {\n\
    \            result = append(result, s[i])\n            i++\n        }\n    }\n\
    \    if i == len(s) {\n        result = append(result, c[j])\n    }\n    return\
    \ result\n}\n", "    result := make([]interface{}, 0)\n    i := 0\n    for i <\
    \ len(s) {\n        if s[i] == c {\n            i++\n        } else {\n      \
    \      result = append(result, s[i])\n            i = 0\n        }\n    }\n  \
    \  if i == 0 {\n        result = append(result, s[i])\n    }\n    return append(result,\
    \ false)\n}\n", "    result := make([]interface{}, 0)\n    i := 0\n    j := len(s)\
    \ - 1\n    for i < len(c) && j < len(c) {\n        if s[i] == c[j] {\n       \
    \     i++\n            j--\n        } else {\n            result = append(result,\
    \ s[i])\n            i++\n            j--\n        }\n    }\n    if i == len(s)\
    \ {\n        result = append(result, s[i])\n    }\n    return append(result, false)\n\
    }\n", "    result := make([]interface{}, 0)\n    i := 0\n    for i < len(s) {\n\
    \        if s[i] == c {\n            i++\n        } else {\n            result\
    \ = append(result, s[i])\n            i++\n        }\n    }\n    if i == len(s)\
    \ {\n        result = append(result, s[i])\n    }\n    return []interface{}{result,\
    \ true}\n}\n", "    result := make([]interface{}, 0)\n    i := 0\n    for i <\
    \ len(s) {\n        if s[i] == c {\n            result = append(result, s[i])\n\
    \            i++\n        }\n    }\n    if i == len(s) {\n        return nil\n\
    \    }\n    for i < len(s) {\n        if s[i] != c {\n            result = append(result,\
    \ s[i])\n            i++\n        }\n    }\n    return []interface{}{string(result),\
    \ true}\n}\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
