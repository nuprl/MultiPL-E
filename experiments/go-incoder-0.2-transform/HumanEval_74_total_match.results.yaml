language: go_test.go
name: HumanEval_74_total_match
results:
- exit_code: 2
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    \n    if len(lst1) == 0 || len(lst2) == 0 {\n\
    \        return []string{}\n    }\n    \n    if len(lst1) > len(lst2) {\n    \
    \    lst1, lst2 = lst2, lst1\n    }\n    \n    result := make([]string, 0)\n \
    \   \n    for _, str1 := range lst1 {\n        for _, str2 := range lst2 {\n \
    \           if str1 == str2 {\n                continue\n            }\n     \
    \       \n            result += []string{str1, str2}\n        }\n    }\n    \n\
    \    return result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate :=\
    \ total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8z5k5ppq_test.go:40:13: invalid operation: operator + not defined on result
    (variable of type []string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074860
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    \n    if len(lst1) != len(lst2) {\n        return\
    \ nil\n    }\n    \n    result := []string{}\n    \n    for _, val := range lst1\
    \ {\n        if val <= lst2[0] {\n            result = append(result, val)\n \
    \       }\n    }\n    \n    return result\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp6dt6_b0z_test.go:60: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmp6dt6_b0z_test.go:60:\
    \ expected '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmp6dt6_b0z_test.go:60: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmp6dt6_b0z_test.go:60: expected '[hI Hi]', got '[admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmp6dt6_b0z_test.go:60:\
    \ expected '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmp6dt6_b0z_test.go:60: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074757
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) == 0 || len(lst2) == 0 {\n     \
    \   return []string{}\n    }\n    \n    if len(lst1) > len(lst2) {\n        lst1,\
    \ lst2 = lst2, lst1\n    }\n    \n    result := make([]string, len(lst1))\n  \
    \  \n    for i := 0; i < len(lst1); i++ {\n        result[i] = lst1[i]\n    }\n\
    \    \n    for i := 0; i < len(lst2); i++ {\n        count := 0\n        for j\
    \ := 0; j < len(result); j++ {\n            if result[j] == lst2[i] {\n      \
    \          count++\n            }\n        }\n        if count == len(result)\
    \ {\n            result = append(result, lst2[i])\n        }\n    }\n    \n  \
    \  return result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp8tsdj_t9_test.go:73: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n        tmp8tsdj_t9_test.go:73:\
    \ expected '[4]', got '[4 4]'\n    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n\
    \        tmp8tsdj_t9_test.go:73: expected '[hI Hi]', got '[hi admin]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmp8tsdj_t9_test.go:73: expected\
    \ '[hI hi hi]', got '[hi admin]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074860
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    result := []string{}\n    len1 := len(lst1)\n\
    \    len2 := len(lst2)\n    if len1 == len2 {\n        for i := 0; i < len1; i++\
    \ {\n            if lst1[i] < lst2[i] {\n                result = append(result,\
    \ lst1[i])\n            }\n        }\n    } else {\n        fmt.Println(\"lst1\
    \ and lst2 have different length\")\n    }\n    return result\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "lst1 and lst2 have different length\nlst1 and lst2 have different length\n\
    lst1 and lst2 have different length\nlst1 and lst2 have different length\nlst1\
    \ and lst2 have different length\nlst1 and lst2 have different length\n--- FAIL:\
    \ TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1 (0.00s)\n\
    \        tmpwlqmol6d_test.go:59: expected '[hi hi]', got '[admin]'\n    --- FAIL:\
    \ TestTotal_Match/test_num__2 (0.00s)\n        tmpwlqmol6d_test.go:59: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpwlqmol6d_test.go:59: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpwlqmol6d_test.go:59: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpwlqmol6d_test.go:59: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpwlqmol6d_test.go:59: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074755
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return nil\n\
    \    }\n    \n    result := make([]string, 0)\n    \n    for i := 0; i < len(lst1);\
    \ i++ {\n        if lst1[i] != lst2[i] {\n            result = append(result,\
    \ lst1[i])\n        }\n    }\n    \n    return result\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp2qq5g9f9_test.go:59: expected '[hi hi]', got '[admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmp2qq5g9f9_test.go:59:\
    \ expected '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmp2qq5g9f9_test.go:59: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmp2qq5g9f9_test.go:59: expected '[hI Hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmp2qq5g9f9_test.go:59:\
    \ expected '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmp2qq5g9f9_test.go:59: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074860
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    len1 := len(lst1)\n    len2 := len(lst2)\n  \
    \  if len1 == len2 {\n        return lst1\n    }\n    if len1 > len2 {\n     \
    \   len1, len2 = len2, len1\n    }\n    result := make([]string, len1)\n    for\
    \ i := 0; i < len1; i++ {\n        result[i] = lst1[i]\n    }\n    for i := 0;\
    \ i < len2; i++ {\n        if result[i] != lst2[i] {\n            return result\n\
    \        }\n    }\n    return result\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x5124c0,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x5124c0, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.total_match(...)\n\t/tmp/tmpzjix10b8_test.go:36\n\
    command-line-arguments_test.TestTotal_Match(0x0?)\n\t/tmp/tmpzjix10b8_test.go:57\
    \ +0x60f\ntesting.tRunner(0xc0001a0340, 0x527dd0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074751
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    len1 := len(lst1)\n    len2 := len(lst2)\n  \
    \  if len1 == len2 {\n        return lst1\n    }\n    if len1 > len2 {\n     \
    \   len1, len2 = len2, len1\n    }\n    result := make([]string, len1)\n    for\
    \ i := 0; i < len1; i++ {\n        if lst1[i] > lst2[i] {\n            result[i]\
    \ = lst1[i]\n        } else {\n            result[i] = lst2[i]\n        }\n  \
    \  }\n    return result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpqm7vxr2s_test.go:63: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpqm7vxr2s_test.go:63:\
    \ expected '[hi admin]', got '[hi hi]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpqm7vxr2s_test.go:63: expected '[hI Hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpqm7vxr2s_test.go:63:\
    \ expected '[hI hi hi]', got '[hi hi]'\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpqm7vxr2s_test.go:63: expected '[hi admin]', got '[hi hi]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074860
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    len1 := len(lst1)\n    len2 := len(lst2)\n  \
    \  if len1 == len2 {\n        return lst1\n    }\n    if len1 > len2 {\n     \
    \   len1, len2 = len2, len1\n    }\n    result := make([]string, len1)\n    for\
    \ i := 0; i < len1; i++ {\n        result[i] = lst1[i]\n    }\n    for i := 0;\
    \ i < len2; i++ {\n        j := i\n        for j < len1 && lst1[j] == lst2[i]\
    \ {\n            j++\n        }\n        if j == len1 {\n            result[i]\
    \ = lst2[i]\n        }\n    }\n    return result\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\npanic: runtime error: index out of range\
    \ [2] with length 2 [recovered]\n\tpanic: runtime error: index out of range [2]\
    \ with length 2\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513700,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513700, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.total_match({0xc0000e2040?, 0x2, 0x450329?},\
    \ {0xc0000f5db0, 0x4, 0x0?})\n\t/tmp/tmp9phxnlnb_test.go:41 +0x238\ncommand-line-arguments_test.TestTotal_Match(0x0?)\n\
    \t/tmp/tmp9phxnlnb_test.go:56 +0x1f0\ntesting.tRunner(0xc0001924e0, 0x529040)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074860
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    result := []string{}\n    if len(lst1) != len(lst2)\
    \ {\n        return lst1\n    }\n    for _, s := range lst1 {\n        if lst2\
    \ != nil && len(lst2) != 0 {\n            for _, s2 := range lst2 {\n        \
    \        if s == s2 {\n                    result = append(result, s)\n      \
    \          }\n            }\n        } else {\n            result = append(result,\
    \ s)\n        }\n    }\n    return result\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmps6cb6vjj_test.go:62: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmps6cb6vjj_test.go:62: expected\
    \ '[hI hi hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n\
    \        tmps6cb6vjj_test.go:62: expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074860
- exit_code: 2
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    result := []string{}\n    if len(lst1) != len(lst2)\
    \ {\n        return lst1\n    }\n    for _, v := range lst1 {\n        if lst2\
    \ != nil && len(v) < len(lst2[0]) {\n            continue\n        }\n       \
    \ found, _ := contains(lst2, v)\n        if found {\n            result = append(result,\
    \ v)\n        }\n    }\n    return result\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpt5pobsc3_test.go:31:21: undefined: contains

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074860
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return nil\n\
    \    }\n    result := make([]string, 0)\n    for _, item := range lst1 {\n   \
    \     if lst2 != nil && len(item) > len(lst2[0]) {\n            continue\n   \
    \     }\n        for _, item2 := range lst2 {\n            if item == item2 {\n\
    \                continue\n            }\n            if item > item2 {\n    \
    \            break\n            }\n        }\n        result = append(result,\
    \ item)\n    }\n    return result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n\
    \  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpd1hf1z7n_test.go:65: expected '[hi hi]', got '[hi]'\n  \
    \  --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpd1hf1z7n_test.go:65:\
    \ expected '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpd1hf1z7n_test.go:65: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpd1hf1z7n_test.go:65: expected '[hI Hi]', got '[hi]'\n  \
    \  --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpd1hf1z7n_test.go:65:\
    \ expected '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpd1hf1z7n_test.go:65: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074860
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) == 0 {\n        return lst2\n  \
    \  }\n    if len(lst2) == 0 {\n        return lst1\n    }\n    \n    lst1Len :=\
    \ len(lst1)\n    lst2Len := len(lst2)\n    \n    if lst1Len > lst2Len {\n    \
    \    lst1, lst2 = lst2, lst1\n        lst1Len, lst2Len = lst2Len, lst1Len\n  \
    \  }\n    \n    result := make([]string, 0)\n    \n    for i := 0; i < lst1Len;\
    \ i++ {\n        if lst1[i] > lst2[i] {\n            break\n        }\n      \
    \  result = append(result, lst1[i])\n    }\n    \n    for i := 0; i < lst2Len;\
    \ i++ {\n        if lst2[i] > lst1[i] {\n            break\n        }\n      \
    \  result = append(result, lst2[i])\n    }\n    \n    return result\n}\n\nfunc\
    \ TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{}, []string{}), expected: []string{} },\n \
    \    { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    }), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\npanic: runtime error: index out of range\
    \ [1] with length 1 [recovered]\n\tpanic: runtime error: index out of range [1]\
    \ with length 1\n\ngoroutine 20 [running]:\ntesting.tRunner.func1.2({0x513800,\
    \ 0xc000162000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513800, 0xc000162000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.total_match({0xc000116530?, 0x8?, 0x51400000003?},\
    \ {0xc00011c140?, 0x5e4ea0?, 0x5d4590?})\n\t/tmp/tmp14dzhgcv_test.go:48 +0x392\n\
    command-line-arguments_test.TestTotal_Match(0x0?)\n\t/tmp/tmp14dzhgcv_test.go:67\
    \ +0x2a3\ntesting.tRunner(0xc000103860, 0x529140)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074860
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    result := []string{}\n    if len(lst1) == 0 {\n\
    \        return result\n    }\n    if len(lst2) == 0 {\n        return result\n\
    \    }\n    \n    len1 := len(lst1)\n    len2 := len(lst2)\n    \n    if len1\
    \ == len2 {\n        for i := 0; i < len1; i++ {\n            if lst1[i] < lst2[i]\
    \ {\n                result = append(result, lst1[i])\n            }\n       \
    \ }\n        return result\n    }\n    \n    if len1 < len2 {\n        for i :=\
    \ 0; i < len2; i++ {\n            if lst1[i] < lst2[i] {\n                result\
    \ = append(result, lst2[i])\n            }\n        }\n        return result\n\
    \    }\n    \n    for i := 0; i < len1; i++ {\n        if lst1[i] < lst2[i] {\n\
    \            result = append(result, lst1[i])\n        }\n    }\n    for i :=\
    \ 0; i < len2; i++ {\n        if lst2[i] < lst1[i] {\n            result = append(result,\
    \ lst2[i])\n        }\n    }\n    return result\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\npanic: runtime error: index out of range\
    \ [2] with length 2 [recovered]\n\tpanic: runtime error: index out of range [2]\
    \ with length 2\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513700,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513700, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.total_match({0xc0000f5d30, 0x2, 0x0?}, {0xc0000f5db0,\
    \ 0x4, 0x0?})\n\t/tmp/tmplxxcf5xr_test.go:45 +0x510\ncommand-line-arguments_test.TestTotal_Match(0xc000192680?)\n\
    \t/tmp/tmplxxcf5xr_test.go:74 +0x22f\ntesting.tRunner(0xc000192680, 0x529040)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074860
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return nil\n\
    \    }\n    \n    result := make([]string, len(lst1))\n    for i := 0; i < len(lst1);\
    \ i++ {\n        if lst1[i] < lst2[i] {\n            result[i] = lst1[i]\n   \
    \     } else {\n            result[i] = lst2[i]\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmph2erqzno_test.go:59: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmph2erqzno_test.go:59:\
    \ expected '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmph2erqzno_test.go:59: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmph2erqzno_test.go:59: expected '[hI hi hi]', got '[]'\n \
    \   --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n        tmph2erqzno_test.go:59:\
    \ expected '[hi admin]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074754
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return nil\n\
    \    }\n    result := make([]string, 0)\n    for _, val1 := range lst1 {\n   \
    \     found := false\n        for _, val2 := range lst2 {\n            if val1\
    \ == val2 {\n                found = true\n                break\n           \
    \ }\n        }\n        if !found {\n            result = append(result, val1)\n\
    \        }\n    }\n    return result\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp3n7ihazy_test.go:63: expected '[hi hi]', got '[admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmp3n7ihazy_test.go:63:\
    \ expected '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmp3n7ihazy_test.go:63: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmp3n7ihazy_test.go:63: expected '[hI Hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmp3n7ihazy_test.go:63:\
    \ expected '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmp3n7ihazy_test.go:63: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074860
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    m := make(map[string]bool)\n    for _, v := range\
    \ lst1 {\n        m[v] = true\n    }\n    for _, v := range lst2 {\n        if\
    \ _, ok := m[v]; !ok {\n            return lst1\n        }\n    }\n    return\
    \ lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpluxmgytr_test.go:56: expected '[hI Hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpluxmgytr_test.go:56:\
    \ expected '[hI hi hi]', got '[hi admin]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074860
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return lst1\n\
    \    }\n    \n    result := make([]string, len(lst1))\n    \n    for i := 0; i\
    \ < len(lst1); i++ {\n        if lst1[i] != lst2[i] {\n            result[i] =\
    \ lst1[i]\n        }\n    }\n    \n    return result\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpg46wy5h8_test.go:59: expected '[hi hi]', got '[ admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmpg46wy5h8_test.go:59:\
    \ expected '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmpg46wy5h8_test.go:59: expected '[hI hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n        tmpg46wy5h8_test.go:59:\
    \ expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074860
- exit_code: 2
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return nil\n\
    \    }\n    \n    result := []string{}\n    for _, val := range lst1 {\n     \
    \   if !contains(lst2, val) {\n            result = append(result, val)\n    \
    \    }\n    }\n    return result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n\
    \  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdvb8kb1__test.go:29:13: undefined: contains

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074753
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    result := []string{}\n    if len(lst1) != len(lst2)\
    \ {\n        return lst1\n    }\n    for _, val := range lst1 {\n        if val\
    \ <= lst2[0] {\n            result = append(result, val)\n        }\n    }\n \
    \   return result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp3fmwunr9_test.go:56: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmp3fmwunr9_test.go:56:\
    \ expected '[hI Hi]', got '[admin]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmp3fmwunr9_test.go:56: expected '[hI hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n        tmp3fmwunr9_test.go:56:\
    \ expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074860
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    \n    if len(lst1) == 0 {\n        return lst2\n\
    \    }\n    if len(lst2) == 0 {\n        return lst1\n    }\n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpk5xvna93_test.go:274:6: expected ''('', found TestTotal_Match

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074755
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var result []string\n    \n    if len(lst1) !=\
    \ len(lst2) {\n        return nil\n    }\n    \n    for _, value := range lst1\
    \ {\n        if lst2 := lst2[:len(lst1)-1]; len(lst2) < len(value) {\n       \
    \     lst2 = append(lst2, value)\n        }\n        \n        if lst2 := lst2[:len(lst1)-1];\
    \ len(lst2) < len(value) {\n            lst2 = append(lst2, value)\n        }\n\
    \    }\n    \n    for _, value := range lst2 {\n        if lst1 := lst1[:len(lst2)-1];\
    \ len(lst1) < len(value) {\n            lst1 = append(lst1, value)\n        }\n\
    \        \n        if lst1 := lst1[:len(lst2)-1]; len(lst1) < len(value) {\n \
    \           lst1 = append(lst1, value)\n        }\n    }\n    \n    for _, value\
    \ := range lst1 {\n        if lst2 := lst2[:len(lst1)-1]; len(lst2) < len(value)\
    \ {\n            lst2 = append(lst2, value)\n        }\n        \n        if lst2\
    \ := lst2[:len(lst1)-1]; len(lst2) < len(value) {\n            lst2 = append(lst2,\
    \ value)\n        }\n    }\n    \n    for _, value := range lst2 {\n        if\
    \ lst1 := lst1[:len(lst2)-1]; len(lst1) < len(value) {\n            lst1 = append(lst1,\
    \ value)\n        }\n        \n        if lst1 := lst1[:len(lst2)-1]; len(lst1)\
    \ < len(value) {\n            lst1 = append(lst1, value)\n        }\n    }\n \
    \   \n    for _, value := range lst1 {\n        if lst2 := lst2[:len(lst1)-1];\
    \ len(lst2) < len(value) {\n            lst2 = append(lst2, value)\n        }\n\
    \        \n        if lst2 := lst2[:len(lst1)-1]; len(lst2) < len(value) {\n \
    \           lst2 = append(lst2, value)\n        }\n    }\n    \n    for _, value\
    \ := range lst2 {\n        if lst1 := lst1[:len(lst2)-1]; len(lst1) < len(value)\
    \ {\n            lst1 = append(lst1, value)\n        }\n        \n        if lst1\
    \ := lst1[:len(lst2)-1]; len(lst1) < len(value) {\n            lst1 = append(lst1,\
    \ value)\n        }\n    }\n    \n    for _, value := range lst1 {\n        if\
    \ lst2 := lst2[:len(lst1)-1]; len(lst2) < len(value) {\n            lst2 = append(lst2,\
    \ value)\n        }\n        \n        if lst2 := lst2[:len(lst1)-1]; len(lst2)\
    \ < len(value) {\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpfi0ln081_test.go:96:6: expected ''('', found TestTotal_Match

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074859
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    lst3 := make([]string, len(lst1))\n    \n   \
    \ for i := 0; i < len(lst1); i++ {\n        lst3[i] = lst1[i]\n    }\n    \n \
    \   for i := 0; i < len(lst2); i++ {\n        lst3[i] = lst3[i] + lst2[i]\n  \
    \  }\n    \n    lst4 := make([]string, len(lst1))\n    \n    for i := 0; i < len(lst1);\
    \ i++ {\n        lst4[i] = lst3[i]\n    }\n    \n    return lst4\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\npanic: runtime error: index out of range\
    \ [2] with length 2 [recovered]\n\tpanic: runtime error: index out of range [2]\
    \ with length 2\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.total_match(...)\n\t/tmp/tmp1p6x4pm8_test.go:30\n\
    command-line-arguments_test.TestTotal_Match(0x0?)\n\t/tmp/tmp1p6x4pm8_test.go:51\
    \ +0xbb9\ntesting.tRunner(0xc0001a0340, 0x528d58)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074860
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    \n    if len(lst1) != len(lst2) {\n        return\
    \ nil\n    }\n    \n    result := make([]string, 0)\n    \n    for _, val1 :=\
    \ range lst1 {\n        for _, val2 := range lst2 {\n            if val1 < val2\
    \ {\n                continue \n            }\n        }\n        result = append(result,\
    \ val1)\n    }\n    \n    return result\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpzp8_iwm9_test.go:63: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpzp8_iwm9_test.go:63:\
    \ expected '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpzp8_iwm9_test.go:63: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpzp8_iwm9_test.go:63: expected '[hI Hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpzp8_iwm9_test.go:63:\
    \ expected '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpzp8_iwm9_test.go:63: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074860
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    lst3 := make([]string, 0)\n    lst4 := make([]string,\
    \ 0)\n    \n    if len(lst1) != len(lst2) {\n        return lst3\n    }\n    \n\
    \    for _, val := range lst1 {\n        if val <= lst2[0] {\n            lst4\
    \ = append(lst4, val)\n        }\n    }\n    \n    for _, val := range lst2 {\n\
    \        if val <= lst1[0] {\n            lst3 = append(lst3, val)\n        }\n\
    \    }\n    \n    if len(lst4) == 0 {\n        return lst3\n    }\n    \n    if\
    \ len(lst3) == 0 {\n        return lst4\n    }\n    \n    return lst3\n}\n\nfunc\
    \ TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{}, []string{}), expected: []string{} },\n \
    \    { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    }), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__2\
    \ (0.00s)\n        tmpzyjaaydz_test.go:74: expected '[hi admin]', got '[]'\n \
    \   --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n        tmpzyjaaydz_test.go:74:\
    \ expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n\
    \        tmpzyjaaydz_test.go:74: expected '[hI hi hi]', got '[]'\n    --- FAIL:\
    \ TestTotal_Match/test_num__6 (0.00s)\n        tmpzyjaaydz_test.go:74: expected\
    \ '[hi admin]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074860
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    result := []string{}\n    \n    if len(lst1)\
    \ == 0 {\n        return result\n    }\n    if len(lst2) == 0 {\n        return\
    \ result\n    }\n    \n    len1 := len(lst1)\n    len2 := len(lst2)\n    \n  \
    \  if len1 == len2 {\n        for i := 0; i < len1; i++ {\n            if lst1[i]\
    \ < lst2[i] {\n                result = append(result, lst1[i])\n            }\n\
    \        }\n        return result\n    }\n    \n    if len1 > len2 {\n       \
    \ for i := 0; i < len2; i++ {\n            if lst1[i] < lst2[i] {\n          \
    \      result = append(result, lst2[i])\n            }\n        }\n        return\
    \ result\n    }\n    \n    for i := 0; i < len1; i++ {\n        if lst1[i] < lst2[i]\
    \ {\n            result = append(result, lst1[i])\n        }\n    }\n    for i\
    \ := 0; i < len2; i++ {\n        if lst2[i] < lst1[i] {\n            result =\
    \ append(result, lst2[i])\n        }\n    }\n    return result\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\npanic: runtime error: index out of range\
    \ [2] with length 2 [recovered]\n\tpanic: runtime error: index out of range [2]\
    \ with length 2\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513700,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513700, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.total_match({0xc0000f5d30, 0x2, 0x0?}, {0xc0000f5db0,\
    \ 0x4, 0x0?})\n\t/tmp/tmpw32wtb3n_test.go:59 +0x3ad\ncommand-line-arguments_test.TestTotal_Match(0xc0001a0340?)\n\
    \t/tmp/tmpw32wtb3n_test.go:75 +0x22f\ntesting.tRunner(0xc0001a0340, 0x529040)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074860
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    \n    // Write your code here\n    \n    return\
    \ lst1\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpw0ywk6kn_test.go:50: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmpw0ywk6kn_test.go:50:\
    \ expected '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmpw0ywk6kn_test.go:50: expected '[hI hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n        tmpw0ywk6kn_test.go:50:\
    \ expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074750
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    \n    if len(lst1) != len(lst2) {\n        return\
    \ lst1\n    }\n    \n    result := []string{}\n    \n    for i := 0; i < len(lst1);\
    \ i++ {\n        if lst1[i] < lst2[i] {\n            result = append(result, lst1[i])\n\
    \        }\n    }\n    \n    return result\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpoodthk_v_test.go:60: expected '[hi hi]', got '[admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmpoodthk_v_test.go:60:\
    \ expected '[hI Hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n\
    \        tmpoodthk_v_test.go:60: expected '[hI hi hi]', got '[hi admin]'\n   \
    \ --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n        tmpoodthk_v_test.go:60:\
    \ expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074752
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var result []string\n    if len(lst1) != len(lst2)\
    \ {\n        return lst1\n    }\n    for i := 0; i < len(lst1); i++ {\n      \
    \  if lst1[i] != lst2[i] {\n            result = append(result, lst1[i])\n   \
    \     }\n    }\n    return result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n\
    \  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpxf2qehjp_test.go:56: expected '[hi hi]', got '[admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmpxf2qehjp_test.go:56:\
    \ expected '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmpxf2qehjp_test.go:56: expected '[hI hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n        tmpxf2qehjp_test.go:56:\
    \ expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074860
- exit_code: 2
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var result []string\n    for _, v := range lst1\
    \ {\n        if !contains(lst2, v) {\n            result = append(result, v)\n\
    \        }\n    }\n    return result\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpz_mf5j5w_test.go:25:13: undefined: contains

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074860
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return lst1\n\
    \    }\n    \n    result := make([]string, len(lst1))\n    \n    for i := range\
    \ lst1 {\n        result[i] = lst1[i]\n    }\n    \n    for i := range lst2 {\n\
    \        j := 0\n        for k := range result {\n            if lst1[i] == result[k]\
    \ {\n                j++\n            }\n        }\n        if j < len(lst2) {\n\
    \            result[i] = lst2[j]\n        }\n    }\n    \n    return result\n\
    }\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{}, []string{}), expected: []string{}\
    \ },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmps4bwpptg_test.go:69: expected '[hI Hi]', got '[Hi Hi]'\n\
    \    --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmps4bwpptg_test.go:69:\
    \ expected '[hI hi hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__8\
    \ (0.00s)\n        tmps4bwpptg_test.go:69: expected '[]', got '[this]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074860
- exit_code: 2
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    \n    if len(lst1) != len(lst2) {\n        return\
    \ lst1\n    }\n    \n    result := make([]string, len(lst1))\n    \n    for i\
    \ := 0; i < len(lst1); i++ {\n        \n        total := 0\n        \n       \
    \ for j := 0; j < len(lst2); j++ {\n            \n            total += lst1[i]\n\
    \            \n            if lst1[i] == lst2[j] {\n                \n       \
    \         total++\n                \n            }\n            \n        }\n\
    \        \n        if total < len(lst2) {\n            \n            result[i]\
    \ = lst1[i]\n            \n        } else {\n            \n            result[i]\
    \ = lst2[i]\n            \n        }\n        \n    }\n    \n    return result\n\
    }\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{}, []string{}), expected: []string{}\
    \ },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2juzgkcr_test.go:36:13: invalid operation: total += lst1[i] (mismatched
    types int and string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074860
- exit_code: 2
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    m := make(map[string]int)\n    for _, s := range\
    \ lst1 {\n        m[s] = m[s] + 1\n    }\n    for _, s := range lst2 {\n     \
    \   m[s] = m[s] + 1\n    }\n    for s, _ := range m {\n        if m[s] > m[len(lst1)]\
    \ {\n            return lst1\n        }\n    }\n    return lst2\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4lzb64tv_test.go:31:21: cannot use len(lst1) (value of type int) as type
    string in map index

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074861
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    len1 := len(lst1)\n    len2 := len(lst2)\n  \
    \  if len1 == len2 {\n        return lst1\n    }\n    \n    result := make([]string,\
    \ len1)\n    for i := 0; i < len1; i++ {\n        result[i] = lst1[i]\n    }\n\
    \    \n    for i := 0; i < len2; i++ {\n        if lst1[i] != lst2[i] {\n    \
    \        break\n        }\n        result[i] = lst1[i]\n    }\n    \n    return\
    \ result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x5134c0,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x5134c0, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.total_match(...)\n\t/tmp/tmpjs749m8c_test.go:35\n\
    command-line-arguments_test.TestTotal_Match(0x0?)\n\t/tmp/tmpjs749m8c_test.go:58\
    \ +0x72f\ntesting.tRunner(0xc0001924e0, 0x528dd0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n"
  timestamp: 1660074862
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    lst1Len := len(lst1)\n    lst2Len := len(lst2)\n\
    \    if lst1Len > lst2Len {\n        return lst1\n    }\n    if lst1Len == lst2Len\
    \ {\n        return lst1\n    }\n    \n    result := make([]string, lst1Len)\n\
    \    for i := 0; i < lst1Len; i++ {\n        if lst1[i] > lst2[i] {\n        \
    \    result[i] = lst1[i]\n        } else {\n            result[i] = lst2[i]\n\
    \        }\n    }\n    return result\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpwvkg70pn_test.go:64: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpwvkg70pn_test.go:64:\
    \ expected '[hi admin]', got '[hi hi]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpwvkg70pn_test.go:64: expected '[hI Hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpwvkg70pn_test.go:64:\
    \ expected '[hI hi hi]', got '[hi hi]'\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpwvkg70pn_test.go:64: expected '[hi admin]', got '[hi hi]'\n\
    \    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n        tmpwvkg70pn_test.go:64:\
    \ expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074862
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    lst1Len := len(lst1)\n    lst2Len := len(lst2)\n\
    \    if lst1Len > lst2Len {\n        return lst1\n    }\n    if lst1Len == lst2Len\
    \ {\n        return lst1\n    }\n    result := make([]string, lst1Len)\n    for\
    \ i := 0; i < lst1Len; i++ {\n        if lst1[i] < lst2[i] {\n            result[i]\
    \ = lst1[i]\n        } else {\n            result[i] = lst2[i]\n        }\n  \
    \  }\n    return result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp_9phujmr_test.go:63: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n        tmp_9phujmr_test.go:63:\
    \ expected '[4]', got '[1]'\n    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n\
    \        tmp_9phujmr_test.go:63: expected '[hI Hi]', got '[hi admin]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmp_9phujmr_test.go:63: expected\
    \ '[hI hi hi]', got '[hI admin]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmp_9phujmr_test.go:63: expected '[hi admin]', got '[hI admin]'\n   \
    \ --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n        tmp_9phujmr_test.go:63:\
    \ expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074862
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    len1 := len(lst1)\n    len2 := len(lst2)\n  \
    \  if len1 == len2 {\n        return lst1\n    }\n    if len1 > len2 {\n     \
    \   len1, len2 = len2, len1\n    }\n    result := make([]string, len1)\n    for\
    \ i := 0; i < len1; i++ {\n        result[i] = lst1[i]\n    }\n    for i := 0;\
    \ i < len2; i++ {\n        if lst1[i] != lst2[i] {\n            result[i] = lst2[i]\n\
    \        }\n    }\n    return result\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\npanic: runtime error: index out of range\
    \ [2] with length 2 [recovered]\n\tpanic: runtime error: index out of range [2]\
    \ with length 2\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513700,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513700, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.total_match({0xc0000e2040?, 0x2, 0x450329?},\
    \ {0xc0000f5db0, 0x4, 0x0?})\n\t/tmp/tmp3limb9qb_test.go:36 +0x218\ncommand-line-arguments_test.TestTotal_Match(0x0?)\n\
    \t/tmp/tmp3limb9qb_test.go:52 +0x1f0\ntesting.tRunner(0xc0001964e0, 0x529040)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074862
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return nil\n\
    \    }\n    result := make([]string, len(lst1))\n    for i := 0; i < len(lst1);\
    \ i++ {\n        result[i] = lst1[i]\n    }\n    for i := 0; i < len(lst2); i++\
    \ {\n        if result[i] != lst2[i] {\n            return nil\n        }\n  \
    \  }\n    return result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpwkjn6k0v_test.go:59: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpwkjn6k0v_test.go:59: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpwkjn6k0v_test.go:59: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpwkjn6k0v_test.go:59: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpwkjn6k0v_test.go:59: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpwkjn6k0v_test.go:59: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074862
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    \n    if len(lst1) != len(lst2) {\n        return\
    \ nil\n    }\n    \n    result := []string{}\n    \n    for _, str1 := range lst1\
    \ {\n        \n        for _, str2 := range lst2 {\n            \n           \
    \ if str1 == str2 {\n                \n                continue \n           \
    \ }\n            \n            \n            \n            \n            \n  \
    \          \n            \n            \n            \n            \n        \
    \    \n            \n            \n            \n            \n            \n\
    \            \n            \n            \n            \n            \n      \
    \      \n            \n            \n            \n            \n            \n\
    \            \n            \n            \n            \n            \n      \
    \      \n            \n            \n            \n            \n            \n\
    \            \n            \n            \n            \n            \n      \
    \      \n            \n            \n            \n            \n            \n\
    \            \n            \n            \n            \n            \n      \
    \      \n            \n            \n            \n            \n            \n\
    \            \n            \n            \n            \n            \n      \
    \      \n            \n            \n            \n            \n            \n\
    \            \n            \n            \n            \n            \n      \
    \      \n            \n            \n            \n            \n            \n\
    \            \n            \n            \n            \n            \n      \
    \      \n            \n            \n            \n            \n            \n\
    \            \n            \n            \n            \n            \n      \
    \      \n            \n            \n            \n            \n            \n\
    \            \n            \n            \n            \n            \n      \
    \      \n            \n            \n            \n            \n            \n\
    \            \n            \n            \n            \n            \n      \
    \      \n            \n            \n            \n            \n            \n\
    \            \n            \n            \n            \n            \n      \
    \      \n            \n            \n            \n            \n            \n\
    \            \n            \n            \n            \n            \n      \
    \      \n            \n            \n            \n            \n            \n\
    \            \n            \n            \n            \n            \n      \
    \      \n            \n            \n            \n            \n            \n\
    \            \n            \n            \n            \n            \n      \
    \      \n            \n            \n            \n            \n            \n\
    \            \n            \n            \n            \n            \n      \
    \      \n            \n            \n            \n            \n            \n\
    \            \n            \n            \n            \n            \n      \
    \      \n            \n            \n            \n            \n            \n\
    \            \n            \n            \n            \n            \n      \
    \      \n            \n            \n            \n            \n            \n\
    \            \n            \n            \n            \n            \n      \
    \      \n            \n            \n            \n            \n            \n\
    \            \n            \n            \n            \n            \n      \
    \      \n            \n            \n            \n            \n            \n\
    \            \nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp5yb_oxyc_test.go:264:6: expected ''('', found TestTotal_Match

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074861
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    result := []string{}\n    if len(lst1) != len(lst2)\
    \ {\n        return lst1\n    }\n    for i := 0; i < len(lst1); i++ {\n      \
    \  if lst1[i] != lst2[i] {\n            break\n        }\n        result = append(result,\
    \ lst1[i])\n    }\n    return result\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpmmndznjv_test.go:57: expected '[hi hi]', got '[hi]'\n  \
    \  --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmpmmndznjv_test.go:57:\
    \ expected '[hI Hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n\
    \        tmpmmndznjv_test.go:57: expected '[hI hi hi]', got '[hi admin]'\n   \
    \ --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n        tmpmmndznjv_test.go:57:\
    \ expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074862
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    \n    if len(lst1) == 0 {\n        return lst2\n\
    \    }\n    if len(lst2) == 0 {\n        return lst1\n    }\n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpk5xvna93_test.go:274:6: expected ''('', found TestTotal_Match

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074755
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    len1 := len(lst1)\n    len2 := len(lst2)\n  \
    \  if len1 == len2 {\n        return lst1\n    }\n    \n    result := make([]string,\
    \ len1)\n    for i := 0; i < len1; i++ {\n        if lst1[i] > lst2[i] {\n   \
    \         result[i] = lst1[i]\n        } else {\n            result[i] = lst2[i]\n\
    \        }\n    }\n    return result\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x5134c0,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x5134c0, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.total_match(...)\n\t/tmp/tmpynjzab86_test.go:31\n\
    command-line-arguments_test.TestTotal_Match(0x0?)\n\t/tmp/tmpynjzab86_test.go:55\
    \ +0x737\ntesting.tRunner(0xc0001a0340, 0x528dd8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074862
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return nil\n\
    \    }\n    \n    result := []string{}\n    for _, val := range lst1 {\n     \
    \   if val <= lst2[0] {\n            result = append(result, val)\n        }\n\
    \    }\n    return result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpf_6rhgvp_test.go:57: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpf_6rhgvp_test.go:57:\
    \ expected '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpf_6rhgvp_test.go:57: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpf_6rhgvp_test.go:57: expected '[hI Hi]', got '[admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpf_6rhgvp_test.go:57:\
    \ expected '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpf_6rhgvp_test.go:57: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074862
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    len1 := len(lst1)\n    len2 := len(lst2)\n  \
    \  if len1 == len2 {\n        return lst1\n    }\n    if len1 > len2 {\n     \
    \   len1, len2 = len2, len1\n    }\n    result := make([]string, len1)\n    for\
    \ i := 0; i < len1; i++ {\n        result[i] = lst1[i]\n    }\n    for i := 0;\
    \ i < len2; i++ {\n        found := false\n        for j := 0; j < len1; j++ {\n\
    \            if lst1[j] == lst2[i] {\n                found = true\n         \
    \       break\n            }\n        }\n        if !found {\n            result\
    \ = append(result, lst2[i])\n        }\n    }\n    return result\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513700,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513700, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.total_match({0xc0000d8550?, 0x1, 0x450329?},\
    \ {0xc0000f5bf8, 0x0, 0x0?})\n\t/tmp/tmplbrqe765_test.go:44 +0x336\ncommand-line-arguments_test.TestTotal_Match(0x0?)\n\
    \t/tmp/tmplbrqe765_test.go:65 +0x60e\ntesting.tRunner(0xc0001a01a0, 0x529040)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074862
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    \n    if len(lst1) != len(lst2) {\n        return\
    \ lst1\n    }\n    \n    result := []string{}\n    \n    for i := 0; i < len(lst1);\
    \ i++ {\n        \n        if lst1[i] != lst2[i] {\n            break\n      \
    \  }\n        \n        result = append(result, lst1[i])\n    }\n    \n    return\
    \ result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpg6d3375u_test.go:63: expected '[hi hi]', got '[hi]'\n  \
    \  --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmpg6d3375u_test.go:63:\
    \ expected '[hI Hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n\
    \        tmpg6d3375u_test.go:63: expected '[hI hi hi]', got '[hi admin]'\n   \
    \ --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n        tmpg6d3375u_test.go:63:\
    \ expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074862
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    lst1Len := len(lst1)\n    lst2Len := len(lst2)\n\
    \    if lst1Len == 0 || lst2Len == 0 {\n        return lst1\n    }\n    if lst1Len\
    \ < lst2Len {\n        return lst1\n    }\n    \n    result := make([]string,\
    \ lst1Len)\n    for i := 0; i < lst1Len; i++ {\n        result[i] = lst1[i]\n\
    \    }\n    for i := 0; i < lst2Len; i++ {\n        if result[i] != lst2[i] {\n\
    \            break\n        }\n    }\n    \n    for i := 0; i < lst1Len; i++ {\n\
    \        if result[i] != lst1[i] {\n            break\n        }\n    }\n    \n\
    \    return result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate :=\
    \ total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpz2fiqx_g_test.go:72: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmpz2fiqx_g_test.go:72:\
    \ expected '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmpz2fiqx_g_test.go:72: expected '[hI hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n        tmpz2fiqx_g_test.go:72:\
    \ expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074862
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return nil\n\
    \    }\n    \n    result := make([]string, len(lst1))\n    for i := 0; i < len(lst1);\
    \ i++ {\n        if lst1[i] < lst2[i] {\n            result[i] = lst1[i]\n   \
    \     } else {\n            result[i] = lst2[i]\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmph2erqzno_test.go:59: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmph2erqzno_test.go:59:\
    \ expected '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmph2erqzno_test.go:59: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmph2erqzno_test.go:59: expected '[hI hi hi]', got '[]'\n \
    \   --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n        tmph2erqzno_test.go:59:\
    \ expected '[hi admin]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074754
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    len1 := len(lst1)\n    len2 := len(lst2)\n  \
    \  if len1 == len2 {\n        return lst1\n    }\n    if len1 > len2 {\n     \
    \   lst2 = append([]string{}, lst2...)\n        len2 = len(lst2)\n    }\n    \n\
    \    result := make([]string, len1)\n    for i := 0; i < len1; i++ {\n       \
    \ result[i] = lst1[i]\n    }\n    for i := 0; i < len2; i++ {\n        if lst1[i]\
    \ != lst2[i] {\n            break\n        }\n        result[i] = lst2[i]\n  \
    \  }\n    return result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513700,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513700, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.total_match({0x62b7e0?, 0x0, 0x450329?},\
    \ {0xc0000f5d00?, 0x1, 0x0?})\n\t/tmp/tmp1iiwkos2_test.go:38 +0x1fa\ncommand-line-arguments_test.TestTotal_Match(0x0?)\n\
    \t/tmp/tmp1iiwkos2_test.go:60 +0x5bb\ntesting.tRunner(0xc0001a01a0, 0x529040)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074862
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    \n    // Write your code here\n    \n    return\
    \ lst1\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpw0ywk6kn_test.go:50: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmpw0ywk6kn_test.go:50:\
    \ expected '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmpw0ywk6kn_test.go:50: expected '[hI hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n        tmpw0ywk6kn_test.go:50:\
    \ expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074750
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return nil\n\
    \    }\n    result := make([]string, len(lst1))\n    for i := 0; i < len(lst1);\
    \ i++ {\n        if lst1[i] != lst2[i] {\n            return nil\n        }\n\
    \    }\n    return result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp285yba6a_test.go:56: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmp285yba6a_test.go:56: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmp285yba6a_test.go:56: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmp285yba6a_test.go:56: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmp285yba6a_test.go:56: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmp285yba6a_test.go:56: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074862
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return nil\n\
    \    }\n    \n    result := make([]string, 0)\n    for _, item := range lst1 {\n\
    \        if lst2 != nil && len(item) > len(lst2[0]) {\n            continue\n\
    \        }\n        \n        for _, item2 := range lst2 {\n            if item\
    \ == item2 {\n                continue\n            }\n            \n        \
    \    if len(item) > len(item2) {\n                continue\n            }\n  \
    \          \n            if len(item) < len(item2) {\n                continue\n\
    \            }\n            \n            if len(item) == 0 {\n              \
    \  continue\n            }\n            \n            if len(item) > len(item2)\
    \ {\n                continue\n            }\n            \n            if len(item)\
    \ < len(item2) {\n                continue\n            }\n            \n    \
    \        if len(item) == 0 {\n                continue\n            }\n      \
    \      \n            if len(item) > len(item2) {\n                continue\n \
    \           }\n            \n            if len(item) < len(item2) {\n       \
    \         continue\n            }\n            \n            if len(item) == 0\
    \ {\n                continue\n            }\n            \n            if len(item)\
    \ > len(item2) {\n                continue\n            }\n            \n    \
    \        if len(item) < len(item2) {\n                continue\n            }\n\
    \            \n            if len(item) == 0 {\n                continue\n   \
    \         }\n            \n            if len(item) > len(item2) {\n         \
    \       continue\n            }\n            \n            if len(item) < len(item2)\
    \ {\n                continue\n            }\n            \n            if len(item)\
    \ == 0 {\n                continue\n            }\n            \n            if\
    \ len(item) > len(item2) {\n                continue\n            }\n        \
    \    \n            if len(item) < len(item2) {\n                continue\n   \
    \         }\n            \n            if len(item) == 0 {\n                continue\n\
    \            }\n            \n            if len(item) > len(item2) {\n      \
    \          continue\n            }\n            \n            if len(item) < len(item2)\
    \ {\n                continue\n            }\n            \n            if len(item)\
    \ == 0 {\n                continue\n            }\n            \n            if\
    \ len(item) > len(item2) {\n                continue\n            }\n        \
    \    \n            if len(item) < len(item2) {\n                continue\n   \
    \         }\n            \n            if len(item) == 0 {\n                continue\n\
    \            }\n            \n            if len(item) > len(item2) {\n      \
    \          continue\n            }\n            \n            if len(item) < len(item2)\
    \ {\n                continue\n            }\n            \n            if len(item)\
    \ == 0 {\n                continue\n            }\n            \n            if\
    \ len(item) > len(item2) {\n                continue\n            }\n        \
    \    \n            if len(item) < len(item2) {\n                continue\n   \
    \         }\n            \n            if len(item) == 0 {\n                continue\n\
    \            }\n            \n            if len(item) > len(item2) {\n      \
    \          continue\n            }\n            \n            if len(item) < len(item2)\
    \ {\n                continue\n            }\n            \n            if len(item)\
    \ == 0 {\n                continue\n            }\n            \n            if\
    \ len(item) > len(item2) {\n                continue\n            }\n        \
    \    \n            if len(item) < len(item2) {\n                continue\n   \
    \         }\n            \n            if len(item) == 0 {\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpi2ahf_q2_test.go:180:6: expected ''('', found TestTotal_Match

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074861
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return nil\n\
    \    }\n    \n    result := make([]string, len(lst1))\n    \n    for i := 0; i\
    \ < len(lst1); i++ {\n        if lst1[i] != lst2[i] {\n            result[i] =\
    \ lst1[i]\n        }\n    }\n    \n    return result\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp5d93kwak_test.go:59: expected '[hi hi]', got '[ admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmp5d93kwak_test.go:59:\
    \ expected '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmp5d93kwak_test.go:59: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmp5d93kwak_test.go:59: expected '[hI Hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmp5d93kwak_test.go:59:\
    \ expected '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmp5d93kwak_test.go:59: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074759
- exit_code: 2
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    result := []string{}\n    if len(lst1) != len(lst2)\
    \ {\n        return lst1\n    }\n    for _, val := range lst1 {\n        if !contains(lst2,\
    \ val) {\n            result = append(result, val)\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp92cmz1om_test.go:28:13: undefined: contains

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074760
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return nil\n\
    \    }\n    \n    result := make([]string, 0)\n    for _, x := range lst1 {\n\
    \        if lst2 != nil && len(x) >= len(lst2[0]) {\n            continue\n  \
    \      }\n        \n        for _, y := range lst2 {\n            if x == y {\n\
    \                continue\n            }\n            \n            if len(x)\
    \ >= len(y) {\n                continue\n            }\n            \n       \
    \     if len(x) < len(y) {\n                continue\n            }\n        \
    \    \n            if len(x) == 0 {\n                continue\n            }\n\
    \            \n            if x == y[:len(x)] {\n                continue\n  \
    \          }\n            \n            if y == x[:len(y)] {\n               \
    \ continue\n            }\n            \n            if x == y[:len(x)] && y ==\
    \ x[:len(y)] {\n                continue\n            }\n            \n      \
    \      if x == y[:len(x)] && len(x) > len(y) {\n                continue\n   \
    \         }\n            \n            if y == x[:len(y)] && len(y) > len(x) {\n\
    \                continue\n            }\n            \n            if x == y[:len(x)]\
    \ && y == x[:len(y)] && len(x) < len(y) {\n                continue\n        \
    \    }\n            \n            if x == y[:len(x)] && y == x[:len(y)] && len(y)\
    \ < len(x) {\n                continue\n            }\n            \n        \
    \    if x == y[:len(x)] && len(x) == 0 {\n                continue\n         \
    \   }\n            \n            if y == x[:len(y)] && len(y) == 0 {\n       \
    \         continue\n            }\n            \n            if x == y[:len(x)]\
    \ && y == x[:len(y)] && len(x) > len(y) {\n                continue\n        \
    \    }\n            \n            if y == x[:len(y)] && y == x[:len(y)] && len(y)\
    \ > len(x) {\n                continue\n            }\n            \n        \
    \    if x == y[:len(x)] && y == x[:len(y)] && len(y) == 0 {\n                continue\n\
    \            }\n            \n            if x == y[:len(x)] && len(x) == 0 &&\
    \ len(y) > len(x) {\n                continue\n            }\n            \n \
    \           if y == x[:len(y)] && len(y) == 0 && len(x) > len(y) {\n         \
    \       continue\n            }\n            \n            if x == y[:len(x)]\
    \ && y == x[:len(y)] && len(y) == 0 {\n                continue\n            }\n\
    \            \n            if x == y[:len(x)] && len(x) == 0 && len(y) == 0 {\n\
    \                continue\n            }\n            \n            if x == y[:len(x)]\
    \ && len(x) > 0 && y == x[:len(y)] && len(y) > len(x) {\n                continue\n\
    \            }\n            \n            if y == x[:len(y)] && len(y) > 0 &&\
    \ x == y[:len(x)] && len(y) > len(x) {\n                continue\n           \
    \ }\n            \n            if x == y[:len(x)] && y == x\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp0fow_1_i_test.go:123:6: expected ''('', found TestTotal_Match

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074861
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return nil\n\
    \    }\n    result := make([]string, len(lst1))\n    for i := 0; i < len(lst1);\
    \ i++ {\n        result[i] = lst1[i]\n    }\n    for i := 0; i < len(lst1); i++\
    \ {\n        if lst1[i] != lst2[i] {\n            break\n        }\n    }\n  \
    \  return result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmphynl_zpf_test.go:59: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmphynl_zpf_test.go:59:\
    \ expected '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmphynl_zpf_test.go:59: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmphynl_zpf_test.go:59: expected '[hI Hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmphynl_zpf_test.go:59:\
    \ expected '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmphynl_zpf_test.go:59: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074759
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    \n    if len(lst1) != len(lst2) {\n        return\
    \ nil\n    }\n    \n    result := []string{}\n    \n    for i := 0; i < len(lst1);\
    \ i++ {\n        if lst1[i] < lst2[i] {\n            result = append(result, lst1[i])\n\
    \        } else {\n            result = append(result, lst2[i])\n        }\n \
    \   }\n    \n    return result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmppvvdmtu6_test.go:62: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmppvvdmtu6_test.go:62:\
    \ expected '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmppvvdmtu6_test.go:62: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmppvvdmtu6_test.go:62: expected '[hI hi hi]', got '[]'\n \
    \   --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n        tmppvvdmtu6_test.go:62:\
    \ expected '[hi admin]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074862
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    result := make([]string, 0)\n    \n    if len(lst1)\
    \ != len(lst2) {\n        return nil\n    }\n    \n    for i := 0; i < len(lst1);\
    \ i++ {\n        if lst1[i] < lst2[i] {\n            result = append(result, lst1[i])\n\
    \        } else {\n            result = append(result, lst2[i])\n        }\n \
    \   }\n    \n    return result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp3mmqv04v_test.go:61: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmp3mmqv04v_test.go:61:\
    \ expected '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmp3mmqv04v_test.go:61: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmp3mmqv04v_test.go:61: expected '[hI hi hi]', got '[]'\n \
    \   --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n        tmp3mmqv04v_test.go:61:\
    \ expected '[hi admin]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074862
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    len1 := len(lst1)\n    len2 := len(lst2)\n  \
    \  if len1 == len2 {\n        return lst1\n    }\n    if len1 < len2 {\n     \
    \   return lst1\n    }\n    return lst2\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp1rdilk47_test.go:55: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmp1rdilk47_test.go:55:\
    \ expected '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmp1rdilk47_test.go:55: expected '[hI hi hi]', got '[hi admin]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074757
- exit_code: 2
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return nil\n\
    \    }\n    \n    result := make([]string, 0)\n    \n    for _, val := range lst1\
    \ {\n        if !contains(lst2, val) {\n            result = append(result, val)\n\
    \        }\n    }\n    \n    return result\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0pt9s96g_test.go:30:13: undefined: contains

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074754
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    m := make(map[string]int)\n    for _, s := range\
    \ lst1 {\n        m[s] = m[s] + 1\n    }\n    for _, s := range lst2 {\n     \
    \   m[s] = m[s] + 1\n    }\n    result := make([]string, 0)\n    for k, v := range\
    \ m {\n        if v > len(lst2) {\n            result = append(result, k)\n  \
    \      }\n    }\n    if len(result) == 0 {\n        result = append(result, lst1...)\n\
    \    }\n    return result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp6rrfdw04_test.go:63: expected '[hi hi]', got '[hi]'\n  \
    \  --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmp6rrfdw04_test.go:63:\
    \ expected '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmp6rrfdw04_test.go:63: expected '[hI hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n        tmp6rrfdw04_test.go:63:\
    \ expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074862
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return nil\n\
    \    }\n    \n    result := make([]string, len(lst1))\n    for i := 0; i < len(lst1);\
    \ i++ {\n        if lst1[i] < lst2[i] {\n            result[i] = lst1[i]\n   \
    \     } else {\n            result[i] = lst2[i]\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmph2erqzno_test.go:59: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmph2erqzno_test.go:59:\
    \ expected '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmph2erqzno_test.go:59: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmph2erqzno_test.go:59: expected '[hI hi hi]', got '[]'\n \
    \   --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n        tmph2erqzno_test.go:59:\
    \ expected '[hi admin]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074754
- exit_code: 2
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var result []string\n    if len(lst1) == 0 {\n\
    \        return result\n    }\n    if len(lst2) == 0 {\n        return result\n\
    \    }\n    \n    result := lst1\n    \n    for _, val := range lst2 {\n     \
    \   found := false\n        for _, val2 := range result {\n            if val\
    \ == val2 {\n                found = true\n                break\n           \
    \ }\n        }\n        if !found {\n            result = append(result, val)\n\
    \        }\n    }\n    \n    return result\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7mdvk_59_test.go:31:12: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074862
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    len1 := len(lst1)\n    len2 := len(lst2)\n  \
    \  if len1 == len2 {\n        return lst1\n    }\n    \n    result := make([]string,\
    \ len1)\n    \n    for i := 0; i < len1; i++ {\n        if lst1[i] < lst2[i] {\n\
    \            result[i] = lst1[i]\n        } else {\n            result[i] = lst2[i]\n\
    \        }\n    }\n    \n    return result\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x5134c0,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x5134c0, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.total_match(...)\n\t/tmp/tmpk3hpqapc_test.go:32\n\
    command-line-arguments_test.TestTotal_Match(0x0?)\n\t/tmp/tmpk3hpqapc_test.go:57\
    \ +0x737\ntesting.tRunner(0xc0001924e0, 0x528dd8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074862
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    lst1Len := len(lst1)\n    lst2Len := len(lst2)\n\
    \    if lst1Len > lst2Len {\n        return lst1\n    }\n    if lst1Len == lst2Len\
    \ {\n        return lst1\n    }\n    \n    result := make([]string, 0)\n    for\
    \ i := 0; i < lst1Len; i++ {\n        if lst1[i] < lst2[i] {\n            result\
    \ = append(result, lst1[i])\n        }\n    }\n    return result\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpw9rropcx_test.go:62: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpw9rropcx_test.go:62:\
    \ expected '[hi admin]', got '[admin]'\n    --- FAIL: TestTotal_Match/test_num__3\
    \ (0.00s)\n        tmpw9rropcx_test.go:62: expected '[4]', got '[]'\n    --- FAIL:\
    \ TestTotal_Match/test_num__4 (0.00s)\n        tmpw9rropcx_test.go:62: expected\
    \ '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n\
    \        tmpw9rropcx_test.go:62: expected '[hI hi hi]', got '[admin]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__6 (0.00s)\n        tmpw9rropcx_test.go:62: expected\
    \ '[hi admin]', got '[admin]'\n    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n\
    \        tmpw9rropcx_test.go:62: expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074862
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    lst3 := make([]string, len(lst1))\n    for i\
    \ := range lst1 {\n        lst3[i] = lst1[i]\n    }\n    for i := range lst2 {\n\
    \        lst3[i] = lst3[i]\n    }\n    \n    lst4 := make([]string, len(lst1))\n\
    \    for i := range lst1 {\n        lst4[i] = lst1[i]\n    }\n    for i := range\
    \ lst2 {\n        lst4[i] = lst4[i]\n    }\n    \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpk8uhj1j__test.go:248:6: expected ''('', found TestTotal_Match

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074862
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return nil\n\
    \    }\n    result := []string{}\n    for _, str1 := range lst1 {\n        for\
    \ _, str2 := range lst2 {\n            if str1 == str2 {\n                result\
    \ = append(result, str1)\n                break\n            }\n        }\n  \
    \  }\n    return result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpsdhgusl0_test.go:59: expected '[hi hi]', got '[hi]'\n  \
    \  --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpsdhgusl0_test.go:59:\
    \ expected '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpsdhgusl0_test.go:59: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpsdhgusl0_test.go:59: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpsdhgusl0_test.go:59: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpsdhgusl0_test.go:59: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074864
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    \n    if len(lst1) != len(lst2) {\n        return\
    \ lst1\n    }\n    \n    result := make([]string, len(lst1))\n    \n    for i\
    \ := 0; i < len(lst1); i++ {\n        if lst1[i] != lst2[i] {\n            result[i]\
    \ = lst1[i]\n        }\n    }\n    \n    return result\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpctafjxwt_test.go:60: expected '[hi hi]', got '[ admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmpctafjxwt_test.go:60:\
    \ expected '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmpctafjxwt_test.go:60: expected '[hI hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n        tmpctafjxwt_test.go:60:\
    \ expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074864
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return nil\n\
    \    }\n    \n    result := make([]string, len(lst1))\n    for i, _ := range lst1\
    \ {\n        result[i] = lst1[i]\n    }\n    \n    for i, _ := range lst2 {\n\
    \        if result[i] != lst2[i] {\n            return nil\n        }\n    }\n\
    \    \n    return result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpasco2ao0_test.go:62: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpasco2ao0_test.go:62: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpasco2ao0_test.go:62: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpasco2ao0_test.go:62: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpasco2ao0_test.go:62: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpasco2ao0_test.go:62: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074864
- exit_code: 2
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    len1 := len(lst1)\n    len2 := len(lst2)\n  \
    \  if len1 == len2 {\n        return lst1\n    }\n    if len1 > len2 {\n     \
    \   len1, len2 = len2, len1\n    }\n    result := make([]string, len1)\n    for\
    \ i := 0; i < len1; i++ {\n        result[i] = lst1[i]\n    }\n    for i := 0;\
    \ i < len2; i++ {\n        if result[i] != lst2[i] {\n            break\n    \
    \    }\n    }\n    return result[:i+1]\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpk28wkkee_test.go:40:20: undefined: i

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074864
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    \n    if len(lst1) != len(lst2) {\n        return\
    \ nil\n    }\n    \n    result := []string{}\n    \n    for _, str1 := range lst1\
    \ {\n        \n        for _, str2 := range lst2 {\n            \n           \
    \ if str1 == str2 {\n                continue\n            }\n            \n \
    \           charCount := 0\n            \n            for _, char := range str1\
    \ {\n                charCount += int(char)\n            }\n            \n   \
    \         for _, char := range str2 {\n                charCount += int(char)\n\
    \            }\n            \n            if charCount > len(str1) {\n       \
    \         result = append(result, str1)\n                break\n            }\n\
    \        }\n    }\n    \n    return result\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp0tswsvop_test.go:79: expected '[hi hi]', got '[admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmp0tswsvop_test.go:79:\
    \ expected '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmp0tswsvop_test.go:79: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmp0tswsvop_test.go:79: expected '[hI Hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmp0tswsvop_test.go:79:\
    \ expected '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmp0tswsvop_test.go:79: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074864
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    lst1Len := len(lst1)\n    lst2Len := len(lst2)\n\
    \    if lst1Len < lst2Len {\n        return lst1\n    }\n    \n    result := make([]string,\
    \ lst1Len)\n    for i := 0; i < lst1Len; i++ {\n        result[i] = lst1[i]\n\
    \    }\n    \n    for i := 0; i < lst2Len; i++ {\n        if lst1[i] != lst2[i]\
    \ {\n            result[i] = lst2[i]\n        }\n    }\n    \n    return result\n\
    }\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{}, []string{}), expected: []string{}\
    \ },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmptcg8qlnw_test.go:64: expected '[hI hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n        tmptcg8qlnw_test.go:64:\
    \ expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074864
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return nil\n\
    \    }\n    \n    result := make([]string, len(lst1))\n    \n    for i := range\
    \ lst1 {\n        result[i] = lst1[i]\n    }\n    \n    for i := range lst2 {\n\
    \        j := i\n        for j > 0 && lst1[j-1] == lst2[j] {\n            j--\n\
    \        }\n        if j == 0 {\n            result[i] = lst2[i]\n        }\n\
    \    }\n    \n    return result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__2\
    \ (0.00s)\n        tmpaa6n9igd_test.go:67: expected '[hi admin]', got '[]'\n \
    \   --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n        tmpaa6n9igd_test.go:67:\
    \ expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n\
    \        tmpaa6n9igd_test.go:67: expected '[hI Hi]', got '[hI admin]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpaa6n9igd_test.go:67: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpaa6n9igd_test.go:67: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074864
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    len1 := len(lst1)\n    len2 := len(lst2)\n  \
    \  if len1 == len2 {\n        return lst1\n    }\n    if len1 > len2 {\n     \
    \   lst2 = append([]string{}, lst2...)\n        len2 = len1\n    }\n    \n   \
    \ result := make([]string, len2)\n    for i := 0; i < len2; i++ {\n        result[i]\
    \ = lst2[i]\n    }\n    \n    for i := 0; i < len1; i++ {\n        j := 0\n  \
    \      for k := 0; k < len2; k++ {\n            if lst1[i] < lst2[k] {\n     \
    \           result[j] = lst1[i]\n                j++\n            }\n        }\n\
    \    }\n    return result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513700,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513700, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.total_match({0xc0000d8540?, 0x1, 0x450329?},\
    \ {0xc0000f5bf8?, 0x0, 0x0?})\n\t/tmp/tmpiwxr2twu_test.go:35 +0x265\ncommand-line-arguments_test.TestTotal_Match(0x0?)\n\
    \t/tmp/tmpiwxr2twu_test.go:65 +0x60e\ntesting.tRunner(0xc0001924e0, 0x529040)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074864
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return nil\n\
    \    }\n    \n    result := make([]string, len(lst1))\n    for i := 0; i < len(lst1);\
    \ i++ {\n        result[i] = lst1[i]\n    }\n    \n    for i := 0; i < len(lst1);\
    \ i++ {\n        if lst1[i] != lst2[i] {\n            break\n        }\n    }\n\
    \    \n    for i := 0; i < len(lst1); i++ {\n        if lst1[i] != lst2[i] {\n\
    \            break\n        }\n    }\n    \n    return result\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpb2z2k2w0_test.go:68: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpb2z2k2w0_test.go:68:\
    \ expected '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpb2z2k2w0_test.go:68: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpb2z2k2w0_test.go:68: expected '[hI Hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpb2z2k2w0_test.go:68:\
    \ expected '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpb2z2k2w0_test.go:68: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074761
- exit_code: 2
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    result := make([]string, 0)\n    if len(lst1)\
    \ == 0 {\n        return result\n    }\n    if len(lst2) == 0 {\n        return\
    \ result\n    }\n    if len(lst1) > len(lst2) {\n        lst1, lst2 = lst2, lst1\n\
    \    }\n    for _, val := range lst1 {\n        if !contains(lst2, val) {\n  \
    \          result = append(result, val)\n        }\n    }\n    return result\n\
    }\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{}, []string{}), expected: []string{}\
    \ },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjn31x687_test.go:34:13: undefined: contains

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074864
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    result := make([]string, 0)\n    \n    if len(lst1)\
    \ == 0 {\n        return result\n    }\n    \n    if len(lst2) == 0 {\n      \
    \  return result\n    }\n    \n    len1 := len(lst1)\n    len2 := len(lst2)\n\
    \    \n    if len1 == len2 {\n        for i := 0; i < len1; i++ {\n          \
    \  if lst1[i] < lst2[i] {\n                result = append(result, lst1[i])\n\
    \            }\n        }\n        return result\n    }\n    \n    if len1 < len2\
    \ {\n        for i := 0; i < len2; i++ {\n            if lst2[i] < lst1[i] {\n\
    \                result = append(result, lst2[i])\n            }\n        }\n\
    \        return result\n    }\n    \n    for i := 0; i < len1; i++ {\n       \
    \ if lst1[i] < lst2[i] {\n            result = append(result, lst1[i])\n     \
    \   }\n    }\n    \n    for i := 0; i < len2; i++ {\n        if lst2[i] < lst1[i]\
    \ {\n            result = append(result, lst2[i])\n        }\n    }\n    \n  \
    \  return result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\npanic: runtime error: index out of range\
    \ [2] with length 2 [recovered]\n\tpanic: runtime error: index out of range [2]\
    \ with length 2\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513700,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513700, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.total_match({0xc0000f5d30, 0x2, 0x0?}, {0xc0000f5db0,\
    \ 0x4, 0x0?})\n\t/tmp/tmpuuk9ba_x_test.go:47 +0x4d4\ncommand-line-arguments_test.TestTotal_Match(0xc0001a0340?)\n\
    \t/tmp/tmpuuk9ba_x_test.go:78 +0x22f\ntesting.tRunner(0xc0001a0340, 0x529040)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074865
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    \n    \n    if len(lst1) != len(lst2) {\n   \
    \     return lst1\n    }\n    \n    \n    \n    \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpb5sdlwy5_test.go:276:6: expected ''('', found TestTotal_Match

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074762
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    len1 := len(lst1)\n    len2 := len(lst2)\n  \
    \  if len1 == len2 {\n        return lst1\n    }\n    if len1 > len2 {\n     \
    \   return lst2\n    }\n    return lst1\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpfab3puaw_test.go:55: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmpfab3puaw_test.go:55:\
    \ expected '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmpfab3puaw_test.go:55: expected '[hI hi hi]', got '[hi admin]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074751
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return nil\n\
    \    }\n    \n    result := make([]string, 0)\n    for i := 0; i < len(lst1);\
    \ i++ {\n        if lst1[i] < lst2[i] {\n            result = append(result, lst1[i])\n\
    \        } else {\n            result = append(result, lst2[i])\n        }\n \
    \   }\n    \n    return result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmph_cq04e7_test.go:60: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmph_cq04e7_test.go:60:\
    \ expected '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmph_cq04e7_test.go:60: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmph_cq04e7_test.go:60: expected '[hI hi hi]', got '[]'\n \
    \   --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n        tmph_cq04e7_test.go:60:\
    \ expected '[hi admin]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074865
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return nil\n\
    \    }\n    \n    result := make([]string, len(lst1))\n    for i := 0; i < len(lst1);\
    \ i++ {\n        result[i] = lst1[i]\n    }\n    \n    for i := 0; i < len(lst1);\
    \ i++ {\n        if lst1[i] != lst2[i] {\n            return nil\n        }\n\
    \    }\n    \n    return result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpmnr9wdc0_test.go:62: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpmnr9wdc0_test.go:62: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpmnr9wdc0_test.go:62: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpmnr9wdc0_test.go:62: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpmnr9wdc0_test.go:62: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpmnr9wdc0_test.go:62: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074759
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    \n    // Write your code here\n    \n    return\
    \ lst1\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpw0ywk6kn_test.go:50: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmpw0ywk6kn_test.go:50:\
    \ expected '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmpw0ywk6kn_test.go:50: expected '[hI hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n        tmpw0ywk6kn_test.go:50:\
    \ expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074750
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    \n    if len(lst1) != len(lst2) {\n        return\
    \ lst1\n    }\n    \n    result := make([]string, len(lst1))\n    \n    for i\
    \ := 0; i < len(lst1); i++ {\n        if lst1[i] != lst2[i] {\n            result[i]\
    \ = lst1[i]\n        }\n    }\n    \n    return result\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpctafjxwt_test.go:60: expected '[hi hi]', got '[ admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmpctafjxwt_test.go:60:\
    \ expected '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmpctafjxwt_test.go:60: expected '[hI hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n        tmpctafjxwt_test.go:60:\
    \ expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074864
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    \n    // Write your code here\n    \n    return\
    \ lst1\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpw0ywk6kn_test.go:50: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmpw0ywk6kn_test.go:50:\
    \ expected '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmpw0ywk6kn_test.go:50: expected '[hI hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n        tmpw0ywk6kn_test.go:50:\
    \ expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074750
- exit_code: 2
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return lst1\n\
    \    }\n    \n    result := make([]string, 0)\n    \n    for _, v := range lst1\
    \ {\n        if !contains(lst2, v) {\n            result = append(result, v)\n\
    \        }\n    }\n    \n    return result\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_0eelxvl_test.go:30:13: undefined: contains

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074864
- exit_code: 2
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    lst3 := make([]string, 0)\n    for _, v := range\
    \ lst1 {\n        if strings.Count(v, \"\") < strings.Count(lst2[0], \"\") {\n\
    \            lst3 = append(lst3, v)\n        }\n    }\n    return lst3\n}\n\n\
    func TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{}, []string{}), expected: []string{}\
    \ },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpcjg9w76__test.go:25:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074864
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    lst1Len := len(lst1)\n    lst2Len := len(lst2)\n\
    \    if lst1Len == 0 || lst2Len == 0 {\n        return lst1\n    }\n    if lst1Len\
    \ > lst2Len {\n        return lst1\n    }\n    \n    result := make([]string,\
    \ lst1Len)\n    \n    for i := 0; i < lst1Len; i++ {\n        result[i] = lst1[i]\n\
    \    }\n    \n    for i := 0; i < lst2Len; i++ {\n        if result[i] != lst2[i]\
    \ {\n            break\n        }\n    }\n    \n    for i := 0; i < lst2Len; i++\
    \ {\n        if result[i] != lst2[i] {\n            break\n        }\n    }\n\
    \    \n    return result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpwyl47rpj_test.go:74: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmpwyl47rpj_test.go:74:\
    \ expected '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmpwyl47rpj_test.go:74: expected '[hI hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n        tmpwyl47rpj_test.go:74:\
    \ expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074865
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return nil\n\
    \    }\n    \n    result := make([]string, len(lst1))\n    for i := 0; i < len(lst1);\
    \ i++ {\n        if lst1[i] != lst2[i] {\n            result[i] = lst1[i]\n  \
    \      }\n    }\n    return result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n\
    \  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpg7vpcbvy_test.go:57: expected '[hi hi]', got '[ admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpg7vpcbvy_test.go:57:\
    \ expected '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpg7vpcbvy_test.go:57: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpg7vpcbvy_test.go:57: expected '[hI Hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpg7vpcbvy_test.go:57:\
    \ expected '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpg7vpcbvy_test.go:57: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074750
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var result []string\n    \n    if len(lst1) ==\
    \ 0 {\n        return lst2\n    }\n    if len(lst2) == 0 {\n        return lst1\n\
    \    }\n    \n    len1 := len(lst1)\n    len2 := len(lst2)\n    \n    if len1\
    \ == len2 {\n        for i := 0; i < len1; i++ {\n            if lst1[i] < lst2[i]\
    \ {\n                result = append(result, lst1[i])\n            }\n       \
    \ }\n    } else {\n        result = append(result, lst1[0])\n    }\n    \n   \
    \ for i := 1; i < len1; i++ {\n        if lst1[i] < lst2[i] {\n            result\
    \ = append(result, lst1[i])\n        }\n    }\n    \n    return result\n}\n\n\
    func TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{}, []string{}), expected: []string{}\
    \ },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpngbikn1r_test.go:75: expected '[hi hi]', got '[admin admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmpngbikn1r_test.go:75:\
    \ expected '[hI Hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n\
    \        tmpngbikn1r_test.go:75: expected '[hI hi hi]', got '[hi admin]'\n   \
    \ --- FAIL: TestTotal_Match/test_num__7 (0.00s)\n        tmpngbikn1r_test.go:75:\
    \ expected '[]', got '[this]'\n    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n\
    \        tmpngbikn1r_test.go:75: expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074865
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    \n    if len(lst1) != len(lst2) {\n        return\
    \ lst1\n    }\n    \n    result := []string{}\n    \n    for _, v := range lst1\
    \ {\n        if lst2 != nil && len(v) < len(lst2[0]) {\n            continue\n\
    \        }\n        \n        for _, v2 := range lst2 {\n            if v == v2\
    \ {\n                continue\n            }\n            \n            if len(v)\
    \ < len(v2) {\n                continue\n            }\n            \n       \
    \     if v != \"\" && v2 != \"\" {\n                if v != v2 {\n           \
    \         continue\n                }\n            }\n            \n         \
    \   result = append(result, v)\n        }\n    }\n    \n    return result\n}\n\
    \nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{}, []string{}), expected: []string{}\
    \ },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpggwz6yqj_test.go:78: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmpggwz6yqj_test.go:78: expected\
    \ '[hI Hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n   \
    \     tmpggwz6yqj_test.go:78: expected '[hI hi hi]', got '[hi admin]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__8 (0.00s)\n        tmpggwz6yqj_test.go:78: expected\
    \ '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074865
- exit_code: 2
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return nil\n\
    \    }\n    \n    result := make([]string, 0)\n    for _, val := range lst1 {\n\
    \        if strings.Contains(val, lst2[0]) {\n            result = append(result,\
    \ val)\n        }\n    }\n    \n    if len(result) == 0 {\n        return nil\n\
    \    }\n    \n    return result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpn8aib34q_test.go:29:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074864
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    \n    if len(lst1) != len(lst2) {\n        return\
    \ nil\n    }\n    \n    result := make([]string, len(lst1))\n    \n    for i :=\
    \ 0; i < len(lst1); i++ {\n        \n        count := 0\n        \n        for\
    \ j := 0; j < len(lst2); j++ {\n            \n            if lst1[i] < lst2[j]\
    \ {\n                count++\n            }\n        }\n        \n        if count\
    \ == len(lst2) {\n            result[i] = lst1[i]\n        }\n    }\n    \n  \
    \  return result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpz4nxkv40_test.go:70: expected '[hi hi]', got '[ admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpz4nxkv40_test.go:70:\
    \ expected '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpz4nxkv40_test.go:70: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpz4nxkv40_test.go:70: expected '[hI Hi]', got '[ ]'\n   \
    \ --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpz4nxkv40_test.go:70:\
    \ expected '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpz4nxkv40_test.go:70: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074865
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    m := make(map[string]int)\n    for _, s := range\
    \ lst1 {\n        m[s] = m[s] + 1\n    }\n    for _, s := range lst2 {\n     \
    \   m[s] = m[s] + 1\n    }\n    result := make([]string, 0)\n    for k := range\
    \ m {\n        if m[k] == len(lst1) {\n            result = append(result, k)\n\
    \        }\n    }\n    if len(result) == 0 {\n        return lst1\n    }\n   \
    \ return result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpb7ikxojc_test.go:63: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpb7ikxojc_test.go:63:\
    \ expected '[hi admin]', got '[admin]'\n    --- FAIL: TestTotal_Match/test_num__3\
    \ (0.00s)\n        tmpb7ikxojc_test.go:63: expected '[4]', got '[1 2 3 5]'\n \
    \   --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmpb7ikxojc_test.go:63:\
    \ expected '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmpb7ikxojc_test.go:63: expected '[hI hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n        tmpb7ikxojc_test.go:63:\
    \ expected '[hi admin]', got '[hi]'\n    --- FAIL: TestTotal_Match/test_num__8\
    \ (0.00s)\n        tmpb7ikxojc_test.go:63: expected '[]', got '[this]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074865
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    lst1Len := len(lst1)\n    lst2Len := len(lst2)\n\
    \    if lst1Len > lst2Len {\n        return lst1\n    }\n    if lst1Len == lst2Len\
    \ {\n        return lst1\n    }\n    \n    result := make([]string, 0)\n    for\
    \ i := 0; i < lst1Len; i++ {\n        if lst1[i] < lst2[i] {\n            result\
    \ = append(result, lst1[i])\n        }\n    }\n    return append(result, lst2...)\n\
    }\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{}, []string{}), expected: []string{}\
    \ },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpv9ez6jth_test.go:62: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpv9ez6jth_test.go:62:\
    \ expected '[hi admin]', got '[admin hi hi admin project]'\n    --- FAIL: TestTotal_Match/test_num__3\
    \ (0.00s)\n        tmpv9ez6jth_test.go:62: expected '[4]', got '[1 2 3 4 5]'\n\
    \    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmpv9ez6jth_test.go:62:\
    \ expected '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmpv9ez6jth_test.go:62: expected '[hI hi hi]', got '[admin\
    \ hI hi hi]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n        tmpv9ez6jth_test.go:62:\
    \ expected '[hi admin]', got '[admin hI hi hii]'\n    --- FAIL: TestTotal_Match/test_num__7\
    \ (0.00s)\n        tmpv9ez6jth_test.go:62: expected '[]', got '[this]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__8 (0.00s)\n        tmpv9ez6jth_test.go:62: expected\
    \ '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074865
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return lst1\n\
    \    }\n    \n    result := make([]string, len(lst1))\n    \n    for i := 0; i\
    \ < len(lst1); i++ {\n        if lst1[i] != lst2[i] {\n            result[i] =\
    \ lst1[i]\n        }\n    }\n    \n    return result\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpg46wy5h8_test.go:59: expected '[hi hi]', got '[ admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmpg46wy5h8_test.go:59:\
    \ expected '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmpg46wy5h8_test.go:59: expected '[hI hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n        tmpg46wy5h8_test.go:59:\
    \ expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074860
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    \n    // Write your code here\n    \n    return\
    \ lst1\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpw0ywk6kn_test.go:50: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmpw0ywk6kn_test.go:50:\
    \ expected '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmpw0ywk6kn_test.go:50: expected '[hI hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n        tmpw0ywk6kn_test.go:50:\
    \ expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074750
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    len1 := len(lst1)\n    len2 := len(lst2)\n  \
    \  if len1 == len2 {\n        return lst1\n    }\n    if len1 > len2 {\n     \
    \   len1, len2 = len2, len1\n    }\n    result := make([]string, len1)\n    for\
    \ i := 0; i < len1; i++ {\n        j := 0\n        for ; j < len2 && lst1[i] <\
    \ lst2[j]; j++ {\n        }\n        if j == len2 {\n            result[i] = lst1[i]\n\
    \        }\n    }\n    return result\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmptaan274r_test.go:64: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmptaan274r_test.go:64:\
    \ expected '[hi admin]', got '[ ]'\n    --- FAIL: TestTotal_Match/test_num__3\
    \ (0.00s)\n        tmptaan274r_test.go:64: expected '[4]', got '[]'\n    --- FAIL:\
    \ TestTotal_Match/test_num__4 (0.00s)\n        tmptaan274r_test.go:64: expected\
    \ '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n\
    \        tmptaan274r_test.go:64: expected '[hI hi hi]', got '[ admin]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__6 (0.00s)\n        tmptaan274r_test.go:64: expected\
    \ '[hi admin]', got '[ admin]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074756
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return lst1\n\
    \    }\n    \n    result := []string{}\n    for _, item := range lst1 {\n    \
    \    if lst2 != nil {\n            for _, item2 := range lst2 {\n            \
    \    if item == item2 {\n                    result = append(result, item)\n \
    \               }\n            }\n        }\n    }\n    return result\n}\n\nfunc\
    \ TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{}, []string{}), expected: []string{} },\n \
    \    { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    }), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpikosddpv_test.go:61: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpikosddpv_test.go:61: expected\
    \ '[hI hi hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n\
    \        tmpikosddpv_test.go:61: expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074865
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    len1 := len(lst1)\n    len2 := len(lst2)\n  \
    \  \n    if len1 == len2 {\n        return lst1\n    }\n    \n    result := make([]string,\
    \ len1)\n    \n    for i := 0; i < len1; i++ {\n        if lst1[i] < lst2[i] {\n\
    \            result[i] = lst1[i]\n        } else {\n            result[i] = lst2[i]\n\
    \        }\n    }\n    \n    return result\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 20 [running]:\ntesting.tRunner.func1.2({0x5134c0,\
    \ 0xc000162000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x5134c0, 0xc000162000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.total_match(...)\n\t/tmp/tmpdtyjnfvp_test.go:33\n\
    command-line-arguments_test.TestTotal_Match(0x0?)\n\t/tmp/tmpdtyjnfvp_test.go:58\
    \ +0x737\ntesting.tRunner(0xc0001036c0, 0x528dd8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074750
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    len1 := len(lst1)\n    len2 := len(lst2)\n  \
    \  if len1 == len2 {\n        return lst1\n    }\n    \n    result := make([]string,\
    \ len1)\n    for i := 0; i < len1; i++ {\n        count := 0\n        for j :=\
    \ 0; j < len2; j++ {\n            if lst1[i] < lst2[j] {\n                count++\n\
    \            }\n        }\n        if count > len2 {\n            result = append(result,\
    \ lst1[i])\n        }\n    }\n    return result\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp2hri2rhx_test.go:65: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmp2hri2rhx_test.go:65:\
    \ expected '[hi admin]', got '[ ]'\n    --- FAIL: TestTotal_Match/test_num__3\
    \ (0.00s)\n        tmp2hri2rhx_test.go:65: expected '[4]', got '[]'\n    --- FAIL:\
    \ TestTotal_Match/test_num__4 (0.00s)\n        tmp2hri2rhx_test.go:65: expected\
    \ '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n\
    \        tmp2hri2rhx_test.go:65: expected '[hI hi hi]', got '[ ]'\n    --- FAIL:\
    \ TestTotal_Match/test_num__6 (0.00s)\n        tmp2hri2rhx_test.go:65: expected\
    \ '[hi admin]', got '[ ]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074865
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return nil\n\
    \    }\n    \n    result := make([]string, len(lst1))\n    \n    for i := range\
    \ lst1 {\n        result[i] = lst1[i]\n    }\n    \n    for i := range lst2 {\n\
    \        j := 0\n        for k := range result {\n            if result[k] ==\
    \ lst2[i] {\n                j++\n            }\n        }\n        if j < len(result)\
    \ {\n            result[j] = lst2[i]\n        }\n    }\n    \n    return result\n\
    }\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{}, []string{}), expected: []string{}\
    \ },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__2\
    \ (0.00s)\n        tmp_4ngyd56_test.go:69: expected '[hi admin]', got '[]'\n \
    \   --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n        tmp_4ngyd56_test.go:69:\
    \ expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n\
    \        tmp_4ngyd56_test.go:69: expected '[hI Hi]', got '[Hi admin]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmp_4ngyd56_test.go:69: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmp_4ngyd56_test.go:69: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074865
- exit_code: 2
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    m := make(map[string]int)\n    for _, s := range\
    \ lst1 {\n        m[s] = m[s] + 1\n    }\n    for _, s := range lst2 {\n     \
    \   m[s] = m[s] + 1\n    }\n    for k, v := range m {\n        if v > len(lst1)\
    \ {\n            return lst1\n        }\n    }\n    return lst2\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpi6dvusmk_test.go:30:9: k declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074865
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    len1 := len(lst1)\n    len2 := len(lst2)\n  \
    \  if len1 == len2 {\n        return lst1\n    }\n    if len1 > len2 {\n     \
    \   return lst1\n    }\n    return lst2\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp2tn8o81p_test.go:55: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmp2tn8o81p_test.go:55:\
    \ expected '[hi admin]', got '[hi hi admin project]'\n    --- FAIL: TestTotal_Match/test_num__3\
    \ (0.00s)\n        tmp2tn8o81p_test.go:55: expected '[4]', got '[1 2 3 4 5]'\n\
    \    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmp2tn8o81p_test.go:55:\
    \ expected '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmp2tn8o81p_test.go:55: expected '[hi admin]', got '[hI hi\
    \ hii]'\n    --- FAIL: TestTotal_Match/test_num__7 (0.00s)\n        tmp2tn8o81p_test.go:55:\
    \ expected '[]', got '[this]'\n    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n\
    \        tmp2tn8o81p_test.go:55: expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074752
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    \n    \n    if len(lst1) != len(lst2) {\n   \
    \     return lst1\n    }\n    \n    \n    \n    \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpb5sdlwy5_test.go:276:6: expected ''('', found TestTotal_Match

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074762
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    len1 := len(lst1)\n    len2 := len(lst2)\n  \
    \  if len1 == len2 {\n        return lst1\n    }\n    if len1 > len2 {\n     \
    \   lst2 = append([]string{}, lst2...)\n        len2 = len1\n    }\n    result\
    \ := make([]string, len2)\n    for i := 0; i < len2; i++ {\n        result[i]\
    \ = lst2[i]\n    }\n    for i := 0; i < len1; i++ {\n        j := i\n        for\
    \ j < len2 && lst1[j] == lst2[j] {\n            j++\n        }\n        if j >\
    \ len2 {\n            break\n        }\n        result[i] = lst1[j]\n    }\n \
    \   return result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513700,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513700, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.total_match({0xc0000d8540?, 0x1, 0x450329?},\
    \ {0xc0000f5bf8?, 0x0, 0x0?})\n\t/tmp/tmpabwt541e_test.go:34 +0x268\ncommand-line-arguments_test.TestTotal_Match(0x0?)\n\
    \t/tmp/tmpabwt541e_test.go:64 +0x60e\ntesting.tRunner(0xc0001a01a0, 0x529040)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074866
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return lst1\n\
    \    }\n    \n    result := make([]string, len(lst1))\n    \n    for i := 0; i\
    \ < len(lst1); i++ {\n        total := 0\n        for j := 0; j < len(lst2); j++\
    \ {\n            if lst1[i] < lst2[j] {\n                total++\n           \
    \ }\n        }\n        if total == len(lst2) {\n            result[i] = lst1[i]\n\
    \        }\n    }\n    \n    return result\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmph923jwlc_test.go:65: expected '[hi hi]', got '[ admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmph923jwlc_test.go:65:\
    \ expected '[hI Hi]', got '[ ]'\n    --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n\
    \        tmph923jwlc_test.go:65: expected '[hI hi hi]', got '[hi admin]'\n   \
    \ --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n        tmph923jwlc_test.go:65:\
    \ expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074866
- exit_code: 2
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return nil\n\
    \    }\n    \n    result := []string{}\n    for _, v := range lst1 {\n       \
    \ if !contains(lst2, v) {\n            result = append(result, v)\n        }\n\
    \    }\n    return result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprwxdxd3b_test.go:29:13: undefined: contains

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074865
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    len1 := len(lst1)\n    len2 := len(lst2)\n  \
    \  if len1 == len2 {\n        return lst1\n    }\n    if len1 > len2 {\n     \
    \   return lst1\n    }\n    return lst2\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp2tn8o81p_test.go:55: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmp2tn8o81p_test.go:55:\
    \ expected '[hi admin]', got '[hi hi admin project]'\n    --- FAIL: TestTotal_Match/test_num__3\
    \ (0.00s)\n        tmp2tn8o81p_test.go:55: expected '[4]', got '[1 2 3 4 5]'\n\
    \    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmp2tn8o81p_test.go:55:\
    \ expected '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmp2tn8o81p_test.go:55: expected '[hi admin]', got '[hI hi\
    \ hii]'\n    --- FAIL: TestTotal_Match/test_num__7 (0.00s)\n        tmp2tn8o81p_test.go:55:\
    \ expected '[]', got '[this]'\n    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n\
    \        tmp2tn8o81p_test.go:55: expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074752
- exit_code: 2
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return nil\n\
    \    }\n    result := make([]string, 0)\n    for _, val := range lst1 {\n    \
    \    if lst2 != nil && len(val) < len(lst2) {\n            continue\n        }\n\
    \        result <- val\n    }\n    return result\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpl5brxbjc_test.go:31:9: invalid operation: cannot send to non-channel result
    (variable of type []string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074865
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return nil\n\
    \    }\n    \n    result := make([]string, len(lst1))\n    for i, _ := range result\
    \ {\n        result[i] = lst1[i]\n    }\n    \n    for i := 0; i < len(lst1);\
    \ i++ {\n        if lst1[i] != lst2[i] {\n            return nil\n        }\n\
    \    }\n    \n    return result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmppouivsf3_test.go:62: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmppouivsf3_test.go:62: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmppouivsf3_test.go:62: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmppouivsf3_test.go:62: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmppouivsf3_test.go:62: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmppouivsf3_test.go:62: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074866
- exit_code: 2
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    lst3 := make([]string, 0)\n    for _, val :=\
    \ range lst1 {\n        if !contains(lst2, val) {\n            lst3 = append(lst3,\
    \ val)\n        }\n    }\n    return lst3\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpwt2tglnu_test.go:25:13: undefined: contains

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074750
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    result := []string{}\n    if len(lst1) == 0 {\n\
    \        return result\n    }\n    if len(lst2) == 0 {\n        return result\n\
    \    }\n    if len(lst1) > len(lst2) {\n        lst1, lst2 = lst2, lst1\n    }\n\
    \    for _, str1 := range lst1 {\n        for _, str2 := range lst2 {\n      \
    \      if str1 == str2 {\n                result = append(result, str1)\n    \
    \            break\n            }\n        }\n    }\n    return result\n}\n\n\
    func TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{}, []string{}), expected: []string{}\
    \ },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpkpxsq0ip_test.go:65: expected '[hi hi]', got '[hi]'\n  \
    \  --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmpkpxsq0ip_test.go:65:\
    \ expected '[hI Hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n\
    \        tmpkpxsq0ip_test.go:65: expected '[hI hi hi]', got '[hi]'\n    --- FAIL:\
    \ TestTotal_Match/test_num__6 (0.00s)\n        tmpkpxsq0ip_test.go:65: expected\
    \ '[hi admin]', got '[hi]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074866
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return nil\n\
    \    }\n    \n    result := make([]string, len(lst1))\n    for i := 0; i < len(lst1);\
    \ i++ {\n        if lst1[i] != lst2[i] {\n            result[i] = lst1[i]\n  \
    \      } else {\n            result[i] = lst2[i]\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpj3qfdwmf_test.go:59: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpj3qfdwmf_test.go:59:\
    \ expected '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpj3qfdwmf_test.go:59: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpj3qfdwmf_test.go:59: expected '[hI Hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpj3qfdwmf_test.go:59:\
    \ expected '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpj3qfdwmf_test.go:59: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074866
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return nil\n\
    \    }\n    \n    result := make([]string, len(lst1))\n    \n    for i := range\
    \ lst1 {\n        total := 0\n        for j := range lst2 {\n            total\
    \ += len(lst1[i]) + len(lst2[j])\n        }\n        if total > len(lst1[i]) {\n\
    \            result = append(result, lst1[i])\n        }\n    }\n    \n    return\
    \ result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpn0czx4ml_test.go:63: expected '[hi hi]', got '[  hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpn0czx4ml_test.go:63:\
    \ expected '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpn0czx4ml_test.go:63: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpn0czx4ml_test.go:63: expected '[hI Hi]', got '[  hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpn0czx4ml_test.go:63:\
    \ expected '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpn0czx4ml_test.go:63: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074866
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    \n    // Write your code here\n    \n    return\
    \ lst1\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpw0ywk6kn_test.go:50: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmpw0ywk6kn_test.go:50:\
    \ expected '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmpw0ywk6kn_test.go:50: expected '[hI hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n        tmpw0ywk6kn_test.go:50:\
    \ expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074750
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    lst1Len := len(lst1)\n    lst2Len := len(lst2)\n\
    \    if lst1Len > lst2Len {\n        return lst1\n    }\n    if lst1Len == lst2Len\
    \ {\n        return lst1\n    }\n    \n    result := make([]string, 0)\n    \n\
    \    for i := 0; i < lst1Len; i++ {\n        if lst1[i] < lst2[i] {\n        \
    \    result = append(result, lst1[i])\n        }\n    }\n    \n    return result\n\
    }\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{}, []string{}), expected: []string{}\
    \ },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpkq5k7rur_test.go:64: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpkq5k7rur_test.go:64:\
    \ expected '[hi admin]', got '[admin]'\n    --- FAIL: TestTotal_Match/test_num__3\
    \ (0.00s)\n        tmpkq5k7rur_test.go:64: expected '[4]', got '[]'\n    --- FAIL:\
    \ TestTotal_Match/test_num__4 (0.00s)\n        tmpkq5k7rur_test.go:64: expected\
    \ '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n\
    \        tmpkq5k7rur_test.go:64: expected '[hI hi hi]', got '[admin]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__6 (0.00s)\n        tmpkq5k7rur_test.go:64: expected\
    \ '[hi admin]', got '[admin]'\n    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n\
    \        tmpkq5k7rur_test.go:64: expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074866
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) == 0 {\n        return lst2\n  \
    \  }\n    if len(lst2) == 0 {\n        return lst1\n    }\n    \n    len1 := len(lst1)\n\
    \    len2 := len(lst2)\n    \n    if len1 == len2 {\n        \n        for i :=\
    \ 0; i < len1; i++ {\n            if lst1[i] < lst2[i] {\n                return\
    \ lst1\n            }\n        }\n        return lst2\n    }\n    \n    diff :=\
    \ len1 - len2\n    \n    if diff > 0 {\n        return total_match(lst1[:diff],\
    \ lst2)\n    }\n    \n    return total_match(lst1, lst2[:diff])\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\npanic: runtime error: slice bounds out\
    \ of range [:-2] [recovered]\n\tpanic: runtime error: slice bounds out of range\
    \ [:-2]\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513800, 0xc000014360})\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x513800,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.total_match({0xc0000e2060?, 0x2?, 0x2?},\
    \ {0xc0000fa7c0?, 0x2?, 0x2?})\n\t/tmp/tmp15h3dadc_test.go:49 +0xbb\ncommand-line-arguments_test.TestTotal_Match(0x0?)\n\
    \t/tmp/tmp15h3dadc_test.go:61 +0x1ce\ntesting.tRunner(0xc0001a01a0, 0x529140)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074866
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    \n    if len(lst1) != len(lst2) {\n        return\
    \ nil\n    }\n    \n    result := make([]string, len(lst1))\n    \n    for i :=\
    \ 0; i < len(lst1); i++ {\n        \n        count := 0\n        \n        for\
    \ j := 0; j < len(lst2); j++ {\n            \n            if lst1[i] < lst2[j]\
    \ {\n                count++\n            }\n        }\n        \n        if count\
    \ == len(lst2) {\n            result[i] = lst1[i]\n        }\n    }\n    \n  \
    \  return result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpz4nxkv40_test.go:70: expected '[hi hi]', got '[ admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpz4nxkv40_test.go:70:\
    \ expected '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpz4nxkv40_test.go:70: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpz4nxkv40_test.go:70: expected '[hI Hi]', got '[ ]'\n   \
    \ --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpz4nxkv40_test.go:70:\
    \ expected '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpz4nxkv40_test.go:70: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074865
- exit_code: 2
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return nil\n\
    \    }\n    \n    result := make([]string, 0)\n    for _, val := range lst1 {\n\
    \        if lst2 != nil && len(val) >= len(lst2[0]) {\n            result += lst2\n\
    \        }\n    }\n    return result\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp05q4x7d3_test.go:30:13: invalid operation: operator + not defined on result
    (variable of type []string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074866
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    \n    // Write your code here\n    \n    return\
    \ lst1\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpw0ywk6kn_test.go:50: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmpw0ywk6kn_test.go:50:\
    \ expected '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmpw0ywk6kn_test.go:50: expected '[hI hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n        tmpw0ywk6kn_test.go:50:\
    \ expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074750
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    len1 := len(lst1)\n    len2 := len(lst2)\n  \
    \  if len1 == len2 {\n        return lst1\n    }\n    \n    result := make([]string,\
    \ len1)\n    \n    for i := 0; i < len1; i++ {\n        if lst1[i] < lst2[i] {\n\
    \            result[i] = lst1[i]\n        } else {\n            result[i] = lst2[i]\n\
    \        }\n    }\n    \n    return result\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x5134c0,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x5134c0, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.total_match(...)\n\t/tmp/tmpk3hpqapc_test.go:32\n\
    command-line-arguments_test.TestTotal_Match(0x0?)\n\t/tmp/tmpk3hpqapc_test.go:57\
    \ +0x737\ntesting.tRunner(0xc0001924e0, 0x528dd8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074862
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    len1 := len(lst1)\n    len2 := len(lst2)\n  \
    \  if len1 == len2 {\n        return lst1\n    }\n    if len1 > len2 {\n     \
    \   lst1, lst2 = lst2, lst1\n        len1, len2 = len2, len1\n    }\n    result\
    \ := make([]string, len1)\n    for i := 0; i < len1; i++ {\n        result[i]\
    \ = lst1[i]\n    }\n    for i := 0; i < len2; i++ {\n        found := false\n\
    \        for j := 0; j < len1; j++ {\n            if lst1[j] == lst2[i] {\n  \
    \              found = true\n                break\n            }\n        }\n\
    \        if !found {\n            result = append(result, lst2[i])\n        }\n\
    \    }\n    return result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpb648xqob_test.go:72: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpb648xqob_test.go:72:\
    \ expected '[hi admin]', got '[hi admin project]'\n    --- FAIL: TestTotal_Match/test_num__3\
    \ (0.00s)\n        tmpb648xqob_test.go:72: expected '[4]', got '[4 1 2 3 5]'\n\
    \    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmpb648xqob_test.go:72:\
    \ expected '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmpb648xqob_test.go:72: expected '[hI hi hi]', got '[hi admin\
    \ hI]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n        tmpb648xqob_test.go:72:\
    \ expected '[hi admin]', got '[hi admin hI hii]'\n    --- FAIL: TestTotal_Match/test_num__7\
    \ (0.00s)\n        tmpb648xqob_test.go:72: expected '[]', got '[this]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__8 (0.00s)\n        tmpb648xqob_test.go:72: expected\
    \ '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074867
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    len1 := len(lst1)\n    len2 := len(lst2)\n  \
    \  if len1 == len2 {\n        return lst1\n    }\n    if len1 > len2 {\n     \
    \   lst2 = append([]string{}, lst2...)\n        len2 = len1\n    }\n    \n   \
    \ result := make([]string, len2)\n    \n    for i := 0; i < len2; i++ {\n    \
    \    j := 0\n        for ; j < len1 && lst1[j] == lst2[i]; j++ {\n        }\n\
    \        if j == len1 {\n            result[i] = lst2[i]\n        } else {\n \
    \           result[i] = lst1[j]\n        }\n    }\n    return result\n}\n\nfunc\
    \ TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{}, []string{}), expected: []string{} },\n \
    \    { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    }), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2({0x513700,\
    \ 0xc0001c6000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513700, 0xc0001c6000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.total_match({0xc000188370?, 0x1, 0x450329?},\
    \ {0xc0000f0bf8?, 0x0, 0x0?})\n\t/tmp/tmpkohk2wdv_test.go:37 +0x27b\ncommand-line-arguments_test.TestTotal_Match(0x0?)\n\
    \t/tmp/tmpkohk2wdv_test.go:63 +0x60e\ntesting.tRunner(0xc0001851e0, 0x529040)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074867
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    result := make([]string, 0)\n    if len(lst1)\
    \ != len(lst2) {\n        return nil\n    }\n    for _, val := range lst1 {\n\
    \        if lst2 != nil && len(val) >= len(lst2[0]) {\n            result = append(result,\
    \ val)\n        }\n    }\n    return result\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmphq7jvxlr_test.go:56: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmphq7jvxlr_test.go:56:\
    \ expected '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmphq7jvxlr_test.go:56: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmphq7jvxlr_test.go:56: expected '[hI Hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmphq7jvxlr_test.go:56:\
    \ expected '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmphq7jvxlr_test.go:56: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074867
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    \n    \n    if len(lst1) != len(lst2) {\n   \
    \     return nil\n    }\n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpjqka1py2_test.go:276:6: expected ''('', found TestTotal_Match

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074866
- exit_code: 2
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    lst1Len := len(lst1)\n    lst2Len := len(lst2)\n\
    \    if lst1Len > lst2Len {\n        return lst1\n    }\n    if lst1Len == lst2Len\
    \ {\n        return lst1\n    }\n    result := make([]string, 0)\n    result :=\
    \ append(result, lst1...)\n    for i := 0; i < lst2Len; i++ {\n        if lst1[i]\
    \ != lst2[i] {\n            break\n        }\n        result = append(result,\
    \ lst1[i])\n    }\n    return result\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpcxte82ei_test.go:32:12: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074867
- exit_code: 2
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var result []string\n    for _, val := range\
    \ lst1 {\n        if !contains(lst2, val) {\n            result = append(result,\
    \ val)\n        }\n    }\n    return result\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7waa0qum_test.go:25:13: undefined: contains

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074752
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    len1 := len(lst1)\n    len2 := len(lst2)\n  \
    \  if len1 == len2 {\n        return lst1\n    }\n    if len1 > len2 {\n     \
    \   len1, len2 = len2, len1\n    }\n    result := make([]string, len1)\n    for\
    \ i := 0; i < len1; i++ {\n        result[i] = lst1[i]\n    }\n    for i := 0;\
    \ i < len2; i++ {\n        j := i\n        for j < len1 && lst1[j] == lst2[i]\
    \ {\n            j++\n        }\n        if j == len1 {\n            result[i]\
    \ = lst2[i]\n        }\n    }\n    return result\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\npanic: runtime error: index out of range\
    \ [2] with length 2 [recovered]\n\tpanic: runtime error: index out of range [2]\
    \ with length 2\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513700,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513700, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.total_match({0xc0000e2040?, 0x2, 0x450329?},\
    \ {0xc0000f5db0, 0x4, 0x0?})\n\t/tmp/tmp9phxnlnb_test.go:41 +0x238\ncommand-line-arguments_test.TestTotal_Match(0x0?)\n\
    \t/tmp/tmp9phxnlnb_test.go:56 +0x1f0\ntesting.tRunner(0xc0001924e0, 0x529040)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074860
- exit_code: 2
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    result := []string{}\n    \n    if len(lst1)\
    \ != len(lst2) {\n        return lst1\n    }\n    \n    for _, val := range lst1\
    \ {\n        if lst2 := total_match_test(val, lst2); lst2 != nil {\n         \
    \   result = append(result, lst2[0])\n        }\n    }\n    \n    return result\n\
    }\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{}, []string{}), expected: []string{}\
    \ },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpzpicr1x5_test.go:30:20: undefined: total_match_test

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074867
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return lst1\n\
    \    }\n    \n    result := make([]string, len(lst1))\n    for i := 0; i < len(lst1);\
    \ i++ {\n        result[i] = lst1[i]\n    }\n    \n    for i := 0; i < len(lst1);\
    \ i++ {\n        if lst1[i] != lst2[i] {\n            result[i] = lst1[i]\n  \
    \      }\n    }\n    \n    return result\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpmlqwmh5__test.go:62: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmpmlqwmh5__test.go:62:\
    \ expected '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmpmlqwmh5__test.go:62: expected '[hI hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n        tmpmlqwmh5__test.go:62:\
    \ expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074867
- exit_code: 2
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return nil\n\
    \    }\n    \n    result := make([]string, len(lst1))\n    \n    for i, v := range\
    \ lst1 {\n        if lst1[i] != lst2[i] {\n            result[i] = lst1[i]\n \
    \       }\n    }\n    \n    return result\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0rymso0b_test.go:29:12: v declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074867
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    m := make(map[string]int)\n    for _, s := range\
    \ lst1 {\n        m[s] = m[s] + 1\n    }\n    for _, s := range lst2 {\n     \
    \   m[s] = m[s] + 1\n    }\n    result := make([]string, 0)\n    for s, v := range\
    \ m {\n        if v > len(lst1) {\n            result = append(result, s)\n  \
    \      }\n    }\n    return result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n\
    \  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp6_83jxmo_test.go:60: expected '[hi hi]', got '[hi]'\n  \
    \  --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmp6_83jxmo_test.go:60:\
    \ expected '[hi admin]', got '[hi]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmp6_83jxmo_test.go:60: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmp6_83jxmo_test.go:60: expected\
    \ '[hI hi hi]', got '[hi]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmp6_83jxmo_test.go:60: expected '[hi admin]', got '[]'\n    --- FAIL:\
    \ TestTotal_Match/test_num__7 (0.00s)\n        tmp6_83jxmo_test.go:60: expected\
    \ '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074867
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    \n    // Write your code here\n    \n    return\
    \ lst1\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpw0ywk6kn_test.go:50: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmpw0ywk6kn_test.go:50:\
    \ expected '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmpw0ywk6kn_test.go:50: expected '[hI hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n        tmpw0ywk6kn_test.go:50:\
    \ expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074750
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    len1 := len(lst1)\n    len2 := len(lst2)\n  \
    \  if len1 == len2 {\n        return lst1\n    }\n    if len1 > len2 {\n     \
    \   lst1, lst2 = lst2, lst1\n        len1, len2 = len2, len1\n    }\n    \n  \
    \  result := make([]string, len1)\n    for i := 0; i < len1; i++ {\n        count\
    \ := 0\n        for j := 0; j < len2; j++ {\n            if lst1[i] < lst2[j]\
    \ {\n                count++\n            }\n        }\n        if count == len2\
    \ {\n            result[i] = lst1[i]\n        }\n    }\n    return result\n}\n\
    \nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{}, []string{}), expected: []string{}\
    \ },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp2l26bgp7_test.go:69: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmp2l26bgp7_test.go:69:\
    \ expected '[hi admin]', got '[ ]'\n    --- FAIL: TestTotal_Match/test_num__3\
    \ (0.00s)\n        tmp2l26bgp7_test.go:69: expected '[4]', got '[]'\n    --- FAIL:\
    \ TestTotal_Match/test_num__4 (0.00s)\n        tmp2l26bgp7_test.go:69: expected\
    \ '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n\
    \        tmp2l26bgp7_test.go:69: expected '[hI hi hi]', got '[ admin]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__6 (0.00s)\n        tmp2l26bgp7_test.go:69: expected\
    \ '[hi admin]', got '[ admin]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074867
- exit_code: 2
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return nil\n\
    \    }\n    result := make([]string, 0)\n    for _, v := range lst1 {\n      \
    \  if !contains(lst2, v) {\n            result = append(result, v)\n        }\n\
    \    }\n    return result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7v7kxu18_test.go:28:13: undefined: contains

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074867
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    len1 := len(lst1)\n    len2 := len(lst2)\n  \
    \  if len1 == len2 {\n        return lst1\n    }\n    if len1 > len2 {\n     \
    \   lst2, lst1 = lst1, lst2\n    }\n    result := make([]string, len1)\n    for\
    \ i := 0; i < len1; i++ {\n        j := 0\n        for ; j < len2 && lst1[i] <\
    \ lst2[j]; j++ {\n        }\n        result[i] = lst1[i]\n        if j == len2\
    \ {\n            break\n        }\n    }\n    return result\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.total_match(...)\n\t/tmp/tmpcyjchnq0_test.go:36\n\
    command-line-arguments_test.TestTotal_Match(0x0?)\n\t/tmp/tmpcyjchnq0_test.go:59\
    \ +0x557\ntesting.tRunner(0xc0001a0340, 0x528f38)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074867
- exit_code: 2
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    \n    if len(lst1) != len(lst2) {\n        return\
    \ nil\n    }\n    \n    result := []string{}\n    \n    for _, v := range lst1\
    \ {\n        if !contains(lst2, v) {\n            result = append(result, v)\n\
    \        }\n    }\n    \n    return result\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmppjqhgum4_test.go:31:13: undefined: contains

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074867
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return nil\n\
    \    }\n    \n    result := make([]string, len(lst1))\n    \n    for i := range\
    \ lst1 {\n        total := 0\n        for j := range lst2 {\n            total\
    \ += len(lst1[i])\n            if lst1[i] == lst2[j] {\n                total--\n\
    \            }\n        }\n        if total == 0 {\n            result = append(result,\
    \ lst1[i])\n        }\n    }\n    \n    return result\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp7c3dq2qf_test.go:66: expected '[hi hi]', got '[ ]'\n   \
    \ --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmp7c3dq2qf_test.go:66:\
    \ expected '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmp7c3dq2qf_test.go:66: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmp7c3dq2qf_test.go:66: expected '[hI Hi]', got '[ ]'\n   \
    \ --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmp7c3dq2qf_test.go:66:\
    \ expected '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmp7c3dq2qf_test.go:66: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074868
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) == 0 {\n        return lst2\n  \
    \  }\n    if len(lst2) == 0 {\n        return lst1\n    }\n    \n    len1 := len(lst1)\n\
    \    len2 := len(lst2)\n    \n    if len1 == len2 {\n        \n        for i :=\
    \ 0; i < len1; i++ {\n            if lst1[i] < lst2[i] {\n                return\
    \ lst1\n            }\n        }\n        return lst2\n    }\n    \n    result\
    \ := make([]string, len1)\n    \n    for i := 0; i < len1; i++ {\n        result[i]\
    \ = lst1[i]\n    }\n    \n    for i := 0; i < len2; i++ {\n        if result[i]\
    \ < lst2[i] {\n            result[i] = lst2[i]\n        }\n    }\n    \n    return\
    \ result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\npanic: runtime error: index out of range\
    \ [2] with length 2 [recovered]\n\tpanic: runtime error: index out of range [2]\
    \ with length 2\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513800,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513800, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.total_match({0xc0000e2060?, 0x2, 0x2?},\
    \ {0xc0000fa7c0?, 0x4, 0x2?})\n\t/tmp/tmp6qzokqpc_test.go:50 +0x22a\ncommand-line-arguments_test.TestTotal_Match(0x0?)\n\
    \t/tmp/tmp6qzokqpc_test.go:67 +0x1ce\ntesting.tRunner(0xc0001924e0, 0x529140)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074868
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return nil\n\
    \    }\n    result := make([]string, len(lst1))\n    for i := 0; i < len(lst1);\
    \ i++ {\n        result[i] = lst1[i]\n    }\n    for i := 0; i < len(lst2); i++\
    \ {\n        if lst1[i] != lst2[i] {\n            return nil\n        }\n    }\n\
    \    return result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate :=\
    \ total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpp38l15ky_test.go:59: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpp38l15ky_test.go:59: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpp38l15ky_test.go:59: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpp38l15ky_test.go:59: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpp38l15ky_test.go:59: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpp38l15ky_test.go:59: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074868
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) == 0 {\n        return lst2\n  \
    \  }\n    if len(lst2) == 0 {\n        return lst1\n    }\n    \n    len1 := len(lst1)\n\
    \    len2 := len(lst2)\n    \n    if len1 == len2 {\n        \n        for i :=\
    \ 0; i < len1; i++ {\n            if lst1[i] < lst2[i] {\n                return\
    \ lst1\n            }\n        }\n        return lst2\n    }\n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \nfunc TestTotal_Match(t *testing.T) {\n  candidate :=\
    \ total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp1crov75j_test.go:256:6: expected ''('', found TestTotal_Match

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074867
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return lst1\n\
    \    }\n    \n    result := make([]string, len(lst1))\n    for i, _ := range lst1\
    \ {\n        result[i] = lst1[i]\n    }\n    \n    for i, _ := range lst2 {\n\
    \        if result[i] != lst2[i] {\n            return lst1\n        }\n    }\n\
    \    \n    return result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpu1x3uqbl_test.go:62: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmpu1x3uqbl_test.go:62:\
    \ expected '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmpu1x3uqbl_test.go:62: expected '[hI hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n        tmpu1x3uqbl_test.go:62:\
    \ expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074868
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) == 0 {\n        return lst2\n  \
    \  }\n    if len(lst2) == 0 {\n        return lst1\n    }\n    \n    len1 := len(lst1)\n\
    \    len2 := len(lst2)\n    \n    if len1 == len2 {\n        return lst1\n   \
    \ }\n    \n    result := make([]string, len1)\n    \n    for i := 0; i < len1;\
    \ i++ {\n        result [i] = lst1[i]\n    }\n    \n    for i := 0; i < len2;\
    \ i++ {\n        result [i] = lst2[i]\n    }\n    \n    return result\n}\n\nfunc\
    \ TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{}, []string{}), expected: []string{} },\n \
    \    { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    }), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\npanic: runtime error: index out of range\
    \ [2] with length 2 [recovered]\n\tpanic: runtime error: index out of range [2]\
    \ with length 2\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513800,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513800, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.total_match(...)\n\t/tmp/tmpe08lniud_test.go:44\n\
    command-line-arguments_test.TestTotal_Match(0x0?)\n\t/tmp/tmpe08lniud_test.go:59\
    \ +0xbd2\ntesting.tRunner(0xc0001a0340, 0x529140)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074868
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    m := make(map[string]bool)\n    for _, s := range\
    \ lst1 {\n        m[s] = true\n    }\n    for _, s := range lst2 {\n        if\
    \ _, ok := m[s]; !ok {\n            return lst1\n        }\n    }\n    return\
    \ lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpvn6gxaco_test.go:56: expected '[hI Hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpvn6gxaco_test.go:56:\
    \ expected '[hI hi hi]', got '[hi admin]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074868
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    \n    if len(lst1) == 0 || len(lst2) == 0 {\n\
    \        return []string{}\n    }\n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n\nfunc TestTotal_Match(t *testing.T) {\n\
    \  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpg3rgrptl_test.go:275:6: expected ''('', found TestTotal_Match

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074867
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    len1 := len(lst1)\n    len2 := len(lst2)\n  \
    \  if len1 == len2 {\n        return lst1\n    }\n    if len1 > len2 {\n     \
    \   len1, len2 = len2, len1\n    }\n    \n    result := make([]string, len1)\n\
    \    for i := 0; i < len1; i++ {\n        j := 0\n        for ; j < len2; j++\
    \ {\n            if lst1[i] < lst2[j] {\n                break\n            }\n\
    \        }\n        result[i] = lst1[i]\n    }\n    return result\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpoh_39quj_test.go:66: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmpoh_39quj_test.go:66:\
    \ expected '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmpoh_39quj_test.go:66: expected '[hI hi hi]', got '[hi admin]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074868
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    \n    // Write code here\n    \n    return lst1\n\
    }\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{}, []string{}), expected: []string{}\
    \ },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpxrtuicjm_test.go:50: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmpxrtuicjm_test.go:50:\
    \ expected '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmpxrtuicjm_test.go:50: expected '[hI hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n        tmpxrtuicjm_test.go:50:\
    \ expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074869
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return nil\n\
    \    }\n    \n    result := make([]string, len(lst1))\n    for i := 0; i < len(lst1);\
    \ i++ {\n        if lst1[i] < lst2[i] {\n            result[i] = lst1[i]\n   \
    \     } else {\n            result[i] = lst2[i]\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmph2erqzno_test.go:59: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmph2erqzno_test.go:59:\
    \ expected '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmph2erqzno_test.go:59: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmph2erqzno_test.go:59: expected '[hI hi hi]', got '[]'\n \
    \   --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n        tmph2erqzno_test.go:59:\
    \ expected '[hi admin]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074754
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    len1 := len(lst1)\n    len2 := len(lst2)\n  \
    \  if len1 == len2 {\n        return lst1\n    }\n    \n    result := make([]string,\
    \ len1)\n    for i := 0; i < len1; i++ {\n        result [i] = lst1[i]\n    }\n\
    \    \n    for i := 0; i < len2; i++ {\n        j := i\n        for j > 0 && lst1[j-1]\
    \ == lst2[j] {\n            j--\n        }\n        if j == 0 {\n            result\
    \ [i] = lst2[i]\n        }\n    }\n    \n    return result\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\npanic: runtime error: index out of range\
    \ [2] with length 2 [recovered]\n\tpanic: runtime error: index out of range [2]\
    \ with length 2\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513700,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513700, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.total_match({0xc0000e2040?, 0x2, 0x450329?},\
    \ {0xc0000f5db0, 0x4, 0x0?})\n\t/tmp/tmp9ou47esn_test.go:40 +0x1bc\ncommand-line-arguments_test.TestTotal_Match(0x0?)\n\
    \t/tmp/tmp9ou47esn_test.go:56 +0x1f0\ntesting.tRunner(0xc0001a01a0, 0x529040)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074869
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    result := []string{}\n    len1 := len(lst1)\n\
    \    len2 := len(lst2)\n    if len1 == len2 {\n        for i := 0; i < len1; i++\
    \ {\n            if lst1[i] < lst2[i] {\n                result = append(result,\
    \ lst1[i])\n            }\n        }\n    } else {\n        fmt.Println(\"lst1\
    \ and lst2 have different lengths\")\n    }\n    return result\n}\n</code>\n<|/\
    \ a dscore=0 |>\n<| a dscore=0 |>\n<code>\npackage main\n\nimport (\n    \"fmt\"\
    \n    \"sort\"\n)\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp7jggk18j_test.go:37:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074868
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    result := []string{}\n    for _, val1 := range\
    \ lst1 {\n        for _, val2 := range lst2 {\n            if val1 == val2 {\n\
    \                result = append(result, val1)\n                break\n      \
    \      }\n        }\n    }\n    return result\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp0iwow3i5_test.go:56: expected '[hi hi]', got '[hi]'\n  \
    \  --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmp0iwow3i5_test.go:56:\
    \ expected '[hI Hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n\
    \        tmp0iwow3i5_test.go:56: expected '[hI hi hi]', got '[hi]'\n    --- FAIL:\
    \ TestTotal_Match/test_num__6 (0.00s)\n        tmp0iwow3i5_test.go:56: expected\
    \ '[hi admin]', got '[hi]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074869
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    \n    if len(lst1) != len(lst2) {\n        return\
    \ nil\n    }\n    \n    result := make([]string, 0)\n    \n    for _, str1 :=\
    \ range lst1 {\n        \n        for _, str2 := range lst2 {\n            \n\
    \            if str1 == str2 {\n                \n                continue\n \
    \           }\n            \n            if str1 > str2 {\n                \n\
    \                break\n            }\n            \n            if str1 < str2\
    \ {\n                \n                break\n            }\n            \n  \
    \      }\n        \n        result = append(result, str1)\n    }\n    \n    return\
    \ result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpf0prtupa_test.go:78: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpf0prtupa_test.go:78:\
    \ expected '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpf0prtupa_test.go:78: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpf0prtupa_test.go:78: expected '[hI Hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpf0prtupa_test.go:78:\
    \ expected '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpf0prtupa_test.go:78: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074869
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    len1 := len(lst1)\n    len2 := len(lst2)\n  \
    \  if len1 == len2 {\n        return lst1\n    }\n    if len1 > len2 {\n     \
    \   lst2 = append([]string{}, lst2...)\n        len2 = len(lst2)\n    }\n    \n\
    \    result := make([]string, len1)\n    for i := 0; i < len1; i++ {\n       \
    \ j := 0\n        for ; j < len2; j++ {\n            if lst1[i] < lst2[j] {\n\
    \                break\n            }\n        }\n        result[i] = lst1[i]\n\
    \    }\n    return result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpuw7n34gc_test.go:67: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmpuw7n34gc_test.go:67:\
    \ expected '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmpuw7n34gc_test.go:67: expected '[hI hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n        tmpuw7n34gc_test.go:67:\
    \ expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074869
- exit_code: 2
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    result := []string{}\n    if len(lst1) != len(lst2)\
    \ {\n        return lst1\n    }\n    for _, val := range lst1 {\n        if !contains(lst2,\
    \ val) {\n            result = append(result, val)\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp92cmz1om_test.go:28:13: undefined: contains

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074760
- exit_code: 2
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    lst3 := make([]string, 0)\n    if len(lst1) !=\
    \ len(lst2) {\n        return lst3\n    }\n    for _, val := range lst1 {\n  \
    \      if !contains(lst2, val) {\n            lst3 = append(lst3, val)\n     \
    \   }\n    }\n    return lst3\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpwceip81j_test.go:28:13: undefined: contains

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074869
- exit_code: 2
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    lst3 := make([]string, len(lst1))\n    for i\
    \ := 0; i < len(lst1); i++ {\n        lst3[i] = lst1[i]\n    }\n    for i := 0;\
    \ i < len(lst2); i++ {\n        lst3[i] = lst3[i] + lst2[i]\n    }\n    lst3 :=\
    \ lst3[:len(lst3)]\n    lst3 := append(lst3, lst1...)\n    lst3 := append(lst3,\
    \ lst2...)\n    return lst3\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5ef6exc6_test.go:30:10: no new variables on left side of :=

    /tmp/tmp5ef6exc6_test.go:31:10: no new variables on left side of :=

    /tmp/tmp5ef6exc6_test.go:32:10: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074869
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return nil\n\
    \    }\n    \n    result := make([]string, len(lst1))\n    for i := 0; i < len(lst1);\
    \ i++ {\n        result[i] = lst1[i]\n    }\n    \n    for i := 0; i < len(lst1);\
    \ i++ {\n        if lst1[i] != lst2[i] {\n            result[i] = lst2[i]\n  \
    \      }\n    }\n    \n    return result\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__2\
    \ (0.00s)\n        tmphgpnn8u6_test.go:62: expected '[hi admin]', got '[]'\n \
    \   --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n        tmphgpnn8u6_test.go:62:\
    \ expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n\
    \        tmphgpnn8u6_test.go:62: expected '[hI hi hi]', got '[]'\n    --- FAIL:\
    \ TestTotal_Match/test_num__6 (0.00s)\n        tmphgpnn8u6_test.go:62: expected\
    \ '[hi admin]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074869
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    result := []string{}\n    if len(lst1) == 0 {\n\
    \        return result\n    }\n    if len(lst2) == 0 {\n        return result\n\
    \    }\n    \n    len1 := len(lst1)\n    len2 := len(lst2)\n    \n    if len1\
    \ == len2 {\n        for i := 0; i < len1; i++ {\n            if lst1[i] < lst2[i]\
    \ {\n                result = append(result, lst1[i])\n            }\n       \
    \ }\n        return result\n    }\n    \n    if len1 < len2 {\n        for i :=\
    \ 0; i < len2; i++ {\n            if lst2[i] < lst1[i] {\n                result\
    \ = append(result, lst2[i])\n            }\n        }\n        return result\n\
    \    }\n    \n    for i := 0; i < len1; i++ {\n        if lst1[i] < lst2[i] {\n\
    \            result = append(result, lst1[i])\n        }\n    }\n    for i :=\
    \ 0; i < len2; i++ {\n        if lst2[i] < lst1[i] {\n            result = append(result,\
    \ lst2[i])\n        }\n    }\n    return result\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\npanic: runtime error: index out of range\
    \ [2] with length 2 [recovered]\n\tpanic: runtime error: index out of range [2]\
    \ with length 2\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513700,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513700, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.total_match({0xc0000f5d30, 0x2, 0x0?}, {0xc0000f5db0,\
    \ 0x4, 0x0?})\n\t/tmp/tmp8uyyu924_test.go:45 +0x509\ncommand-line-arguments_test.TestTotal_Match(0xc000192680?)\n\
    \t/tmp/tmp8uyyu924_test.go:74 +0x22f\ntesting.tRunner(0xc000192680, 0x529040)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074869
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    \n    if len(lst1) == 0 || len(lst2) == 0 {\n\
    \        return lst1\n    }\n    \n    if len(lst1) > len(lst2) {\n        lst1,\
    \ lst2 = lst2, lst1\n    }\n    \n    total := 0\n    for _, val := range lst1\
    \ {\n        total += len(val)\n    }\n    \n    for _, val := range lst2 {\n\
    \        total -= len(val)\n    }\n    \n    if total == 0 {\n        return lst1\n\
    \    }\n    \n    return lst1[:len(lst1)-total]\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\npanic: runtime error: slice bounds out\
    \ of range [:-1] [recovered]\n\tpanic: runtime error: slice bounds out of range\
    \ [:-1]\n\ngoroutine 34 [running]:\ntesting.tRunner.func1.2({0x513800, 0xc0001d8000})\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x513800,\
    \ 0xc0001d8000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.total_match(...)\n\t/tmp/tmpv2a7rz6r_test.go:45\n\
    command-line-arguments_test.TestTotal_Match(0x0?)\n\t/tmp/tmpv2a7rz6r_test.go:56\
    \ +0xb4c\ntesting.tRunner(0xc000198ea0, 0x529140)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074869
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    \n    if len(lst1) == 0 {\n        return lst2\n\
    \    }\n    if len(lst2) == 0 {\n        return lst1\n    }\n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpk5xvna93_test.go:274:6: expected ''('', found TestTotal_Match

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074755
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    len1 := len(lst1)\n    len2 := len(lst2)\n  \
    \  if len1 == len2 {\n        return lst1\n    }\n    if len1 < len2 {\n     \
    \   return lst2\n    }\n    return lst1\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp2vw012pd_test.go:55: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmp2vw012pd_test.go:55:\
    \ expected '[hi admin]', got '[hi hi admin project]'\n    --- FAIL: TestTotal_Match/test_num__3\
    \ (0.00s)\n        tmp2vw012pd_test.go:55: expected '[4]', got '[1 2 3 4 5]'\n\
    \    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmp2vw012pd_test.go:55:\
    \ expected '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmp2vw012pd_test.go:55: expected '[hi admin]', got '[hI hi\
    \ hii]'\n    --- FAIL: TestTotal_Match/test_num__7 (0.00s)\n        tmp2vw012pd_test.go:55:\
    \ expected '[]', got '[this]'\n    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n\
    \        tmp2vw012pd_test.go:55: expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074752
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    len1 := len(lst1)\n    len2 := len(lst2)\n  \
    \  if len1 == len2 {\n        return lst1\n    }\n    if len1 > len2 {\n     \
    \   lst2 = append(lst2, lst1...)\n        lst1 = lst1[:len1]\n    }\n    result\
    \ := make([]string, len1)\n    for i := 0; i < len1; i++ {\n        result[i]\
    \ = lst1[i]\n    }\n    for i := 0; i < len2; i++ {\n        j := 0\n        for\
    \ k := 0; k < len1; k++ {\n            if lst1[k] == lst2[j] {\n             \
    \   j++\n            }\n        }\n        if j < len2 {\n            result[i]\
    \ = lst2[j]\n        }\n    }\n    return result\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\npanic: runtime error: index out of range\
    \ [2] with length 2 [recovered]\n\tpanic: runtime error: index out of range [2]\
    \ with length 2\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513700,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513700, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.total_match({0xc0000e2040, 0x2, 0x450329?},\
    \ {0xc0000f5db0?, 0x4, 0x0?})\n\t/tmp/tmp6tysqn04_test.go:44 +0x2c5\ncommand-line-arguments_test.TestTotal_Match(0x0?)\n\
    \t/tmp/tmp6tysqn04_test.go:59 +0x1f0\ntesting.tRunner(0xc0001924e0, 0x529040)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074869
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return nil\n\
    \    }\n    \n    result := make([]string, len(lst1))\n    \n    for i := 0; i\
    \ < len(lst1); i++ {\n        if lst1[i] != lst2[i] {\n            result[i] =\
    \ lst1[i]\n        }\n    }\n    \n    return result\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp5d93kwak_test.go:59: expected '[hi hi]', got '[ admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmp5d93kwak_test.go:59:\
    \ expected '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmp5d93kwak_test.go:59: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmp5d93kwak_test.go:59: expected '[hI Hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmp5d93kwak_test.go:59:\
    \ expected '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmp5d93kwak_test.go:59: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074759
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    len1 := len(lst1)\n    len2 := len(lst2)\n  \
    \  if len1 == len2 {\n        return lst1\n    }\n    if len1 > len2 {\n     \
    \   len1, len2 = len2, len1\n    }\n    result := make([]string, len1)\n    for\
    \ i := 0; i < len1; i++ {\n        j := 0\n        for ; j < len2; j++ {\n   \
    \         if lst1[i] < lst2[j] {\n                break\n            }\n     \
    \   }\n        result[i] = lst1[i]\n    }\n    return result\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp_y_qkhai_test.go:65: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmp_y_qkhai_test.go:65:\
    \ expected '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmp_y_qkhai_test.go:65: expected '[hI hi hi]', got '[hi admin]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074869
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return nil\n\
    \    }\n    \n    result := make([]string, len(lst1))\n    for i := 0; i < len(lst1);\
    \ i++ {\n        if lst1[i] != lst2[i] {\n            result[i] = lst1[i]\n  \
    \      }\n    }\n    return result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n\
    \  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpg7vpcbvy_test.go:57: expected '[hi hi]', got '[ admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpg7vpcbvy_test.go:57:\
    \ expected '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpg7vpcbvy_test.go:57: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpg7vpcbvy_test.go:57: expected '[hI Hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpg7vpcbvy_test.go:57:\
    \ expected '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpg7vpcbvy_test.go:57: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074750
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) == 0 {\n        return lst2\n  \
    \  }\n    if len(lst2) == 0 {\n        return lst1\n    }\n    \n    lst1Len :=\
    \ len(lst1)\n    lst2Len := len(lst2)\n    \n    if lst1Len > lst2Len {\n    \
    \    return lst1\n    }\n    \n    result := make([]string, 0)\n    \n    for\
    \ i := 0; i < lst1Len; i++ {\n        if lst1[i] < lst2[i] {\n            result\
    \ = append(result, lst1[i])\n        }\n    }\n    \n    for i := 0; i < lst2Len;\
    \ i++ {\n        if lst2[i] < lst1[i] {\n            result = append(result, lst2[i])\n\
    \        }\n    }\n    \n    return result\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\npanic: runtime error: index out of range\
    \ [2] with length 2 [recovered]\n\tpanic: runtime error: index out of range [2]\
    \ with length 2\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513800,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513800, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.total_match({0xc0000e2060?, 0x2, 0x51400000003?},\
    \ {0xc0000fa7c0?, 0x4, 0x5d4590?})\n\t/tmp/tmpwc0j09wp_test.go:46 +0x365\ncommand-line-arguments_test.TestTotal_Match(0x0?)\n\
    \t/tmp/tmpwc0j09wp_test.go:63 +0x1ce\ntesting.tRunner(0xc0001924e0, 0x529140)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074869
- exit_code: 2
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    \n    if len(lst1) == 0 || len(lst2) == 0 {\n\
    \        return lst1\n    }\n    \n    result := []string{}\n    \n    for _,\
    \ val := range lst1 {\n        \n        if _, ok := lst2[len(lst2)-1]; ok {\n\
    \            result = append(result, val)\n        }\n    }\n    \n    return\
    \ result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5zccgkon_test.go:32:21: assignment mismatch: 2 variables but 1 value

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074869
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    len1 := len(lst1)\n    len2 := len(lst2)\n  \
    \  if len1 == len2 {\n        return lst1\n    }\n    if len1 > len2 {\n     \
    \   lst2, lst1 = lst1, lst2\n        len2, len1 = len1, len2\n    }\n    result\
    \ := make([]string, len1)\n    for i := 0; i < len1; i++ {\n        count := 0\n\
    \        for j := 0; j < len2; j++ {\n            if lst1[i] == lst2[j] {\n  \
    \              count++\n            }\n        }\n        if count > len(lst2)\
    \ {\n            result = append(result, lst1[i])\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpkv_mf_jk_test.go:68: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpkv_mf_jk_test.go:68:\
    \ expected '[hi admin]', got '[ ]'\n    --- FAIL: TestTotal_Match/test_num__3\
    \ (0.00s)\n        tmpkv_mf_jk_test.go:68: expected '[4]', got '[]'\n    --- FAIL:\
    \ TestTotal_Match/test_num__4 (0.00s)\n        tmpkv_mf_jk_test.go:68: expected\
    \ '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n\
    \        tmpkv_mf_jk_test.go:68: expected '[hI hi hi]', got '[ ]'\n    --- FAIL:\
    \ TestTotal_Match/test_num__6 (0.00s)\n        tmpkv_mf_jk_test.go:68: expected\
    \ '[hi admin]', got '[ ]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074869
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    \n    if len(lst1) != len(lst2) {\n        return\
    \ lst1\n    }\n    \n    result := []string{}\n    \n    for i := 0; i < len(lst1);\
    \ i++ {\n        \n        if lst1[i] != lst2[i] {\n            break\n      \
    \  }\n        \n        result = append(result, lst1[i])\n    }\n    \n    return\
    \ result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpg6d3375u_test.go:63: expected '[hi hi]', got '[hi]'\n  \
    \  --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmpg6d3375u_test.go:63:\
    \ expected '[hI Hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n\
    \        tmpg6d3375u_test.go:63: expected '[hI hi hi]', got '[hi admin]'\n   \
    \ --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n        tmpg6d3375u_test.go:63:\
    \ expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074862
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpkee1wx5g_test.go:280:6: expected ''('', found TestTotal_Match

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074749
- exit_code: 2
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var result []string\n    \n    if len(lst1) ==\
    \ 0 {\n        return result\n    }\n    \n    if len(lst2) == 0 {\n        return\
    \ result\n    }\n    \n    if len(lst1) > len(lst2) {\n        lst1, lst2 = lst2,\
    \ lst1\n    }\n    \n    for _, val := range lst1 {\n        if _, ok := lst2[len(lst2)-1];\
    \ ok {\n            lst2 = append(lst2, val)\n        } else {\n            result\
    \ = append(result, val)\n        }\n    }\n    \n    return result\n}\n\nfunc\
    \ TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{}, []string{}), expected: []string{} },\n \
    \    { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    }), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjugly8dg_test.go:38:21: assignment mismatch: 2 variables but 1 value

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074869
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return nil\n\
    \    }\n    \n    result := make([]string, 0)\n    for _, element := range lst1\
    \ {\n        if element == \"\" {\n            continue\n        }\n        \n\
    \        found := false\n        for _, element2 := range lst2 {\n           \
    \ if element == element2 {\n                found = true\n                break\n\
    \            }\n        }\n        if !found {\n            result = append(result,\
    \ element)\n        }\n    }\n    \n    return result\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpg2unuqx1_test.go:69: expected '[hi hi]', got '[admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpg2unuqx1_test.go:69:\
    \ expected '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpg2unuqx1_test.go:69: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpg2unuqx1_test.go:69: expected '[hI Hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpg2unuqx1_test.go:69:\
    \ expected '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpg2unuqx1_test.go:69: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074870
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    result := []string{}\n    if len(lst1) != len(lst2)\
    \ {\n        return lst1\n    }\n    for _, val := range lst1 {\n        if val\
    \ <= lst2[0] {\n            result = append(result, val)\n        }\n    }\n \
    \   return result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp3fmwunr9_test.go:56: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmp3fmwunr9_test.go:56:\
    \ expected '[hI Hi]', got '[admin]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmp3fmwunr9_test.go:56: expected '[hI hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n        tmp3fmwunr9_test.go:56:\
    \ expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074860
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var result []string\n    if len(lst1) != len(lst2)\
    \ {\n        return nil\n    }\n    for _, x := range lst1 {\n        if lst2\
    \ != nil && len(x) >= len(lst2[0]) {\n            result = append(result, x)\n\
    \        }\n    }\n    return result\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp29qq830r_test.go:56: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmp29qq830r_test.go:56:\
    \ expected '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmp29qq830r_test.go:56: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmp29qq830r_test.go:56: expected '[hI Hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmp29qq830r_test.go:56:\
    \ expected '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmp29qq830r_test.go:56: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074870
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var result []string\n    \n    if len(lst1) ==\
    \ 0 {\n        return result\n    }\n    if len(lst2) == 0 {\n        return result\n\
    \    }\n    \n    for _, item := range lst1 {\n        if item == \"\" {\n   \
    \         continue\n        }\n        \n        for _, item2 := range lst2 {\n\
    \            if item == item2 {\n                continue\n            }\n   \
    \         \n            if item > item2 {\n                break\n           \
    \ }\n        }\n        \n        result = append(result, item)\n    }\n    \n\
    \    return result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate :=\
    \ total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmppnlv_lt6_test.go:74: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmppnlv_lt6_test.go:74:\
    \ expected '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmppnlv_lt6_test.go:74: expected '[hI hi hi]', got '[hi admin]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074870
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    \n    if len(lst1) != len(lst2) {\n        return\
    \ lst1\n    }\n    \n    result := []string{}\n    \n    for _, item := range\
    \ lst1 {\n        found := false\n        for _, item2 := range lst2 {\n     \
    \       if item == item2 {\n                found = true\n                break\n\
    \            }\n        }\n        if !found {\n            result = append(result,\
    \ item)\n        }\n    }\n    \n    return result\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp2vt2t8pv_test.go:67: expected '[hi hi]', got '[admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmp2vt2t8pv_test.go:67:\
    \ expected '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmp2vt2t8pv_test.go:67: expected '[hI hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n        tmp2vt2t8pv_test.go:67:\
    \ expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074870
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return nil\n\
    \    }\n    \n    result := make([]string, len(lst1))\n    \n    for i := range\
    \ lst1 {\n        result[i] = lst1[i]\n    }\n    \n    for i := range lst2 {\n\
    \        if lst1[i] != lst2[i] {\n            result[i] = \"\"\n        }\n  \
    \  }\n    \n    return result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp18v6c5el_test.go:63: expected '[hi hi]', got '[hi ]'\n \
    \   --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmp18v6c5el_test.go:63:\
    \ expected '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmp18v6c5el_test.go:63: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmp18v6c5el_test.go:63: expected '[hI Hi]', got '[ ]'\n   \
    \ --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmp18v6c5el_test.go:63:\
    \ expected '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmp18v6c5el_test.go:63: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074870
- exit_code: 2
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return nil\n\
    \    }\n    \n    result := []string{}\n    for _, s := range lst1 {\n       \
    \ if !contains(lst2, s) {\n            result = append(result, s)\n        }\n\
    \    }\n    return result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxjr2cbuy_test.go:29:13: undefined: contains

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074870
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    lst3 := make([]string, len(lst1))\n    for i\
    \ := 0; i < len(lst1); i++ {\n        lst3[i] = lst1[i]\n    }\n    for i := 0;\
    \ i < len(lst2); i++ {\n        lst3[i] = lst3[i] + lst2[i]\n    }\n    return\
    \ lst3\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\npanic: runtime error: index out of range\
    \ [2] with length 2 [recovered]\n\tpanic: runtime error: index out of range [2]\
    \ with length 2\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.total_match(...)\n\t/tmp/tmp2qyob64e_test.go:28\n\
    command-line-arguments_test.TestTotal_Match(0x0?)\n\t/tmp/tmp2qyob64e_test.go:42\
    \ +0x97f\ntesting.tRunner(0xc0001a0340, 0x528d58)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074870
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return nil\n\
    \    }\n    \n    result := make([]string, 0)\n    \n    for _, l1 := range lst1\
    \ {\n        found := false\n        for _, l2 := range lst2 {\n            if\
    \ l1 == l2 {\n                found = true\n                break\n          \
    \  }\n        }\n        if !found {\n            result = append(result, l1)\n\
    \        }\n    }\n    \n    return result\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpg6d6cypu_test.go:66: expected '[hi hi]', got '[admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpg6d6cypu_test.go:66:\
    \ expected '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpg6d6cypu_test.go:66: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpg6d6cypu_test.go:66: expected '[hI Hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpg6d6cypu_test.go:66:\
    \ expected '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpg6d6cypu_test.go:66: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074870
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return nil\n\
    \    }\n    \n    result := make([]string, len(lst1))\n    for i, _ := range result\
    \ {\n        result[i] = lst1[i]\n    }\n    \n    for i := 0; i < len(lst1);\
    \ i++ {\n        if lst1[i] != lst2[i] {\n            break\n        }\n     \
    \   result[i] = lst1[i]\n    }\n    \n    return result\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmplpx1e6ml_test.go:63: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmplpx1e6ml_test.go:63:\
    \ expected '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmplpx1e6ml_test.go:63: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmplpx1e6ml_test.go:63: expected '[hI Hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmplpx1e6ml_test.go:63:\
    \ expected '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmplpx1e6ml_test.go:63: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074870
- exit_code: 2
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return nil\n\
    \    }\n    \n    result := make([]string, len(lst1))\n    for i, v := range lst1\
    \ {\n        if lst1[i] < lst2[i] {\n            result[i] = lst1[i]\n       \
    \ } else {\n            result[i] = lst2[i]\n        }\n    }\n    return result\n\
    }\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{}, []string{}), expected: []string{}\
    \ },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6kdw3jeh_test.go:28:12: v declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074870
- exit_code: 2
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    result := []string{}\n    if len(lst1) != len(lst2)\
    \ {\n        return nil\n    }\n    for _, val := range lst1 {\n        if !contains(lst2,\
    \ val) {\n            result = append(result, val)\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp32uxqtbe_test.go:28:13: undefined: contains

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074870
- exit_code: 2
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    lst1Len := len(lst1)\n    lst2Len := len(lst2)\n\
    \    if lst1Len > lst2Len {\n        return lst1\n    }\n    if lst2Len > lst1Len\
    \ {\n        return lst2\n    }\n    \n    result := make([]string, 0)\n    for\
    \ i := 0; i < lst1Len; i++ {\n        result := append(result, lst1[i])\n    }\n\
    \    for i := 0; i < lst2Len; i++ {\n        result := append(result, lst2[i])\n\
    \    }\n    \n    return result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpex_yhkj8_test.go:34:9: result declared but not used

    /tmp/tmpex_yhkj8_test.go:37:9: result declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074870
- exit_code: 2
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return nil\n\
    \    }\n    \n    result := make([]string, len(lst1))\n    for i, v := range lst1\
    \ {\n        if lst1[i] != lst2[i] {\n            result[i] = lst1[i]\n      \
    \  }\n    }\n    return result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp68nz1k37_test.go:28:12: v declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074752
- exit_code: 2
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var result []string\n    \n    if len(lst1) ==\
    \ 0 || len(lst2) == 0 {\n        return result\n    }\n    \n    result := lst1\n\
    \    \n    for _, val := range lst2 {\n        if val != result[len(result)-1]\
    \ {\n            result = append(result, val)\n        }\n    }\n    \n    return\
    \ result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpj0mj4qhy_test.go:29:12: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074870
- exit_code: 2
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    result := []string{}\n    if len(lst1) == 0 {\n\
    \        return result\n    }\n    if len(lst2) == 0 {\n        return result\n\
    \    }\n    \n    lst1Len := len(lst1)\n    lst2Len := len(lst2)\n    \n    if\
    \ lst1Len > lst2Len {\n        lst1, lst2 = lst2, lst1\n        lst1Len, lst2Len\
    \ = lst2Len, lst1Len\n    }\n    \n    result := lst1[:lst1Len]\n    \n    for\
    \ i := 0; i < lst1Len; i++ {\n        found := false\n        for j := 0; j <\
    \ lst2Len; j++ {\n            if lst1[i] == lst2[j] {\n                found =\
    \ true\n                break\n            }\n        }\n        if !found {\n\
    \            result = append(result, lst1[i])\n        }\n    }\n    \n    return\
    \ result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp31v7s8cl_test.go:39:12: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074870
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return nil\n\
    \    }\n    \n    result := make([]string, len(lst1))\n    \n    for i := 0; i\
    \ < len(lst1); i++ {\n        total := 0\n        for _, v := range lst1 {\n \
    \           if v == lst2[i] {\n                total++\n            }\n      \
    \  }\n        if total > len(lst2) {\n            result = append(result, lst2[i])\n\
    \        }\n    }\n    \n    return result\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp7e0vqk0s_test.go:65: expected '[hi hi]', got '[ ]'\n   \
    \ --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmp7e0vqk0s_test.go:65:\
    \ expected '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmp7e0vqk0s_test.go:65: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmp7e0vqk0s_test.go:65: expected '[hI Hi]', got '[ ]'\n   \
    \ --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmp7e0vqk0s_test.go:65:\
    \ expected '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmp7e0vqk0s_test.go:65: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074871
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    \n    // Write code here\n    \n    return lst1\n\
    }\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{}, []string{}), expected: []string{}\
    \ },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpxrtuicjm_test.go:50: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmpxrtuicjm_test.go:50:\
    \ expected '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmpxrtuicjm_test.go:50: expected '[hI hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n        tmpxrtuicjm_test.go:50:\
    \ expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074869
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    len1 := len(lst1)\n    len2 := len(lst2)\n  \
    \  \n    if len1 == len2 {\n        return lst1\n    }\n    \n    result := make([]string,\
    \ len1)\n    \n    for i := 0; i < len1; i++ {\n        if lst1[i] > lst2[i] {\n\
    \            result[i] = lst1[i]\n        } else {\n            result[i] = lst2[i]\n\
    \        }\n    }\n    \n    return result\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 34 [running]:\ntesting.tRunner.func1.2({0x5134c0,\
    \ 0xc0001d8000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x5134c0, 0xc0001d8000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.total_match(...)\n\t/tmp/tmpx96bq53w_test.go:33\n\
    command-line-arguments_test.TestTotal_Match(0x0?)\n\t/tmp/tmpx96bq53w_test.go:58\
    \ +0x737\ntesting.tRunner(0xc0001991e0, 0x528dd8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n"
  timestamp: 1660074871
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    len1 := len(lst1)\n    len2 := len(lst2)\n  \
    \  if len1 == len2 {\n        return lst1\n    }\n    if len1 > len2 {\n     \
    \   return lst2\n    }\n    return lst1\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpfab3puaw_test.go:55: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmpfab3puaw_test.go:55:\
    \ expected '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmpfab3puaw_test.go:55: expected '[hI hi hi]', got '[hi admin]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074751
- exit_code: 2
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    \n    if len(lst1) != len(lst2) {\n        return\
    \ nil\n    }\n    \n    result := make([]string, 0)\n    \n    for _, val := range\
    \ lst1 {\n        if lst2 != nil && len(val) >= len(lst2[0]) {\n            result\
    \ := append(result, val)\n        }\n    }\n    \n    return result\n}\n\nfunc\
    \ TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{}, []string{}), expected: []string{} },\n \
    \    { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    }), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvl00ia_l_test.go:32:13: result declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074871
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    lst1Len := len(lst1)\n    lst2Len := len(lst2)\n\
    \    if lst1Len == 0 || lst2Len == 0 {\n        return lst1\n    }\n    if lst1Len\
    \ > lst2Len {\n        lst1, lst2 = lst2, lst1\n        lst1Len, lst2Len = lst2Len,\
    \ lst1Len\n    }\n    \n    result := make([]string, lst1Len)\n    \n    for i\
    \ := 0; i < lst1Len; i++ {\n        total := 0\n        for j := 0; j < lst2Len;\
    \ j++ {\n            if lst1[i] < lst2[j] {\n                total++\n       \
    \     }\n        }\n        if total == lst2Len {\n            result[i] = lst1[i]\n\
    \        }\n    }\n    \n    return result\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpyoz7ubb0_test.go:71: expected '[hi hi]', got '[ admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpyoz7ubb0_test.go:71:\
    \ expected '[hi admin]', got '[ ]'\n    --- FAIL: TestTotal_Match/test_num__3\
    \ (0.00s)\n        tmpyoz7ubb0_test.go:71: expected '[4]', got '[]'\n    --- FAIL:\
    \ TestTotal_Match/test_num__4 (0.00s)\n        tmpyoz7ubb0_test.go:71: expected\
    \ '[hI Hi]', got '[ ]'\n    --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n  \
    \      tmpyoz7ubb0_test.go:71: expected '[hI hi hi]', got '[ admin]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__6 (0.00s)\n        tmpyoz7ubb0_test.go:71: expected\
    \ '[hi admin]', got '[ admin]'\n    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n\
    \        tmpyoz7ubb0_test.go:71: expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074871
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return nil\n\
    \    }\n    \n    result := make([]string, len(lst1))\n    for i := 0; i < len(lst1);\
    \ i++ {\n        result[i] = lst1[i]\n    }\n    \n    for i := 0; i < len(lst1);\
    \ i++ {\n        if lst1[i] != lst2[i] {\n            break\n        }\n    }\n\
    \    \n    for i := 0; i < len(lst1); i++ {\n        if lst1[i] != lst2[i] {\n\
    \            result[i] = lst1[i]\n        }\n    }\n    \n    return result\n\
    }\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{}, []string{}), expected: []string{}\
    \ },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpnxt3tixt_test.go:68: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpnxt3tixt_test.go:68:\
    \ expected '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpnxt3tixt_test.go:68: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpnxt3tixt_test.go:68: expected '[hI Hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpnxt3tixt_test.go:68:\
    \ expected '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpnxt3tixt_test.go:68: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074871
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    len1 := len(lst1)\n    len2 := len(lst2)\n  \
    \  if len1 == len2 {\n        return lst1\n    }\n    if len1 > len2 {\n     \
    \   len1, len2 = len2, len1\n    }\n    result := make([]string, len1)\n    for\
    \ i := 0; i < len1; i++ {\n        result[i] = lst1[i]\n    }\n    for i := 0;\
    \ i < len2; i++ {\n        j := i\n        for j < len1 && lst1[j] == lst2[i]\
    \ {\n            j++\n        }\n        if j == len1 {\n            result[i]\
    \ = lst2[i]\n        }\n    }\n    return result\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\npanic: runtime error: index out of range\
    \ [2] with length 2 [recovered]\n\tpanic: runtime error: index out of range [2]\
    \ with length 2\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513700,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513700, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.total_match({0xc0000e2040?, 0x2, 0x450329?},\
    \ {0xc0000f5db0, 0x4, 0x0?})\n\t/tmp/tmp9phxnlnb_test.go:41 +0x238\ncommand-line-arguments_test.TestTotal_Match(0x0?)\n\
    \t/tmp/tmp9phxnlnb_test.go:56 +0x1f0\ntesting.tRunner(0xc0001924e0, 0x529040)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074860
- exit_code: 2
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return nil\n\
    \    }\n    \n    result := make([]string, len(lst1))\n    \n    for i := 0; i\
    \ < len(lst1); i++ {\n        total := 0\n        for j := 0; j < len(lst2); j++\
    \ {\n            total += lst1[i]\n            if total > lst2[j] {\n        \
    \        break\n            }\n        }\n        result[i] = total\n    }\n \
    \   \n    return result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpp8_07xp9_test.go:32:13: invalid operation: total += lst1[i] (mismatched
    types int and string)

    /tmp/tmpp8_07xp9_test.go:33:24: invalid operation: total > lst2[j] (mismatched
    types int and string)

    /tmp/tmpp8_07xp9_test.go:37:21: cannot use total (variable of type int) as type
    string in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074871
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return nil\n\
    \    }\n    \n    result := make([]string, len(lst1))\n    for i := 0; i < len(lst1);\
    \ i++ {\n        if lst1[i] < lst2[i] {\n            result[i] = lst1[i]\n   \
    \     } else {\n            result[i] = lst2[i]\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmph2erqzno_test.go:59: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmph2erqzno_test.go:59:\
    \ expected '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmph2erqzno_test.go:59: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmph2erqzno_test.go:59: expected '[hI hi hi]', got '[]'\n \
    \   --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n        tmph2erqzno_test.go:59:\
    \ expected '[hi admin]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074754
- exit_code: 2
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    lst3 := make([]string, 0)\n    for _, val :=\
    \ range lst1 {\n        if !contains(lst2, val) {\n            lst3 = append(lst3,\
    \ val)\n        }\n    }\n    return lst3\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpwt2tglnu_test.go:25:13: undefined: contains

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074750
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    lst3 := make([]string, 0)\n    if len(lst1) !=\
    \ len(lst2) {\n        return lst3\n    }\n    for _, v := range lst1 {\n    \
    \    if lst2 != nil {\n            for _, v1 := range lst2 {\n               \
    \ if v == v1 {\n                    lst3 = append(lst3, v)\n                 \
    \   break\n                }\n            }\n        }\n    }\n    return lst3\n\
    }\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{}, []string{}), expected: []string{}\
    \ },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpw9_6kcru_test.go:61: expected '[hi hi]', got '[hi]'\n  \
    \  --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpw9_6kcru_test.go:61:\
    \ expected '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpw9_6kcru_test.go:61: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpw9_6kcru_test.go:61: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpw9_6kcru_test.go:61: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpw9_6kcru_test.go:61: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074871
- exit_code: 2
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    \n    if len(lst1) == 0 || len(lst2) == 0 {\n\
    \        return []string{}\n    }\n    \n    result := []string{}\n    \n    for\
    \ _, str1 := range lst1 {\n        \n        for _, str2 := range lst2 {\n   \
    \         \n            if str1 == str2 {\n                \n                continue\n\
    \            }\n            \n            charCount := 0\n            \n     \
    \       for _, char := range str1 {\n                \n                charCount\
    \ += char\n            }\n            \n            for _, char := range str2\
    \ {\n                \n                charCount += char\n            }\n    \
    \        \n            if charCount > len(str1) {\n                \n        \
    \        break\n            }\n            \n            if charCount < len(str2)\
    \ {\n                \n                break\n            }\n            \n  \
    \          result = append(result, str1)\n        }\n    }\n    \n    return result\n\
    }\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{}, []string{}), expected: []string{}\
    \ },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpwrys5a_c_test.go:43:17: invalid operation: charCount += char (mismatched
    types int and rune)

    /tmp/tmpwrys5a_c_test.go:48:17: invalid operation: charCount += char (mismatched
    types int and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074871
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    lst3 := make([]string, len(lst1))\n    \n   \
    \ for i := 0; i < len(lst1); i++ {\n        lst3[i] = lst1[i]\n    }\n    \n \
    \   for i := 0; i < len(lst2); i++ {\n        lst3[i] = lst3[i] + lst2[i]\n  \
    \  }\n    \n    lst4 := make([]string, len(lst1))\n    \n    for i := 0; i < len(lst1);\
    \ i++ {\n        lst4[i] = lst3[i]\n    }\n    \n    return lst4\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\npanic: runtime error: index out of range\
    \ [2] with length 2 [recovered]\n\tpanic: runtime error: index out of range [2]\
    \ with length 2\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.total_match(...)\n\t/tmp/tmp1p6x4pm8_test.go:30\n\
    command-line-arguments_test.TestTotal_Match(0x0?)\n\t/tmp/tmp1p6x4pm8_test.go:51\
    \ +0xbb9\ntesting.tRunner(0xc0001a0340, 0x528d58)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074860
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return nil\n\
    \    }\n    \n    result := []string{}\n    \n    for _, str1 := range lst1 {\n\
    \        found := false\n        for _, str2 := range lst2 {\n            if str1\
    \ == str2 {\n                found = true\n                break\n           \
    \ }\n        }\n        if !found {\n            result = append(result, str1)\n\
    \        }\n    }\n    \n    return result\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp_b5mun_k_test.go:66: expected '[hi hi]', got '[admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmp_b5mun_k_test.go:66:\
    \ expected '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmp_b5mun_k_test.go:66: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmp_b5mun_k_test.go:66: expected '[hI Hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmp_b5mun_k_test.go:66:\
    \ expected '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmp_b5mun_k_test.go:66: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074871
