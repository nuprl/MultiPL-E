language: go_test.go
name: HumanEval_123_get_odd_collatz
results:
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := make([]int, 0)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, n)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    \nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11,\
    \ 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual:\
    \ candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected:\
    \ []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvap_jo7i_test.go:74:6: expected ''('', found TestGet_Odd_Collatz

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074298
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := []int{}\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, n)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11,\
    \ 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual:\
    \ candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected:\
    \ []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpagn925m6_test.go:74:6: expected ''('', found TestGet_Odd_Collatz

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074298
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := make([]int, 0)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, n)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    \nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11,\
    \ 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual:\
    \ candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected:\
    \ []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvap_jo7i_test.go:74:6: expected ''('', found TestGet_Odd_Collatz

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074298
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := []int{}\n    odd_list = append(odd_list, 1)\n\
    \    for i := 2; i <= n; i++ {\n        if odd_list[i-1]%2 == 0 {\n          \
    \  odd_list[i] = odd_list[i-1]/2\n        } else {\n            odd_list[i] =\
    \ 3*odd_list[i-1] + 1\n        }\n    }\n    return odd_list\n}\n\nfunc TestGet_Odd_Collatz(t\
    \ *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5),\
    \ expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3,\
    \ 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\npanic: runtime error: index out\
    \ of range [1] with length 1 [recovered]\n\tpanic: runtime error: index out of\
    \ range [1] with length 1\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513760,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513760, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.get_odd_collatz(...)\n\t/tmp/tmpe6bdxd85_test.go:25\n\
    command-line-arguments_test.TestGet_Odd_Collatz(0x0?)\n\t/tmp/tmpe6bdxd85_test.go:41\
    \ +0x5fd\ntesting.tRunner(0xc0000da340, 0x529088)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074299
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := make([]int, 0)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    \nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11,\
    \ 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual:\
    \ candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected:\
    \ []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpmkk49utj_test.go:74:6: expected ''('', found TestGet_Odd_Collatz

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074298
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    var odd_list []int\n    odd_list = append(odd_list, 1)\n \
    \   for i := 2; i <= n; i++ {\n        if odd_list[i-1]%2 == 0 {\n           \
    \ odd_list[i-1] = odd_list[i-1]/2\n        } else {\n            odd_list[i-1]\
    \ = odd_list[i-1]*3 + 1 \n        }\n    }\n    return odd_list\n}\n\nfunc TestGet_Odd_Collatz(t\
    \ *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5),\
    \ expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3,\
    \ 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\npanic: runtime error: index out\
    \ of range [1] with length 1 [recovered]\n\tpanic: runtime error: index out of\
    \ range [1] with length 1\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513760,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513760, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.get_odd_collatz(...)\n\t/tmp/tmp8kzs3257_test.go:25\n\
    command-line-arguments_test.TestGet_Odd_Collatz(0x0?)\n\t/tmp/tmp8kzs3257_test.go:41\
    \ +0x570\ntesting.tRunner(0xc0000cc680, 0x529088)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074438
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := make([]int, 0)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    \nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11,\
    \ 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual:\
    \ candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected:\
    \ []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpmkk49utj_test.go:74:6: expected ''('', found TestGet_Odd_Collatz

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074298
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := []int{}\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, n)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11,\
    \ 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual:\
    \ candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected:\
    \ []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpagn925m6_test.go:74:6: expected ''('', found TestGet_Odd_Collatz

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074298
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := make([]int, 0)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, n)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    \nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11,\
    \ 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual:\
    \ candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected:\
    \ []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvap_jo7i_test.go:74:6: expected ''('', found TestGet_Odd_Collatz

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074298
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := make([]int, 0)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, n)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    \nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11,\
    \ 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual:\
    \ candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected:\
    \ []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvap_jo7i_test.go:74:6: expected ''('', found TestGet_Odd_Collatz

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074298
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := make([]int, 0)\n    odd_list = append(odd_list,\
    \ 1)\n    for i := 2; i <= n; i++ {\n        if odd_list[i-1]%2 == 0 {\n     \
    \       odd_list[i] = odd_list[i-1]/2\n        } else {\n            odd_list[i]\
    \ = 3*odd_list[i-1]+1\n        }\n    }\n    return odd_list\n}\n\nfunc TestGet_Odd_Collatz(t\
    \ *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5),\
    \ expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3,\
    \ 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\npanic: runtime error: index out\
    \ of range [1] with length 1 [recovered]\n\tpanic: runtime error: index out of\
    \ range [1] with length 1\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513760,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513760, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.get_odd_collatz(...)\n\t/tmp/tmpjuqwyu6r_test.go:25\n\
    command-line-arguments_test.TestGet_Odd_Collatz(0x0?)\n\t/tmp/tmpjuqwyu6r_test.go:41\
    \ +0x632\ntesting.tRunner(0xc0000da340, 0x529088)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074304
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := make([]int, 0)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, n)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    \nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11,\
    \ 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual:\
    \ candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected:\
    \ []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvap_jo7i_test.go:74:6: expected ''('', found TestGet_Odd_Collatz

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074298
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := make([]int, 0)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, n)\n    for i := 2; i < n; i++ {\n     \
    \   if odd_list[i-1]%2 == 0 {\n            odd_list[i] = odd_list[i-1]/2\n   \
    \     } else {\n            odd_list[i] = 3*odd_list[i-1]+1\n        }\n    }\n\
    \    return odd_list\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate\
    \ := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected:\
    \ []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1,\
    \ 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual:\
    \ candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\npanic: runtime error: index out\
    \ of range [2] with length 2 [recovered]\n\tpanic: runtime error: index out of\
    \ range [2] with length 2\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2({0x513760,\
    \ 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513760, 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.get_odd_collatz(...)\n\t/tmp/tmprqqgjtrf_test.go:27\n\
    command-line-arguments_test.TestGet_Odd_Collatz(0x0?)\n\t/tmp/tmprqqgjtrf_test.go:42\
    \ +0x71c\ntesting.tRunner(0xc0001036c0, 0x529088)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n"
  timestamp: 1660074301
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := []int{}\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, n)\n    for i := 2; i < n; i++ {\n        if\
    \ odd_list[i-1]%2 == 0 {\n            odd_list[i] = odd_list[i-1]/2\n        }\
    \ else {\n            odd_list[i] = 3*odd_list[i-1]+1\n        }\n    }\n    return\
    \ odd_list\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11,\
    \ 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual:\
    \ candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected:\
    \ []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\npanic: runtime error: index out\
    \ of range [2] with length 2 [recovered]\n\tpanic: runtime error: index out of\
    \ range [2] with length 2\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513760,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513760, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.get_odd_collatz(...)\n\t/tmp/tmpu88zkfuv_test.go:27\n\
    command-line-arguments_test.TestGet_Odd_Collatz(0x0?)\n\t/tmp/tmpu88zkfuv_test.go:42\
    \ +0x6dc\ntesting.tRunner(0xc0000da340, 0x529088)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074304
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    if n < 2 {\n        return []int{n}\n    }\n    odd_list :=\
    \ []int{}\n    odd_list = append(odd_list, n)\n    for i := 1; i <= n; i++ {\n\
    \        if n%2 == 0 {\n            odd_list = append(odd_list, n/2)\n       \
    \ }\n        n = n//2\n    }\n    return odd_list\n}\n\nfunc TestGet_Odd_Collatz(t\
    \ *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5),\
    \ expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3,\
    \ 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0\
    \ (0.00s)\n        tmpl4blu8r6_test.go:52: expected '[%!s(int=1) %!s(int=5) %!s(int=7)\
    \ %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=14) %!s(int=7) %!s(int=7)\
    \ %!s(int=7) %!s(int=7) %!s(int=7) %!s(int=7) %!s(int=7) %!s(int=7) %!s(int=7)\
    \ %!s(int=7) %!s(int=7) %!s(int=7) %!s(int=7) %!s(int=7)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1\
    \ (0.00s)\n        tmpl4blu8r6_test.go:52: expected '[%!s(int=1) %!s(int=5)]',\
    \ got '[%!s(int=5)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n\
    \        tmpl4blu8r6_test.go:52: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]',\
    \ got '[%!s(int=12) %!s(int=6) %!s(int=6) %!s(int=6) %!s(int=6) %!s(int=6) %!s(int=6)\
    \ %!s(int=6) %!s(int=6) %!s(int=6) %!s(int=6) %!s(int=6) %!s(int=6)]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074438
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    var odd_list []int\n    odd_list = append(odd_list, 1)\n \
    \   odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate\
    \ := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected:\
    \ []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1,\
    \ 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual:\
    \ candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp1ux7figv_test.go:74:6: expected ''('', found TestGet_Odd_Collatz

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074304
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := make([]int, 0)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, n)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    \nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11,\
    \ 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual:\
    \ candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected:\
    \ []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvap_jo7i_test.go:74:6: expected ''('', found TestGet_Odd_Collatz

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074298
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := make([]int, 0)\n    odd_list = append(odd_list,\
    \ n)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    \nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11,\
    \ 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual:\
    \ candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected:\
    \ []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp3ndub0ke_test.go:74:6: expected ''('', found TestGet_Odd_Collatz

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074298
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := make([]int, 0)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, n)\n    for i := 2; i < n; i++ {\n     \
    \   if odd_list[i-1]%2 == 0 {\n            odd_list[i] = odd_list[i-1]/2\n   \
    \     } else {\n            odd_list[i] = odd_list[i-1]*3 + 1 \n        }\n  \
    \  }\n    return odd_list\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate\
    \ := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected:\
    \ []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1,\
    \ 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual:\
    \ candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\npanic: runtime error: index out\
    \ of range [2] with length 2 [recovered]\n\tpanic: runtime error: index out of\
    \ range [2] with length 2\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2({0x513760,\
    \ 0xc0001ce000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513760, 0xc0001ce000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.get_odd_collatz(...)\n\t/tmp/tmphwz1msx__test.go:27\n\
    command-line-arguments_test.TestGet_Odd_Collatz(0x0?)\n\t/tmp/tmphwz1msx__test.go:42\
    \ +0x71c\ntesting.tRunner(0xc00019b1e0, 0x529088)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074299
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := []int{}\n    odd_list = append(odd_list, n)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11,\
    \ 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual:\
    \ candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected:\
    \ []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpp9791e82_test.go:74:6: expected ''('', found TestGet_Odd_Collatz

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074303
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := make([]int, 0)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    \nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11,\
    \ 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual:\
    \ candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected:\
    \ []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpmkk49utj_test.go:74:6: expected ''('', found TestGet_Odd_Collatz

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074298
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := []int{}\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11,\
    \ 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual:\
    \ candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected:\
    \ []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvumfz2oq_test.go:74:6: expected ''('', found TestGet_Odd_Collatz

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074437
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := []int{}\n    odd_list = append(odd_list, 1)\n\
    \    for i := 2; i <= n; i++ {\n        if i%2 == 0 {\n            odd_list =\
    \ append(odd_list, i*2)\n        } else {\n            odd_list = append(odd_list,\
    \ i*2+3)\n        }\n    }\n    return odd_list\n}\n\nfunc TestGet_Odd_Collatz(t\
    \ *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5),\
    \ expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3,\
    \ 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0\
    \ (0.00s)\n        tmp0ojeejx4_test.go:50: expected '[%!s(int=1) %!s(int=5) %!s(int=7)\
    \ %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=1) %!s(int=4) %!s(int=9)\
    \ %!s(int=8) %!s(int=13) %!s(int=12) %!s(int=17) %!s(int=16) %!s(int=21) %!s(int=20)\
    \ %!s(int=25) %!s(int=24) %!s(int=29) %!s(int=28)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1\
    \ (0.00s)\n        tmp0ojeejx4_test.go:50: expected '[%!s(int=1) %!s(int=5)]',\
    \ got '[%!s(int=1) %!s(int=4) %!s(int=9) %!s(int=8) %!s(int=13)]'\n    --- FAIL:\
    \ TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmp0ojeejx4_test.go:50: expected\
    \ '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=1) %!s(int=4) %!s(int=9)\
    \ %!s(int=8) %!s(int=13) %!s(int=12) %!s(int=17) %!s(int=16) %!s(int=21) %!s(int=20)\
    \ %!s(int=25) %!s(int=24)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074299
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := make([]int, 0)\n    odd_list = append(odd_list,\
    \ n)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    \nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11,\
    \ 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual:\
    \ candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected:\
    \ []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp3ndub0ke_test.go:74:6: expected ''('', found TestGet_Odd_Collatz

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074298
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := make([]int, 0)\n    odd_list = append(odd_list,\
    \ 1)\n    for i := 2; i <= n; i++ {\n        if odd_list[i-1]%2 == 0 {\n     \
    \       odd_list[i] = odd_list[i-1]/2\n        } else {\n            odd_list[i]\
    \ = 3*odd_list[i-1]+1\n        }\n    }\n    return odd_list\n}\n\nfunc TestGet_Odd_Collatz(t\
    \ *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5),\
    \ expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3,\
    \ 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\npanic: runtime error: index out\
    \ of range [1] with length 1 [recovered]\n\tpanic: runtime error: index out of\
    \ range [1] with length 1\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513760,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513760, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.get_odd_collatz(...)\n\t/tmp/tmpjuqwyu6r_test.go:25\n\
    command-line-arguments_test.TestGet_Odd_Collatz(0x0?)\n\t/tmp/tmpjuqwyu6r_test.go:41\
    \ +0x632\ntesting.tRunner(0xc0000da340, 0x529088)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074304
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := make([]int, 0)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, n)\n    for i := 2; i < n; i++ {\n     \
    \   if odd_list[i-1]%2 == 0 {\n            odd_list[i] = odd_list[i-1]/2\n   \
    \     } else {\n            odd_list[i] = odd_list[i-1]*3 + 1 \n        }\n  \
    \  }\n    return odd_list\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate\
    \ := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected:\
    \ []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1,\
    \ 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual:\
    \ candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\npanic: runtime error: index out\
    \ of range [2] with length 2 [recovered]\n\tpanic: runtime error: index out of\
    \ range [2] with length 2\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2({0x513760,\
    \ 0xc0001ce000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513760, 0xc0001ce000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.get_odd_collatz(...)\n\t/tmp/tmphwz1msx__test.go:27\n\
    command-line-arguments_test.TestGet_Odd_Collatz(0x0?)\n\t/tmp/tmphwz1msx__test.go:42\
    \ +0x71c\ntesting.tRunner(0xc00019b1e0, 0x529088)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074299
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := make([]int, 0)\n    odd_list = append(odd_list,\
    \ n)\n    odd_list = append(odd_list, 1)\n    for i := 2; i < n; i++ {\n     \
    \   if odd_list[i] % 2 == 0 {\n            odd_list[i] = odd_list[i]/2\n     \
    \   } else {\n            odd_list[i] = odd_list[i] * 3 + 1 \n        }\n    }\n\
    \    return odd_list\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate\
    \ := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected:\
    \ []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1,\
    \ 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual:\
    \ candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\npanic: runtime error: index out\
    \ of range [2] with length 2 [recovered]\n\tpanic: runtime error: index out of\
    \ range [2] with length 2\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2({0x513760,\
    \ 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513760, 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.get_odd_collatz(...)\n\t/tmp/tmpmnvaz0ju_test.go:26\n\
    command-line-arguments_test.TestGet_Odd_Collatz(0x0?)\n\t/tmp/tmpmnvaz0ju_test.go:42\
    \ +0x6a5\ntesting.tRunner(0xc0001031e0, 0x529088)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074438
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := []int{}\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, n)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11,\
    \ 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual:\
    \ candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected:\
    \ []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpagn925m6_test.go:74:6: expected ''('', found TestGet_Odd_Collatz

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074298
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    var odd_list []int\n    odd_list = append(odd_list, 1)\n \
    \   for i := 2; i <= n; i++ {\n        if i%2 == 0 {\n            odd_list = append(odd_list,\
    \ i*2)\n        } else {\n            odd_list = append(odd_list, i*2+3)\n   \
    \     }\n    }\n    return odd_list\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T)\
    \ {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14),\
    \ expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected:\
    \ []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n\
    \     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0\
    \ (0.00s)\n        tmph34sx2_4_test.go:50: expected '[%!s(int=1) %!s(int=5) %!s(int=7)\
    \ %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=1) %!s(int=4) %!s(int=9)\
    \ %!s(int=8) %!s(int=13) %!s(int=12) %!s(int=17) %!s(int=16) %!s(int=21) %!s(int=20)\
    \ %!s(int=25) %!s(int=24) %!s(int=29) %!s(int=28)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1\
    \ (0.00s)\n        tmph34sx2_4_test.go:50: expected '[%!s(int=1) %!s(int=5)]',\
    \ got '[%!s(int=1) %!s(int=4) %!s(int=9) %!s(int=8) %!s(int=13)]'\n    --- FAIL:\
    \ TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmph34sx2_4_test.go:50: expected\
    \ '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=1) %!s(int=4) %!s(int=9)\
    \ %!s(int=8) %!s(int=13) %!s(int=12) %!s(int=17) %!s(int=16) %!s(int=21) %!s(int=20)\
    \ %!s(int=25) %!s(int=24)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074299
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := []int{}\n    odd_list = append(odd_list, n)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11,\
    \ 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual:\
    \ candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected:\
    \ []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpp9791e82_test.go:74:6: expected ''('', found TestGet_Odd_Collatz

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074303
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := []int{}\n    if n%2 == 0 {\n        odd_list =\
    \ append(odd_list, n)\n    }\n    for i := 3; i <= n; i++ {\n        if n%i ==\
    \ 0 {\n            odd_list = append(odd_list, i)\n        }\n    }\n    return\
    \ odd_list\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11,\
    \ 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual:\
    \ candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected:\
    \ []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0\
    \ (0.00s)\n        tmphka0j6vp_test.go:50: expected '[%!s(int=1) %!s(int=5) %!s(int=7)\
    \ %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=14) %!s(int=7) %!s(int=14)]'\n\
    \    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmphka0j6vp_test.go:50:\
    \ expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=5)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2\
    \ (0.00s)\n        tmphka0j6vp_test.go:50: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]',\
    \ got '[%!s(int=12) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=12)]'\n    --- FAIL:\
    \ TestGet_Odd_Collatz/test_num__3 (0.00s)\n        tmphka0j6vp_test.go:50: expected\
    \ '[%!s(int=1)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074304
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    if n < 1 {\n        return []int{}\n    }\n    odd_list :=\
    \ []int{}\n    odd_list = append(odd_list, n)\n    odd_list = append(odd_list,\
    \ get_odd_collatz(n/2))\n    odd_list = append(odd_list, get_odd_collatz(n/3))\n\
    \    odd_list = append(odd_list, get_odd_collatz(n/4))\n    odd_list = append(odd_list,\
    \ get_odd_collatz(n/5))\n    odd_list = append(odd_list, get_odd_collatz(n/6))\n\
    \    odd_list = append(odd_list, get_odd_collatz(n/7))\n    odd_list = append(odd_list,\
    \ get_odd_collatz(n/8))\n    odd_list = append(odd_list, get_odd_collatz(n/9))\n\
    \    odd_list = append(odd_list, get_odd_collatz(n/10))\n    odd_list = append(odd_list,\
    \ get_odd_collatz(n/11))\n    odd_list = append(odd_list, get_odd_collatz(n/12))\n\
    \    odd_list = append(odd_list, get_odd_collatz(n/13))\n    odd_list = append(odd_list,\
    \ get_odd_collatz(n/14))\n    odd_list = append(odd_list, get_odd_collatz(n/15))\n\
    \    odd_list = append(odd_list, get_odd_collatz(n/16))\n    odd_list = append(odd_list,\
    \ get_odd_collatz(n/17))\n    odd_list = append(odd_list, get_odd_collatz(n/18))\n\
    \    odd_list = append(odd_list, get_odd_collatz(n/19))\n    odd_list = append(odd_list,\
    \ get_odd_collatz(n/20))\n    odd_list = append(odd_list, get_odd_collatz(n/21))\n\
    \    odd_list = append(odd_list, get_odd_collatz(n/22))\n    odd_list = append(odd_list,\
    \ get_odd_collatz(n/23))\n    odd_list = append(odd_list, get_odd_collatz(n/24))\n\
    \    odd_list = append(odd_list, get_odd_collatz(n/25))\n    odd_list = append(odd_list,\
    \ get_odd_collatz(n/26))\n    odd_list = append(odd_list, get_odd_collatz(n/27))\n\
    func TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17}\
    \ },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12),\
    \ expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpy7_qzgzc_test.go:53:6: expected ''('', found TestGet_Odd_Collatz

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074437
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := []int{}\n    odd_list = append(odd_list, 1)\n\
    \    for i := 2; i <= n; i++ {\n        if i%2 == 0 {\n            odd_list =\
    \ append(odd_list, i)\n        } else {\n            odd_list = append(odd_list,\
    \ 3*i+1)\n        }\n    }\n    return odd_list\n}\n\nfunc TestGet_Odd_Collatz(t\
    \ *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5),\
    \ expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3,\
    \ 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0\
    \ (0.00s)\n        tmpm9ki4vee_test.go:50: expected '[%!s(int=1) %!s(int=5) %!s(int=7)\
    \ %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=1) %!s(int=2) %!s(int=10)\
    \ %!s(int=4) %!s(int=16) %!s(int=6) %!s(int=22) %!s(int=8) %!s(int=28) %!s(int=10)\
    \ %!s(int=34) %!s(int=12) %!s(int=40) %!s(int=14)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1\
    \ (0.00s)\n        tmpm9ki4vee_test.go:50: expected '[%!s(int=1) %!s(int=5)]',\
    \ got '[%!s(int=1) %!s(int=2) %!s(int=10) %!s(int=4) %!s(int=16)]'\n    --- FAIL:\
    \ TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpm9ki4vee_test.go:50: expected\
    \ '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=1) %!s(int=2) %!s(int=10)\
    \ %!s(int=4) %!s(int=16) %!s(int=6) %!s(int=22) %!s(int=8) %!s(int=28) %!s(int=10)\
    \ %!s(int=34) %!s(int=12)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074438
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := make([]int, 0)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, n)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    \nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11,\
    \ 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual:\
    \ candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected:\
    \ []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvap_jo7i_test.go:74:6: expected ''('', found TestGet_Odd_Collatz

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074298
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := []int{}\n    odd_list = append(odd_list, 1)\n\
    \    for i := 2; i <= n; i++ {\n        if i%2 == 0 {\n            odd_list =\
    \ append(odd_list, i*2)\n        } else {\n            odd_list = append(odd_list,\
    \ i*2+3)\n        }\n    }\n    return odd_list\n}\n\nfunc TestGet_Odd_Collatz(t\
    \ *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5),\
    \ expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3,\
    \ 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0\
    \ (0.00s)\n        tmp0ojeejx4_test.go:50: expected '[%!s(int=1) %!s(int=5) %!s(int=7)\
    \ %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=1) %!s(int=4) %!s(int=9)\
    \ %!s(int=8) %!s(int=13) %!s(int=12) %!s(int=17) %!s(int=16) %!s(int=21) %!s(int=20)\
    \ %!s(int=25) %!s(int=24) %!s(int=29) %!s(int=28)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1\
    \ (0.00s)\n        tmp0ojeejx4_test.go:50: expected '[%!s(int=1) %!s(int=5)]',\
    \ got '[%!s(int=1) %!s(int=4) %!s(int=9) %!s(int=8) %!s(int=13)]'\n    --- FAIL:\
    \ TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmp0ojeejx4_test.go:50: expected\
    \ '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=1) %!s(int=4) %!s(int=9)\
    \ %!s(int=8) %!s(int=13) %!s(int=12) %!s(int=17) %!s(int=16) %!s(int=21) %!s(int=20)\
    \ %!s(int=25) %!s(int=24)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074299
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := make([]int, 0)\n    odd_list = append(odd_list,\
    \ 1)\n    for i := 2; i < n; i++ {\n        if odd_list[i-1]%2 == 0 {\n      \
    \      odd_list[i] = odd_list[i-1]/2\n        } else {\n            odd_list[i]\
    \ = odd_list[i-1]*3 + 1 \n        }\n    }\n    return odd_list\n}\n\nfunc TestGet_Odd_Collatz(t\
    \ *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5),\
    \ expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3,\
    \ 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\npanic: runtime error: index out\
    \ of range [1] with length 1 [recovered]\n\tpanic: runtime error: index out of\
    \ range [1] with length 1\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513760,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513760, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.get_odd_collatz(...)\n\t/tmp/tmp_h2fn39d_test.go:25\n\
    command-line-arguments_test.TestGet_Odd_Collatz(0x0?)\n\t/tmp/tmp_h2fn39d_test.go:41\
    \ +0x632\ntesting.tRunner(0xc0000cc4e0, 0x529088)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074438
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := []int{}\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, n)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11,\
    \ 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual:\
    \ candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected:\
    \ []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpagn925m6_test.go:74:6: expected ''('', found TestGet_Odd_Collatz

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074298
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := []int{}\n    if n%2 == 0 {\n        odd_list =\
    \ append(odd_list, n)\n    }\n    for i := 3; i <= n; i++ {\n        if n%i ==\
    \ 0 {\n            odd_list = append(odd_list, i)\n        }\n    }\n    return\
    \ odd_list\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11,\
    \ 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual:\
    \ candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected:\
    \ []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0\
    \ (0.00s)\n        tmphka0j6vp_test.go:50: expected '[%!s(int=1) %!s(int=5) %!s(int=7)\
    \ %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=14) %!s(int=7) %!s(int=14)]'\n\
    \    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmphka0j6vp_test.go:50:\
    \ expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=5)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2\
    \ (0.00s)\n        tmphka0j6vp_test.go:50: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]',\
    \ got '[%!s(int=12) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=12)]'\n    --- FAIL:\
    \ TestGet_Odd_Collatz/test_num__3 (0.00s)\n        tmphka0j6vp_test.go:50: expected\
    \ '[%!s(int=1)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074304
- exit_code: 2
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := []int{}\n    if n == 1 {\n        return odd_list\n\
    \    }\n    odd_list = append(odd_list, n)\n    odd_list = append(odd_list, get_odd_collatz(n/2)*2)\n\
    \    odd_list = append(odd_list, get_odd_collatz(n/2)*3+1)\n    return odd_list\n\
    }\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11,\
    \ 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual:\
    \ candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected:\
    \ []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp641joa9n_test.go:27:54: cannot convert 2 (untyped int constant) to []int

    /tmp/tmp641joa9n_test.go:28:54: cannot convert 3 (untyped int constant) to []int

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074438
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := make([]int, 0)\n    odd_list = append(odd_list,\
    \ 1)\n    for i := 2; i < n; i++ {\n        if odd_list[i-1]%2 == 0 {\n      \
    \      odd_list[i] = odd_list[i-1]/2\n        } else {\n            odd_list[i]\
    \ = 3*odd_list[i-1]+1\n        }\n    }\n    return odd_list\n}\n\nfunc TestGet_Odd_Collatz(t\
    \ *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5),\
    \ expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3,\
    \ 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\npanic: runtime error: index out\
    \ of range [1] with length 1 [recovered]\n\tpanic: runtime error: index out of\
    \ range [1] with length 1\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513760,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513760, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.get_odd_collatz(...)\n\t/tmp/tmpc1jud2es_test.go:25\n\
    command-line-arguments_test.TestGet_Odd_Collatz(0x0?)\n\t/tmp/tmpc1jud2es_test.go:41\
    \ +0x632\ntesting.tRunner(0xc0000da340, 0x529088)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074300
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    if n < 2 {\n        return []int{n}\n    }\n    odd_list :=\
    \ []int{}\n    odd_list = append(odd_list, n)\n    odd_list = append(odd_list,\
    \ get_odd_collatz(n/2))\n    odd_list = append(odd_list, get_odd_collatz(n/3))\n\
    \    odd_list = append(odd_list, get_odd_collatz(n/4))\n    odd_list = append(odd_list,\
    \ get_odd_collatz(n/5))\n    odd_list = append(odd_list, get_odd_collatz(n/6))\n\
    \    odd_list = append(odd_list, get_odd_collatz(n/7))\n    odd_list = append(odd_list,\
    \ get_odd_collatz(n/8))\n    odd_list = append(odd_list, get_odd_collatz(n/9))\n\
    \    odd_list = append(odd_list, get_odd_collatz(n/10))\n    odd_list = append(odd_list,\
    \ get_odd_collatz(n/11))\n    odd_list = append(odd_list, get_odd_collatz(n/12))\n\
    \    odd_list = append(odd_list, get_odd_collatz(n/13))\n    odd_list = append(odd_list,\
    \ get_odd_collatz(n/14))\n    odd_list = append(odd_list, get_odd_collatz(n/15))\n\
    \    odd_list = append(odd_list, get_odd_collatz(n/16))\n    odd_list = append(odd_list,\
    \ get_odd_collatz(n/17))\n    odd_list = append(odd_list, get_odd_collatz(n/18))\n\
    \    odd_list = append(odd_list, get_odd_collatz(n/19))\n    odd_list = append(odd_list,\
    \ get_odd_collatz(n/20))\n    odd_list = append(odd_list, get_odd_collatz(n/21))\n\
    \    odd_list = append(odd_list, get_odd_collatz(n/22))\n    odd_list = append(odd_list,\
    \ get_odd_collatz(n/23))\n    odd_list = append(odd_list, get_odd_collatz(n/24))\n\
    \    odd_list = append(odd_list, get_odd_collatz(n/25))\n    odd_list = append(odd_list,\
    \ get_odd_collatz(n/26))\n    odd_list = append(odd_list, get_odd_collatz(n/\n\
    func TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17}\
    \ },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12),\
    \ expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpr5jixww7_test.go:53:6: expected ''('', found TestGet_Odd_Collatz

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074298
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := make([]int, 0)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, n)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    \nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11,\
    \ 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual:\
    \ candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected:\
    \ []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvap_jo7i_test.go:74:6: expected ''('', found TestGet_Odd_Collatz

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074298
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    if n < 2 {\n        return []int{n}\n    }\n    odd_list :=\
    \ []int{}\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ get_odd_collatz(n/2))\n    odd_list = append(odd_list, get_odd_collatz(n/3))\n\
    \    odd_list = append(odd_list, get_odd_collatz(n/4))\n    odd_list = append(odd_list,\
    \ get_odd_collatz(n/5))\n    odd_list = append(odd_list, get_odd_collatz(n/6))\n\
    \    odd_list = append(odd_list, get_odd_collatz(n/7))\n    odd_list = append(odd_list,\
    \ get_odd_collatz(n/8))\n    odd_list = append(odd_list, get_odd_collatz(n/9))\n\
    \    odd_list = append(odd_list, get_odd_collatz(n/10))\n    odd_list = append(odd_list,\
    \ get_odd_collatz(n/11))\n    odd_list = append(odd_list, get_odd_collatz(n/12))\n\
    \    odd_list = append(odd_list, get_odd_collatz(n/13))\n    odd_list = append(odd_list,\
    \ get_odd_collatz(n/14))\n    odd_list = append(odd_list, get_odd_collatz(n/15))\n\
    \    odd_list = append(odd_list, get_odd_collatz(n/16))\n    odd_list = append(odd_list,\
    \ get_odd_collatz(n/17))\n    odd_list = append(odd_list, get_odd_collatz(n/18))\n\
    \    odd_list = append(odd_list, get_odd_collatz(n/19))\n    odd_list = append(odd_list,\
    \ get_odd_collatz(n/20))\n    odd_list = append(odd_list, get_odd_collatz(n/21))\n\
    \    odd_list = append(odd_list, get_odd_collatz(n/22))\n    odd_list = append(odd_list,\
    \ get_odd_collatz(n/23))\n    odd_list = append(odd_list, get_odd_collatz(n/24))\n\
    \    odd_list = append(odd_list, get_odd_collatz(n/25))\n    odd_list = append(odd_list,\
    \ get_odd_collatz(n/26))\n    odd_list = append(odd_list, get_odd_collatz(n/\n\
    func TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17}\
    \ },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12),\
    \ expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpaz4txxen_test.go:53:6: expected ''('', found TestGet_Odd_Collatz

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074437
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := make([]int, 0)\n    odd_list = append(odd_list,\
    \ 1)\n    for i := 2; i <= n; i++ {\n        if i%2 == 0 {\n            odd_list\
    \ = append(odd_list, 3*i+1)\n        } else {\n            odd_list = append(odd_list,\
    \ 3*i)\n        }\n    }\n    return odd_list\n}\n\nfunc TestGet_Odd_Collatz(t\
    \ *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5),\
    \ expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3,\
    \ 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0\
    \ (0.00s)\n        tmpbg2eoj65_test.go:50: expected '[%!s(int=1) %!s(int=5) %!s(int=7)\
    \ %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=1) %!s(int=7) %!s(int=9)\
    \ %!s(int=13) %!s(int=15) %!s(int=19) %!s(int=21) %!s(int=25) %!s(int=27) %!s(int=31)\
    \ %!s(int=33) %!s(int=37) %!s(int=39) %!s(int=43)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1\
    \ (0.00s)\n        tmpbg2eoj65_test.go:50: expected '[%!s(int=1) %!s(int=5)]',\
    \ got '[%!s(int=1) %!s(int=7) %!s(int=9) %!s(int=13) %!s(int=15)]'\n    --- FAIL:\
    \ TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpbg2eoj65_test.go:50: expected\
    \ '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=1) %!s(int=7) %!s(int=9)\
    \ %!s(int=13) %!s(int=15) %!s(int=19) %!s(int=21) %!s(int=25) %!s(int=27) %!s(int=31)\
    \ %!s(int=33) %!s(int=37)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074302
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := make([]int, 0)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, n)\n    for i := 2; i < n; i++ {\n     \
    \   if odd_list[i] % 2 == 0 {\n            odd_list[i] = odd_list[i] / 2\n   \
    \         odd_list = append(odd_list, odd_list[i]*2)\n        } else {\n     \
    \       odd_list[i] = odd_list[i] * 3 + 1 \n            odd_list = append(odd_list,\
    \ odd_list[i])\n        }\n    }\n    return odd_list\n}\n\nfunc TestGet_Odd_Collatz(t\
    \ *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5),\
    \ expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3,\
    \ 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\npanic: runtime error: index out\
    \ of range [2] with length 2 [recovered]\n\tpanic: runtime error: index out of\
    \ range [2] with length 2\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2({0x513760,\
    \ 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513760, 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.get_odd_collatz(...)\n\t/tmp/tmpoyjsnnng_test.go:26\n\
    command-line-arguments_test.TestGet_Odd_Collatz(0x0?)\n\t/tmp/tmpoyjsnnng_test.go:44\
    \ +0x8a5\ntesting.tRunner(0xc0001031e0, 0x529088)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074302
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := []int{}\n    odd_list = append(odd_list, 1)\n\
    \    for i := 2; i <= n; i++ {\n        if i%2 == 0 {\n            odd_list =\
    \ append(odd_list, i)\n        } else {\n            odd_list = append(odd_list,\
    \ 3*i+1)\n        }\n    }\n    odd_list = append(odd_list, 1)\n    return odd_list\n\
    }\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11,\
    \ 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual:\
    \ candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected:\
    \ []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0\
    \ (0.00s)\n        tmpyv3yu3lt_test.go:51: expected '[%!s(int=1) %!s(int=5) %!s(int=7)\
    \ %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=1) %!s(int=2) %!s(int=10)\
    \ %!s(int=4) %!s(int=16) %!s(int=6) %!s(int=22) %!s(int=8) %!s(int=28) %!s(int=10)\
    \ %!s(int=34) %!s(int=12) %!s(int=40) %!s(int=14) %!s(int=1)]'\n    --- FAIL:\
    \ TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpyv3yu3lt_test.go:51: expected\
    \ '[%!s(int=1) %!s(int=5)]', got '[%!s(int=1) %!s(int=2) %!s(int=10) %!s(int=4)\
    \ %!s(int=16) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n\
    \        tmpyv3yu3lt_test.go:51: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]',\
    \ got '[%!s(int=1) %!s(int=2) %!s(int=10) %!s(int=4) %!s(int=16) %!s(int=6) %!s(int=22)\
    \ %!s(int=8) %!s(int=28) %!s(int=10) %!s(int=34) %!s(int=12) %!s(int=1)]'\n  \
    \  --- FAIL: TestGet_Odd_Collatz/test_num__3 (0.00s)\n        tmpyv3yu3lt_test.go:51:\
    \ expected '[%!s(int=1)]', got '[%!s(int=1) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660074438
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    if n < 2 {\n        return []int{}\n    }\n    odd_list :=\
    \ []int{}\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    for i := 2; i <= n; i++ {\n        if odd_list[i-1]%2 == 0 {\n     \
    \       odd_list[i] = odd_list[i-1]/2\n        } else {\n            odd_list[i]\
    \ = odd_list[i-1]*3+1 \n        }\n    }\n    return odd_list\n}\n\nfunc TestGet_Odd_Collatz(t\
    \ *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5),\
    \ expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3,\
    \ 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\npanic: runtime error: index out\
    \ of range [2] with length 2 [recovered]\n\tpanic: runtime error: index out of\
    \ range [2] with length 2\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513760,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513760, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.get_odd_collatz(...)\n\t/tmp/tmpwhb3zzsz_test.go:32\n\
    command-line-arguments_test.TestGet_Odd_Collatz(0x0?)\n\t/tmp/tmpwhb3zzsz_test.go:45\
    \ +0x647\ntesting.tRunner(0xc0000da340, 0x529088)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074438
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := []int{}\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, n)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11,\
    \ 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual:\
    \ candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected:\
    \ []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpagn925m6_test.go:74:6: expected ''('', found TestGet_Odd_Collatz

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074298
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := []int{}\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, n)\n    for i := 2; i < n; i++ {\n        if\
    \ odd_list[i-1]%2 == 0 {\n            odd_list[i] = odd_list[i-1]/2\n        }\
    \ else {\n            odd_list[i] = odd_list[i-1]*3+1 \n        }\n    }\n   \
    \ return odd_list\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate\
    \ := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected:\
    \ []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1,\
    \ 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual:\
    \ candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\npanic: runtime error: index out\
    \ of range [2] with length 2 [recovered]\n\tpanic: runtime error: index out of\
    \ range [2] with length 2\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2({0x513760,\
    \ 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513760, 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.get_odd_collatz(...)\n\t/tmp/tmpypxq71gs_test.go:27\n\
    command-line-arguments_test.TestGet_Odd_Collatz(0x0?)\n\t/tmp/tmpypxq71gs_test.go:42\
    \ +0x6dc\ntesting.tRunner(0xc0001031e0, 0x529088)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074301
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := []int{}\n    odd_list = append(odd_list, 1)\n\
    \    for i := 2; i <= n; i++ {\n        if i%2 == 0 {\n            odd_list =\
    \ append(odd_list, i*2)\n        } else {\n            odd_list = append(odd_list,\
    \ i*2+3)\n        }\n    }\n    return odd_list\n}\n\nfunc TestGet_Odd_Collatz(t\
    \ *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5),\
    \ expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3,\
    \ 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0\
    \ (0.00s)\n        tmp0ojeejx4_test.go:50: expected '[%!s(int=1) %!s(int=5) %!s(int=7)\
    \ %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=1) %!s(int=4) %!s(int=9)\
    \ %!s(int=8) %!s(int=13) %!s(int=12) %!s(int=17) %!s(int=16) %!s(int=21) %!s(int=20)\
    \ %!s(int=25) %!s(int=24) %!s(int=29) %!s(int=28)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1\
    \ (0.00s)\n        tmp0ojeejx4_test.go:50: expected '[%!s(int=1) %!s(int=5)]',\
    \ got '[%!s(int=1) %!s(int=4) %!s(int=9) %!s(int=8) %!s(int=13)]'\n    --- FAIL:\
    \ TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmp0ojeejx4_test.go:50: expected\
    \ '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=1) %!s(int=4) %!s(int=9)\
    \ %!s(int=8) %!s(int=13) %!s(int=12) %!s(int=17) %!s(int=16) %!s(int=21) %!s(int=20)\
    \ %!s(int=25) %!s(int=24)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074299
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := make([]int, 0)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, n)\n    for i := 2; i < n; i++ {\n     \
    \   if odd_list[i] % 2 == 0 {\n            odd_list[i] = odd_list[i] / 2\n   \
    \         odd_list = append(odd_list, odd_list[i]*2)\n        } else {\n     \
    \       odd_list[i] = odd_list[i] * 3 + 1\n            odd_list = append(odd_list,\
    \ odd_list[i])\n        }\n    }\n    return odd_list\n}\n\nfunc TestGet_Odd_Collatz(t\
    \ *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5),\
    \ expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3,\
    \ 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\npanic: runtime error: index out\
    \ of range [2] with length 2 [recovered]\n\tpanic: runtime error: index out of\
    \ range [2] with length 2\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513760,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513760, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.get_odd_collatz(...)\n\t/tmp/tmp6pd011_9_test.go:26\n\
    command-line-arguments_test.TestGet_Odd_Collatz(0x0?)\n\t/tmp/tmp6pd011_9_test.go:44\
    \ +0x8a5\ntesting.tRunner(0xc0000da340, 0x529088)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074299
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := make([]int, 0)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, n)\n    for i := 2; i < n; i++ {\n     \
    \   if odd_list[i-1]%2 == 0 {\n            odd_list[i] = odd_list[i-1]/2\n   \
    \     } else {\n            odd_list[i] = 3*odd_list[i-1] + 1\n        }\n   \
    \ }\n    return odd_list\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate\
    \ := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected:\
    \ []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1,\
    \ 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual:\
    \ candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\npanic: runtime error: index out\
    \ of range [2] with length 2 [recovered]\n\tpanic: runtime error: index out of\
    \ range [2] with length 2\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513760,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513760, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.get_odd_collatz(...)\n\t/tmp/tmpv6gn_zzx_test.go:27\n\
    command-line-arguments_test.TestGet_Odd_Collatz(0x0?)\n\t/tmp/tmpv6gn_zzx_test.go:42\
    \ +0x71c\ntesting.tRunner(0xc0000cc4e0, 0x529088)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074303
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := make([]int, 0)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, n)\n    for i := 2; i < n; i++ {\n     \
    \   if odd_list[i] % 2 == 0 {\n            odd_list[i] = odd_list[i] / 2\n   \
    \         odd_list = append(odd_list, odd_list[i]*2)\n        } else {\n     \
    \       odd_list[i] = odd_list[i] * 3 + 1 \n        }\n    }\n    return odd_list\n\
    }\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11,\
    \ 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual:\
    \ candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected:\
    \ []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\npanic: runtime error: index out\
    \ of range [2] with length 2 [recovered]\n\tpanic: runtime error: index out of\
    \ range [2] with length 2\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2({0x513760,\
    \ 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513760, 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.get_odd_collatz(...)\n\t/tmp/tmpu6chtioc_test.go:26\n\
    command-line-arguments_test.TestGet_Odd_Collatz(0x0?)\n\t/tmp/tmpu6chtioc_test.go:43\
    \ +0x7c5\ntesting.tRunner(0xc000103520, 0x529088)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074299
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := make([]int, 0)\n    odd_list = append(odd_list,\
    \ 1)\n    for i := 2; i <= n; i++ {\n        if odd_list[i-1]%2 == 0 {\n     \
    \       odd_list[i] = odd_list[i-1]/2\n        } else {\n            odd_list[i]\
    \ = 3*odd_list[i-1] + 1\n        }\n    }\n    return odd_list\n}\n\nfunc TestGet_Odd_Collatz(t\
    \ *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5),\
    \ expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3,\
    \ 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\npanic: runtime error: index out\
    \ of range [1] with length 1 [recovered]\n\tpanic: runtime error: index out of\
    \ range [1] with length 1\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513760,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513760, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.get_odd_collatz(...)\n\t/tmp/tmpsg9_2rno_test.go:25\n\
    command-line-arguments_test.TestGet_Odd_Collatz(0x0?)\n\t/tmp/tmpsg9_2rno_test.go:41\
    \ +0x632\ntesting.tRunner(0xc0000da1a0, 0x529088)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074299
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := []int{}\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11,\
    \ 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual:\
    \ candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected:\
    \ []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvumfz2oq_test.go:74:6: expected ''('', found TestGet_Odd_Collatz

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074437
- exit_code: 2
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    if n < 2 {\n        return []int{n}\n    }\n    odd_list :=\
    \ []int{}\n    odd_list = append(odd_list, n)\n    odd_list = append(odd_list,\
    \ get_odd_collatz(n/2)*2)\n    odd_list = append(odd_list, get_odd_collatz(n/2)*2+1)\n\
    \    return odd_list\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate\
    \ := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected:\
    \ []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1,\
    \ 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual:\
    \ candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpss_d5e49_test.go:27:54: cannot convert 2 (untyped int constant) to []int

    /tmp/tmpss_d5e49_test.go:28:54: cannot convert 2 (untyped int constant) to []int

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074304
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := []int{}\n    odd_list = append(odd_list, 1)\n\
    \    for i := 2; i <= n; i++ {\n        if i%2 == 0 {\n            odd_list =\
    \ append(odd_list, i)\n        }\n        if i%2 != 0 {\n            odd_list\
    \ = append(odd_list, i*3+1)\n        }\n    }\n    return odd_list\n}\n\nfunc\
    \ TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17}\
    \ },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12),\
    \ expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0\
    \ (0.00s)\n        tmpyyx2s6yz_test.go:51: expected '[%!s(int=1) %!s(int=5) %!s(int=7)\
    \ %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=1) %!s(int=2) %!s(int=10)\
    \ %!s(int=4) %!s(int=16) %!s(int=6) %!s(int=22) %!s(int=8) %!s(int=28) %!s(int=10)\
    \ %!s(int=34) %!s(int=12) %!s(int=40) %!s(int=14)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1\
    \ (0.00s)\n        tmpyyx2s6yz_test.go:51: expected '[%!s(int=1) %!s(int=5)]',\
    \ got '[%!s(int=1) %!s(int=2) %!s(int=10) %!s(int=4) %!s(int=16)]'\n    --- FAIL:\
    \ TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpyyx2s6yz_test.go:51: expected\
    \ '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=1) %!s(int=2) %!s(int=10)\
    \ %!s(int=4) %!s(int=16) %!s(int=6) %!s(int=22) %!s(int=8) %!s(int=28) %!s(int=10)\
    \ %!s(int=34) %!s(int=12)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074438
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := make([]int, 0)\n    odd_list = append(odd_list,\
    \ 1)\n    for i := 2; i <= n; i++ {\n        if i%2 == 0 {\n            odd_list\
    \ = append(odd_list, i*3)\n        } else {\n            odd_list = append(odd_list,\
    \ i*3+1)\n        }\n    }\n    return odd_list\n}\n\nfunc TestGet_Odd_Collatz(t\
    \ *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5),\
    \ expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3,\
    \ 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0\
    \ (0.00s)\n        tmp2sovfy90_test.go:50: expected '[%!s(int=1) %!s(int=5) %!s(int=7)\
    \ %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=1) %!s(int=6) %!s(int=10)\
    \ %!s(int=12) %!s(int=16) %!s(int=18) %!s(int=22) %!s(int=24) %!s(int=28) %!s(int=30)\
    \ %!s(int=34) %!s(int=36) %!s(int=40) %!s(int=42)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1\
    \ (0.00s)\n        tmp2sovfy90_test.go:50: expected '[%!s(int=1) %!s(int=5)]',\
    \ got '[%!s(int=1) %!s(int=6) %!s(int=10) %!s(int=12) %!s(int=16)]'\n    --- FAIL:\
    \ TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmp2sovfy90_test.go:50: expected\
    \ '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=1) %!s(int=6) %!s(int=10)\
    \ %!s(int=12) %!s(int=16) %!s(int=18) %!s(int=22) %!s(int=24) %!s(int=28) %!s(int=30)\
    \ %!s(int=34) %!s(int=36)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074438
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    var odd_list []int\n    odd_list = append(odd_list, 1)\n \
    \   for i := 2; i <= n; i++ {\n        if i%2 == 0 {\n            odd_list = append(odd_list,\
    \ i*2)\n        } else {\n            odd_list = append(odd_list, i*2+3)\n   \
    \     }\n    }\n    return odd_list\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T)\
    \ {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14),\
    \ expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected:\
    \ []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n\
    \     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0\
    \ (0.00s)\n        tmph34sx2_4_test.go:50: expected '[%!s(int=1) %!s(int=5) %!s(int=7)\
    \ %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=1) %!s(int=4) %!s(int=9)\
    \ %!s(int=8) %!s(int=13) %!s(int=12) %!s(int=17) %!s(int=16) %!s(int=21) %!s(int=20)\
    \ %!s(int=25) %!s(int=24) %!s(int=29) %!s(int=28)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1\
    \ (0.00s)\n        tmph34sx2_4_test.go:50: expected '[%!s(int=1) %!s(int=5)]',\
    \ got '[%!s(int=1) %!s(int=4) %!s(int=9) %!s(int=8) %!s(int=13)]'\n    --- FAIL:\
    \ TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmph34sx2_4_test.go:50: expected\
    \ '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=1) %!s(int=4) %!s(int=9)\
    \ %!s(int=8) %!s(int=13) %!s(int=12) %!s(int=17) %!s(int=16) %!s(int=21) %!s(int=20)\
    \ %!s(int=25) %!s(int=24)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074299
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    if n == 1 {\n        return [1]\n    }\n    odd_list := []int{}\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, get_odd_collatz(n/2))\n\
    \    odd_list = append(odd_list, get_odd_collatz(n/3))\n    odd_list = append(odd_list,\
    \ get_odd_collatz(n/4))\n    odd_list = append(odd_list, get_odd_collatz(n/5))\n\
    \    odd_list = append(odd_list, get_odd_collatz(n/6))\n    odd_list = append(odd_list,\
    \ get_odd_collatz(n/7))\n    odd_list = append(odd_list, get_odd_collatz(n/8))\n\
    \    odd_list = append(odd_list, get_odd_collatz(n/9))\n    odd_list = append(odd_list,\
    \ get_odd_collatz(n/10))\n    odd_list = append(odd_list, get_odd_collatz(n/11))\n\
    \    odd_list = append(odd_list, get_odd_collatz(n/12))\n    odd_list = append(odd_list,\
    \ get_odd_collatz(n/13))\n    odd_list = append(odd_list, get_odd_collatz(n/14))\n\
    \    odd_list = append(odd_list, get_odd_collatz(n/15))\n    odd_list = append(odd_list,\
    \ get_odd_collatz(n/16))\n    odd_list = append(odd_list, get_odd_collatz(n/17))\n\
    \    odd_list = append(odd_list, get_odd_collatz(n/18))\n    odd_list = append(odd_list,\
    \ get_odd_collatz(n/19))\n    odd_list = append(odd_list, get_odd_collatz(n/20))\n\
    \    odd_list = append(odd_list, get_odd_collatz(n/20))\n    odd_list = append(odd_list,\
    \ get_odd_collatz(n/20))\n    odd_list = append(odd_list, get_odd_collatz(n/20))\n\
    \    odd_list = append(odd_list, get_odd_collatz(n/20))\n    odd_list = append(odd_list,\
    \ get_odd_collatz(n/20))\n    odd_list = append(odd_list, get_odd_collatz(n/20))\n\
    \    odd_list = append(odd_list, get_odd_collatz(n/20))\n    odd_list = append(odd_\n\
    func TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17}\
    \ },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12),\
    \ expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp7ywaq_qv_test.go:23:19: expected type, found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074437
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := []int{}\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, n)\n    for i := 2; i < n; i++ {\n        if\
    \ odd_list[i-1]%2 == 0 {\n            odd_list[i] = odd_list[i-1]/2\n        }\
    \ else {\n            odd_list[i] = 3*odd_list[i-1]+1\n        }\n    }\n    return\
    \ odd_list\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11,\
    \ 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual:\
    \ candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected:\
    \ []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\npanic: runtime error: index out\
    \ of range [2] with length 2 [recovered]\n\tpanic: runtime error: index out of\
    \ range [2] with length 2\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513760,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513760, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.get_odd_collatz(...)\n\t/tmp/tmpu88zkfuv_test.go:27\n\
    command-line-arguments_test.TestGet_Odd_Collatz(0x0?)\n\t/tmp/tmpu88zkfuv_test.go:42\
    \ +0x6dc\ntesting.tRunner(0xc0000da340, 0x529088)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074304
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := make([]int, 0)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, n)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    \nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11,\
    \ 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual:\
    \ candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected:\
    \ []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvap_jo7i_test.go:74:6: expected ''('', found TestGet_Odd_Collatz

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074298
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := make([]int, 0)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, n)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    \nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11,\
    \ 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual:\
    \ candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected:\
    \ []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvap_jo7i_test.go:74:6: expected ''('', found TestGet_Odd_Collatz

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074298
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    var odd_list []int\n    odd_list = append(odd_list, 1)\n \
    \   for i := 2; i <= n; i++ {\n        if i%2 == 0 {\n            odd_list = append(odd_list,\
    \ 3*i+1)\n        } else {\n            odd_list = append(odd_list, 3*i+1)\n \
    \           odd_list = append(odd_list, 1)\n        }\n    }\n    return odd_list\n\
    }\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11,\
    \ 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual:\
    \ candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected:\
    \ []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0\
    \ (0.00s)\n        tmpk9zdz4tt_test.go:51: expected '[%!s(int=1) %!s(int=5) %!s(int=7)\
    \ %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=1) %!s(int=7) %!s(int=10)\
    \ %!s(int=1) %!s(int=13) %!s(int=16) %!s(int=1) %!s(int=19) %!s(int=22) %!s(int=1)\
    \ %!s(int=25) %!s(int=28) %!s(int=1) %!s(int=31) %!s(int=34) %!s(int=1) %!s(int=37)\
    \ %!s(int=40) %!s(int=1) %!s(int=43)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1\
    \ (0.00s)\n        tmpk9zdz4tt_test.go:51: expected '[%!s(int=1) %!s(int=5)]',\
    \ got '[%!s(int=1) %!s(int=7) %!s(int=10) %!s(int=1) %!s(int=13) %!s(int=16) %!s(int=1)]'\n\
    \    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpk9zdz4tt_test.go:51:\
    \ expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=1) %!s(int=7) %!s(int=10)\
    \ %!s(int=1) %!s(int=13) %!s(int=16) %!s(int=1) %!s(int=19) %!s(int=22) %!s(int=1)\
    \ %!s(int=25) %!s(int=28) %!s(int=1) %!s(int=31) %!s(int=34) %!s(int=1) %!s(int=37)]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074300
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    if n == 1 {\n        return [1]\n    }\n    odd_list := []int{}\n\
    \    odd_list = append(odd_list, 1)\n    for i := 2; i <= n; i++ {\n        if\
    \ odd_list[i-1]%2 == 0 {\n            odd_list[i] = odd_list[i-1]/2\n        }\
    \ else {\n            odd_list[i] = 3*odd_list[i-1] + 1\n        }\n    }\n  \
    \  return odd_list\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate\
    \ := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected:\
    \ []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1,\
    \ 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual:\
    \ candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp21pxhxaw_test.go:23:19: expected type, found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074437
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := make([]int, 0)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, n)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    \nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11,\
    \ 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual:\
    \ candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected:\
    \ []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvap_jo7i_test.go:74:6: expected ''('', found TestGet_Odd_Collatz

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074298
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := make([]int, 0)\n    odd_list = append(odd_list,\
    \ 1)\n    for i := 2; i < n; i++ {\n        if odd_list[i-1]%2 == 0 {\n      \
    \      odd_list[i] = odd_list[i-1]/2\n        } else {\n            odd_list[i]\
    \ = 3*odd_list[i-1]+1\n        }\n    }\n    return odd_list\n}\n\nfunc TestGet_Odd_Collatz(t\
    \ *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5),\
    \ expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3,\
    \ 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\npanic: runtime error: index out\
    \ of range [1] with length 1 [recovered]\n\tpanic: runtime error: index out of\
    \ range [1] with length 1\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513760,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513760, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.get_odd_collatz(...)\n\t/tmp/tmpc1jud2es_test.go:25\n\
    command-line-arguments_test.TestGet_Odd_Collatz(0x0?)\n\t/tmp/tmpc1jud2es_test.go:41\
    \ +0x632\ntesting.tRunner(0xc0000da340, 0x529088)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074300
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := make([]int, 0)\n    odd_list = append(odd_list,\
    \ n)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    \nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11,\
    \ 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual:\
    \ candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected:\
    \ []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp3ndub0ke_test.go:74:6: expected ''('', found TestGet_Odd_Collatz

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074298
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    var odd_list []int\n    odd_list = append(odd_list, 1)\n \
    \   for i := 2; i <= n; i++ {\n        if i%2 == 0 {\n            odd_list = append(odd_list,\
    \ 3*i+1)\n        } else {\n            odd_list = append(odd_list, 3*i+1)\n \
    \       }\n    }\n    return odd_list\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T)\
    \ {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14),\
    \ expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected:\
    \ []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n\
    \     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0\
    \ (0.00s)\n        tmpkj1z43xq_test.go:50: expected '[%!s(int=1) %!s(int=5) %!s(int=7)\
    \ %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=1) %!s(int=7) %!s(int=10)\
    \ %!s(int=13) %!s(int=16) %!s(int=19) %!s(int=22) %!s(int=25) %!s(int=28) %!s(int=31)\
    \ %!s(int=34) %!s(int=37) %!s(int=40) %!s(int=43)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1\
    \ (0.00s)\n        tmpkj1z43xq_test.go:50: expected '[%!s(int=1) %!s(int=5)]',\
    \ got '[%!s(int=1) %!s(int=7) %!s(int=10) %!s(int=13) %!s(int=16)]'\n    --- FAIL:\
    \ TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpkj1z43xq_test.go:50: expected\
    \ '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=1) %!s(int=7) %!s(int=10)\
    \ %!s(int=13) %!s(int=16) %!s(int=19) %!s(int=22) %!s(int=25) %!s(int=28) %!s(int=31)\
    \ %!s(int=34) %!s(int=37)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074299
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := []int{}\n    odd_list = append(odd_list, 1)\n\
    \    for i := 2; i <= n; i++ {\n        if i%2 == 0 {\n            odd_list =\
    \ append(odd_list, i*2)\n        } else {\n            odd_list = append(odd_list,\
    \ i*2+3)\n        }\n    }\n    return odd_list\n}\n\nfunc TestGet_Odd_Collatz(t\
    \ *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5),\
    \ expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3,\
    \ 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0\
    \ (0.00s)\n        tmp0ojeejx4_test.go:50: expected '[%!s(int=1) %!s(int=5) %!s(int=7)\
    \ %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=1) %!s(int=4) %!s(int=9)\
    \ %!s(int=8) %!s(int=13) %!s(int=12) %!s(int=17) %!s(int=16) %!s(int=21) %!s(int=20)\
    \ %!s(int=25) %!s(int=24) %!s(int=29) %!s(int=28)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1\
    \ (0.00s)\n        tmp0ojeejx4_test.go:50: expected '[%!s(int=1) %!s(int=5)]',\
    \ got '[%!s(int=1) %!s(int=4) %!s(int=9) %!s(int=8) %!s(int=13)]'\n    --- FAIL:\
    \ TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmp0ojeejx4_test.go:50: expected\
    \ '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=1) %!s(int=4) %!s(int=9)\
    \ %!s(int=8) %!s(int=13) %!s(int=12) %!s(int=17) %!s(int=16) %!s(int=21) %!s(int=20)\
    \ %!s(int=25) %!s(int=24)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074299
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := make([]int, 0)\n    odd_list = append(odd_list,\
    \ 1)\n    for i := 2; i <= n; i++ {\n        if i%2 == 0 {\n            odd_list\
    \ = append(odd_list, i*2)\n        } else {\n            odd_list = append(odd_list,\
    \ i*2+3)\n        }\n    }\n    return odd_list\n}\n\nfunc TestGet_Odd_Collatz(t\
    \ *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5),\
    \ expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3,\
    \ 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0\
    \ (0.00s)\n        tmpc21apk61_test.go:50: expected '[%!s(int=1) %!s(int=5) %!s(int=7)\
    \ %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=1) %!s(int=4) %!s(int=9)\
    \ %!s(int=8) %!s(int=13) %!s(int=12) %!s(int=17) %!s(int=16) %!s(int=21) %!s(int=20)\
    \ %!s(int=25) %!s(int=24) %!s(int=29) %!s(int=28)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1\
    \ (0.00s)\n        tmpc21apk61_test.go:50: expected '[%!s(int=1) %!s(int=5)]',\
    \ got '[%!s(int=1) %!s(int=4) %!s(int=9) %!s(int=8) %!s(int=13)]'\n    --- FAIL:\
    \ TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpc21apk61_test.go:50: expected\
    \ '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=1) %!s(int=4) %!s(int=9)\
    \ %!s(int=8) %!s(int=13) %!s(int=12) %!s(int=17) %!s(int=16) %!s(int=21) %!s(int=20)\
    \ %!s(int=25) %!s(int=24)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074299
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := []int{}\n    odd_list = append(odd_list, n)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11,\
    \ 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual:\
    \ candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected:\
    \ []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpp9791e82_test.go:74:6: expected ''('', found TestGet_Odd_Collatz

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074303
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := make([]int, 0)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, n)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    \nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11,\
    \ 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual:\
    \ candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected:\
    \ []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvap_jo7i_test.go:74:6: expected ''('', found TestGet_Odd_Collatz

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074298
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := make([]int, 0)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, n)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    \nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11,\
    \ 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual:\
    \ candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected:\
    \ []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvap_jo7i_test.go:74:6: expected ''('', found TestGet_Odd_Collatz

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074298
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := make([]int, 0)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, n)\n    for i := 2; i < n; i++ {\n     \
    \   if odd_list[i] % 2 == 0 {\n            odd_list[i] = odd_list[i] / 2\n   \
    \         odd_list = append(odd_list, odd_list[i]*2)\n        } else {\n     \
    \       odd_list[i] = odd_list[i] * 3 + 1 \n        }\n    }\n    return odd_list\n\
    }\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11,\
    \ 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual:\
    \ candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected:\
    \ []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\npanic: runtime error: index out\
    \ of range [2] with length 2 [recovered]\n\tpanic: runtime error: index out of\
    \ range [2] with length 2\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2({0x513760,\
    \ 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513760, 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.get_odd_collatz(...)\n\t/tmp/tmpu6chtioc_test.go:26\n\
    command-line-arguments_test.TestGet_Odd_Collatz(0x0?)\n\t/tmp/tmpu6chtioc_test.go:43\
    \ +0x7c5\ntesting.tRunner(0xc000103520, 0x529088)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074299
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := []int{}\n    odd_list = append(odd_list, 1)\n\
    \    for i := 2; i <= n; i++ {\n        if i%2 == 0 {\n            odd_list =\
    \ append(odd_list, i*2)\n        } else {\n            odd_list = append(odd_list,\
    \ i*2+3)\n        }\n    }\n    return odd_list\n}\n\nfunc TestGet_Odd_Collatz(t\
    \ *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5),\
    \ expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3,\
    \ 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0\
    \ (0.00s)\n        tmp0ojeejx4_test.go:50: expected '[%!s(int=1) %!s(int=5) %!s(int=7)\
    \ %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=1) %!s(int=4) %!s(int=9)\
    \ %!s(int=8) %!s(int=13) %!s(int=12) %!s(int=17) %!s(int=16) %!s(int=21) %!s(int=20)\
    \ %!s(int=25) %!s(int=24) %!s(int=29) %!s(int=28)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1\
    \ (0.00s)\n        tmp0ojeejx4_test.go:50: expected '[%!s(int=1) %!s(int=5)]',\
    \ got '[%!s(int=1) %!s(int=4) %!s(int=9) %!s(int=8) %!s(int=13)]'\n    --- FAIL:\
    \ TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmp0ojeejx4_test.go:50: expected\
    \ '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=1) %!s(int=4) %!s(int=9)\
    \ %!s(int=8) %!s(int=13) %!s(int=12) %!s(int=17) %!s(int=16) %!s(int=21) %!s(int=20)\
    \ %!s(int=25) %!s(int=24)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074299
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := []int{}\n    odd_list = append(odd_list, 1)\n\
    \    for i := 2; i <= n; i++ {\n        if i%2 == 0 {\n            odd_list =\
    \ append(odd_list, 3*i+1)\n        } else {\n            odd_list = append(odd_list,\
    \ 3*i)\n        }\n    }\n    return odd_list\n}\n\nfunc TestGet_Odd_Collatz(t\
    \ *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5),\
    \ expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3,\
    \ 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0\
    \ (0.00s)\n        tmp2m7yl0gx_test.go:50: expected '[%!s(int=1) %!s(int=5) %!s(int=7)\
    \ %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=1) %!s(int=7) %!s(int=9)\
    \ %!s(int=13) %!s(int=15) %!s(int=19) %!s(int=21) %!s(int=25) %!s(int=27) %!s(int=31)\
    \ %!s(int=33) %!s(int=37) %!s(int=39) %!s(int=43)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1\
    \ (0.00s)\n        tmp2m7yl0gx_test.go:50: expected '[%!s(int=1) %!s(int=5)]',\
    \ got '[%!s(int=1) %!s(int=7) %!s(int=9) %!s(int=13) %!s(int=15)]'\n    --- FAIL:\
    \ TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmp2m7yl0gx_test.go:50: expected\
    \ '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=1) %!s(int=7) %!s(int=9)\
    \ %!s(int=13) %!s(int=15) %!s(int=19) %!s(int=21) %!s(int=25) %!s(int=27) %!s(int=31)\
    \ %!s(int=33) %!s(int=37)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074438
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    var odd_list []int\n    odd_list = append(odd_list, 1)\n \
    \   for i := 2; i < n; i++ {\n        if odd_list[i-1]%2 == 0 {\n            odd_list[i]\
    \ = odd_list[i-1]/2\n        } else {\n            odd_list[i] = odd_list[i-1]*3\
    \ + 1 \n        }\n    }\n    return odd_list\n}\n\nfunc TestGet_Odd_Collatz(t\
    \ *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5),\
    \ expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3,\
    \ 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\npanic: runtime error: index out\
    \ of range [1] with length 1 [recovered]\n\tpanic: runtime error: index out of\
    \ range [1] with length 1\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513760,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513760, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.get_odd_collatz(...)\n\t/tmp/tmpzcrx26u3_test.go:25\n\
    command-line-arguments_test.TestGet_Odd_Collatz(0x0?)\n\t/tmp/tmpzcrx26u3_test.go:41\
    \ +0x5f2\ntesting.tRunner(0xc0000cc4e0, 0x529088)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074438
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := make([]int, 0)\n    odd_list = append(odd_list,\
    \ 1)\n    for i := 2; i <= n; i++ {\n        if odd_list[i-1]%2 == 0 {\n     \
    \       odd_list[i-1] = odd_list[i-1]/2\n        } else {\n            odd_list[i-1]\
    \ = odd_list[i-1]*3 + 1 \n        }\n    }\n    return odd_list\n}\n\nfunc TestGet_Odd_Collatz(t\
    \ *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5),\
    \ expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3,\
    \ 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\npanic: runtime error: index out\
    \ of range [1] with length 1 [recovered]\n\tpanic: runtime error: index out of\
    \ range [1] with length 1\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513760,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513760, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.get_odd_collatz(...)\n\t/tmp/tmpaij4y5n4_test.go:25\n\
    command-line-arguments_test.TestGet_Odd_Collatz(0x0?)\n\t/tmp/tmpaij4y5n4_test.go:41\
    \ +0x5b0\ntesting.tRunner(0xc0000da1a0, 0x529088)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074300
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    var odd_list []int\n    odd_list = append(odd_list, 1)\n \
    \   for i := 2; i < n; i++ {\n        if odd_list[i-1]%2 == 0 {\n            odd_list[i]\
    \ = odd_list[i-1]/2\n        } else {\n            odd_list[i] = 3*odd_list[i-1]\
    \ + 1\n        }\n    }\n    return odd_list\n}\n\nfunc TestGet_Odd_Collatz(t\
    \ *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5),\
    \ expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3,\
    \ 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\npanic: runtime error: index out\
    \ of range [1] with length 1 [recovered]\n\tpanic: runtime error: index out of\
    \ range [1] with length 1\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513760,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513760, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.get_odd_collatz(...)\n\t/tmp/tmp4knat5fi_test.go:25\n\
    command-line-arguments_test.TestGet_Odd_Collatz(0x0?)\n\t/tmp/tmp4knat5fi_test.go:41\
    \ +0x5f2\ntesting.tRunner(0xc0000da1a0, 0x529088)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074438
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    var odd_list []int\n    odd_list = append(odd_list, 1)\n \
    \   odd_list = append(odd_list, n)\n    for i := 2; i < n; i++ {\n        if odd_list[i]\
    \ % 2 == 0 {\n            odd_list[i] /= 2\n            odd_list = append(odd_list,\
    \ odd_list[i]*3+1)\n        } else {\n            odd_list[i] /= 2\n         \
    \   odd_list = append(odd_list, odd_list[i]*3+1)\n        }\n    }\n    return\
    \ odd_list\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11,\
    \ 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual:\
    \ candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected:\
    \ []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\npanic: runtime error: index out\
    \ of range [2] with length 2 [recovered]\n\tpanic: runtime error: index out of\
    \ range [2] with length 2\n\ngoroutine 4 [running]:\ntesting.tRunner.func1.2({0x513760,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513760, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.get_odd_collatz(...)\n\t/tmp/tmpxthehb9a_test.go:26\n\
    command-line-arguments_test.TestGet_Odd_Collatz(0x0?)\n\t/tmp/tmpxthehb9a_test.go:44\
    \ +0x885\ntesting.tRunner(0xc0000d8000, 0x529088)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.009s\nFAIL\n"
  timestamp: 1660074438
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := make([]int, 0)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, n)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    \nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11,\
    \ 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual:\
    \ candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected:\
    \ []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvap_jo7i_test.go:74:6: expected ''('', found TestGet_Odd_Collatz

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074298
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := []int{}\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, n)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11,\
    \ 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual:\
    \ candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected:\
    \ []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpagn925m6_test.go:74:6: expected ''('', found TestGet_Odd_Collatz

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074298
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := make([]int, 0)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, n)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    \nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11,\
    \ 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual:\
    \ candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected:\
    \ []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvap_jo7i_test.go:74:6: expected ''('', found TestGet_Odd_Collatz

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074298
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := []int{}\n    odd_list = append(odd_list, 1)\n\
    \    for i := 2; i <= n; i++ {\n        if i%2 == 0 {\n            odd_list =\
    \ append(odd_list, 3*i+1)\n        } else {\n            odd_list = append(odd_list,\
    \ 3*i+1)\n        }\n    }\n    return odd_list\n}\n\nfunc TestGet_Odd_Collatz(t\
    \ *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5),\
    \ expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3,\
    \ 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0\
    \ (0.00s)\n        tmpywa906w6_test.go:50: expected '[%!s(int=1) %!s(int=5) %!s(int=7)\
    \ %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=1) %!s(int=7) %!s(int=10)\
    \ %!s(int=13) %!s(int=16) %!s(int=19) %!s(int=22) %!s(int=25) %!s(int=28) %!s(int=31)\
    \ %!s(int=34) %!s(int=37) %!s(int=40) %!s(int=43)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1\
    \ (0.00s)\n        tmpywa906w6_test.go:50: expected '[%!s(int=1) %!s(int=5)]',\
    \ got '[%!s(int=1) %!s(int=7) %!s(int=10) %!s(int=13) %!s(int=16)]'\n    --- FAIL:\
    \ TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpywa906w6_test.go:50: expected\
    \ '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=1) %!s(int=7) %!s(int=10)\
    \ %!s(int=13) %!s(int=16) %!s(int=19) %!s(int=22) %!s(int=25) %!s(int=28) %!s(int=31)\
    \ %!s(int=34) %!s(int=37)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074438
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    var odd_list []int\n    if n <= 1 {\n        return odd_list\n\
    \    }\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, get_odd_collatz(n/2))\n\
    \    odd_list = append(odd_list, get_odd_collatz(n/3))\n    odd_list = append(odd_list,\
    \ get_odd_collatz(n/4))\n    odd_list = append(odd_list, get_odd_collatz(n/5))\n\
    \    odd_list = append(odd_list, get_odd_collatz(n/6))\n    odd_list = append(odd_list,\
    \ get_odd_collatz(n/7))\n    odd_list = append(odd_list, get_odd_collatz(n/8))\n\
    \    odd_list = append(odd_list, get_odd_collatz(n/9))\n    odd_list = append(odd_list,\
    \ get_odd_collatz(n/10))\n    odd_list = append(odd_list, get_odd_collatz(n/11))\n\
    \    odd_list = append(odd_list, get_odd_collatz(n/12))\n    odd_list = append(odd_list,\
    \ get_odd_collatz(n/13))\n    odd_list = append(odd_list, get_odd_collatz(n/14))\n\
    \    odd_list = append(odd_list, get_odd_collatz(n/15))\n    odd_list = append(odd_list,\
    \ get_odd_collatz(n/16))\n    odd_list = append(odd_list, get_odd_collatz(n/17))\n\
    \    odd_list = append(odd_list, get_odd_collatz(n/18))\n    odd_list = append(odd_list,\
    \ get_odd_collatz(n/19))\n    odd_list = append(odd_list, get_odd_collatz(n/20))\n\
    \    odd_list = append(odd_list, get_odd_collatz(n/20))\n    odd_list = append(odd_list,\
    \ get_odd_collatz(n/20))\n    odd_list = append(odd_list, get_odd_collatz(n/20))\n\
    \    odd_list = append(odd_list, get_odd_collatz(n/20))\n    odd_list = append(odd_list,\
    \ get_odd_collatz(n/20))\n    odd_list = append(odd_list, get_odd_collatz(n/20))\n\
    \    odd_list = append(odd_list, get_odd_collatz(n/20))\n    odd_list = append(od\n\
    func TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17}\
    \ },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12),\
    \ expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp9ij2cz1w_test.go:53:25: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074437
- exit_code: 2
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    var result []int\n    result := get_odd_collatz_helper(n,\
    \ result)\n    return result\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n\
    \  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14),\
    \ expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected:\
    \ []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n\
    \     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprrspe8eo_test.go:23:12: no new variables on left side of :=

    /tmp/tmprrspe8eo_test.go:23:15: undefined: get_odd_collatz_helper

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074438
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := make([]int, 0)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, n)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    \nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11,\
    \ 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual:\
    \ candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected:\
    \ []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvap_jo7i_test.go:74:6: expected ''('', found TestGet_Odd_Collatz

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074298
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := make([]int, 0)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    \nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11,\
    \ 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual:\
    \ candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected:\
    \ []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpmkk49utj_test.go:74:6: expected ''('', found TestGet_Odd_Collatz

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074298
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    if n < 2 {\n        return []int{n}\n    }\n    odd_list :=\
    \ []int{}\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ get_odd_collatz(n/2))\n    odd_list = append(odd_list, get_odd_collatz(n/3))\n\
    \    odd_list = append(odd_list, get_odd_collatz(n/4))\n    odd_list = append(odd_list,\
    \ get_odd_collatz(n/5))\n    odd_list = append(odd_list, get_odd_collatz(n/6))\n\
    \    odd_list = append(odd_list, get_odd_collatz(n/7))\n    odd_list = append(odd_list,\
    \ get_odd_collatz(n/8))\n    odd_list = append(odd_list, get_odd_collatz(n/9))\n\
    \    odd_list = append(odd_list, get_odd_collatz(n/10))\n    odd_list = append(odd_list,\
    \ get_odd_collatz(n/11))\n    odd_list = append(odd_list, get_odd_collatz(n/12))\n\
    \    odd_list = append(odd_list, get_odd_collatz(n/13))\n    odd_list = append(odd_list,\
    \ get_odd_collatz(n/14))\n    odd_list = append(odd_list, get_odd_collatz(n/15))\n\
    \    odd_list = append(odd_list, get_odd_collatz(n/16))\n    odd_list = append(odd_list,\
    \ get_odd_collatz(n/17))\n    odd_list = append(odd_list, get_odd_collatz(n/18))\n\
    \    odd_list = append(odd_list, get_odd_collatz(n/19))\n    odd_list = append(odd_list,\
    \ get_odd_collatz(n/20))\n    odd_list = append(odd_list, get_odd_collatz(n/20))\n\
    \    odd_list = append(odd_list, get_odd_collatz(n/20))\n    odd_list = append(odd_list,\
    \ get_odd_collatz(n/20))\n    odd_list = append(odd_list, get_odd_collatz(n/20))\n\
    \    odd_list = append(odd_list, get_odd_collatz(n/20))\n    odd_list = append(odd_list,\
    \ get_odd_collatz(n/20))\n    odd_list = append(odd_list, get_odd_collatz(n/20))\n\
    \    odd_list = \nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11,\
    \ 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual:\
    \ candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected:\
    \ []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp133cdg6n_test.go:54:6: expected ''('', found TestGet_Odd_Collatz

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074437
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := make([]int, 0)\n    odd_list = append(odd_list,\
    \ n)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    \nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11,\
    \ 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual:\
    \ candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected:\
    \ []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp3ndub0ke_test.go:74:6: expected ''('', found TestGet_Odd_Collatz

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074298
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := []int{}\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, n)\n    for i := 2; i < n; i++ {\n        if\
    \ odd_list[i-1]%2 == 0 {\n            odd_list[i] = odd_list[i-1]/2\n        }\
    \ else {\n            odd_list[i] = odd_list[i-1]*3+1 \n        }\n    }\n   \
    \ return odd_list\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate\
    \ := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected:\
    \ []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1,\
    \ 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual:\
    \ candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\npanic: runtime error: index out\
    \ of range [2] with length 2 [recovered]\n\tpanic: runtime error: index out of\
    \ range [2] with length 2\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2({0x513760,\
    \ 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513760, 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.get_odd_collatz(...)\n\t/tmp/tmpypxq71gs_test.go:27\n\
    command-line-arguments_test.TestGet_Odd_Collatz(0x0?)\n\t/tmp/tmpypxq71gs_test.go:42\
    \ +0x6dc\ntesting.tRunner(0xc0001031e0, 0x529088)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074301
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := make([]int, 0)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, n)\n    for i := 2; i < n; i++ {\n     \
    \   if odd_list[i-1]%2 == 0 {\n            odd_list[i] = odd_list[i-1]/2\n   \
    \     } else {\n            odd_list[i] = odd_list[i-1]*3+1 \n        }\n    }\n\
    \    return odd_list\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate\
    \ := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected:\
    \ []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1,\
    \ 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual:\
    \ candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\npanic: runtime error: index out\
    \ of range [2] with length 2 [recovered]\n\tpanic: runtime error: index out of\
    \ range [2] with length 2\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513760,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513760, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.get_odd_collatz(...)\n\t/tmp/tmpeg14lpp7_test.go:27\n\
    command-line-arguments_test.TestGet_Odd_Collatz(0x0?)\n\t/tmp/tmpeg14lpp7_test.go:42\
    \ +0x71c\ntesting.tRunner(0xc0000da340, 0x529088)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074301
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := []int{}\n    odd_list = append(odd_list, 1)\n\
    \    for i := 2; i <= n; i++ {\n        if i%2 == 0 {\n            odd_list =\
    \ append(odd_list, i*2)\n        } else {\n            odd_list = append(odd_list,\
    \ i*2+3)\n        }\n    }\n    return odd_list\n}\n\nfunc TestGet_Odd_Collatz(t\
    \ *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5),\
    \ expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3,\
    \ 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0\
    \ (0.00s)\n        tmp0ojeejx4_test.go:50: expected '[%!s(int=1) %!s(int=5) %!s(int=7)\
    \ %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=1) %!s(int=4) %!s(int=9)\
    \ %!s(int=8) %!s(int=13) %!s(int=12) %!s(int=17) %!s(int=16) %!s(int=21) %!s(int=20)\
    \ %!s(int=25) %!s(int=24) %!s(int=29) %!s(int=28)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1\
    \ (0.00s)\n        tmp0ojeejx4_test.go:50: expected '[%!s(int=1) %!s(int=5)]',\
    \ got '[%!s(int=1) %!s(int=4) %!s(int=9) %!s(int=8) %!s(int=13)]'\n    --- FAIL:\
    \ TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmp0ojeejx4_test.go:50: expected\
    \ '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=1) %!s(int=4) %!s(int=9)\
    \ %!s(int=8) %!s(int=13) %!s(int=12) %!s(int=17) %!s(int=16) %!s(int=21) %!s(int=20)\
    \ %!s(int=25) %!s(int=24)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074299
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := make([]int, 0)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, n)\n    for i := 2; i < n; i++ {\n     \
    \   if odd_list[i] % 2 == 0 {\n            odd_list[i] = odd_list[i] / 2\n   \
    \         odd_list = append(odd_list, odd_list[i]*2)\n        } else {\n     \
    \       odd_list[i] = odd_list[i] * 3 + 1\n            odd_list = append(odd_list,\
    \ odd_list[i])\n        }\n    }\n    return odd_list\n}\n\nfunc TestGet_Odd_Collatz(t\
    \ *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5),\
    \ expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3,\
    \ 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\npanic: runtime error: index out\
    \ of range [2] with length 2 [recovered]\n\tpanic: runtime error: index out of\
    \ range [2] with length 2\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513760,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513760, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.get_odd_collatz(...)\n\t/tmp/tmp6pd011_9_test.go:26\n\
    command-line-arguments_test.TestGet_Odd_Collatz(0x0?)\n\t/tmp/tmp6pd011_9_test.go:44\
    \ +0x8a5\ntesting.tRunner(0xc0000da340, 0x529088)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074299
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    var odd_list []int\n    odd_list = append(odd_list, 1)\n \
    \   odd_list = append(odd_list, n)\n    for i := 2; i < n; i++ {\n        if odd_list[i-1]%2\
    \ == 0 {\n            odd_list[i] = odd_list[i-1]/2\n        } else {\n      \
    \      odd_list[i] = odd_list[i-1]*3 + 1 \n        }\n    }\n    return odd_list\n\
    }\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11,\
    \ 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual:\
    \ candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected:\
    \ []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\npanic: runtime error: index out\
    \ of range [2] with length 2 [recovered]\n\tpanic: runtime error: index out of\
    \ range [2] with length 2\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513760,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513760, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.get_odd_collatz(...)\n\t/tmp/tmpj4_7_eic_test.go:27\n\
    command-line-arguments_test.TestGet_Odd_Collatz(0x0?)\n\t/tmp/tmpj4_7_eic_test.go:42\
    \ +0x6d4\ntesting.tRunner(0xc0000cc4e0, 0x529088)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074439
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := make([]int, 0)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, n)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    \nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11,\
    \ 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual:\
    \ candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected:\
    \ []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvap_jo7i_test.go:74:6: expected ''('', found TestGet_Odd_Collatz

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074298
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := make([]int, 0)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, n)\n    for i := 2; i < n; i++ {\n     \
    \   if odd_list[i] % 2 == 0 {\n            odd_list[i] = odd_list[i] / 2\n   \
    \         odd_list = append(odd_list, odd_list[i]*2)\n        } else {\n     \
    \       odd_list[i] = odd_list[i] * 3 + 1\n            odd_list = append(odd_list,\
    \ odd_list[i])\n        }\n    }\n    return odd_list\n}\n\nfunc TestGet_Odd_Collatz(t\
    \ *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5),\
    \ expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3,\
    \ 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\npanic: runtime error: index out\
    \ of range [2] with length 2 [recovered]\n\tpanic: runtime error: index out of\
    \ range [2] with length 2\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513760,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513760, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.get_odd_collatz(...)\n\t/tmp/tmp6pd011_9_test.go:26\n\
    command-line-arguments_test.TestGet_Odd_Collatz(0x0?)\n\t/tmp/tmp6pd011_9_test.go:44\
    \ +0x8a5\ntesting.tRunner(0xc0000da340, 0x529088)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074299
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    if n < 1 {\n        return []int{}\n    }\n    odd_list :=\
    \ []int{}\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ n)\n    for i := 2; i < n; i++ {\n        if odd_list[i-1]%2 == 0 {\n      \
    \      odd_list[i] = odd_list[i-1]/2\n        } else {\n            odd_list[i]\
    \ = 3*odd_list[i-1] + 1\n        }\n    }\n    return odd_list\n}\n\nfunc TestGet_Odd_Collatz(t\
    \ *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5),\
    \ expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3,\
    \ 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\npanic: runtime error: index out\
    \ of range [2] with length 2 [recovered]\n\tpanic: runtime error: index out of\
    \ range [2] with length 2\n\ngoroutine 4 [running]:\ntesting.tRunner.func1.2({0x513760,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513760, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.get_odd_collatz(...)\n\t/tmp/tmpt1zizj7q_test.go:30\n\
    command-line-arguments_test.TestGet_Odd_Collatz(0x0?)\n\t/tmp/tmpt1zizj7q_test.go:45\
    \ +0x6dc\ntesting.tRunner(0xc0000d8000, 0x529088)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074439
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := []int{}\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, n)\n    for i := 2; i < n; i++ {\n        if\
    \ odd_list[i-1]%2 == 0 {\n            odd_list[i] = odd_list[i-1]/2\n        }\
    \ else {\n            odd_list[i] = 3*odd_list[i-1] + 1\n        }\n    }\n  \
    \  return odd_list\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate\
    \ := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected:\
    \ []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1,\
    \ 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual:\
    \ candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\npanic: runtime error: index out\
    \ of range [2] with length 2 [recovered]\n\tpanic: runtime error: index out of\
    \ range [2] with length 2\n\ngoroutine 4 [running]:\ntesting.tRunner.func1.2({0x513760,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513760, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.get_odd_collatz(...)\n\t/tmp/tmp22psfyfz_test.go:27\n\
    command-line-arguments_test.TestGet_Odd_Collatz(0x0?)\n\t/tmp/tmp22psfyfz_test.go:42\
    \ +0x6dc\ntesting.tRunner(0xc0000d24e0, 0x529088)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074304
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := make([]int, 0)\n    odd_list = append(odd_list,\
    \ 1)\n    for i := 2; i <= n; i++ {\n        if i%2 == 0 {\n            odd_list\
    \ = append(odd_list, i*2)\n        } else {\n            odd_list = append(odd_list,\
    \ i*2+3)\n        }\n    }\n    return odd_list\n}\n\nfunc TestGet_Odd_Collatz(t\
    \ *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5),\
    \ expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3,\
    \ 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0\
    \ (0.00s)\n        tmpc21apk61_test.go:50: expected '[%!s(int=1) %!s(int=5) %!s(int=7)\
    \ %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=1) %!s(int=4) %!s(int=9)\
    \ %!s(int=8) %!s(int=13) %!s(int=12) %!s(int=17) %!s(int=16) %!s(int=21) %!s(int=20)\
    \ %!s(int=25) %!s(int=24) %!s(int=29) %!s(int=28)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1\
    \ (0.00s)\n        tmpc21apk61_test.go:50: expected '[%!s(int=1) %!s(int=5)]',\
    \ got '[%!s(int=1) %!s(int=4) %!s(int=9) %!s(int=8) %!s(int=13)]'\n    --- FAIL:\
    \ TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpc21apk61_test.go:50: expected\
    \ '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=1) %!s(int=4) %!s(int=9)\
    \ %!s(int=8) %!s(int=13) %!s(int=12) %!s(int=17) %!s(int=16) %!s(int=21) %!s(int=20)\
    \ %!s(int=25) %!s(int=24)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074299
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    var odd_list []int\n    odd_list = append(odd_list, 1)\n \
    \   for i := 2; i <= n; i++ {\n        if i%2 == 0 {\n            odd_list = append(odd_list,\
    \ i*2)\n        } else {\n            odd_list = append(odd_list, i*2+3)\n   \
    \     }\n    }\n    return odd_list\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T)\
    \ {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14),\
    \ expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected:\
    \ []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n\
    \     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0\
    \ (0.00s)\n        tmph34sx2_4_test.go:50: expected '[%!s(int=1) %!s(int=5) %!s(int=7)\
    \ %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=1) %!s(int=4) %!s(int=9)\
    \ %!s(int=8) %!s(int=13) %!s(int=12) %!s(int=17) %!s(int=16) %!s(int=21) %!s(int=20)\
    \ %!s(int=25) %!s(int=24) %!s(int=29) %!s(int=28)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1\
    \ (0.00s)\n        tmph34sx2_4_test.go:50: expected '[%!s(int=1) %!s(int=5)]',\
    \ got '[%!s(int=1) %!s(int=4) %!s(int=9) %!s(int=8) %!s(int=13)]'\n    --- FAIL:\
    \ TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmph34sx2_4_test.go:50: expected\
    \ '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=1) %!s(int=4) %!s(int=9)\
    \ %!s(int=8) %!s(int=13) %!s(int=12) %!s(int=17) %!s(int=16) %!s(int=21) %!s(int=20)\
    \ %!s(int=25) %!s(int=24)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074299
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := make([]int, 0)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, n)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    \nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11,\
    \ 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual:\
    \ candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected:\
    \ []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvap_jo7i_test.go:74:6: expected ''('', found TestGet_Odd_Collatz

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074298
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    if n < 2 {\n        return []int{n}\n    }\n    odd_list :=\
    \ []int{}\n    odd_list = append(odd_list, n)\n    odd_list = append(odd_list,\
    \ get_odd_collatz(n/2)*2)\n    odd_list = append(odd_list, get_odd_collatz(n/2)*2+1)\n\
    \    odd_list = append(odd_list, get_odd_collatz(n/2)*2+2)\n    odd_list = append(odd_list,\
    \ get_odd_collatz(n/2)*2+3)\n    odd_list = append(odd_list, get_odd_collatz(n/2)*2+4)\n\
    \    odd_list = append(odd_list, get_odd_collatz(n/2)*2+5)\n    odd_list = append(odd_list,\
    \ get_odd_collatz(n/2)*2+6)\n    odd_list = append(odd_list, get_odd_collatz(n/2)*2+7)\n\
    \    odd_list = append(odd_list, get_odd_collatz(n/2)*2+8)\n    odd_list = append(odd_list,\
    \ get_odd_collatz(n/2)*2+9)\n    odd_list = append(odd_list, get_odd_collatz(n/2)*2+10)\n\
    \    odd_list = append(odd_list, get_odd_collatz(n/2)*2+11)\n    odd_list = append(odd_list,\
    \ get_odd_collatz(n/2)*2+12)\n    odd_list = append(odd_list, get_odd_collatz(n/2)*2+13)\n\
    \    odd_list = append(odd_list, get_odd_collatz(n/2)*2+14)\n    odd_list = append(odd_list,\
    \ get_odd_collatz(n/2)*2+15)\n    odd_list = append(odd_list, get_odd_collatz(n/2)*2+16)\n\
    \    odd_list = append(odd_list, get_odd_collatz(n/2)*2+17)\n    odd_list = append(odd_list,\
    \ get_odd_collatz(n/2)*2+18)\n    odd_list = append(odd_list, get_odd_collatz(n/2)*2+19)\n\
    \    odd_list = append(odd_list, get_odd_collatz(n/2)*2+20)\n    odd_list = append(odd_list,\
    \ get_odd_collatz(n/2)*2+21)\n    odd_list = append(odd_list, get_odd_collatz(n/2)*2+22)\n\
    \    odd_list = append(odd_list, get_odd_collatz(n/2)*2+23)\n\nfunc TestGet_Odd_Collatz(t\
    \ *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5),\
    \ expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3,\
    \ 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6t13gz_x_test.go:52:6: expected ''('', found TestGet_Odd_Collatz

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074438
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := make([]int, 0)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, n)\n    for i := 2; i < n; i++ {\n     \
    \   if odd_list[i] % 2 == 0 {\n            odd_list[i] = odd_list[i] / 2\n   \
    \         odd_list = append(odd_list, odd_list[i]*2)\n        } else {\n     \
    \       odd_list[i] = odd_list[i] * 3 + 1\n            odd_list = append(odd_list,\
    \ odd_list[i])\n        }\n    }\n    return odd_list\n}\n\nfunc TestGet_Odd_Collatz(t\
    \ *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5),\
    \ expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3,\
    \ 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\npanic: runtime error: index out\
    \ of range [2] with length 2 [recovered]\n\tpanic: runtime error: index out of\
    \ range [2] with length 2\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513760,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513760, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.get_odd_collatz(...)\n\t/tmp/tmp6pd011_9_test.go:26\n\
    command-line-arguments_test.TestGet_Odd_Collatz(0x0?)\n\t/tmp/tmp6pd011_9_test.go:44\
    \ +0x8a5\ntesting.tRunner(0xc0000da340, 0x529088)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074299
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := make([]int, 0)\n    odd_list = append(odd_list,\
    \ n)\n    for i := 1; i <= n; i++ {\n        if n%2 == 0 {\n            odd_list\
    \ = append(odd_list, n/2)\n            n = n/2\n        } else {\n           \
    \ odd_list = append(odd_list, 3*n+1)\n            n = 3*n+1\n        }\n    }\n\
    \    return odd_list\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate\
    \ := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected:\
    \ []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1,\
    \ 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual:\
    \ candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0\
    \ (0.00s)\n        tmpxamiga___test.go:52: expected '[%!s(int=1) %!s(int=5) %!s(int=7)\
    \ %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=14) %!s(int=7) %!s(int=22)\
    \ %!s(int=11) %!s(int=34) %!s(int=17) %!s(int=52) %!s(int=26) %!s(int=13) %!s(int=40)\
    \ %!s(int=20) %!s(int=10)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n\
    \        tmpxamiga___test.go:52: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=5)\
    \ %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2\
    \ (0.00s)\n        tmpxamiga___test.go:52: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]',\
    \ got '[%!s(int=12) %!s(int=6) %!s(int=3) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8)\
    \ %!s(int=4)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__3 (0.00s)\n      \
    \  tmpxamiga___test.go:52: expected '[%!s(int=1)]', got '[%!s(int=1) %!s(int=4)\
    \ %!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074302
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := make([]int, 0)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, n)\n    for i := 2; i < n; i++ {\n     \
    \   if odd_list[i] % 2 == 0 {\n            odd_list[i] = odd_list[i] / 2\n   \
    \         odd_list = append(odd_list, odd_list[i]*2)\n        } else {\n     \
    \       odd_list[i] = odd_list[i] * 3 + 1\n            odd_list = append(odd_list,\
    \ odd_list[i])\n        }\n    }\n    return odd_list\n}\n\nfunc TestGet_Odd_Collatz(t\
    \ *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5),\
    \ expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3,\
    \ 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\npanic: runtime error: index out\
    \ of range [2] with length 2 [recovered]\n\tpanic: runtime error: index out of\
    \ range [2] with length 2\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513760,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513760, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.get_odd_collatz(...)\n\t/tmp/tmp6pd011_9_test.go:26\n\
    command-line-arguments_test.TestGet_Odd_Collatz(0x0?)\n\t/tmp/tmp6pd011_9_test.go:44\
    \ +0x8a5\ntesting.tRunner(0xc0000da340, 0x529088)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074299
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := make([]int, 0)\n    odd_list = append(odd_list,\
    \ 1)\n    for i := 2; i <= n; i++ {\n        if odd_list[i-1]%2 == 0 {\n     \
    \       odd_list[i] = odd_list[i-1]/2\n        } else {\n            odd_list[i]\
    \ = 3*odd_list[i-1] + 1\n        }\n    }\n    return odd_list\n}\n\nfunc TestGet_Odd_Collatz(t\
    \ *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5),\
    \ expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3,\
    \ 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\npanic: runtime error: index out\
    \ of range [1] with length 1 [recovered]\n\tpanic: runtime error: index out of\
    \ range [1] with length 1\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513760,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513760, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.get_odd_collatz(...)\n\t/tmp/tmpsg9_2rno_test.go:25\n\
    command-line-arguments_test.TestGet_Odd_Collatz(0x0?)\n\t/tmp/tmpsg9_2rno_test.go:41\
    \ +0x632\ntesting.tRunner(0xc0000da1a0, 0x529088)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074299
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := make([]int, 0)\n    odd_list = append(odd_list,\
    \ 1)\n    for i := 2; i <= n; i++ {\n        if i%2 == 0 {\n            odd_list\
    \ = append(odd_list, i*2)\n        } else {\n            odd_list = append(odd_list,\
    \ i*2+3)\n        }\n    }\n    return odd_list\n}\n\nfunc TestGet_Odd_Collatz(t\
    \ *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5),\
    \ expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3,\
    \ 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0\
    \ (0.00s)\n        tmpc21apk61_test.go:50: expected '[%!s(int=1) %!s(int=5) %!s(int=7)\
    \ %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=1) %!s(int=4) %!s(int=9)\
    \ %!s(int=8) %!s(int=13) %!s(int=12) %!s(int=17) %!s(int=16) %!s(int=21) %!s(int=20)\
    \ %!s(int=25) %!s(int=24) %!s(int=29) %!s(int=28)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1\
    \ (0.00s)\n        tmpc21apk61_test.go:50: expected '[%!s(int=1) %!s(int=5)]',\
    \ got '[%!s(int=1) %!s(int=4) %!s(int=9) %!s(int=8) %!s(int=13)]'\n    --- FAIL:\
    \ TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpc21apk61_test.go:50: expected\
    \ '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=1) %!s(int=4) %!s(int=9)\
    \ %!s(int=8) %!s(int=13) %!s(int=12) %!s(int=17) %!s(int=16) %!s(int=21) %!s(int=20)\
    \ %!s(int=25) %!s(int=24)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074299
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := make([]int, 0)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, n)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    \nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11,\
    \ 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual:\
    \ candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected:\
    \ []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvap_jo7i_test.go:74:6: expected ''('', found TestGet_Odd_Collatz

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074298
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := make([]int, 0)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, n)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    \nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11,\
    \ 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual:\
    \ candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected:\
    \ []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvap_jo7i_test.go:74:6: expected ''('', found TestGet_Odd_Collatz

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074298
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    var odd_list []int\n    odd_list = append(odd_list, 1)\n \
    \   for i := 2; i < n; i++ {\n        if odd_list[i-1]%2 == 0 {\n            odd_list[i]\
    \ = odd_list[i-1]/2\n        } else {\n            odd_list[i] = 3*odd_list[i-1]\
    \ + 1\n        }\n    }\n    return odd_list\n}\n\nfunc TestGet_Odd_Collatz(t\
    \ *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5),\
    \ expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3,\
    \ 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\npanic: runtime error: index out\
    \ of range [1] with length 1 [recovered]\n\tpanic: runtime error: index out of\
    \ range [1] with length 1\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513760,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513760, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.get_odd_collatz(...)\n\t/tmp/tmp4knat5fi_test.go:25\n\
    command-line-arguments_test.TestGet_Odd_Collatz(0x0?)\n\t/tmp/tmp4knat5fi_test.go:41\
    \ +0x5f2\ntesting.tRunner(0xc0000da1a0, 0x529088)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074438
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := make([]int, 0)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, n)\n    for i := 2; i < n; i++ {\n     \
    \   if odd_list[i] % 2 == 0 {\n            odd_list[i] = odd_list[i] / 2\n   \
    \         odd_list = append(odd_list, odd_list[i]*2)\n        } else {\n     \
    \       odd_list[i] = odd_list[i] * 3 + 1 \n            odd_list = append(odd_list,\
    \ odd_list[i])\n        }\n    }\n    return odd_list\n}\n\nfunc TestGet_Odd_Collatz(t\
    \ *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5),\
    \ expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3,\
    \ 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\npanic: runtime error: index out\
    \ of range [2] with length 2 [recovered]\n\tpanic: runtime error: index out of\
    \ range [2] with length 2\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2({0x513760,\
    \ 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513760, 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.get_odd_collatz(...)\n\t/tmp/tmpoyjsnnng_test.go:26\n\
    command-line-arguments_test.TestGet_Odd_Collatz(0x0?)\n\t/tmp/tmpoyjsnnng_test.go:44\
    \ +0x8a5\ntesting.tRunner(0xc0001031e0, 0x529088)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074302
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := make([]int, 0)\n    odd_list = append(odd_list,\
    \ 1)\n    for i := 2; i < n; i++ {\n        if odd_list[i-1]%2 == 0 {\n      \
    \      odd_list[i] = odd_list[i-1]/2\n        } else {\n            odd_list[i]\
    \ = 3*odd_list[i-1]+1\n        }\n    }\n    return odd_list\n}\n\nfunc TestGet_Odd_Collatz(t\
    \ *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5),\
    \ expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3,\
    \ 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\npanic: runtime error: index out\
    \ of range [1] with length 1 [recovered]\n\tpanic: runtime error: index out of\
    \ range [1] with length 1\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513760,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513760, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.get_odd_collatz(...)\n\t/tmp/tmpc1jud2es_test.go:25\n\
    command-line-arguments_test.TestGet_Odd_Collatz(0x0?)\n\t/tmp/tmpc1jud2es_test.go:41\
    \ +0x632\ntesting.tRunner(0xc0000da340, 0x529088)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074300
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := make([]int, 0)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, n)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    \nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11,\
    \ 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual:\
    \ candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected:\
    \ []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvap_jo7i_test.go:74:6: expected ''('', found TestGet_Odd_Collatz

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074298
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := []int{}\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, n)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11,\
    \ 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual:\
    \ candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected:\
    \ []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpagn925m6_test.go:74:6: expected ''('', found TestGet_Odd_Collatz

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074298
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := make([]int, 0)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, n)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    \nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11,\
    \ 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual:\
    \ candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected:\
    \ []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvap_jo7i_test.go:74:6: expected ''('', found TestGet_Odd_Collatz

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074298
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := make([]int, 0)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, n)\n    for i := 2; i < n; i++ {\n     \
    \   if odd_list[i] % 2 == 0 {\n            odd_list[i] = odd_list[i] / 2\n   \
    \         odd_list = append(odd_list, odd_list[i]*2)\n        } else {\n     \
    \       odd_list[i] = odd_list[i] * 3 + 1 \n        }\n    }\n    return odd_list\n\
    }\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11,\
    \ 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual:\
    \ candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected:\
    \ []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\npanic: runtime error: index out\
    \ of range [2] with length 2 [recovered]\n\tpanic: runtime error: index out of\
    \ range [2] with length 2\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2({0x513760,\
    \ 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513760, 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.get_odd_collatz(...)\n\t/tmp/tmpu6chtioc_test.go:26\n\
    command-line-arguments_test.TestGet_Odd_Collatz(0x0?)\n\t/tmp/tmpu6chtioc_test.go:43\
    \ +0x7c5\ntesting.tRunner(0xc000103520, 0x529088)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074299
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := make([]int, 0)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, n)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    \nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11,\
    \ 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual:\
    \ candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected:\
    \ []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvap_jo7i_test.go:74:6: expected ''('', found TestGet_Odd_Collatz

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074298
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := make([]int, 0)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, n)\n    for i := 2; i < n; i++ {\n     \
    \   if odd_list[i] % 2 == 0 {\n            odd_list[i] = odd_list[i] / 2\n   \
    \         odd_list = append(odd_list, odd_list[i]*2)\n        } else {\n     \
    \       odd_list[i] = odd_list[i] * 3 + 1\n            odd_list = append(odd_list,\
    \ odd_list[i])\n        }\n    }\n    return odd_list\n}\n\nfunc TestGet_Odd_Collatz(t\
    \ *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5),\
    \ expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3,\
    \ 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\npanic: runtime error: index out\
    \ of range [2] with length 2 [recovered]\n\tpanic: runtime error: index out of\
    \ range [2] with length 2\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513760,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513760, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.get_odd_collatz(...)\n\t/tmp/tmp6pd011_9_test.go:26\n\
    command-line-arguments_test.TestGet_Odd_Collatz(0x0?)\n\t/tmp/tmp6pd011_9_test.go:44\
    \ +0x8a5\ntesting.tRunner(0xc0000da340, 0x529088)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074299
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := []int{}\n    odd_list = append(odd_list, 1)\n\
    \    for i := 2; i <= n; i++ {\n        if odd_list[i-1]%2 == 0 {\n          \
    \  odd_list[i] = odd_list[i-1]/2\n        } else {\n            odd_list[i] =\
    \ odd_list[i-1]*3+1 \n        }\n    }\n    return odd_list\n}\n\nfunc TestGet_Odd_Collatz(t\
    \ *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5),\
    \ expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3,\
    \ 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\npanic: runtime error: index out\
    \ of range [1] with length 1 [recovered]\n\tpanic: runtime error: index out of\
    \ range [1] with length 1\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2({0x513760,\
    \ 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513760, 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.get_odd_collatz(...)\n\t/tmp/tmpnwp91tl3_test.go:25\n\
    command-line-arguments_test.TestGet_Odd_Collatz(0x0?)\n\t/tmp/tmpnwp91tl3_test.go:41\
    \ +0x5fd\ntesting.tRunner(0xc000103380, 0x529088)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n"
  timestamp: 1660074439
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := make([]int, 0)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, n)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    \nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11,\
    \ 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual:\
    \ candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected:\
    \ []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvap_jo7i_test.go:74:6: expected ''('', found TestGet_Odd_Collatz

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074298
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := make([]int, 0)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, n)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    \nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11,\
    \ 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual:\
    \ candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected:\
    \ []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvap_jo7i_test.go:74:6: expected ''('', found TestGet_Odd_Collatz

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074298
- exit_code: 2
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := []int{}\n    if n == 1 {\n        return odd_list\n\
    \    }\n    odd_list = append(odd_list, n)\n    odd_list = append(odd_list, get_odd_collatz(n/2)*2)\n\
    \    odd_list = append(odd_list, get_odd_collatz(n/2)*2+1)\n    return odd_list\n\
    }\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11,\
    \ 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual:\
    \ candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected:\
    \ []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3pd089vl_test.go:27:54: cannot convert 2 (untyped int constant) to []int

    /tmp/tmp3pd089vl_test.go:28:54: cannot convert 2 (untyped int constant) to []int

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074438
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := make([]int, 0)\n    odd_list = append(odd_list,\
    \ 1)\n    for i := 2; i < n; i++ {\n        if odd_list[i-1]%2 == 0 {\n      \
    \      odd_list[i] = odd_list[i-1]/2\n        } else {\n            odd_list[i]\
    \ = 3*odd_list[i-1]+1\n        }\n    }\n    return odd_list\n}\n\nfunc TestGet_Odd_Collatz(t\
    \ *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5),\
    \ expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3,\
    \ 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\npanic: runtime error: index out\
    \ of range [1] with length 1 [recovered]\n\tpanic: runtime error: index out of\
    \ range [1] with length 1\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513760,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513760, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.get_odd_collatz(...)\n\t/tmp/tmpc1jud2es_test.go:25\n\
    command-line-arguments_test.TestGet_Odd_Collatz(0x0?)\n\t/tmp/tmpc1jud2es_test.go:41\
    \ +0x632\ntesting.tRunner(0xc0000da340, 0x529088)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074300
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := make([]int, 0)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, n)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    \nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11,\
    \ 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual:\
    \ candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected:\
    \ []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvap_jo7i_test.go:74:6: expected ''('', found TestGet_Odd_Collatz

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074298
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := make([]int, 0)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, n)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    \nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11,\
    \ 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual:\
    \ candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected:\
    \ []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvap_jo7i_test.go:74:6: expected ''('', found TestGet_Odd_Collatz

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074298
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := make([]int, 0)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, n)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    \nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11,\
    \ 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual:\
    \ candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected:\
    \ []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvap_jo7i_test.go:74:6: expected ''('', found TestGet_Odd_Collatz

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074298
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := []int{}\n    odd_list = append(odd_list, n)\n\
    \    odd_list = append(odd_list, 1)\n    for i := 2; i < n; i++ {\n        if\
    \ odd_list[i-1]%2 == 0 {\n            odd_list[i] = odd_list[i-1]/2\n        }\
    \ else {\n            odd_list[i] = odd_list[i-1]*3+1 \n        }\n    }\n   \
    \ return odd_list\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate\
    \ := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected:\
    \ []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1,\
    \ 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual:\
    \ candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\npanic: runtime error: index out\
    \ of range [2] with length 2 [recovered]\n\tpanic: runtime error: index out of\
    \ range [2] with length 2\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513760,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513760, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.get_odd_collatz(...)\n\t/tmp/tmp72v0zjh2_test.go:29\n\
    command-line-arguments_test.TestGet_Odd_Collatz(0x0?)\n\t/tmp/tmp72v0zjh2_test.go:42\
    \ +0x6d1\ntesting.tRunner(0xc0000da1a0, 0x529088)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074439
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := []int{}\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, n)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11,\
    \ 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual:\
    \ candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected:\
    \ []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpagn925m6_test.go:74:6: expected ''('', found TestGet_Odd_Collatz

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074298
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := []int{}\n    if n == 1 {\n        return odd_list\n\
    \    }\n    odd_list = append(odd_list, n)\n    odd_list = append(odd_list, get_odd_collatz(n/2)*2)\n\
    \    odd_list = append(odd_list, get_odd_collatz(n/2)*2+1)\n    odd_list = append(odd_list,\
    \ get_odd_collatz(n/2)*2+2)\n    odd_list = append(odd_list, get_odd_collatz(n/2)*2+3)\n\
    \    odd_list = append(odd_list, get_odd_collatz(n/2)*2+4)\n    odd_list = append(odd_list,\
    \ get_odd_collatz(n/2)*2+5)\n    odd_list = append(odd_list, get_odd_collatz(n/2)*2+6)\n\
    \    odd_list = append(odd_list, get_odd_collatz(n/2)*2+7)\n    odd_list = append(odd_list,\
    \ get_odd_collatz(n/2)*2+8)\n    odd_list = append(odd_list, get_odd_collatz(n/2)*2+9)\n\
    \    odd_list = append(odd_list, get_odd_collatz(n/2)*2+10)\n    odd_list = append(odd_list,\
    \ get_odd_collatz(n/2)*2+11)\n    odd_list = append(odd_list, get_odd_collatz(n/2)*2+12)\n\
    \    odd_list = append(odd_list, get_odd_collatz(n/2)*2+13)\n    odd_list = append(odd_list,\
    \ get_odd_collatz(n/2)*2+14)\n    odd_list = append(odd_list, get_odd_collatz(n/2)*2+15)\n\
    \    odd_list = append(odd_list, get_odd_collatz(n/2)*2+16)\n    odd_list = append(odd_list,\
    \ get_odd_collatz(n/2)*2+17)\n    odd_list = append(odd_list, get_odd_collatz(n/2)*2+18)\n\
    \    odd_list = append(odd_list, get_odd_collatz(n/2)*2+19)\n    odd_list = append(odd_list,\
    \ get_odd_collatz(n/2)*2+20)\n    odd_list = append(odd_list, get_odd_collatz(n/2)*2+21)\n\
    \    odd_list = append(odd_list, get_odd_collatz(n/2)*2+22)\n    odd_list = append(odd_list,\
    \ get_odd_collatz(n/2)*2+23)\n    \nfunc TestGet_Odd_Collatz(t *testing.T) {\n\
    \  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14),\
    \ expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected:\
    \ []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n\
    \     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpp30bvrz__test.go:52:6: expected ''('', found TestGet_Odd_Collatz

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074438
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := make([]int, 0)\n    odd_list = append(odd_list,\
    \ 1)\n    for i := 2; i <= n; i++ {\n        if odd_list[i-1]%2 == 0 {\n     \
    \       odd_list[i] = odd_list[i-1]/2\n        } else {\n            odd_list[i]\
    \ = odd_list[i-1]*3+1 \n        }\n    }\n    return odd_list\n}\n\nfunc TestGet_Odd_Collatz(t\
    \ *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5),\
    \ expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3,\
    \ 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\npanic: runtime error: index out\
    \ of range [1] with length 1 [recovered]\n\tpanic: runtime error: index out of\
    \ range [1] with length 1\n\ngoroutine 20 [running]:\ntesting.tRunner.func1.2({0x513760,\
    \ 0xc000162000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513760, 0xc000162000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.get_odd_collatz(...)\n\t/tmp/tmp8paqnd_a_test.go:25\n\
    command-line-arguments_test.TestGet_Odd_Collatz(0x0?)\n\t/tmp/tmp8paqnd_a_test.go:41\
    \ +0x632\ntesting.tRunner(0xc000103860, 0x529088)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074304
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := make([]int, 0)\n    odd_list = append(odd_list,\
    \ 1)\n    for i := 2; i <= n; i++ {\n        if odd_list[i-1]%2 == 0 {\n     \
    \       odd_list[i] = odd_list[i-1]/2\n        } else {\n            odd_list[i]\
    \ = 3*odd_list[i-1] + 1\n        }\n    }\n    return odd_list\n}\n\nfunc TestGet_Odd_Collatz(t\
    \ *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5),\
    \ expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3,\
    \ 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\npanic: runtime error: index out\
    \ of range [1] with length 1 [recovered]\n\tpanic: runtime error: index out of\
    \ range [1] with length 1\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513760,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513760, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.get_odd_collatz(...)\n\t/tmp/tmpsg9_2rno_test.go:25\n\
    command-line-arguments_test.TestGet_Odd_Collatz(0x0?)\n\t/tmp/tmpsg9_2rno_test.go:41\
    \ +0x632\ntesting.tRunner(0xc0000da1a0, 0x529088)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074299
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := make([]int, 0)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, n)\n    for i := 2; i < n; i++ {\n     \
    \   if odd_list[i] % 2 == 0 {\n            odd_list[i] = odd_list[i] / 2\n   \
    \         odd_list = append(odd_list, odd_list[i]*2)\n        } else {\n     \
    \       odd_list[i] = odd_list[i] * 3 + 1\n            odd_list = append(odd_list,\
    \ odd_list[i])\n        }\n    }\n    return odd_list\n}\n\nfunc TestGet_Odd_Collatz(t\
    \ *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5),\
    \ expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3,\
    \ 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\npanic: runtime error: index out\
    \ of range [2] with length 2 [recovered]\n\tpanic: runtime error: index out of\
    \ range [2] with length 2\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513760,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513760, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.get_odd_collatz(...)\n\t/tmp/tmp6pd011_9_test.go:26\n\
    command-line-arguments_test.TestGet_Odd_Collatz(0x0?)\n\t/tmp/tmp6pd011_9_test.go:44\
    \ +0x8a5\ntesting.tRunner(0xc0000da340, 0x529088)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074299
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := make([]int, 0)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, n)\n    for i := 2; i < n; i++ {\n     \
    \   if odd_list[i] % 2 == 0 {\n            odd_list[i] = odd_list[i] / 2\n   \
    \         odd_list = append(odd_list, odd_list[i]*2)\n        } else {\n     \
    \       odd_list[i] = odd_list[i] * 3 + 1\n            odd_list = append(odd_list,\
    \ odd_list[i])\n        }\n    }\n    return odd_list\n}\n\nfunc TestGet_Odd_Collatz(t\
    \ *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5),\
    \ expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3,\
    \ 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\npanic: runtime error: index out\
    \ of range [2] with length 2 [recovered]\n\tpanic: runtime error: index out of\
    \ range [2] with length 2\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513760,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513760, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.get_odd_collatz(...)\n\t/tmp/tmp6pd011_9_test.go:26\n\
    command-line-arguments_test.TestGet_Odd_Collatz(0x0?)\n\t/tmp/tmp6pd011_9_test.go:44\
    \ +0x8a5\ntesting.tRunner(0xc0000da340, 0x529088)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074299
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := make([]int, 0)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, n)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    \nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11,\
    \ 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual:\
    \ candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected:\
    \ []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvap_jo7i_test.go:74:6: expected ''('', found TestGet_Odd_Collatz

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074298
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := make([]int, 0)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, n)\n    for i := 2; i < n; i++ {\n     \
    \   if odd_list[i-1]%2 == 0 {\n            odd_list[i] = odd_list[i-1]/2\n   \
    \     } else {\n            odd_list[i] = odd_list[i-1]*3 + 1 \n        }\n  \
    \  }\n    return odd_list\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate\
    \ := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected:\
    \ []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1,\
    \ 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual:\
    \ candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\npanic: runtime error: index out\
    \ of range [2] with length 2 [recovered]\n\tpanic: runtime error: index out of\
    \ range [2] with length 2\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2({0x513760,\
    \ 0xc0001ce000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513760, 0xc0001ce000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.get_odd_collatz(...)\n\t/tmp/tmphwz1msx__test.go:27\n\
    command-line-arguments_test.TestGet_Odd_Collatz(0x0?)\n\t/tmp/tmphwz1msx__test.go:42\
    \ +0x71c\ntesting.tRunner(0xc00019b1e0, 0x529088)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074299
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := []int{}\n    odd_list = append(odd_list, n)\n\
    \    for i := 1; i < n; i++ {\n        if n%2 == 0 {\n            odd_list = append(odd_list,\
    \ n/2)\n        } else {\n            odd_list = append(odd_list, 3*n+1)\n   \
    \     }\n    }\n    return odd_list\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T)\
    \ {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14),\
    \ expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected:\
    \ []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n\
    \     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0\
    \ (0.00s)\n        tmp1zrfo52w_test.go:50: expected '[%!s(int=1) %!s(int=5) %!s(int=7)\
    \ %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=14) %!s(int=7) %!s(int=7)\
    \ %!s(int=7) %!s(int=7) %!s(int=7) %!s(int=7) %!s(int=7) %!s(int=7) %!s(int=7)\
    \ %!s(int=7) %!s(int=7) %!s(int=7) %!s(int=7)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1\
    \ (0.00s)\n        tmp1zrfo52w_test.go:50: expected '[%!s(int=1) %!s(int=5)]',\
    \ got '[%!s(int=5) %!s(int=16) %!s(int=16) %!s(int=16) %!s(int=16)]'\n    ---\
    \ FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmp1zrfo52w_test.go:50:\
    \ expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=12) %!s(int=6)\
    \ %!s(int=6) %!s(int=6) %!s(int=6) %!s(int=6) %!s(int=6) %!s(int=6) %!s(int=6)\
    \ %!s(int=6) %!s(int=6) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\n\
    FAIL\n"
  timestamp: 1660074439
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := []int{}\n    odd_list = append(odd_list, 1)\n\
    \    for i := 2; i <= n; i++ {\n        if odd_list[i-1]%2 == 0 {\n          \
    \  odd_list[i] = odd_list[i-1]/2\n        } else {\n            odd_list[i] =\
    \ odd_list[i-1]*3 + 1 \n        }\n    }\n    return odd_list\n}\n\nfunc TestGet_Odd_Collatz(t\
    \ *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5),\
    \ expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3,\
    \ 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\npanic: runtime error: index out\
    \ of range [1] with length 1 [recovered]\n\tpanic: runtime error: index out of\
    \ range [1] with length 1\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513760,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513760, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.get_odd_collatz(...)\n\t/tmp/tmpmmoqq1q6_test.go:25\n\
    command-line-arguments_test.TestGet_Odd_Collatz(0x0?)\n\t/tmp/tmpmmoqq1q6_test.go:41\
    \ +0x5fd\ntesting.tRunner(0xc0000da340, 0x529088)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074301
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := make([]int, 0)\n    odd_list = append(odd_list,\
    \ n)\n    odd_list = append(odd_list, 1)\n    for i := 2; i < n; i++ {\n     \
    \   if odd_list[i-1]%2 == 0 {\n            odd_list[i] = odd_list[i-1]/2\n   \
    \     } else {\n            odd_list[i] = 3*odd_list[i-1] + 1\n        }\n   \
    \ }\n    return odd_list\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate\
    \ := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected:\
    \ []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1,\
    \ 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual:\
    \ candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\npanic: runtime error: index out\
    \ of range [2] with length 2 [recovered]\n\tpanic: runtime error: index out of\
    \ range [2] with length 2\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2({0x513760,\
    \ 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513760, 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.get_odd_collatz(...)\n\t/tmp/tmp4u3jgth0_test.go:29\n\
    command-line-arguments_test.TestGet_Odd_Collatz(0x0?)\n\t/tmp/tmp4u3jgth0_test.go:42\
    \ +0x711\ntesting.tRunner(0xc0001031e0, 0x529088)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074439
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := []int{}\n    odd_list = append(odd_list, 1)\n\
    \    for i := 2; i <= n; i++ {\n        if i%2 == 0 {\n            odd_list =\
    \ append(odd_list, 3*i+1)\n        } else {\n            odd_list = append(odd_list,\
    \ 3*i)\n        }\n    }\n    return odd_list\n}\n\nfunc TestGet_Odd_Collatz(t\
    \ *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5),\
    \ expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3,\
    \ 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0\
    \ (0.00s)\n        tmp2m7yl0gx_test.go:50: expected '[%!s(int=1) %!s(int=5) %!s(int=7)\
    \ %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=1) %!s(int=7) %!s(int=9)\
    \ %!s(int=13) %!s(int=15) %!s(int=19) %!s(int=21) %!s(int=25) %!s(int=27) %!s(int=31)\
    \ %!s(int=33) %!s(int=37) %!s(int=39) %!s(int=43)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1\
    \ (0.00s)\n        tmp2m7yl0gx_test.go:50: expected '[%!s(int=1) %!s(int=5)]',\
    \ got '[%!s(int=1) %!s(int=7) %!s(int=9) %!s(int=13) %!s(int=15)]'\n    --- FAIL:\
    \ TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmp2m7yl0gx_test.go:50: expected\
    \ '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=1) %!s(int=7) %!s(int=9)\
    \ %!s(int=13) %!s(int=15) %!s(int=19) %!s(int=21) %!s(int=25) %!s(int=27) %!s(int=31)\
    \ %!s(int=33) %!s(int=37)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074438
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    var odd_list []int\n    odd_list = append(odd_list, 1)\n \
    \   for i := 2; i <= n; i++ {\n        if i%2 == 0 {\n            odd_list = append(odd_list,\
    \ i*2)\n        } else {\n            odd_list = append(odd_list, i*2+3)\n   \
    \     }\n    }\n    return odd_list\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T)\
    \ {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14),\
    \ expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected:\
    \ []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n\
    \     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0\
    \ (0.00s)\n        tmph34sx2_4_test.go:50: expected '[%!s(int=1) %!s(int=5) %!s(int=7)\
    \ %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=1) %!s(int=4) %!s(int=9)\
    \ %!s(int=8) %!s(int=13) %!s(int=12) %!s(int=17) %!s(int=16) %!s(int=21) %!s(int=20)\
    \ %!s(int=25) %!s(int=24) %!s(int=29) %!s(int=28)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1\
    \ (0.00s)\n        tmph34sx2_4_test.go:50: expected '[%!s(int=1) %!s(int=5)]',\
    \ got '[%!s(int=1) %!s(int=4) %!s(int=9) %!s(int=8) %!s(int=13)]'\n    --- FAIL:\
    \ TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmph34sx2_4_test.go:50: expected\
    \ '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=1) %!s(int=4) %!s(int=9)\
    \ %!s(int=8) %!s(int=13) %!s(int=12) %!s(int=17) %!s(int=16) %!s(int=21) %!s(int=20)\
    \ %!s(int=25) %!s(int=24)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074299
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := []int{}\n    odd_list = append(odd_list, 1)\n\
    \    for i := 2; i < n; i++ {\n        if odd_list[i-1]%2 == 0 {\n           \
    \ odd_list[i] = odd_list[i-1]/2\n        } else {\n            odd_list[i] = 3*odd_list[i-1]+1\n\
    \        }\n    }\n    return odd_list\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T)\
    \ {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14),\
    \ expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected:\
    \ []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n\
    \     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\npanic: runtime error: index out\
    \ of range [1] with length 1 [recovered]\n\tpanic: runtime error: index out of\
    \ range [1] with length 1\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513760,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513760, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.get_odd_collatz(...)\n\t/tmp/tmpws7flsmv_test.go:25\n\
    command-line-arguments_test.TestGet_Odd_Collatz(0x0?)\n\t/tmp/tmpws7flsmv_test.go:41\
    \ +0x5fd\ntesting.tRunner(0xc0000cc4e0, 0x529088)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074302
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := make([]int, 0)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, n)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    \nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11,\
    \ 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual:\
    \ candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected:\
    \ []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvap_jo7i_test.go:74:6: expected ''('', found TestGet_Odd_Collatz

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074298
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := make([]int, 0)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, n)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    \nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11,\
    \ 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual:\
    \ candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected:\
    \ []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvap_jo7i_test.go:74:6: expected ''('', found TestGet_Odd_Collatz

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074298
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := []int{}\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, n)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11,\
    \ 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual:\
    \ candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected:\
    \ []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpagn925m6_test.go:74:6: expected ''('', found TestGet_Odd_Collatz

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074298
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := make([]int, 0)\n    odd_list = append(odd_list,\
    \ 1)\n    for i := 2; i <= n; i++ {\n        if odd_list[i-1]%2 == 0 {\n     \
    \       odd_list[i] = odd_list[i-1]/2\n        } else {\n            odd_list[i]\
    \ = 3*odd_list[i-1] + 1\n        }\n    }\n    return odd_list\n}\n\nfunc TestGet_Odd_Collatz(t\
    \ *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5),\
    \ expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3,\
    \ 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\npanic: runtime error: index out\
    \ of range [1] with length 1 [recovered]\n\tpanic: runtime error: index out of\
    \ range [1] with length 1\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513760,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513760, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.get_odd_collatz(...)\n\t/tmp/tmpsg9_2rno_test.go:25\n\
    command-line-arguments_test.TestGet_Odd_Collatz(0x0?)\n\t/tmp/tmpsg9_2rno_test.go:41\
    \ +0x632\ntesting.tRunner(0xc0000da1a0, 0x529088)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074299
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := make([]int, 0)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, n)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    \nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11,\
    \ 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual:\
    \ candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected:\
    \ []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvap_jo7i_test.go:74:6: expected ''('', found TestGet_Odd_Collatz

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074298
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := make([]int, 0)\n    odd_list = append(odd_list,\
    \ 1)\n    for i := 2; i <= n; i++ {\n        if i%2 == 0 {\n            odd_list\
    \ = append(odd_list, i*2)\n        } else {\n            odd_list = append(odd_list,\
    \ i*2+3)\n        }\n    }\n    return odd_list\n}\n\nfunc TestGet_Odd_Collatz(t\
    \ *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5),\
    \ expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3,\
    \ 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0\
    \ (0.00s)\n        tmpc21apk61_test.go:50: expected '[%!s(int=1) %!s(int=5) %!s(int=7)\
    \ %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=1) %!s(int=4) %!s(int=9)\
    \ %!s(int=8) %!s(int=13) %!s(int=12) %!s(int=17) %!s(int=16) %!s(int=21) %!s(int=20)\
    \ %!s(int=25) %!s(int=24) %!s(int=29) %!s(int=28)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1\
    \ (0.00s)\n        tmpc21apk61_test.go:50: expected '[%!s(int=1) %!s(int=5)]',\
    \ got '[%!s(int=1) %!s(int=4) %!s(int=9) %!s(int=8) %!s(int=13)]'\n    --- FAIL:\
    \ TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpc21apk61_test.go:50: expected\
    \ '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=1) %!s(int=4) %!s(int=9)\
    \ %!s(int=8) %!s(int=13) %!s(int=12) %!s(int=17) %!s(int=16) %!s(int=21) %!s(int=20)\
    \ %!s(int=25) %!s(int=24)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074299
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := make([]int, 0)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, n)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    \nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11,\
    \ 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual:\
    \ candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected:\
    \ []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvap_jo7i_test.go:74:6: expected ''('', found TestGet_Odd_Collatz

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074298
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := []int{}\n    odd_list = append(odd_list, 1)\n\
    \    for i := 2; i <= n; i++ {\n        if i%2 == 0 {\n            odd_list =\
    \ append(odd_list, i*2)\n        } else {\n            odd_list = append(odd_list,\
    \ i*2+3)\n        }\n    }\n    return odd_list\n}\n\nfunc TestGet_Odd_Collatz(t\
    \ *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5),\
    \ expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3,\
    \ 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0\
    \ (0.00s)\n        tmp0ojeejx4_test.go:50: expected '[%!s(int=1) %!s(int=5) %!s(int=7)\
    \ %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=1) %!s(int=4) %!s(int=9)\
    \ %!s(int=8) %!s(int=13) %!s(int=12) %!s(int=17) %!s(int=16) %!s(int=21) %!s(int=20)\
    \ %!s(int=25) %!s(int=24) %!s(int=29) %!s(int=28)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1\
    \ (0.00s)\n        tmp0ojeejx4_test.go:50: expected '[%!s(int=1) %!s(int=5)]',\
    \ got '[%!s(int=1) %!s(int=4) %!s(int=9) %!s(int=8) %!s(int=13)]'\n    --- FAIL:\
    \ TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmp0ojeejx4_test.go:50: expected\
    \ '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=1) %!s(int=4) %!s(int=9)\
    \ %!s(int=8) %!s(int=13) %!s(int=12) %!s(int=17) %!s(int=16) %!s(int=21) %!s(int=20)\
    \ %!s(int=25) %!s(int=24)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074299
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    var odd_list []int\n    odd_list = append(odd_list, 1)\n \
    \   for i := 2; i <= n; i++ {\n        if i%2 == 0 {\n            odd_list = append(odd_list,\
    \ i*2)\n        } else {\n            odd_list = append(odd_list, i*2+3)\n   \
    \     }\n    }\n    return odd_list\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T)\
    \ {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14),\
    \ expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected:\
    \ []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n\
    \     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0\
    \ (0.00s)\n        tmph34sx2_4_test.go:50: expected '[%!s(int=1) %!s(int=5) %!s(int=7)\
    \ %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=1) %!s(int=4) %!s(int=9)\
    \ %!s(int=8) %!s(int=13) %!s(int=12) %!s(int=17) %!s(int=16) %!s(int=21) %!s(int=20)\
    \ %!s(int=25) %!s(int=24) %!s(int=29) %!s(int=28)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1\
    \ (0.00s)\n        tmph34sx2_4_test.go:50: expected '[%!s(int=1) %!s(int=5)]',\
    \ got '[%!s(int=1) %!s(int=4) %!s(int=9) %!s(int=8) %!s(int=13)]'\n    --- FAIL:\
    \ TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmph34sx2_4_test.go:50: expected\
    \ '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=1) %!s(int=4) %!s(int=9)\
    \ %!s(int=8) %!s(int=13) %!s(int=12) %!s(int=17) %!s(int=16) %!s(int=21) %!s(int=20)\
    \ %!s(int=25) %!s(int=24)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074299
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := []int{}\n    odd_list = append(odd_list, 1)\n\
    \    for i := 2; i <= n; i++ {\n        if i%2 == 0 {\n            odd_list =\
    \ append(odd_list, i*2)\n        } else {\n            odd_list = append(odd_list,\
    \ i*2+3)\n        }\n    }\n    return odd_list\n}\n\nfunc TestGet_Odd_Collatz(t\
    \ *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5),\
    \ expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3,\
    \ 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0\
    \ (0.00s)\n        tmp0ojeejx4_test.go:50: expected '[%!s(int=1) %!s(int=5) %!s(int=7)\
    \ %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=1) %!s(int=4) %!s(int=9)\
    \ %!s(int=8) %!s(int=13) %!s(int=12) %!s(int=17) %!s(int=16) %!s(int=21) %!s(int=20)\
    \ %!s(int=25) %!s(int=24) %!s(int=29) %!s(int=28)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1\
    \ (0.00s)\n        tmp0ojeejx4_test.go:50: expected '[%!s(int=1) %!s(int=5)]',\
    \ got '[%!s(int=1) %!s(int=4) %!s(int=9) %!s(int=8) %!s(int=13)]'\n    --- FAIL:\
    \ TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmp0ojeejx4_test.go:50: expected\
    \ '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=1) %!s(int=4) %!s(int=9)\
    \ %!s(int=8) %!s(int=13) %!s(int=12) %!s(int=17) %!s(int=16) %!s(int=21) %!s(int=20)\
    \ %!s(int=25) %!s(int=24)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074299
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := make([]int, 0)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, n)\n    for i := 2; i < n; i++ {\n     \
    \   if odd_list[i] % 2 == 0 {\n            odd_list[i] = odd_list[i] / 2\n   \
    \         odd_list[i+1] = odd_list[i] * 3 + 1\n        } else {\n            odd_list[i]\
    \ = odd_list[i] / 2\n        }\n    }\n    return odd_list\n}\n\nfunc TestGet_Odd_Collatz(t\
    \ *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5),\
    \ expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3,\
    \ 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\npanic: runtime error: index out\
    \ of range [2] with length 2 [recovered]\n\tpanic: runtime error: index out of\
    \ range [2] with length 2\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513760,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513760, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.get_odd_collatz(...)\n\t/tmp/tmpi7y0eg7m_test.go:26\n\
    command-line-arguments_test.TestGet_Odd_Collatz(0x0?)\n\t/tmp/tmpi7y0eg7m_test.go:43\
    \ +0x726\ntesting.tRunner(0xc0000cc4e0, 0x529088)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074439
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := []int{}\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, n)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11,\
    \ 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual:\
    \ candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected:\
    \ []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpagn925m6_test.go:74:6: expected ''('', found TestGet_Odd_Collatz

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074298
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := make([]int, 0)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, n)\n    for i := 2; i < n; i++ {\n     \
    \   if odd_list[i] % 2 == 0 {\n            odd_list[i] = odd_list[i]/2\n     \
    \   } else {\n            odd_list[i] = odd_list[i] * 3 + 1 \n        }\n    }\n\
    \    return odd_list\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate\
    \ := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected:\
    \ []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1,\
    \ 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual:\
    \ candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\npanic: runtime error: index out\
    \ of range [2] with length 2 [recovered]\n\tpanic: runtime error: index out of\
    \ range [2] with length 2\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513760,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513760, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.get_odd_collatz(...)\n\t/tmp/tmp0obj3rcb_test.go:26\n\
    command-line-arguments_test.TestGet_Odd_Collatz(0x0?)\n\t/tmp/tmp0obj3rcb_test.go:42\
    \ +0x6a5\ntesting.tRunner(0xc0000da340, 0x529088)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074303
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    var odd_list []int\n    odd_list = append(odd_list, 1)\n \
    \   for i := 2; i <= n; i++ {\n        if i%2 == 0 {\n            odd_list = append(odd_list,\
    \ i*2)\n        } else {\n            odd_list = append(odd_list, i*2+3)\n   \
    \     }\n    }\n    return odd_list\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T)\
    \ {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14),\
    \ expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected:\
    \ []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n\
    \     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0\
    \ (0.00s)\n        tmph34sx2_4_test.go:50: expected '[%!s(int=1) %!s(int=5) %!s(int=7)\
    \ %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=1) %!s(int=4) %!s(int=9)\
    \ %!s(int=8) %!s(int=13) %!s(int=12) %!s(int=17) %!s(int=16) %!s(int=21) %!s(int=20)\
    \ %!s(int=25) %!s(int=24) %!s(int=29) %!s(int=28)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1\
    \ (0.00s)\n        tmph34sx2_4_test.go:50: expected '[%!s(int=1) %!s(int=5)]',\
    \ got '[%!s(int=1) %!s(int=4) %!s(int=9) %!s(int=8) %!s(int=13)]'\n    --- FAIL:\
    \ TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmph34sx2_4_test.go:50: expected\
    \ '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=1) %!s(int=4) %!s(int=9)\
    \ %!s(int=8) %!s(int=13) %!s(int=12) %!s(int=17) %!s(int=16) %!s(int=21) %!s(int=20)\
    \ %!s(int=25) %!s(int=24)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074299
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := []int{}\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, n)\n    for i := 2; i < n; i++ {\n        if\
    \ odd_list[i-1]%2 == 0 {\n            odd_list[i] = odd_list[i-1]/2\n        }\
    \ else {\n            odd_list[i] = odd_list[i-1]*3 + 1 \n        }\n    }\n \
    \   return odd_list\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate\
    \ := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected:\
    \ []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1,\
    \ 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual:\
    \ candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\npanic: runtime error: index out\
    \ of range [2] with length 2 [recovered]\n\tpanic: runtime error: index out of\
    \ range [2] with length 2\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513760,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513760, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.get_odd_collatz(...)\n\t/tmp/tmpgnzni6lj_test.go:27\n\
    command-line-arguments_test.TestGet_Odd_Collatz(0x0?)\n\t/tmp/tmpgnzni6lj_test.go:42\
    \ +0x6dc\ntesting.tRunner(0xc0000cc680, 0x529088)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074299
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := make([]int, 0)\n    odd_list = append(odd_list,\
    \ 1)\n    for i := 2; i < n; i++ {\n        if odd_list[i-1]%2 == 0 {\n      \
    \      odd_list[i] = odd_list[i-1]/2\n        } else {\n            odd_list[i]\
    \ = odd_list[i-1]*3 + 1 \n        }\n    }\n    return odd_list\n}\n\nfunc TestGet_Odd_Collatz(t\
    \ *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5),\
    \ expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3,\
    \ 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\npanic: runtime error: index out\
    \ of range [1] with length 1 [recovered]\n\tpanic: runtime error: index out of\
    \ range [1] with length 1\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513760,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513760, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.get_odd_collatz(...)\n\t/tmp/tmp_h2fn39d_test.go:25\n\
    command-line-arguments_test.TestGet_Odd_Collatz(0x0?)\n\t/tmp/tmp_h2fn39d_test.go:41\
    \ +0x632\ntesting.tRunner(0xc0000cc4e0, 0x529088)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074438
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := make([]int, 0)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, n)\n    for i := 2; i < n; i++ {\n     \
    \   if odd_list[i-1]%2 == 0 {\n            odd_list[i] = odd_list[i-1]/2\n   \
    \     } else {\n            odd_list[i] = odd_list[i-1]*3 + 1 \n        }\n  \
    \  }\n    return odd_list\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate\
    \ := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected:\
    \ []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1,\
    \ 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual:\
    \ candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\npanic: runtime error: index out\
    \ of range [2] with length 2 [recovered]\n\tpanic: runtime error: index out of\
    \ range [2] with length 2\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2({0x513760,\
    \ 0xc0001ce000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513760, 0xc0001ce000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.get_odd_collatz(...)\n\t/tmp/tmphwz1msx__test.go:27\n\
    command-line-arguments_test.TestGet_Odd_Collatz(0x0?)\n\t/tmp/tmphwz1msx__test.go:42\
    \ +0x71c\ntesting.tRunner(0xc00019b1e0, 0x529088)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074299
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := []int{}\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, n)\n    for i := 2; i < n; i++ {\n        if\
    \ odd_list[i-1]%2 == 0 {\n            odd_list[i] = odd_list[i-1]/2\n        }\
    \ else {\n            odd_list[i] = odd_list[i-1]*3+1 \n        }\n    }\n   \
    \ return odd_list\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate\
    \ := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected:\
    \ []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1,\
    \ 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual:\
    \ candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\npanic: runtime error: index out\
    \ of range [2] with length 2 [recovered]\n\tpanic: runtime error: index out of\
    \ range [2] with length 2\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2({0x513760,\
    \ 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513760, 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.get_odd_collatz(...)\n\t/tmp/tmpypxq71gs_test.go:27\n\
    command-line-arguments_test.TestGet_Odd_Collatz(0x0?)\n\t/tmp/tmpypxq71gs_test.go:42\
    \ +0x6dc\ntesting.tRunner(0xc0001031e0, 0x529088)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074301
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := []int{}\n    odd_list = append(odd_list, n)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11,\
    \ 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual:\
    \ candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected:\
    \ []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpp9791e82_test.go:74:6: expected ''('', found TestGet_Odd_Collatz

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074303
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := make([]int, 0)\n    odd_list = append(odd_list,\
    \ n)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    \nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11,\
    \ 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual:\
    \ candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected:\
    \ []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp3ndub0ke_test.go:74:6: expected ''('', found TestGet_Odd_Collatz

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074298
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := make([]int, 0)\n    odd_list = append(odd_list,\
    \ n)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    \nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11,\
    \ 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual:\
    \ candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected:\
    \ []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp3ndub0ke_test.go:74:6: expected ''('', found TestGet_Odd_Collatz

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074298
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := make([]int, 0)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, n)\n    for i := 2; i < n; i++ {\n     \
    \   if odd_list[i] % 2 == 0 {\n            odd_list[i] = odd_list[i] / 2\n   \
    \         odd_list = append(odd_list, odd_list[i]*2)\n        } else {\n     \
    \       odd_list[i] = odd_list[i] * 3 + 1\n            odd_list = append(odd_list,\
    \ odd_list[i])\n        }\n    }\n    return odd_list\n}\n\nfunc TestGet_Odd_Collatz(t\
    \ *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5),\
    \ expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3,\
    \ 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\npanic: runtime error: index out\
    \ of range [2] with length 2 [recovered]\n\tpanic: runtime error: index out of\
    \ range [2] with length 2\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513760,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513760, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.get_odd_collatz(...)\n\t/tmp/tmp6pd011_9_test.go:26\n\
    command-line-arguments_test.TestGet_Odd_Collatz(0x0?)\n\t/tmp/tmp6pd011_9_test.go:44\
    \ +0x8a5\ntesting.tRunner(0xc0000da340, 0x529088)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074299
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := make([]int, 0)\n    odd_list = append(odd_list,\
    \ 1)\n    for i := 2; i <= n; i++ {\n        if odd_list[i-1]%2 == 0 {\n     \
    \       odd_list[i] = odd_list[i-1]/2\n        } else {\n            odd_list[i]\
    \ = odd_list[i-1]*3 + 1 \n        }\n    }\n    return odd_list\n}\n\nfunc TestGet_Odd_Collatz(t\
    \ *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5),\
    \ expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3,\
    \ 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\npanic: runtime error: index out\
    \ of range [1] with length 1 [recovered]\n\tpanic: runtime error: index out of\
    \ range [1] with length 1\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513760,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513760, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.get_odd_collatz(...)\n\t/tmp/tmpex1rbtoa_test.go:25\n\
    command-line-arguments_test.TestGet_Odd_Collatz(0x0?)\n\t/tmp/tmpex1rbtoa_test.go:41\
    \ +0x632\ntesting.tRunner(0xc0000da340, 0x529088)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074300
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := make([]int, 0)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, n)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    \nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11,\
    \ 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual:\
    \ candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected:\
    \ []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvap_jo7i_test.go:74:6: expected ''('', found TestGet_Odd_Collatz

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074298
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := []int{}\n    odd_list = append(odd_list, n)\n\
    \    for i := 1; i <= n; i++ {\n        if i%2 == 0 {\n            odd_list =\
    \ append(odd_list, i*2)\n        } else {\n            odd_list = append(odd_list,\
    \ i*2+3)\n        }\n    }\n    return odd_list\n}\n\nfunc TestGet_Odd_Collatz(t\
    \ *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5),\
    \ expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3,\
    \ 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0\
    \ (0.00s)\n        tmpml7e4htu_test.go:50: expected '[%!s(int=1) %!s(int=5) %!s(int=7)\
    \ %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=14) %!s(int=5) %!s(int=4)\
    \ %!s(int=9) %!s(int=8) %!s(int=13) %!s(int=12) %!s(int=17) %!s(int=16) %!s(int=21)\
    \ %!s(int=20) %!s(int=25) %!s(int=24) %!s(int=29) %!s(int=28)]'\n    --- FAIL:\
    \ TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpml7e4htu_test.go:50: expected\
    \ '[%!s(int=1) %!s(int=5)]', got '[%!s(int=5) %!s(int=5) %!s(int=4) %!s(int=9)\
    \ %!s(int=8) %!s(int=13)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n\
    \        tmpml7e4htu_test.go:50: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]',\
    \ got '[%!s(int=12) %!s(int=5) %!s(int=4) %!s(int=9) %!s(int=8) %!s(int=13) %!s(int=12)\
    \ %!s(int=17) %!s(int=16) %!s(int=21) %!s(int=20) %!s(int=25) %!s(int=24)]'\n\
    \    --- FAIL: TestGet_Odd_Collatz/test_num__3 (0.00s)\n        tmpml7e4htu_test.go:50:\
    \ expected '[%!s(int=1)]', got '[%!s(int=1) %!s(int=5)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074439
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := []int{}\n    odd_list = append(odd_list, n)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11,\
    \ 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual:\
    \ candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected:\
    \ []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpp9791e82_test.go:74:6: expected ''('', found TestGet_Odd_Collatz

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074303
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := []int{}\n    odd_list = append(odd_list, 1)\n\
    \    for i := 2; i <= n; i++ {\n        if i%2 == 0 {\n            odd_list =\
    \ append(odd_list, i*2)\n        } else {\n            odd_list = append(odd_list,\
    \ i*2+3)\n        }\n    }\n    return odd_list\n}\n\nfunc TestGet_Odd_Collatz(t\
    \ *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5),\
    \ expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3,\
    \ 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0\
    \ (0.00s)\n        tmp0ojeejx4_test.go:50: expected '[%!s(int=1) %!s(int=5) %!s(int=7)\
    \ %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=1) %!s(int=4) %!s(int=9)\
    \ %!s(int=8) %!s(int=13) %!s(int=12) %!s(int=17) %!s(int=16) %!s(int=21) %!s(int=20)\
    \ %!s(int=25) %!s(int=24) %!s(int=29) %!s(int=28)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1\
    \ (0.00s)\n        tmp0ojeejx4_test.go:50: expected '[%!s(int=1) %!s(int=5)]',\
    \ got '[%!s(int=1) %!s(int=4) %!s(int=9) %!s(int=8) %!s(int=13)]'\n    --- FAIL:\
    \ TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmp0ojeejx4_test.go:50: expected\
    \ '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=1) %!s(int=4) %!s(int=9)\
    \ %!s(int=8) %!s(int=13) %!s(int=12) %!s(int=17) %!s(int=16) %!s(int=21) %!s(int=20)\
    \ %!s(int=25) %!s(int=24)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074299
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := make([]int, 0)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, n)\n    for i := 2; i < n; i++ {\n     \
    \   if odd_list[i-1]%2 == 0 {\n            odd_list[i] = odd_list[i-1]/2\n   \
    \     } else {\n            odd_list[i] = odd_list[i-1]*3 + 1 \n        }\n  \
    \  }\n    return odd_list\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate\
    \ := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected:\
    \ []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1,\
    \ 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual:\
    \ candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\npanic: runtime error: index out\
    \ of range [2] with length 2 [recovered]\n\tpanic: runtime error: index out of\
    \ range [2] with length 2\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2({0x513760,\
    \ 0xc0001ce000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513760, 0xc0001ce000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.get_odd_collatz(...)\n\t/tmp/tmphwz1msx__test.go:27\n\
    command-line-arguments_test.TestGet_Odd_Collatz(0x0?)\n\t/tmp/tmphwz1msx__test.go:42\
    \ +0x71c\ntesting.tRunner(0xc00019b1e0, 0x529088)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074299
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := make([]int, 0)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, n)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    \nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11,\
    \ 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual:\
    \ candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected:\
    \ []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvap_jo7i_test.go:74:6: expected ''('', found TestGet_Odd_Collatz

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074298
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    var odd_list []int\n    odd_list = append(odd_list, 1)\n \
    \   for i := 2; i <= n; i++ {\n        if i%2 == 0 {\n            odd_list = append(odd_list,\
    \ i*2)\n        } else {\n            odd_list = append(odd_list, i*2+3)\n   \
    \     }\n    }\n    return odd_list\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T)\
    \ {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14),\
    \ expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected:\
    \ []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n\
    \     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0\
    \ (0.00s)\n        tmph34sx2_4_test.go:50: expected '[%!s(int=1) %!s(int=5) %!s(int=7)\
    \ %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=1) %!s(int=4) %!s(int=9)\
    \ %!s(int=8) %!s(int=13) %!s(int=12) %!s(int=17) %!s(int=16) %!s(int=21) %!s(int=20)\
    \ %!s(int=25) %!s(int=24) %!s(int=29) %!s(int=28)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1\
    \ (0.00s)\n        tmph34sx2_4_test.go:50: expected '[%!s(int=1) %!s(int=5)]',\
    \ got '[%!s(int=1) %!s(int=4) %!s(int=9) %!s(int=8) %!s(int=13)]'\n    --- FAIL:\
    \ TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmph34sx2_4_test.go:50: expected\
    \ '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=1) %!s(int=4) %!s(int=9)\
    \ %!s(int=8) %!s(int=13) %!s(int=12) %!s(int=17) %!s(int=16) %!s(int=21) %!s(int=20)\
    \ %!s(int=25) %!s(int=24)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074299
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := make([]int, 0)\n    odd_list = append(odd_list,\
    \ 1)\n    for i := 2; i <= n; i++ {\n        if odd_list[i-1]%2 == 0 {\n     \
    \       odd_list[i] = odd_list[i-1]/2\n        } else {\n            odd_list[i]\
    \ = 3*odd_list[i-1] + 1\n        }\n    }\n    return odd_list\n}\n\nfunc TestGet_Odd_Collatz(t\
    \ *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5),\
    \ expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3,\
    \ 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\npanic: runtime error: index out\
    \ of range [1] with length 1 [recovered]\n\tpanic: runtime error: index out of\
    \ range [1] with length 1\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513760,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513760, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.get_odd_collatz(...)\n\t/tmp/tmpsg9_2rno_test.go:25\n\
    command-line-arguments_test.TestGet_Odd_Collatz(0x0?)\n\t/tmp/tmpsg9_2rno_test.go:41\
    \ +0x632\ntesting.tRunner(0xc0000da1a0, 0x529088)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074299
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := make([]int, 0)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, n)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    \nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11,\
    \ 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual:\
    \ candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected:\
    \ []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvap_jo7i_test.go:74:6: expected ''('', found TestGet_Odd_Collatz

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074298
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := make([]int, 0)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, n)\n    for i := 2; i < n; i++ {\n     \
    \   if odd_list[i-1]%2 == 0 {\n            odd_list[i] = odd_list[i-1]/2\n   \
    \     } else {\n            odd_list[i] = odd_list[i-1]*3 + 1 \n        }\n  \
    \  }\n    return odd_list\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate\
    \ := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected:\
    \ []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1,\
    \ 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual:\
    \ candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\npanic: runtime error: index out\
    \ of range [2] with length 2 [recovered]\n\tpanic: runtime error: index out of\
    \ range [2] with length 2\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2({0x513760,\
    \ 0xc0001ce000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513760, 0xc0001ce000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.get_odd_collatz(...)\n\t/tmp/tmphwz1msx__test.go:27\n\
    command-line-arguments_test.TestGet_Odd_Collatz(0x0?)\n\t/tmp/tmphwz1msx__test.go:42\
    \ +0x71c\ntesting.tRunner(0xc00019b1e0, 0x529088)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074299
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := make([]int, 0)\n    odd_list = append(odd_list,\
    \ 1)\n    for i := 2; i <= n; i++ {\n        if i%2 == 0 {\n            odd_list\
    \ = append(odd_list, i*2)\n        } else {\n            odd_list = append(odd_list,\
    \ i*2+3)\n        }\n    }\n    return odd_list\n}\n\nfunc TestGet_Odd_Collatz(t\
    \ *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5),\
    \ expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3,\
    \ 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0\
    \ (0.00s)\n        tmpc21apk61_test.go:50: expected '[%!s(int=1) %!s(int=5) %!s(int=7)\
    \ %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=1) %!s(int=4) %!s(int=9)\
    \ %!s(int=8) %!s(int=13) %!s(int=12) %!s(int=17) %!s(int=16) %!s(int=21) %!s(int=20)\
    \ %!s(int=25) %!s(int=24) %!s(int=29) %!s(int=28)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1\
    \ (0.00s)\n        tmpc21apk61_test.go:50: expected '[%!s(int=1) %!s(int=5)]',\
    \ got '[%!s(int=1) %!s(int=4) %!s(int=9) %!s(int=8) %!s(int=13)]'\n    --- FAIL:\
    \ TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpc21apk61_test.go:50: expected\
    \ '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=1) %!s(int=4) %!s(int=9)\
    \ %!s(int=8) %!s(int=13) %!s(int=12) %!s(int=17) %!s(int=16) %!s(int=21) %!s(int=20)\
    \ %!s(int=25) %!s(int=24)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074299
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := []int{}\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, n)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11,\
    \ 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual:\
    \ candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected:\
    \ []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpagn925m6_test.go:74:6: expected ''('', found TestGet_Odd_Collatz

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074298
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := []int{}\n    odd_list = append(odd_list, 1)\n\
    \    for i := 2; i <= n; i++ {\n        if i%2 == 0 {\n            odd_list =\
    \ append(odd_list, i*2)\n        } else {\n            odd_list = append(odd_list,\
    \ i*2+3)\n        }\n    }\n    return odd_list\n}\n\nfunc TestGet_Odd_Collatz(t\
    \ *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5),\
    \ expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3,\
    \ 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0\
    \ (0.00s)\n        tmp0ojeejx4_test.go:50: expected '[%!s(int=1) %!s(int=5) %!s(int=7)\
    \ %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=1) %!s(int=4) %!s(int=9)\
    \ %!s(int=8) %!s(int=13) %!s(int=12) %!s(int=17) %!s(int=16) %!s(int=21) %!s(int=20)\
    \ %!s(int=25) %!s(int=24) %!s(int=29) %!s(int=28)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1\
    \ (0.00s)\n        tmp0ojeejx4_test.go:50: expected '[%!s(int=1) %!s(int=5)]',\
    \ got '[%!s(int=1) %!s(int=4) %!s(int=9) %!s(int=8) %!s(int=13)]'\n    --- FAIL:\
    \ TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmp0ojeejx4_test.go:50: expected\
    \ '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=1) %!s(int=4) %!s(int=9)\
    \ %!s(int=8) %!s(int=13) %!s(int=12) %!s(int=17) %!s(int=16) %!s(int=21) %!s(int=20)\
    \ %!s(int=25) %!s(int=24)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074299
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := make([]int, 0)\n    odd_list = append(odd_list,\
    \ 1)\n    for i := 2; i <= n; i++ {\n        if i%2 == 0 {\n            odd_list\
    \ = append(odd_list, i*3)\n        } else {\n            odd_list = append(odd_list,\
    \ i*3+1)\n        }\n    }\n    return odd_list\n}\n\nfunc TestGet_Odd_Collatz(t\
    \ *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5),\
    \ expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3,\
    \ 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0\
    \ (0.00s)\n        tmp2sovfy90_test.go:50: expected '[%!s(int=1) %!s(int=5) %!s(int=7)\
    \ %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=1) %!s(int=6) %!s(int=10)\
    \ %!s(int=12) %!s(int=16) %!s(int=18) %!s(int=22) %!s(int=24) %!s(int=28) %!s(int=30)\
    \ %!s(int=34) %!s(int=36) %!s(int=40) %!s(int=42)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1\
    \ (0.00s)\n        tmp2sovfy90_test.go:50: expected '[%!s(int=1) %!s(int=5)]',\
    \ got '[%!s(int=1) %!s(int=6) %!s(int=10) %!s(int=12) %!s(int=16)]'\n    --- FAIL:\
    \ TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmp2sovfy90_test.go:50: expected\
    \ '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=1) %!s(int=6) %!s(int=10)\
    \ %!s(int=12) %!s(int=16) %!s(int=18) %!s(int=22) %!s(int=24) %!s(int=28) %!s(int=30)\
    \ %!s(int=34) %!s(int=36)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074438
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := []int{}\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, n)\n    for i := 2; i < n; i++ {\n        if\
    \ odd_list[i-1]%2 == 0 {\n            odd_list[i] = odd_list[i-1]/2\n        }\
    \ else {\n            odd_list[i] = odd_list[i-1]*3 + 1 \n        }\n    }\n \
    \   return odd_list\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate\
    \ := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected:\
    \ []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1,\
    \ 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual:\
    \ candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\npanic: runtime error: index out\
    \ of range [2] with length 2 [recovered]\n\tpanic: runtime error: index out of\
    \ range [2] with length 2\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513760,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513760, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.get_odd_collatz(...)\n\t/tmp/tmpgnzni6lj_test.go:27\n\
    command-line-arguments_test.TestGet_Odd_Collatz(0x0?)\n\t/tmp/tmpgnzni6lj_test.go:42\
    \ +0x6dc\ntesting.tRunner(0xc0000cc680, 0x529088)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074299
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := make([]int, 0)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, n)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    \nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11,\
    \ 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual:\
    \ candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected:\
    \ []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvap_jo7i_test.go:74:6: expected ''('', found TestGet_Odd_Collatz

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074298
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := []int{}\n    odd_list = append(odd_list, 1)\n\
    \    for i := 2; i <= n; i++ {\n        if i%2 == 0 {\n            odd_list =\
    \ append(odd_list, i*2)\n        } else {\n            odd_list = append(odd_list,\
    \ i*2+3)\n        }\n    }\n    return odd_list\n}\n\nfunc TestGet_Odd_Collatz(t\
    \ *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5),\
    \ expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3,\
    \ 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0\
    \ (0.00s)\n        tmp0ojeejx4_test.go:50: expected '[%!s(int=1) %!s(int=5) %!s(int=7)\
    \ %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=1) %!s(int=4) %!s(int=9)\
    \ %!s(int=8) %!s(int=13) %!s(int=12) %!s(int=17) %!s(int=16) %!s(int=21) %!s(int=20)\
    \ %!s(int=25) %!s(int=24) %!s(int=29) %!s(int=28)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1\
    \ (0.00s)\n        tmp0ojeejx4_test.go:50: expected '[%!s(int=1) %!s(int=5)]',\
    \ got '[%!s(int=1) %!s(int=4) %!s(int=9) %!s(int=8) %!s(int=13)]'\n    --- FAIL:\
    \ TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmp0ojeejx4_test.go:50: expected\
    \ '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=1) %!s(int=4) %!s(int=9)\
    \ %!s(int=8) %!s(int=13) %!s(int=12) %!s(int=17) %!s(int=16) %!s(int=21) %!s(int=20)\
    \ %!s(int=25) %!s(int=24)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074299
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    var odd_list []int\n    odd_list = append(odd_list, 1)\n \
    \   for i := 2; i <= n; i++ {\n        if i%2 == 0 {\n            odd_list = append(odd_list,\
    \ i*2)\n        } else {\n            odd_list = append(odd_list, i*2+3)\n   \
    \     }\n    }\n    return odd_list\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T)\
    \ {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14),\
    \ expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected:\
    \ []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n\
    \     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0\
    \ (0.00s)\n        tmph34sx2_4_test.go:50: expected '[%!s(int=1) %!s(int=5) %!s(int=7)\
    \ %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=1) %!s(int=4) %!s(int=9)\
    \ %!s(int=8) %!s(int=13) %!s(int=12) %!s(int=17) %!s(int=16) %!s(int=21) %!s(int=20)\
    \ %!s(int=25) %!s(int=24) %!s(int=29) %!s(int=28)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1\
    \ (0.00s)\n        tmph34sx2_4_test.go:50: expected '[%!s(int=1) %!s(int=5)]',\
    \ got '[%!s(int=1) %!s(int=4) %!s(int=9) %!s(int=8) %!s(int=13)]'\n    --- FAIL:\
    \ TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmph34sx2_4_test.go:50: expected\
    \ '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=1) %!s(int=4) %!s(int=9)\
    \ %!s(int=8) %!s(int=13) %!s(int=12) %!s(int=17) %!s(int=16) %!s(int=21) %!s(int=20)\
    \ %!s(int=25) %!s(int=24)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074299
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    var odd_list []int\n    odd_list = append(odd_list, 1)\n \
    \   odd_list = append(odd_list, n)\n    for i := 2; i < n; i++ {\n        if odd_list[i-1]%2\
    \ == 0 {\n            odd_list[i] = odd_list[i-1]/2\n        } else {\n      \
    \      odd_list[i] = odd_list[i-1]*3 + 1 \n        }\n    }\n    return odd_list\n\
    }\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11,\
    \ 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual:\
    \ candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected:\
    \ []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\npanic: runtime error: index out\
    \ of range [2] with length 2 [recovered]\n\tpanic: runtime error: index out of\
    \ range [2] with length 2\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513760,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513760, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.get_odd_collatz(...)\n\t/tmp/tmpj4_7_eic_test.go:27\n\
    command-line-arguments_test.TestGet_Odd_Collatz(0x0?)\n\t/tmp/tmpj4_7_eic_test.go:42\
    \ +0x6d4\ntesting.tRunner(0xc0000cc4e0, 0x529088)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074439
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    if n < 2 {\n        return []int{n}\n    }\n    odd_list :=\
    \ []int{}\n    odd_list = append(odd_list, n)\n    odd_list = append(odd_list,\
    \ get_odd_collatz(n/2)*2)\n    odd_list = append(odd_list, get_odd_collatz(n/2)*2+1)\n\
    \    odd_list = append(odd_list, get_odd_collatz(n/2)*2+2)\n    odd_list = append(odd_list,\
    \ get_odd_collatz(n/2)*2+3)\n    odd_list = append(odd_list, get_odd_collatz(n/2)*2+4)\n\
    \    odd_list = append(odd_list, get_odd_collatz(n/2)*2+5)\n    odd_list = append(odd_list,\
    \ get_odd_collatz(n/2)*2+6)\n    odd_list = append(odd_list, get_odd_collatz(n/2)*2+7)\n\
    \    odd_list = append(odd_list, get_odd_collatz(n/2)*2+8)\n    odd_list = append(odd_list,\
    \ get_odd_collatz(n/2)*2+9)\n    odd_list = append(odd_list, get_odd_collatz(n/2)*2+10)\n\
    \    odd_list = append(odd_list, get_odd_collatz(n/2)*2+11)\n    odd_list = append(odd_list,\
    \ get_odd_collatz(n/2)*2+12)\n    odd_list = append(odd_list, get_odd_collatz(n/2)*2+13)\n\
    \    odd_list = append(odd_list, get_odd_collatz(n/2)*2+14)\n    odd_list = append(odd_list,\
    \ get_odd_collatz(n/2)*2+15)\n    odd_list = append(odd_list, get_odd_collatz(n/2)*2+16)\n\
    \    odd_list = append(odd_list, get_odd_collatz(n/2)*2+17)\n    odd_list = append(odd_list,\
    \ get_odd_collatz(n/2)*2+18)\n    odd_list = append(odd_list, get_odd_collatz(n/2)*2+19)\n\
    \    odd_list = append(odd_list, get_odd_collatz(n/2)*2+20)\n    odd_list = append(odd_list,\
    \ get_odd_collatz(n/2)*2+21)\n    odd_list = append(odd_list, get_odd_collatz(n/2)*2+22)\n\
    \    odd_list = append(odd_list, get_odd_collatz(n/2)*2+23)\n\nfunc TestGet_Odd_Collatz(t\
    \ *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5),\
    \ expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3,\
    \ 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6t13gz_x_test.go:52:6: expected ''('', found TestGet_Odd_Collatz

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074438
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := make([]int, 0)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, n)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    \nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11,\
    \ 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual:\
    \ candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected:\
    \ []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvap_jo7i_test.go:74:6: expected ''('', found TestGet_Odd_Collatz

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074298
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := []int{}\n    odd_list = append(odd_list, n)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11,\
    \ 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual:\
    \ candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected:\
    \ []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpp9791e82_test.go:74:6: expected ''('', found TestGet_Odd_Collatz

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074303
- exit_code: 2
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := []int{}\n    if n%2 == 0 {\n        odd_list =\
    \ append(odd_list, n)\n    } else {\n        odd_list = append(odd_list, get_odd_collatz(n/2))\n\
    \        odd_list = append(odd_list, get_odd_collatz(n*3+1))\n    }\n    return\
    \ odd_list\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11,\
    \ 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual:\
    \ candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected:\
    \ []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp42svbnkw_test.go:26:37: cannot use get_odd_collatz(n / 2) (value of type
    []int) as type int in argument to append

    /tmp/tmp42svbnkw_test.go:27:37: cannot use get_odd_collatz(n * 3 + 1) (value of
    type []int) as type int in argument to append

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074439
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := make([]int, 0)\n    odd_list = append(odd_list,\
    \ n)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    \nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11,\
    \ 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual:\
    \ candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected:\
    \ []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp3ndub0ke_test.go:74:6: expected ''('', found TestGet_Odd_Collatz

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074298
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := make([]int, 0)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    \nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11,\
    \ 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual:\
    \ candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected:\
    \ []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpmkk49utj_test.go:74:6: expected ''('', found TestGet_Odd_Collatz

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074298
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := []int{}\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, n)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11,\
    \ 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual:\
    \ candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected:\
    \ []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpagn925m6_test.go:74:6: expected ''('', found TestGet_Odd_Collatz

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074298
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := make([]int, 0)\n    if n == 1 {\n        return\
    \ odd_list\n    }\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ get_odd_collatz(n/2))\n    odd_list = append(odd_list, get_odd_collatz(n/3))\n\
    \    odd_list = append(odd_list, get_odd_collatz(n/4))\n    odd_list = append(odd_list,\
    \ get_odd_collatz(n/5))\n    odd_list = append(odd_list, get_odd_collatz(n/6))\n\
    \    odd_list = append(odd_list, get_odd_collatz(n/7))\n    odd_list = append(odd_list,\
    \ get_odd_collatz(n/8))\n    odd_list = append(odd_list, get_odd_collatz(n/9))\n\
    \    odd_list = append(odd_list, get_odd_collatz(n/10))\n    odd_list = append(odd_list,\
    \ get_odd_collatz(n/11))\n    odd_list = append(odd_list, get_odd_collatz(n/12))\n\
    \    odd_list = append(odd_list, get_odd_collatz(n/13))\n    odd_list = append(odd_list,\
    \ get_odd_collatz(n/14))\n    odd_list = append(odd_list, get_odd_collatz(n/15))\n\
    \    odd_list = append(odd_list, get_odd_collatz(n/16))\n    odd_list = append(odd_list,\
    \ get_odd_collatz(n/17))\n    odd_list = append(odd_list, get_odd_collatz(n/18))\n\
    \    odd_list = append(odd_list, get_odd_collatz(n/19))\n    odd_list = append(odd_list,\
    \ get_odd_collatz(n/20))\n    odd_list = append(odd_list, get_odd_collatz(n/20))\n\
    \    odd_list = append(odd_list, get_odd_collatz(n/20))\n    odd_list = append(odd_list,\
    \ get_odd_collatz(n/20))\n    odd_list = append(odd_list, get_odd_collatz(n/20))\n\
    \    odd_list = append(odd_list, get_odd_collatz(n/20))\n    odd_list = append(odd_list,\
    \ get_odd_collatz(n/20))\n    odd_list = append(odd_list, get_odd_collatz(n/20))\n\
    \    odd_\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11,\
    \ 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual:\
    \ candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected:\
    \ []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp4287q8re_test.go:54:6: expected ''('', found TestGet_Odd_Collatz

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074439
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := make([]int, 0)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, n)\n    for i := 2; i < n; i++ {\n     \
    \   if odd_list[i-1]%2 == 0 {\n            odd_list[i] = odd_list[i-1]/2\n   \
    \     } else {\n            odd_list[i] = odd_list[i-1]*3+1 \n        }\n    }\n\
    \    return odd_list\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate\
    \ := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected:\
    \ []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1,\
    \ 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual:\
    \ candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\npanic: runtime error: index out\
    \ of range [2] with length 2 [recovered]\n\tpanic: runtime error: index out of\
    \ range [2] with length 2\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513760,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513760, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.get_odd_collatz(...)\n\t/tmp/tmpeg14lpp7_test.go:27\n\
    command-line-arguments_test.TestGet_Odd_Collatz(0x0?)\n\t/tmp/tmpeg14lpp7_test.go:42\
    \ +0x71c\ntesting.tRunner(0xc0000da340, 0x529088)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074301
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := make([]int, 0)\n    odd_list = append(odd_list,\
    \ 1)\n    for i := 2; i <= n; i++ {\n        if i%2 == 0 {\n            odd_list\
    \ = append(odd_list, i*2)\n        } else {\n            odd_list = append(odd_list,\
    \ i*2+3)\n        }\n    }\n    return odd_list\n}\n\nfunc TestGet_Odd_Collatz(t\
    \ *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5),\
    \ expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3,\
    \ 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0\
    \ (0.00s)\n        tmpc21apk61_test.go:50: expected '[%!s(int=1) %!s(int=5) %!s(int=7)\
    \ %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=1) %!s(int=4) %!s(int=9)\
    \ %!s(int=8) %!s(int=13) %!s(int=12) %!s(int=17) %!s(int=16) %!s(int=21) %!s(int=20)\
    \ %!s(int=25) %!s(int=24) %!s(int=29) %!s(int=28)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1\
    \ (0.00s)\n        tmpc21apk61_test.go:50: expected '[%!s(int=1) %!s(int=5)]',\
    \ got '[%!s(int=1) %!s(int=4) %!s(int=9) %!s(int=8) %!s(int=13)]'\n    --- FAIL:\
    \ TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpc21apk61_test.go:50: expected\
    \ '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=1) %!s(int=4) %!s(int=9)\
    \ %!s(int=8) %!s(int=13) %!s(int=12) %!s(int=17) %!s(int=16) %!s(int=21) %!s(int=20)\
    \ %!s(int=25) %!s(int=24)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074299
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    var odd_list []int\n    if n%2 == 0 {\n        odd_list =\
    \ append(odd_list, n)\n    } else {\n        odd_list = append(odd_list, n/2)\n\
    \        odd_list = append(odd_list, 3*n+1)\n    }\n    return odd_list\n}\n\n\
    func TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17}\
    \ },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12),\
    \ expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0\
    \ (0.00s)\n        tmpaqya5jxe_test.go:48: expected '[%!s(int=1) %!s(int=5) %!s(int=7)\
    \ %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=14)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1\
    \ (0.00s)\n        tmpaqya5jxe_test.go:48: expected '[%!s(int=1) %!s(int=5)]',\
    \ got '[%!s(int=2) %!s(int=16)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2\
    \ (0.00s)\n        tmpaqya5jxe_test.go:48: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]',\
    \ got '[%!s(int=12)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__3 (0.00s)\n\
    \        tmpaqya5jxe_test.go:48: expected '[%!s(int=1)]', got '[%!s(int=0) %!s(int=4)]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074299
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := []int{}\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, n)\n    for i := 2; i < n; i++ {\n        if\
    \ odd_list[i-1]%2 == 0 {\n            odd_list[i] = odd_list[i-1]/2\n        }\
    \ else {\n            odd_list[i] = 3*odd_list[i-1] + 1\n        }\n    }\n  \
    \  return odd_list\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate\
    \ := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected:\
    \ []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1,\
    \ 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual:\
    \ candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\npanic: runtime error: index out\
    \ of range [2] with length 2 [recovered]\n\tpanic: runtime error: index out of\
    \ range [2] with length 2\n\ngoroutine 4 [running]:\ntesting.tRunner.func1.2({0x513760,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513760, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.get_odd_collatz(...)\n\t/tmp/tmp22psfyfz_test.go:27\n\
    command-line-arguments_test.TestGet_Odd_Collatz(0x0?)\n\t/tmp/tmp22psfyfz_test.go:42\
    \ +0x6dc\ntesting.tRunner(0xc0000d24e0, 0x529088)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074304
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := make([]int, 0)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, n)\n    for i := 2; i < n; i++ {\n     \
    \   if odd_list[i-1]%2 == 0 {\n            odd_list[i] = odd_list[i-1]/2\n   \
    \     } else {\n            odd_list[i] = 3*odd_list[i-1] + 1\n        }\n   \
    \ }\n    return odd_list\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate\
    \ := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected:\
    \ []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1,\
    \ 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual:\
    \ candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\npanic: runtime error: index out\
    \ of range [2] with length 2 [recovered]\n\tpanic: runtime error: index out of\
    \ range [2] with length 2\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513760,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513760, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.get_odd_collatz(...)\n\t/tmp/tmpv6gn_zzx_test.go:27\n\
    command-line-arguments_test.TestGet_Odd_Collatz(0x0?)\n\t/tmp/tmpv6gn_zzx_test.go:42\
    \ +0x71c\ntesting.tRunner(0xc0000cc4e0, 0x529088)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074303
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := []int{}\n    if n == 1 {\n        odd_list = append(odd_list,\
    \ 1)\n        return odd_list\n    }\n    for i := 1; i <= n; i++ {\n        if\
    \ i%2 == 0 {\n            odd_list = append(odd_list, i)\n        } else {\n \
    \           odd_list = append(odd_list, 3*i+1)\n        }\n    }\n    return odd_list\n\
    }\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11,\
    \ 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual:\
    \ candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected:\
    \ []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0\
    \ (0.00s)\n        tmplf3_r55v_test.go:53: expected '[%!s(int=1) %!s(int=5) %!s(int=7)\
    \ %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=4) %!s(int=2) %!s(int=10)\
    \ %!s(int=4) %!s(int=16) %!s(int=6) %!s(int=22) %!s(int=8) %!s(int=28) %!s(int=10)\
    \ %!s(int=34) %!s(int=12) %!s(int=40) %!s(int=14)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1\
    \ (0.00s)\n        tmplf3_r55v_test.go:53: expected '[%!s(int=1) %!s(int=5)]',\
    \ got '[%!s(int=4) %!s(int=2) %!s(int=10) %!s(int=4) %!s(int=16)]'\n    --- FAIL:\
    \ TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmplf3_r55v_test.go:53: expected\
    \ '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=4) %!s(int=2) %!s(int=10)\
    \ %!s(int=4) %!s(int=16) %!s(int=6) %!s(int=22) %!s(int=8) %!s(int=28) %!s(int=10)\
    \ %!s(int=34) %!s(int=12)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074439
- exit_code: 1
  program: "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers\
    \ in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics\
    \ that concerns a sequence defined\n// as follows: start with any positive integer\
    \ n. Then each term is obtained from the \n// previous term as follows: if the\
    \ previous term is even, the next term is one half of \n// the previous term.\
    \ If the previous term is odd, the next term is 3 times the previous\n// term\
    \ plus 1. The conjecture is that no matter what value of n, the sequence will\
    \ always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted\
    \ in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5]\
    \ # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are\
    \ only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n\
    \ int) []int {\n    odd_list := []int{}\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, n)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list\
    \ = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list,\
    \ 1)\n    odd_list = append(odd_list, 1)\n    odd_list = append(odd_list, 1)\n\
    \    odd_\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11,\
    \ 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual:\
    \ candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected:\
    \ []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpagn925m6_test.go:74:6: expected ''('', found TestGet_Odd_Collatz

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074298
