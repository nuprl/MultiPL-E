language: go_test.go
name: HumanEval_72_will_it_fly
results:
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here.\n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpkziq0sjv_test.go:279:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075246
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    max := 0\n    for _,\
    \ v := range q {\n        max += v\n    }\n    if max > w {\n        return false\n\
    \    }\n    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n   \
    \ if sum < max {\n        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpz2ae1lk5_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpz2ae1lk5_test.go:60:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075248
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    max := 0\n    for _,\
    \ v := range q {\n        if v > max {\n            max = v\n        }\n    }\n\
    \    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n    return\
    \ sum <= w && max <= w\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate\
    \ := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 2,\
    \ 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmphloxwv2e_test.go:56: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmphloxwv2e_test.go:56:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075248
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max += v\n    }\n    if max > w\
    \ {\n        return false\n    }\n    sum := 0\n    for _, v := range q {\n  \
    \      sum += v\n    }\n    if sum < max {\n        return false\n    }\n    return\
    \ will_it_fly(q[:len(q)-1], w)\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate\
    \ := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 2,\
    \ 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpc2takwr1_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpc2takwr1_test.go:62:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075248
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max += v\n    }\n    if max > w\
    \ {\n        return false\n    }\n    sum := 0\n    for _, v := range q {\n  \
    \      sum += v\n    }\n    if sum < max {\n        return false\n    }\n    return\
    \ will_it_fly(q[:len(q)-1], w)\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate\
    \ := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 2,\
    \ 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpc2takwr1_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpc2takwr1_test.go:62:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075248
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ if q[len(q)-1] != len(q)/2 {\n        return false\n    }\n    max := 0\n  \
    \  for _, v := range q {\n        max += v\n    }\n    if max > w {\n        return\
    \ false\n    }\n    return will_it_fly(q[:len(q)-1], w)\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmppvsp0d46_test.go:58: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmppvsp0d46_test.go:58:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__5\
    \ (0.00s)\n        tmppvsp0d46_test.go:58: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075248
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // TODO: write your function here\n    return false\n\
    }\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n\
    \     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmp8wfvrt32_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmp8wfvrt32_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__5\
    \ (0.00s)\n        tmp8wfvrt32_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075248
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max += v\n    }\n    if max ==\
    \ w {\n        return true\n    }\n    if max > w {\n        return false\n  \
    \  }\n    return will_it_fly(q[1:], w)\n}\n\nfunc TestWill_It_Fly(t *testing.T)\
    \ {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmp3w322xyb_test.go:58: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmp3w322xyb_test.go:58:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.006s\nFAIL\n"
  timestamp: 1660075248
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max += v\n    }\n    if max > w\
    \ {\n        return false\n    }\n    return will_it_fly(q[:len(q)-1], w) && will_it_fly(q[len(q)-1:],\
    \ w)\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc020160388\
    \ stack=[0xc020160000, 0xc040160000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x520348?, 0x5e3ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 18 [running]:\ncommand-line-arguments_test.will_it_fly({0xc04015fe28?,\
    \ 0x0?, 0x3?}, 0x9?)\n\t/tmp/tmpaa4esyhb_test.go:23 +0xec fp=0xc020160398 sp=0xc020160390\
    \ pc=0x4ef74c\ncommand-line-arguments_test.will_it_fly({0xc04015fe28, 0x1, 0x3},\
    \ 0x9)\n\t/tmp/tmpaa4esyhb_test.go:34 +0x73 fp=0xc0201603d0 sp=0xc020160398 pc=0x4ef6d3\n\
    command-line-arguments_test.will_it_fly({0xc04015fe28, 0x1, 0x3}, 0x9)\n\t/tmp/tmpaa4esyhb_test.go:34\
    \ +0xbd fp=0xc020160408 sp=0xc0201603d0 pc=0x4ef71d\ncommand-line-arguments_test.will_it_fly({0xc04015fe28,\
    \ 0x1, 0x3}, 0x9)\n\t/tmp/tmpaa4esyhb_test.go:34 +0xbd fp=0xc020160440 sp=0xc020160408\
    \ pc=0x4ef71d\ncommand-line-arguments_test.will_it_fly({0xc04015fe28, 0x1, 0x3},\
    \ 0x9)\n\t/tmp/tmpaa4esyhb_test.go:34 +0xbd fp=0xc020160478 sp=0xc020160440 pc=0x4ef71d\n\
    command-line-arguments_test.will_it_fly({0xc04015fe28, 0x1, 0x3}, 0x9)\n\t/tmp/tmpaa4esyhb_test.go:34\
    \ +0xbd fp=0xc0201604b0 sp=0xc020160478 pc=0x4ef71d\ncommand-line-arguments_test.will_it_fly({0xc04015fe28,\
    \ 0x1, 0x3}, 0x9)\n\t/tmp/tmpaa4esyhb_test.go:34 +0xbd fp=0xc0201604e8 sp=0xc0201604b0\
    \ pc=0x4ef71d\ncommand-line-arguments_test.will_it_fly({0xc04015fe28, 0x1, 0x3},\
    \ 0x9)\n\t/tmp/tmpaa4esyhb_test.go:34 +0xbd fp=0xc020160520 sp=0xc0201604e8 pc=0x4ef71d\n\
    command-line-arguments_test.will_it_fly({0xc04015fe28, 0x1, 0x3}, 0x9)\n\t/tmp/tmpaa4esyhb_test.go:34\
    \ +0xbd fp=0xc020160558 sp=0xc020160520 pc=0x4ef71d\ncommand-line-arguments_test.will_it_fly({0xc04015fe28,\
    \ 0x1, 0x3}, 0x9)\n\t/tmp/tmpaa4esyhb_test.go:34 +0xbd fp=0xc020160590 sp=0xc020160558\
    \ pc=0x4ef71d\ncommand-line-arguments_test.will_it_fly({0xc04015fe28, 0x1, 0x3},\
    \ 0x9)\n"
  timestamp: 1660075249
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ if len(q) == 1 {\n        return q[0] == q[0]\n    }\n    max := 0\n    for\
    \ _, v := range q {\n        max += v\n    }\n    if max > w {\n        return\
    \ false\n    }\n    sum := 0\n    for _, v := range q {\n        sum += v\n  \
    \  }\n    if sum < max {\n        return false\n    }\n    return will_it_fly(q[1:],\
    \ w)\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpjrylov42_test.go:65: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpjrylov42_test.go:65:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075248
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ if q[len(q)-1] != len(q)/2 {\n        return false\n    }\n    max := 0\n  \
    \  for _, v := range q {\n        max += v\n    }\n    if max > w {\n        return\
    \ false\n    }\n    return will_it_fly(q[:len(q)-1], w)\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmppvsp0d46_test.go:58: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmppvsp0d46_test.go:58:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__5\
    \ (0.00s)\n        tmppvsp0d46_test.go:58: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075248
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here.\n    return true\n}\n\nfunc\
    \ TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual:\
    \ candidate([]int{1, 2}, 5), expected: false },\n     { actual: candidate([]int{3},\
    \ 5), expected: true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n\
    \     { actual: candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmp716x6nwg_test.go:46: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmp716x6nwg_test.go:46:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmp716x6nwg_test.go:46: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075248
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here.\n    return true\n}\n\nfunc\
    \ TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual:\
    \ candidate([]int{1, 2}, 5), expected: false },\n     { actual: candidate([]int{3},\
    \ 5), expected: true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n\
    \     { actual: candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmp716x6nwg_test.go:46: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmp716x6nwg_test.go:46:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmp716x6nwg_test.go:46: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075248
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max = max * 10 + v\n    }\n   \
    \ if max > w {\n        return false\n    }\n    sum := 0\n    for _, v := range\
    \ q {\n        sum += v\n    }\n    if sum < max {\n        return false\n   \
    \ }\n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate :=\
    \ will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected:\
    \ true },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n    \
    \ { actual: candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpjxhoceaw_test.go:62: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075248
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    max := 0\n    for _,\
    \ v := range q {\n        if v > max {\n            max = v\n        }\n    }\n\
    \    if max == 0 {\n        return true\n    }\n    sum := 0\n    for _, v :=\
    \ range q {\n        sum += v\n    }\n    if sum == 0 {\n        return true\n\
    \    }\n    if sum > w {\n        return false\n    }\n    return true\n}\n\n\
    func TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n\
    \     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpm2co9in__test.go:65: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpm2co9in__test.go:65:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660075248
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    if q == nil || len(q)\
    \ == 0 {\n        return false\n    }\n    if w == 0 {\n        return true\n\
    \    }\n    max := 0\n    for _, v := range q {\n        max = max+v\n    }\n\
    \    if max > w {\n        return false\n    }\n    sum := 0\n    for _, v :=\
    \ range q {\n        sum = sum+v\n    }\n    if sum < max {\n        return false\n\
    \    }\n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate\
    \ := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 2,\
    \ 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpuw1vb4f3_test.go:66: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpuw1vb4f3_test.go:66:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075248
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max += v\n    }\n    if max > w\
    \ {\n        return false\n    }\n    sum := 0\n    for _, v := range q {\n  \
    \      sum += v\n    }\n    if sum < max {\n        return false\n    }\n    return\
    \ will_it_fly(q[1:], w)\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate\
    \ := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 2,\
    \ 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpkxakimrv_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpkxakimrv_test.go:62:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075248
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here.\n    max := 0\n    for _,\
    \ v := range q {\n        if v > max {\n            max = v\n        }\n    }\n\
    \    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n    if sum\
    \ < max {\n        return false\n    }\n    if sum == max {\n        return true\n\
    \    }\n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate\
    \ := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 2,\
    \ 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmp5gpx_xid_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmp5gpx_xid_test.go:62:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmp5gpx_xid_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075248
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // TODO: Write a function that returns True if the\
    \ object q will fly, and False otherwise.\n    // The object q will fly if it's\
    \ balanced (it is a palindromic list) and the sum of its elements is less than\
    \ or equal the maximum possible weight w.\n    // Example:\n    // >>> will_it_fly([]int{1,\
    \ 2}, 5)\n    // false\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> will_it_fly([]int{3, 2, 3}, 1)\n    // false\n\
    \    // # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    \    // >>> will_it_fly([]int{3, 2, 3}, 9)\n    // true\n    // # 3+2+3 is less\
    \ than the maximum possible weight, and it's balanced.\n    // >>> will_it_fly([]int{3},\
    \ 5)\n    // true\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    \n    // TODO: Write a function that returns True if the object\
    \ q will fly, and False otherwise.\n    // The object q will fly if it's balanced\
    \ (it is a palindromic list) and the sum of its elements is less than or equal\
    \ the maximum possible weight w.\n    // Example:\n    // >>> will_it_fly([]int{1,\
    \ 2}, 5)\n    // false\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> will_it_fly([]int{3, 2, 3}, 1)\n    // false\n\
    \    // # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    \    // >>> will_it_fly([]int{3, 2, 3}, 9)\n    // true\n    // # 3+2+3 is less\
    \ than the maximum possible weight, and it's balanced.\n    // >>> will_it_fly([]int{3},\
    \ 5)\n    // true\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    \n    // TODO: Write a function that returns True if the object\
    \ q will fly, and False otherwise.\n    // The object q will fly if it's balanced\
    \ (it is a palindromic list) and the sum of its elements is less than or equal\
    \ the maximum possible weight w.\n    // Example:\n    // >>> will_it_fly([]int{1,\
    \ 2}, 5)\n    // false\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> will_it_fly([]int{3, 2, 3}, 1)\n    // false\n\
    \    // # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    \    // >>> will_it_fly([]int{3, 2, 3}, 9)\n    // true\n    // # 3+2+3 is \n\
    func TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n\
    \     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmptpd9ro3c_test.go:68:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075246
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    max := 0\n    for _,\
    \ v := range q {\n        max += v\n    }\n    if max > w {\n        return false\n\
    \    }\n    for _, v := range q {\n        if v != q[len(q)-1] {\n           \
    \ return false\n        }\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpxqe_bpnr_test.go:58: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075248
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    if q == nil || w == 0\
    \ {\n        return true\n    }\n    max := 0\n    for _, v := range q {\n   \
    \     max += v\n    }\n    if max == 0 {\n        return true\n    }\n    if max\
    \ > w {\n        return false\n    }\n    sum := 0\n    for _, v := range q {\n\
    \        sum += v\n    }\n    if sum < max {\n        return false\n    }\n  \
    \  return true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpuepg_7e0_test.go:66: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpuepg_7e0_test.go:66:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075248
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    if q == nil || w == 0\
    \ {\n        return true\n    }\n    max := 0\n    for _, v := range q {\n   \
    \     max += v\n    }\n    if max > w {\n        return false\n    }\n    sum\
    \ := 0\n    for _, v := range q {\n        sum += v\n    }\n    if sum < max {\n\
    \        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T)\
    \ {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpv5hhnplq_test.go:63: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpv5hhnplq_test.go:63:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075248
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    max := 0\n    for _,\
    \ v := range q {\n        max += v\n    }\n    if max > w {\n        return false\n\
    \    }\n    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n   \
    \ if sum < max {\n        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpz2ae1lk5_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpz2ae1lk5_test.go:60:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075248
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) <= 1 {\n        return true\n    }\n   \
    \ if w == 0 {\n        return false\n    }\n    max := 0\n    for _, v := range\
    \ q {\n        max += v\n    }\n    if max > w {\n        return false\n    }\n\
    \    return will_it_fly(q[:len(q)-1], w) && will_it_fly(q[len(q)-1:], w)\n}\n\n\
    func TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n\
    \     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpb29cwu2w_test.go:58: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpb29cwu2w_test.go:58:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075248
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max += v\n    }\n    if max > w\
    \ {\n        return false\n    }\n    sum := 0\n    for _, v := range q {\n  \
    \      sum += v\n    }\n    if sum < max {\n        return false\n    }\n    return\
    \ will_it_fly(q[1:], w)\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate\
    \ := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 2,\
    \ 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpkxakimrv_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpkxakimrv_test.go:62:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075248
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    max := 0\n    for _,\
    \ v := range q {\n        max += v\n    }\n    if max > w {\n        return false\n\
    \    }\n    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n   \
    \ if sum < max {\n        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpz2ae1lk5_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpz2ae1lk5_test.go:60:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075248
- exit_code: 2
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ if w == 0 {\n        return false\n    }\n    if q[len(q)-1] == 0 {\n      \
    \  return false\n    }\n    if q[len(q)-1] == 1 {\n        return will_it_fly(q[:len(q)-1],\
    \ w-1)\n    }\n    return will_it_fly(q[:len(q)-1], w) && will_it_fly(q[len(q)-1],\
    \ w)\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpz4s6wrx9_test.go:36:56: cannot use q[len(q) - 1] (variable of type int)
    as type []int in argument to will_it_fly

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075247
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    max := 0\n    for _,\
    \ v := range q {\n        max += v\n    }\n    if max > w {\n        return false\n\
    \    }\n    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n   \
    \ if sum < max {\n        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpz2ae1lk5_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpz2ae1lk5_test.go:60:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075248
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    max := 0\n    for _,\
    \ v := range q {\n        max += v\n    }\n    if max > w {\n        return false\n\
    \    }\n    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n   \
    \ if sum < max {\n        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpz2ae1lk5_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpz2ae1lk5_test.go:60:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075248
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) <= 1 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max += v\n    }\n    if max > w\
    \ {\n        return false\n    }\n    sum := 0\n    for _, v := range q {\n  \
    \      sum += v\n    }\n    return sum <= w && sum == max\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpji2n81yq_test.go:59: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpji2n81yq_test.go:59:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075248
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max += v\n    }\n    if max > w\
    \ {\n        return false\n    }\n    sum := 0\n    for _, v := range q {\n  \
    \      sum += v\n    }\n    return sum <= w\n}\n\nfunc TestWill_It_Fly(t *testing.T)\
    \ {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpe0swsoee_test.go:59: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpe0swsoee_test.go:59:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075248
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    max := 0\n    for _,\
    \ v := range q {\n        if v > max {\n            max = v\n        }\n    }\n\
    \    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n    if sum\
    \ < max {\n        return false\n    }\n    if sum == max {\n        return true\n\
    \    }\n    if sum > max {\n        return true\n    }\n    return false\n}\n\n\
    func TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n\
    \     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmp5zgjsd5k_test.go:65: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmp5zgjsd5k_test.go:65:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmp5zgjsd5k_test.go:65: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075249
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // \nfunc TestWill_It_Fly(t *testing.T)\
    \ {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpc974zb7c_test.go:171:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075248
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max += v\n    }\n    if max < w\
    \ {\n        return false\n    }\n    sum := 0\n    for _, v := range q {\n  \
    \      sum += v\n    }\n    if sum < w {\n        return true\n    }\n    return\
    \ will_it_fly(q[:len(q)-1], w)\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate\
    \ := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 2,\
    \ 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmppxunwe56_test.go:62: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmppxunwe56_test.go:62:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__3\
    \ (0.00s)\n        tmppxunwe56_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075250
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max += v\n    }\n    if max > w\
    \ {\n        return false\n    }\n    sum := 0\n    for _, v := range q {\n  \
    \      sum += v\n    }\n    return sum <= w\n}\n\nfunc TestWill_It_Fly(t *testing.T)\
    \ {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpe0swsoee_test.go:59: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpe0swsoee_test.go:59:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075248
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max += v\n    }\n    if max > w\
    \ {\n        return false\n    }\n    if max < w {\n        return true\n    }\n\
    \    return will_it_fly(q[:len(q)-1], w)\n}\n\nfunc TestWill_It_Fly(t *testing.T)\
    \ {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmp6xqjj7r3_test.go:58: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmp6xqjj7r3_test.go:58:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075251
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here.\n    max := 0\n    for _,\
    \ v := range q {\n        if v > max {\n            max = v\n        }\n    }\n\
    \    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n    if sum\
    \ < max {\n        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmp2f9ufvrx_test.go:59: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmp2f9ufvrx_test.go:59:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmp2f9ufvrx_test.go:59: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075251
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ if w == 0 {\n        return false\n    }\n    max := 0\n    for _, v := range\
    \ q {\n        max += v\n    }\n    if max > w {\n        return false\n    }\n\
    \    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n    if sum\
    \ > w {\n        return true\n    }\n    return will_it_fly(q[1:], w)\n}\n\nfunc\
    \ TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual:\
    \ candidate([]int{1, 2}, 5), expected: false },\n     { actual: candidate([]int{3},\
    \ 5), expected: true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n\
    \     { actual: candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmprk5tr41g_test.go:65: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmprk5tr41g_test.go:65:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660075251
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here.\n    max := 0\n    for _,\
    \ v := range q {\n        max += v\n    }\n    if max < w {\n        return false\n\
    \    }\n    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n   \
    \ if sum < max {\n        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpv9yuwgsf_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpv9yuwgsf_test.go:60:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__3\
    \ (0.00s)\n        tmpv9yuwgsf_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpv9yuwgsf_test.go:60:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075251
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here.\n    return true\n}\n\nfunc\
    \ TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual:\
    \ candidate([]int{1, 2}, 5), expected: false },\n     { actual: candidate([]int{3},\
    \ 5), expected: true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n\
    \     { actual: candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmp716x6nwg_test.go:46: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmp716x6nwg_test.go:46:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmp716x6nwg_test.go:46: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075248
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here.\n    max := 0\n    for _,\
    \ v := range q {\n        if v > max {\n            max = v\n        }\n    }\n\
    \    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n    if sum\
    \ < max {\n        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmp2f9ufvrx_test.go:59: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmp2f9ufvrx_test.go:59:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmp2f9ufvrx_test.go:59: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075251
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ if q[len(q)-1] != len(q)/2 {\n        return false\n    }\n    max := 0\n  \
    \  for _, v := range q {\n        max += v\n    }\n    if max > w {\n        return\
    \ false\n    }\n    return will_it_fly(q[:len(q)-1], w)\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmppvsp0d46_test.go:58: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmppvsp0d46_test.go:58:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__5\
    \ (0.00s)\n        tmppvsp0d46_test.go:58: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075248
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here.\n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpkziq0sjv_test.go:279:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075246
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    \n    return true\n}\n\
    \nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n\
    \     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmp3t_5ocew_test.go:47: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmp3t_5ocew_test.go:47:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmp3t_5ocew_test.go:47: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075251
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpusd7ge2s_test.go:279:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075250
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here.\n    max := 0\n    for _,\
    \ v := range q {\n        max += v\n    }\n    if max > w {\n        return false\n\
    \    }\n    if max == w {\n        return true\n    }\n    if max < w {\n    \
    \    return false\n    }\n    if max > 0 {\n        return will_it_fly(q[:len(q)-1],\
    \ w)\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate\
    \ := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 2,\
    \ 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmp3lkn_t9r_test.go:62: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmp3lkn_t9r_test.go:62:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmp3lkn_t9r_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075251
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpusd7ge2s_test.go:279:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075250
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ if len(q) == 1 {\n        return q[0] == q[0]\n    }\n    if q[0] != q[len(q)-1]\
    \ {\n        return false\n    }\n    max := 0\n    for i := 0; i < len(q); i++\
    \ {\n        max += q[i]\n    }\n    if max < w {\n        return false\n    }\n\
    \    return will_it_fly(q[1:], w)\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n\
    \  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpdo4nsst0_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075251
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here.\n    return true\n}\n\nfunc\
    \ TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual:\
    \ candidate([]int{1, 2}, 5), expected: false },\n     { actual: candidate([]int{3},\
    \ 5), expected: true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n\
    \     { actual: candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmp716x6nwg_test.go:46: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmp716x6nwg_test.go:46:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmp716x6nwg_test.go:46: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075248
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    \n    return true\n}\n\
    \nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n\
    \     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmp3t_5ocew_test.go:47: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmp3t_5ocew_test.go:47:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmp3t_5ocew_test.go:47: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075251
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    max := 0\n    for _,\
    \ v := range q {\n        max += v\n    }\n    if max > w {\n        return false\n\
    \    }\n    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n   \
    \ if sum < max {\n        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpz2ae1lk5_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpz2ae1lk5_test.go:60:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075248
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ if q[len(q)-1] < w {\n        return false\n    }\n    max := 0\n    for _,\
    \ v := range q {\n        max += v\n    }\n    if max < w {\n        return false\n\
    \    }\n    return will_it_fly(q[:len(q)-1], w)\n}\n\nfunc TestWill_It_Fly(t *testing.T)\
    \ {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpipuh2hrk_test.go:58: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpipuh2hrk_test.go:58:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__3\
    \ (0.00s)\n        tmpipuh2hrk_test.go:58: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075251
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max += v\n    }\n    if max > w\
    \ {\n        return false\n    }\n    sum := 0\n    for _, v := range q {\n  \
    \      sum += v\n    }\n    if sum < max {\n        return false\n    }\n    return\
    \ will_it_fly(q[:len(q)-1], w)\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate\
    \ := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 2,\
    \ 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpc2takwr1_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpc2takwr1_test.go:62:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075248
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here.\n    max := 0\n    for _,\
    \ v := range q {\n        max += v\n    }\n    if max > w {\n        return false\n\
    \    }\n    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n   \
    \ if sum < max {\n        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmp3v0i9vy5_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmp3v0i9vy5_test.go:60:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075251
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max += v\n    }\n    if max > w\
    \ {\n        return false\n    }\n    sum := 0\n    for _, v := range q {\n  \
    \      sum += v\n    }\n    if sum < max {\n        return false\n    }\n    return\
    \ true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpt8rxjd89_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpt8rxjd89_test.go:62:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075251
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max += v\n    }\n    if max > w\
    \ {\n        return false\n    }\n    sum := 0\n    for _, v := range q {\n  \
    \      sum += v\n    }\n    if sum < max {\n        return false\n    }\n    return\
    \ will_it_fly(q[:len(q)-1], w)\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate\
    \ := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 2,\
    \ 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpc2takwr1_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpc2takwr1_test.go:62:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075248
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ if w == 0 {\n        return false\n    }\n    max := q[len(q)-1]\n    for _,\
    \ v := range q[:len(q)-1] {\n        if v > max {\n            return false\n\
    \        }\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n\
    \  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpss5l3eqp_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmpss5l3eqp_test.go:57:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmpss5l3eqp_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075251
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max += v\n    }\n    if max > w\
    \ {\n        return false\n    }\n    max -= w\n    sum := 0\n    for _, v :=\
    \ range q {\n        sum += v\n        if sum > max {\n            return false\n\
    \        }\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n\
    \  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpx1jz3zrb_test.go:63: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpx1jz3zrb_test.go:63:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__5\
    \ (0.00s)\n        tmpx1jz3zrb_test.go:63: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075251
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ if q[len(q)-1] == 0 {\n        return false\n    }\n    if q[len(q)-1] == 1\
    \ {\n        return will_it_fly(q[:len(q)-1], w)\n    }\n    if q[len(q)-1] ==\
    \ 2 {\n        return will_it_fly(q[:len(q)-1], w)\n    }\n    if q[len(q)-1]\
    \ == 3 {\n        return will_it_fly(q[:len(q)-1], w)\n    }\n    if q[len(q)-1]\
    \ == 4 {\n        return will_it_fly(q[:len(q)-1], w)\n    }\n    if q[len(q)-1]\
    \ == 5 {\n        return will_it_fly(q[:len(q)-1], w)\n    }\n    if q[len(q)-1]\
    \ == 6 {\n        return will_it_fly(q[:len(q)-1], w)\n    }\n    if q[len(q)-1]\
    \ == 7 {\n        return will_it_fly(q[:len(q)-1], w)\n    }\n    if q[len(q)-1]\
    \ == 8 {\n        return will_it_fly(q[:len(q)-1], w)\n    }\n    if q[len(q)-1]\
    \ == 9 {\n        return will_it_fly(q[:len(q)-1], w)\n    }\n    if q[len(q)-1]\
    \ == 10 {\n        return will_it_fly(q[:len(q)-1], w)\n    }\n    if q[len(q)-1]\
    \ == 11 {\n        return will_it_fly(q[:len(q)-1], w)\n    }\n    if q[len(q)-1]\
    \ == 12 {\n        return will_it_fly(q[:len(q)-1], w)\n    }\n    if q[len(q)-1]\
    \ == 13 {\n        return will_it_fly(q[:len(q)-1], w)\n    }\n    if q[len(q)-1]\
    \ == 14 {\n        return will_it_fly(q[:len(q)-1], w)\n    }\n    if q[len(q)-1]\
    \ == 15 {\n        return will_it_fly(q[:len(q)-1], w)\n    }\n    if q[len(q)-1]\
    \ == 16 {\n        return will_it_fly(q[:len(q)-1], w)\n    }\n    if q[len(q)-1]\
    \ == 17 {\n        return will_it_fly(q[:len(q)-1], w)\n    }\n    if q[len(q)-1]\
    \ == 18 {\n        return will_it_fly(q[:len(q)-1], w)\n    }\n    if q[len(q)-1]\
    \ == 19 {\n        return will_it_fly(q[:len(q)-1], w)\n    }\n    if q[len(q)-1]\
    \ == 20 {\n        return will_it_fly(q[:len(q)-1], w)\n    }\n    if \nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpwv7cxcdo_test.go:91:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075250
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpusd7ge2s_test.go:279:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075250
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    max := 0\n    for _,\
    \ v := range q {\n        if v > max {\n            max = v\n        }\n    }\n\
    \    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n    if sum\
    \ < max {\n        return false\n    }\n    if sum == max {\n        return true\n\
    \    }\n    if sum > max {\n        return true\n    }\n    return false\n}\n\n\
    func TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n\
    \     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmp5zgjsd5k_test.go:65: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmp5zgjsd5k_test.go:65:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmp5zgjsd5k_test.go:65: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075249
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Your code here\n    max := 0\n    for _, v := range\
    \ q {\n        max = max+v\n    }\n    if max == w {\n        return true\n  \
    \  }\n    if max > w {\n        return false\n    }\n    sum := 0\n    for _,\
    \ v := range q {\n        sum = sum+v\n    }\n    if sum == max {\n        return\
    \ true\n    }\n    return false\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n \
    \ candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpjgsvy3wb_test.go:63: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpjgsvy3wb_test.go:63:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075251
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    return true\n}\n\nfunc\
    \ TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual:\
    \ candidate([]int{1, 2}, 5), expected: false },\n     { actual: candidate([]int{3},\
    \ 5), expected: true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n\
    \     { actual: candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpw2hbzu1y_test.go:46: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmpw2hbzu1y_test.go:46:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmpw2hbzu1y_test.go:46: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075251
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) <= 1 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max += v\n    }\n    if max > w\
    \ {\n        return false\n    }\n    sum := 0\n    for _, v := range q {\n  \
    \      sum += v\n    }\n    if sum < max {\n        return false\n    }\n    return\
    \ true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpwphdy2cx_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpwphdy2cx_test.go:62:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075251
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ if w == 0 {\n        return false\n    }\n    if q[len(q)-1] < w {\n       \
    \ return false\n    }\n    max := q[0]\n    for _, v := range q[1:] {\n      \
    \  if v > max {\n            max = v\n        }\n    }\n    return max <= w\n\
    }\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n\
    \     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmph1z1qxf7_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmph1z1qxf7_test.go:60:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075251
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here.\n    max := 0\n    for _,\
    \ v := range q {\n        max += v\n    }\n    if max < w {\n        return false\n\
    \    }\n    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n   \
    \ if sum < max {\n        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpv9yuwgsf_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpv9yuwgsf_test.go:60:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__3\
    \ (0.00s)\n        tmpv9yuwgsf_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpv9yuwgsf_test.go:60:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075251
- exit_code: 2
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    max := 0\n    for _,\
    \ v := range q {\n        max += v\n    }\n    if max < w {\n        return false\n\
    \    }\n    if max > w {\n        return true\n    }\n    return is_palindromic(q)\
    \ && sum_of_elements(q) <= max\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate\
    \ := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 2,\
    \ 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7o8sg94__test.go:35:12: undefined: is_palindromic

    /tmp/tmp7o8sg94__test.go:35:33: undefined: sum_of_elements

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075251
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    max := 0\n    for _,\
    \ v := range q {\n        max += v\n    }\n    if max > w {\n        return false\n\
    \    }\n    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n   \
    \ if sum < max {\n        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpz2ae1lk5_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpz2ae1lk5_test.go:60:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075248
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max += v\n    }\n    if max > w\
    \ {\n        return false\n    }\n    sum := 0\n    for _, v := range q {\n  \
    \      sum += v\n    }\n    if sum < max {\n        return false\n    }\n    return\
    \ will_it_fly(q[:len(q)-1], w)\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate\
    \ := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 2,\
    \ 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpc2takwr1_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpc2takwr1_test.go:62:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075248
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max += v\n    }\n    if max > w\
    \ {\n        return false\n    }\n    sum := 0\n    for _, v := range q {\n  \
    \      sum += v\n    }\n    return sum <= w\n}\n\nfunc TestWill_It_Fly(t *testing.T)\
    \ {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpe0swsoee_test.go:59: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpe0swsoee_test.go:59:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075248
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here.\n    \n    // Write your\
    \ code here.\n    \n    // Write your code here.\n    \n    // Write your code\
    \ here.\n    \n    // Write your code here.\n    \n    // Write your code here.\n\
    \    \n    // Write your code here.\n    \n    // Write your code here.\n    \n\
    \    // Write your code here.\n    \n    // Write your code here.\n    \n    //\
    \ Write your code here.\n    \n    // Write your code here.\n    \n    // Write\
    \ your code here.\n    \n    // Write your code here.\n    \n    // Write your\
    \ code here.\n    \n    // Write your code here.\n    \n    // Write your code\
    \ here.\n    \n    // Write your code here.\n    \n    // Write your code here.\n\
    \    \n    // Write your code here.\n    \n    // Write your code here.\n    \n\
    \    // Write your code here.\n    \n    // Write your code here.\n    \n    //\
    \ Write your code here.\n    \n    // Write your code here.\n    \n    // Write\
    \ your code here.\n    \n    // Write your code here.\n    \n    // Write your\
    \ code here.\n    \n    // Write your code here.\n    \n    // Write your code\
    \ here.\n    \n    // Write your code here.\n    \n    // Write your code here.\n\
    \    \n    // Write your code here.\n    \n    // Write your code here.\n    \n\
    \    // Write your code here.\n    \n    // Write your code here.\n    \n    //\
    \ Write your code here.\n    \n    // Write your code here.\n    \n    // Write\
    \ your code here.\n    \n    // Write your code here.\n    \n    // Write your\
    \ code here.\n    \n    // Write your code here.\n    \n    // Write your code\
    \ here.\n    \n    // Write your code here.\n    \n    // Write your code here.\n\
    \    \n    // Write your code here.\n    \n    // Write your code here.\n    \n\
    \    // Write your code here.\n    \n    // Write your code here.\n    \n    //\
    \ Write your code here.\n    \n    // Write your code here.\n    \n    // Write\
    \ your code here.\n    \n    // Write your code here.\n    \n    // Write your\
    \ code here.\n    \n    // Write your code here.\n    \n    // Write your code\
    \ here.\n    \n    // Write your code here.\n    \n    // Write your code here.\n\
    \    \n    // Write your code here.\n    \n    // Write your code here.\n    \n\
    \    // Write your code here.\n    \n    // Write your code here.\n    \n    //\
    \ Write your code here.\n    \n    // Write your code here.\n    \n    // Write\
    \ your code here.\n    \n    // Write your code here.\n    \n    // Write your\
    \ code here.\n    \n    // Write your code here.\n    \n    // Write your code\
    \ here.\n    \n    // Write your code here.\n    \n    // Write your code here.\n\
    \    \n    // Write your code here.\n    \n    // Write your code here.\n    \n\
    \    // \nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6b85gklk_test.go:171:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075250
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    max := 0\n    for _,\
    \ v := range q {\n        max += v\n    }\n    if max > w {\n        return false\n\
    \    }\n    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n   \
    \ if sum < max {\n        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpz2ae1lk5_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpz2ae1lk5_test.go:60:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075248
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    if q == nil || w == 0\
    \ {\n        return true\n    }\n    max := 0\n    for _, v := range q {\n   \
    \     max += v\n    }\n    if max > w {\n        return false\n    }\n    sum\
    \ := 0\n    for _, v := range q {\n        sum += v\n    }\n    if sum < max {\n\
    \        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T)\
    \ {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpv5hhnplq_test.go:63: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpv5hhnplq_test.go:63:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075248
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here.\n    max := 0\n    for _,\
    \ v := range q {\n        if v > max {\n            max = v\n        }\n    }\n\
    \    if max == 0 {\n        return true\n    }\n    sum := 0\n    for _, v :=\
    \ range q {\n        sum += v\n    }\n    if sum < w {\n        return false\n\
    \    }\n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate\
    \ := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 2,\
    \ 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmp2fuai3qp_test.go:62: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmp2fuai3qp_test.go:62:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__3\
    \ (0.00s)\n        tmp2fuai3qp_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmp2fuai3qp_test.go:62:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.006s\nFAIL\n"
  timestamp: 1660075252
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ if len(q) == 1 {\n        return q[0] == q[0]\n    }\n    if q[0] != q[len(q)-1]\
    \ {\n        return false\n    }\n    return will_it_fly(q[1:], w)\n}\n\nfunc\
    \ TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual:\
    \ candidate([]int{1, 2}, 5), expected: false },\n     { actual: candidate([]int{3},\
    \ 5), expected: true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n\
    \     { actual: candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpkt5aqfio_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075253
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    max := 0\n    for _,\
    \ v := range q {\n        max += v\n    }\n    if max < w {\n        return false\n\
    \    }\n    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n   \
    \ if sum < max {\n        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpuswn56kv_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpuswn56kv_test.go:60:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__3\
    \ (0.00s)\n        tmpuswn56kv_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpuswn56kv_test.go:60:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.006s\nFAIL\n"
  timestamp: 1660075253
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    return true\n}\n\nfunc\
    \ TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual:\
    \ candidate([]int{1, 2}, 5), expected: false },\n     { actual: candidate([]int{3},\
    \ 5), expected: true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n\
    \     { actual: candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpw2hbzu1y_test.go:46: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmpw2hbzu1y_test.go:46:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmpw2hbzu1y_test.go:46: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075251
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    return true\n}\n\nfunc\
    \ TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual:\
    \ candidate([]int{1, 2}, 5), expected: false },\n     { actual: candidate([]int{3},\
    \ 5), expected: true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n\
    \     { actual: candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpw2hbzu1y_test.go:46: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmpw2hbzu1y_test.go:46:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmpw2hbzu1y_test.go:46: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075251
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Your code here\n    max := 0\n    for _, v := range\
    \ q {\n        max += v\n    }\n    if max > w {\n        return false\n    }\n\
    \    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n    if sum\
    \ < max {\n        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpwvk8se7x_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpwvk8se7x_test.go:60:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660075253
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) <= 1 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max += v\n    }\n    if max > w\
    \ {\n        return false\n    }\n    sum := 0\n    for _, v := range q {\n  \
    \      sum += v\n    }\n    if sum < max {\n        return false\n    }\n    return\
    \ will_it_fly(q[:len(q)-1], w)\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate\
    \ := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 2,\
    \ 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmp_39ew7_2_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmp_39ew7_2_test.go:62:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.006s\nFAIL\n"
  timestamp: 1660075253
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here.\n    return true\n}\n\nfunc\
    \ TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual:\
    \ candidate([]int{1, 2}, 5), expected: false },\n     { actual: candidate([]int{3},\
    \ 5), expected: true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n\
    \     { actual: candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmp716x6nwg_test.go:46: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmp716x6nwg_test.go:46:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmp716x6nwg_test.go:46: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075248
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here.\n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpkziq0sjv_test.go:279:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075246
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    max := 0\n    for _,\
    \ v := range q {\n        max += v\n    }\n    if max > w {\n        return false\n\
    \    }\n    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n   \
    \ if sum < max {\n        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpz2ae1lk5_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpz2ae1lk5_test.go:60:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075248
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpusd7ge2s_test.go:279:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075250
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here.\n    max := 0\n    for _,\
    \ v := range q {\n        if v > max {\n            max = v\n        }\n    }\n\
    \    if max == 0 {\n        return true\n    }\n    sum := 0\n    for _, v :=\
    \ range q {\n        sum += v\n    }\n    if sum == 0 {\n        return true\n\
    \    }\n    if sum > w {\n        return false\n    }\n    if sum == w {\n   \
    \     return true\n    }\n    if sum < w {\n        return false\n    }\n    return\
    \ true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmp2sksno_8_test.go:71: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmp2sksno_8_test.go:71:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmp2sksno_8_test.go:71: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075253
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here.\n    max := 0\n    for _,\
    \ v := range q {\n        max += v\n    }\n    if max > w {\n        return false\n\
    \    }\n    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n   \
    \ if sum < max {\n        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmp3v0i9vy5_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmp3v0i9vy5_test.go:60:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075251
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max += v\n    }\n    if max > w\
    \ {\n        return false\n    }\n    sum := 0\n    for _, v := range q {\n  \
    \      sum += v\n    }\n    if sum < max {\n        return false\n    }\n    return\
    \ will_it_fly(q[:len(q)-1], w)\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate\
    \ := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 2,\
    \ 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpc2takwr1_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpc2takwr1_test.go:62:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075248
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ if len(q) == 1 {\n        return q[0] == q[0]\n    }\n    if q[0] != q[len(q)-1]\
    \ {\n        return false\n    }\n    return will_it_fly(q[1:], w)\n}\n\nfunc\
    \ TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual:\
    \ candidate([]int{1, 2}, 5), expected: false },\n     { actual: candidate([]int{3},\
    \ 5), expected: true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n\
    \     { actual: candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpkt5aqfio_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075253
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    max := 0\n    for _,\
    \ v := range q {\n        max += v\n    }\n    if max > w {\n        return false\n\
    \    }\n    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n   \
    \ if sum < max {\n        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpz2ae1lk5_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpz2ae1lk5_test.go:60:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075248
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    if len(q) == 0 {\n  \
    \      return true\n    }\n    if w == 0 {\n        return false\n    }\n    if\
    \ q[len(q)-1] != 0 {\n        return false\n    }\n    max := 0\n    for _, v\
    \ := range q {\n        max += v\n    }\n    if max > w {\n        return false\n\
    \    }\n    return will_it_fly(q[:len(q)-1], w) || will_it_fly(q[1:], w)\n}\n\n\
    func TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n\
    \     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpxczpla52_test.go:62: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpxczpla52_test.go:62:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__5\
    \ (0.00s)\n        tmpxczpla52_test.go:62: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075254
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max = max > v ? max : v\n    }\n\
    \    if max == 0 {\n        return true\n    }\n    sum := 0\n    for _, v :=\
    \ range q {\n        sum += v\n    }\n    return sum <= w && will_it_fly(q[:len(q)-1],\
    \ w)\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpzwzppzpa_test.go:29:23: illegal character U+003F ''?''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075253
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max += v\n    }\n    if max > w\
    \ {\n        return false\n    }\n    sum := 0\n    for _, v := range q {\n  \
    \      sum += v\n    }\n    if sum < max {\n        return false\n    }\n    return\
    \ will_it_fly(q[:len(q)-1], w)\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate\
    \ := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 2,\
    \ 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpc2takwr1_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpc2takwr1_test.go:62:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075248
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ if q[len(q)-1] < w {\n        return false\n    }\n    max := q[0]\n    for\
    \ _, v := range q[1:] {\n        if v > max {\n            max = v\n        }\n\
    \    }\n    return max == w\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate\
    \ := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 2,\
    \ 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpmbklvypz_test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpmbklvypz_test.go:57:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075255
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max = max > v ? max : v\n    }\n\
    \    return max <= w\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate :=\
    \ will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected:\
    \ true },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n    \
    \ { actual: candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpuiru1mkh_test.go:29:23: illegal character U+003F ''?''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075254
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    return true\n}\n\nfunc\
    \ TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual:\
    \ candidate([]int{1, 2}, 5), expected: false },\n     { actual: candidate([]int{3},\
    \ 5), expected: true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n\
    \     { actual: candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpw2hbzu1y_test.go:46: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmpw2hbzu1y_test.go:46:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmpw2hbzu1y_test.go:46: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075251
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ if w == 0 {\n        return false\n    }\n    max := 0\n    for _, v := range\
    \ q {\n        max = max * 10 + v\n    }\n    if max > w {\n        return false\n\
    \    }\n    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n   \
    \ if sum < max {\n        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmp_eahnr61_test.go:65: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075255
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here.\n    \n    max := 0\n   \
    \ for _, v := range q {\n        max += v\n    }\n    \n    if max == 0 {\n  \
    \      return true\n    }\n    \n    if max < w {\n        return false\n    }\n\
    \    \n    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n    \n\
    \    if sum < max {\n        return false\n    }\n    \n    return true\n}\n\n\
    func TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n\
    \     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmp88ayro45_test.go:69: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmp88ayro45_test.go:69:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__3\
    \ (0.00s)\n        tmp88ayro45_test.go:69: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmp88ayro45_test.go:69:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.006s\nFAIL\n"
  timestamp: 1660075255
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here.\n    max := 0\n    for _,\
    \ v := range q {\n        max += v\n    }\n    if max > w {\n        return false\n\
    \    }\n    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n   \
    \ if sum < max {\n        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmp3v0i9vy5_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmp3v0i9vy5_test.go:60:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075251
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here.\n    max := 0\n    for _,\
    \ v := range q {\n        max += v\n    }\n    if max == 0 {\n        return true\n\
    \    }\n    if max < w {\n        return false\n    }\n    sum := 0\n    for _,\
    \ v := range q {\n        sum += v\n    }\n    if sum < max {\n        return\
    \ false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n \
    \ candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmp3nc3vr34_test.go:63: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmp3nc3vr34_test.go:63:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__3\
    \ (0.00s)\n        tmp3nc3vr34_test.go:63: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmp3nc3vr34_test.go:63:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660075255
- exit_code: 2
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) <= 1 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max = max(max, v)\n    }\n    if\
    \ max < w {\n        return false\n    }\n    sum := 0\n    for _, v := range\
    \ q {\n        sum += v\n    }\n    if sum < w {\n        return false\n    }\n\
    \    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7id0b1h5_test.go:28:12: v declared but not used

    /tmp/tmp7id0b1h5_test.go:29:15: invalid operation: cannot call non-function max
    (variable of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075255
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max = max * 10 + v\n    }\n   \
    \ if max > w {\n        return false\n    }\n    sum := 0\n    for _, v := range\
    \ q {\n        sum += v\n    }\n    if sum < max {\n        return false\n   \
    \ }\n    return will_it_fly(q[:len(q)-1], w)\n}\n\nfunc TestWill_It_Fly(t *testing.T)\
    \ {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpx5vastjn_test.go:62: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075255
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Your code here\n    max := 0\n    for _, v := range\
    \ q {\n        if v > max {\n            max = v\n        }\n    }\n    sum :=\
    \ 0\n    for _, v := range q {\n        sum += v\n    }\n    if sum < max {\n\
    \        return false\n    }\n    if sum == max {\n        return true\n    }\n\
    \    return false\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmp38v2pkka_test.go:62: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075255
- exit_code: 2
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max = max(max, v)\n    }\n    if\
    \ max > w {\n        return false\n    }\n    sum := 0\n    for _, v := range\
    \ q {\n        sum += v\n    }\n    if sum < w {\n        return true\n    }\n\
    \    return will_it_fly(q[:len(q)-1], w)\n}\n\nfunc TestWill_It_Fly(t *testing.T)\
    \ {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpp6e53rj1_test.go:28:12: v declared but not used

    /tmp/tmpp6e53rj1_test.go:29:15: invalid operation: cannot call non-function max
    (variable of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075255
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here.\n    max := 0\n    for _,\
    \ v := range q {\n        max += v\n    }\n    if max > w {\n        return false\n\
    \    }\n    if max == w {\n        return true\n    }\n    sum := 0\n    for _,\
    \ v := range q {\n        sum += v\n    }\n    return sum <= w\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmp_9s9r8bm_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmp_9s9r8bm_test.go:60:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660075255
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here.\n    max := 0\n    for _,\
    \ v := range q {\n        max += v\n    }\n    if max > w {\n        return false\n\
    \    }\n    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n   \
    \ if sum < max {\n        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmp3v0i9vy5_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmp3v0i9vy5_test.go:60:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075251
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    max := 0\n    for _,\
    \ v := range q {\n        max += v\n    }\n    if max < w {\n        return false\n\
    \    }\n    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n   \
    \ if sum < max {\n        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpuswn56kv_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpuswn56kv_test.go:60:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__3\
    \ (0.00s)\n        tmpuswn56kv_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpuswn56kv_test.go:60:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.006s\nFAIL\n"
  timestamp: 1660075253
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) <= 1 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max += v\n    }\n    if max < w\
    \ {\n        return false\n    }\n    sum := 0\n    for _, v := range q {\n  \
    \      sum += v\n    }\n    return sum <= w\n}\n\nfunc TestWill_It_Fly(t *testing.T)\
    \ {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmp2z8hn4j2_test.go:59: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmp2z8hn4j2_test.go:59:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075255
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here.\n    max := 0\n    for _,\
    \ v := range q {\n        if v > max {\n            max = v\n        }\n    }\n\
    \    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n    if sum\
    \ < max {\n        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmp2f9ufvrx_test.go:59: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmp2f9ufvrx_test.go:59:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmp2f9ufvrx_test.go:59: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075251
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max += v\n    }\n    if max > w\
    \ {\n        return false\n    }\n    sum := 0\n    for _, v := range q {\n  \
    \      sum += v\n    }\n    if sum > max {\n        return false\n    }\n    return\
    \ true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpuce5kb70_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpuce5kb70_test.go:62:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075255
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max = max * 10 + v\n    }\n   \
    \ if max > w {\n        return false\n    }\n    sum := 0\n    for _, v := range\
    \ q {\n        sum += v\n    }\n    if sum < max {\n        return false\n   \
    \ }\n    return will_it_fly(q[:len(q)-1], w)\n}\n\nfunc TestWill_It_Fly(t *testing.T)\
    \ {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpx5vastjn_test.go:62: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075255
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        if v > max {\n            max =\
    \ v\n        }\n    }\n    if max > w {\n        return false\n    }\n    sum\
    \ := 0\n    for _, v := range q {\n        sum += v\n    }\n    if sum < max {\n\
    \        return false\n    }\n    return will_it_fly(q[:len(q)-1], w)\n}\n\nfunc\
    \ TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual:\
    \ candidate([]int{1, 2}, 5), expected: false },\n     { actual: candidate([]int{3},\
    \ 5), expected: true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n\
    \     { actual: candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpe7cem8gj_test.go:64: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpe7cem8gj_test.go:64:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075255
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here.\n    max := 0\n    for _,\
    \ v := range q {\n        max += v\n    }\n    if max > w {\n        return false\n\
    \    }\n    for i := range q {\n        if q[i] > max {\n            return false\n\
    \        }\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n\
    \  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmp7qoyysdu_test.go:58: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmp7qoyysdu_test.go:58:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075255
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    max := 0\n    for _,\
    \ v := range q {\n        max += v\n    }\n    if max > w {\n        return false\n\
    \    }\n    for _, v := range q {\n        if v != 0 {\n            if v != q[len(q)-1]\
    \ {\n                return false\n            }\n        }\n    }\n    return\
    \ true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpiv7r454e_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075255
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here.\n    max := 0\n    for _,\
    \ v := range q {\n        max += v\n    }\n    if max > w {\n        return false\n\
    \    }\n    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n   \
    \ if sum < max {\n        return true\n    }\n    return false\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmprkvvy0pf_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmprkvvy0pf_test.go:60:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__5\
    \ (0.00s)\n        tmprkvvy0pf_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075255
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) <= 1 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max += v\n    }\n    if max > w\
    \ {\n        return false\n    }\n    sum := 0\n    for _, v := range q {\n  \
    \      sum += v\n    }\n    if sum < max {\n        return false\n    }\n    return\
    \ true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpwphdy2cx_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpwphdy2cx_test.go:62:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075251
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ if w == 0 {\n        return false\n    }\n    if q[len(q)-1] != 0 {\n      \
    \  return false\n    }\n    if w == 1 {\n        return true\n    }\n    max :=\
    \ 0\n    for _, v := range q {\n        if v > max {\n            max = v\n  \
    \      }\n    }\n    if max > w {\n        return false\n    }\n    return will_it_fly(q[:len(q)-1],\
    \ w-max)\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmp464_ghel_test.go:66: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmp464_ghel_test.go:66:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__5\
    \ (0.00s)\n        tmp464_ghel_test.go:66: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075256
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // \nfunc TestWill_It_Fly(t *testing.T)\
    \ {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpc974zb7c_test.go:171:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075248
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max += v\n    }\n    if max > w\
    \ {\n        return false\n    }\n    sum := 0\n    for _, v := range q {\n  \
    \      sum += v\n    }\n    if sum < max {\n        return false\n    }\n    return\
    \ will_it_fly(q[:len(q)-1], w)\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate\
    \ := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 2,\
    \ 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpc2takwr1_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpc2takwr1_test.go:62:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075248
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    return true\n}\n\nfunc\
    \ TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual:\
    \ candidate([]int{1, 2}, 5), expected: false },\n     { actual: candidate([]int{3},\
    \ 5), expected: true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n\
    \     { actual: candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpw2hbzu1y_test.go:46: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmpw2hbzu1y_test.go:46:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmpw2hbzu1y_test.go:46: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075251
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ if w == 0 {\n        return false\n    }\n    if q[len(q)-1] == 0 {\n      \
    \  return will_it_fly(q[:len(q)-1], w)\n    }\n    max := 0\n    for _, v := range\
    \ q {\n        if v > max {\n            max = v\n        }\n    }\n    return\
    \ will_it_fly(q[:len(q)-1], w) && max == w\n}\n\nfunc TestWill_It_Fly(t *testing.T)\
    \ {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpd1fricsj_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpd1fricsj_test.go:60:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.006s\nFAIL\n"
  timestamp: 1660075256
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ if len(q) == 1 {\n        return q[0] == q[0]\n    }\n    if q[0] != q[len(q)-1]\
    \ {\n        return false\n    }\n    max := 0\n    for _, v := range q {\n  \
    \      max += v\n    }\n    if max > w {\n        return false\n    }\n    return\
    \ will_it_fly(q[1:], w)\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate\
    \ := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 2,\
    \ 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpsbpiakqp_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075256
- exit_code: 0
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    if len(q) == 0 {\n  \
    \      return true\n    }\n    if len(q) == 1 {\n        return q[0] == q[0]\n\
    \    }\n    if q[0] != q[len(q)-1] {\n        return false\n    }\n    max :=\
    \ 0\n    for i := 0; i < len(q); i++ {\n        max += q[i]\n    }\n    if max\
    \ > w {\n        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660075256
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max += v\n    }\n    if max > w\
    \ {\n        return false\n    }\n    return will_it_fly(q[1:], w)\n}\n\nfunc\
    \ TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual:\
    \ candidate([]int{1, 2}, 5), expected: false },\n     { actual: candidate([]int{3},\
    \ 5), expected: true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n\
    \     { actual: candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpz0sp7hpf_test.go:55: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpz0sp7hpf_test.go:55:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.006s\nFAIL\n"
  timestamp: 1660075256
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max += v\n    }\n    if max > w\
    \ {\n        return false\n    }\n    sum := 0\n    for _, v := range q {\n  \
    \      sum += v\n    }\n    if sum < max {\n        return false\n    }\n    return\
    \ true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpt8rxjd89_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpt8rxjd89_test.go:62:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075251
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) <= 1 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max += v\n    }\n    if max > w\
    \ {\n        return false\n    }\n    for _, v := range q {\n        if v != q[len(q)-1]\
    \ {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpl_9q9yrf_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075257
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        if v > max {\n            max =\
    \ v\n        }\n    }\n    if w > max {\n        return false\n    }\n    sum\
    \ := 0\n    for _, v := range q {\n        sum += v\n    }\n    return sum <=\
    \ w\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpq0slqum8_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpq0slqum8_test.go:61:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.006s\nFAIL\n"
  timestamp: 1660075256
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ if len(q) == 1 {\n        return q[0] == q[0]\n    }\n    if q[0] != q[len(q)-1]\
    \ {\n        return false\n    }\n    max := 0\n    for i := 0; i < len(q); i++\
    \ {\n        if max < q[i] {\n            max = q[i]\n        }\n    }\n    if\
    \ max == 0 {\n        return true\n    }\n    if w == 0 {\n        return true\n\
    \    }\n    if max > w {\n        return false\n    }\n    return will_it_fly(q[1:],\
    \ w-max)\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpx709aai6_test.go:69: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075257
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max += v\n    }\n    if max > w\
    \ {\n        return false\n    }\n    sum := 0\n    for _, v := range q {\n  \
    \      sum += v\n    }\n    if sum < max {\n        return false\n    }\n    return\
    \ will_it_fly(q[1:], w)\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate\
    \ := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 2,\
    \ 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpkxakimrv_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpkxakimrv_test.go:62:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075248
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ if w == 0 {\n        return false\n    }\n    max := 0\n    for _, v := range\
    \ q {\n        max = max * 10 + v\n    }\n    if max > w {\n        return false\n\
    \    }\n    if max < w {\n        return true\n    }\n    sum := 0\n    for _,\
    \ v := range q {\n        sum += v\n    }\n    if sum < w {\n        return true\n\
    \    }\n    return false\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate\
    \ := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 2,\
    \ 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpclt6do1z_test.go:68: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__5 (0.00s)\n        tmpclt6do1z_test.go:68:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075257
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ if w == 0 {\n        return false\n    }\n    max := 0\n    for _, v := range\
    \ q {\n        max += v\n    }\n    if max > w {\n        return false\n    }\n\
    \    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n    if sum\
    \ < max {\n        return false\n    }\n    return will_it_fly(q[:len(q)-1], w-sum)\n\
    }\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n\
    \     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmp0877yln9_test.go:65: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__1 (0.00s)\n        tmp0877yln9_test.go:65:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075258
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpusd7ge2s_test.go:279:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075250
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here.\n    max := 0\n    for _,\
    \ v := range q {\n        max += v\n    }\n    if max > w {\n        return false\n\
    \    }\n    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n   \
    \ if sum < max {\n        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmp3v0i9vy5_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmp3v0i9vy5_test.go:60:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075251
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ if q[len(q)-1] == 0 {\n        return false\n    }\n    max := 0\n    for _,\
    \ v := range q {\n        max += v\n    }\n    if max > w {\n        return false\n\
    \    }\n    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n   \
    \ if sum < max {\n        return false\n    }\n    return will_it_fly(q[:len(q)-1],\
    \ w)\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmp2_r8oj2e_test.go:65: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmp2_r8oj2e_test.go:65:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075258
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here.\n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpkziq0sjv_test.go:279:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075246
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpusd7ge2s_test.go:279:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075250
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here.\n    max := 0\n    for _,\
    \ v := range q {\n        max = max+v\n    }\n    if max < w {\n        return\
    \ false\n    }\n    if max == w {\n        return true\n    }\n    sum := 0\n\
    \    for _, v := range q {\n        sum = sum+v\n    }\n    if sum < max {\n \
    \       return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T)\
    \ {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpbaoml2jh_test.go:63: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpbaoml2jh_test.go:63:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__3\
    \ (0.00s)\n        tmpbaoml2jh_test.go:63: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpbaoml2jh_test.go:63:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.006s\nFAIL\n"
  timestamp: 1660075258
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) <= 1 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max += v\n    }\n    if max > w\
    \ {\n        return false\n    }\n    sum := 0\n    for _, v := range q {\n  \
    \      sum += v\n    }\n    if sum < max {\n        return false\n    }\n    return\
    \ will_it_fly(q[:len(q)-1], w)\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate\
    \ := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 2,\
    \ 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmp_39ew7_2_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmp_39ew7_2_test.go:62:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.006s\nFAIL\n"
  timestamp: 1660075253
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ if w == 0 {\n        return false\n    }\n    if q[len(q)-1] == 0 {\n      \
    \  return will_it_fly(q[:len(q)-1], w)\n    }\n    if q[0] == 0 {\n        return\
    \ will_it_fly(q[1:], w)\n    }\n    if q[len(q)-1] == q[0] {\n        return will_it_fly(q[:len(q)-1],\
    \ w)\n    }\n    if q[len(q)-1] < q[0] {\n        return will_it_fly(q[:len(q)-1],\
    \ w)\n    }\n    if q[0] < q[len(q)-1] {\n        return will_it_fly(q[1:], w)\n\
    \    }\n    return will_it_fly(q[:len(q)-1], w)\n}\n\nfunc TestWill_It_Fly(t *testing.T)\
    \ {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpr5s9j9mm_test.go:66: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmpr5s9j9mm_test.go:66:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmpr5s9j9mm_test.go:66: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075258
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ if q[0] != 0 {\n        return false\n    }\n    max := 0\n    for _, v := range\
    \ q {\n        max += v\n    }\n    if max > w {\n        return false\n    }\n\
    \    return will_it_fly(q[1:], w)\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n\
    \  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmp7o4319gr_test.go:58: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmp7o4319gr_test.go:58:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__5\
    \ (0.00s)\n        tmp7o4319gr_test.go:58: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075258
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Your code here\n    max := 0\n    for _, v := range\
    \ q {\n        max += v\n    }\n    if max > w {\n        return false\n    }\n\
    \    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n    if sum\
    \ < max {\n        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpwvk8se7x_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpwvk8se7x_test.go:60:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660075253
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    if len(q) == 0 {\n  \
    \      return true\n    }\n    if len(q) == 1 {\n        return q[0] == q[0]\n\
    \    }\n    max := 0\n    for _, v := range q {\n        max += v\n    }\n   \
    \ if max > w {\n        return false\n    }\n    sum := 0\n    for _, v := range\
    \ q {\n        sum += v\n    }\n    if sum < max {\n        return false\n   \
    \ }\n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate :=\
    \ will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected:\
    \ true },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n    \
    \ { actual: candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmp376uq5ai_test.go:66: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmp376uq5ai_test.go:66:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075258
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    max := 0\n    for _,\
    \ v := range q {\n        max += v\n    }\n    if max > w {\n        return false\n\
    \    }\n    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n   \
    \ if sum < max {\n        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpz2ae1lk5_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpz2ae1lk5_test.go:60:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075248
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    if len(q) == 0 {\n  \
    \      return true\n    }\n    if q[len(q)-1] != len(q)/2 {\n        return false\n\
    \    }\n    max := 0\n    for _, v := range q {\n        max += v\n    }\n   \
    \ if max > w {\n        return false\n    }\n    return will_it_fly(q[:len(q)-1],\
    \ w)\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmp20m7w8ox_test.go:59: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmp20m7w8ox_test.go:59:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__5\
    \ (0.00s)\n        tmp20m7w8ox_test.go:59: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075258
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max += v\n    }\n    if max > w\
    \ {\n        return false\n    }\n    sum := 0\n    for _, v := range q {\n  \
    \      sum += v\n    }\n    if sum < max {\n        return false\n    }\n    return\
    \ will_it_fly(q[1:], w)\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate\
    \ := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 2,\
    \ 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpkxakimrv_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpkxakimrv_test.go:62:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075248
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here.\n    max := 0\n    for _,\
    \ v := range q {\n        if v > max {\n            max = v\n        }\n    }\n\
    \    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n    if sum\
    \ == w && max <= w {\n        return true\n    }\n    return false\n}\n\nfunc\
    \ TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual:\
    \ candidate([]int{1, 2}, 5), expected: false },\n     { actual: candidate([]int{3},\
    \ 5), expected: true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n\
    \     { actual: candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpbg02g286_test.go:59: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpbg02g286_test.go:59:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmpbg02g286_test.go:59: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075258
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here.\n    max := 0\n    for _,\
    \ v := range q {\n        max += v\n    }\n    if max < w {\n        return false\n\
    \    }\n    if max == w {\n        return true\n    }\n    sum := 0\n    for _,\
    \ v := range q {\n        sum += v\n    }\n    return sum <= w\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpmspirqmu_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpmspirqmu_test.go:60:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmpmspirqmu_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660075258
- exit_code: 2
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ if q[len(q)-1] != len(q)/2 {\n        return false\n    }\n    if w == 0 {\n\
    \        return true\n    }\n    if w == 1 {\n        return true\n    }\n   \
    \ if q[0] > w {\n        return false\n    }\n    return will_it_fly(q[1:], w-q)\n\
    }\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n\
    \     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqtl8e0ox_test.go:39:31: invalid operation: w - q (mismatched types int
    and []int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075258
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ if q[0] < w {\n        return false\n    }\n    if q[len(q)-1] < w {\n     \
    \   return false\n    }\n    max := q[0]\n    for _, v := range q[1:] {\n    \
    \    if v > max {\n            max = v\n        }\n    }\n    return max == w\n\
    }\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n\
    \     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpqah32v_5_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpqah32v_5_test.go:60:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075258
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here.\n    max := 0\n    for _,\
    \ v := range q {\n        max += v\n    }\n    if max > w {\n        return false\n\
    \    }\n    for _, v := range q {\n        if v != q[len(q)-1] {\n           \
    \ return false\n        }\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpsn8owpis_test.go:58: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075258
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max += v\n    }\n    if max > w\
    \ {\n        return false\n    }\n    sum := 0\n    for _, v := range q {\n  \
    \      sum += v\n    }\n    if sum > max {\n        return false\n    }\n    return\
    \ true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpuce5kb70_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpuce5kb70_test.go:62:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075255
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max += v\n    }\n    if max > w\
    \ {\n        return false\n    }\n    return will_it_fly(q[1:], w)\n}\n\nfunc\
    \ TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual:\
    \ candidate([]int{1, 2}, 5), expected: false },\n     { actual: candidate([]int{3},\
    \ 5), expected: true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n\
    \     { actual: candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpz0sp7hpf_test.go:55: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpz0sp7hpf_test.go:55:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.006s\nFAIL\n"
  timestamp: 1660075256
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpusd7ge2s_test.go:279:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075250
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // TODO: Write the function here.\n    return false\n\
    }\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n\
    \     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpzgl2zoye_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpzgl2zoye_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__5\
    \ (0.00s)\n        tmpzgl2zoye_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075258
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here.\n    max := 0\n    for _,\
    \ v := range q {\n        max += v\n    }\n    if max > w {\n        return false\n\
    \    }\n    if max < w {\n        return true\n    }\n    return true\n}\n\nfunc\
    \ TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual:\
    \ candidate([]int{1, 2}, 5), expected: false },\n     { actual: candidate([]int{3},\
    \ 5), expected: true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n\
    \     { actual: candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpwaxq6p6r_test.go:56: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpwaxq6p6r_test.go:56:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660075259
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpusd7ge2s_test.go:279:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075250
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) <= 1 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max += v\n    }\n    if max > w\
    \ {\n        return false\n    }\n    sum := 0\n    for _, v := range q {\n  \
    \      sum += v\n        if sum > w {\n            return false\n        }\n \
    \   }\n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate\
    \ := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 2,\
    \ 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpydo_m6l5_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpydo_m6l5_test.go:62:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660075259
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max = max * 10 + v\n    }\n   \
    \ if max > w {\n        return false\n    }\n    sum := 0\n    for _, v := range\
    \ q {\n        sum += v\n    }\n    if sum < max {\n        return false\n   \
    \ }\n    return will_it_fly(q[1:], w)\n}\n\nfunc TestWill_It_Fly(t *testing.T)\
    \ {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpnnwx0c9s_test.go:62: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075259
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpusd7ge2s_test.go:279:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075250
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max = max * 10 + v\n    }\n   \
    \ if max > w {\n        return false\n    }\n    sum := 0\n    for _, v := range\
    \ q {\n        sum += v\n    }\n    if sum > max {\n        return false\n   \
    \ }\n    return will_it_fly(q[1:], w)\n}\n\nfunc TestWill_It_Fly(t *testing.T)\
    \ {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmprw1icvrc_test.go:62: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075259
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    return true\n}\n\nfunc\
    \ TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual:\
    \ candidate([]int{1, 2}, 5), expected: false },\n     { actual: candidate([]int{3},\
    \ 5), expected: true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n\
    \     { actual: candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpw2hbzu1y_test.go:46: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmpw2hbzu1y_test.go:46:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmpw2hbzu1y_test.go:46: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075251
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // \nfunc TestWill_It_Fly(t *testing.T)\
    \ {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpc974zb7c_test.go:171:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075248
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ if w == 0 {\n        return false\n    }\n    if q[len(q)-1] != 0 {\n      \
    \  return false\n    }\n    max := 0\n    for _, v := range q {\n        max +=\
    \ v\n    }\n    if max > w {\n        return false\n    }\n    return will_it_fly(q[:len(q)-1],\
    \ w) || will_it_fly(q[1:], w)\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate\
    \ := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 2,\
    \ 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpwb59nyzx_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpwb59nyzx_test.go:61:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__5\
    \ (0.00s)\n        tmpwb59nyzx_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075259
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    max := 0\n    for _,\
    \ v := range q {\n        max += v\n    }\n    if max < w {\n        return false\n\
    \    }\n    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n   \
    \ if sum < max {\n        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpuswn56kv_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpuswn56kv_test.go:60:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__3\
    \ (0.00s)\n        tmpuswn56kv_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpuswn56kv_test.go:60:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.006s\nFAIL\n"
  timestamp: 1660075253
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpusd7ge2s_test.go:279:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075250
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max += v\n    }\n    if max > w\
    \ {\n        return false\n    }\n    sum := 0\n    for _, v := range q {\n  \
    \      sum += v\n    }\n    if sum < max {\n        return false\n    }\n    return\
    \ will_it_fly(q[:len(q)-1], w)\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate\
    \ := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 2,\
    \ 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpc2takwr1_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpc2takwr1_test.go:62:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075248
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here.\n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpkziq0sjv_test.go:279:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075246
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpusd7ge2s_test.go:279:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075250
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max = max * 10 + v\n    }\n   \
    \ if max > w {\n        return false\n    }\n    sum := 0\n    for _, v := range\
    \ q {\n        sum += v\n    }\n    if sum < max {\n        return false\n   \
    \ }\n    return will_it_fly(q[:len(q)-1], w)\n}\n\nfunc TestWill_It_Fly(t *testing.T)\
    \ {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpx5vastjn_test.go:62: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075255
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here.\n    max := 0\n    for _,\
    \ v := range q {\n        max += v\n    }\n    if max > w {\n        return false\n\
    \    }\n    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n   \
    \ if sum < max {\n        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmp3v0i9vy5_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmp3v0i9vy5_test.go:60:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075251
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max += v\n    }\n    if max > w\
    \ {\n        return false\n    }\n    sum := 0\n    for _, v := range q {\n  \
    \      sum += v\n    }\n    if sum < max {\n        return false\n    }\n    return\
    \ will_it_fly(q[:len(q)-1], w)\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate\
    \ := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 2,\
    \ 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpc2takwr1_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpc2takwr1_test.go:62:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075248
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    max := 0\n    for _,\
    \ v := range q {\n        max += v\n    }\n    if max > w {\n        return false\n\
    \    }\n    for _, v := range q {\n        if v != 0 {\n            if v != q[len(q)-1]\
    \ {\n                return false\n            }\n        }\n    }\n    return\
    \ true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpiv7r454e_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075255
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max = max * 10 + v\n    }\n   \
    \ if max > w {\n        return false\n    }\n    sum := 0\n    for _, v := range\
    \ q {\n        sum += v\n    }\n    if sum < max {\n        return false\n   \
    \ }\n    return will_it_fly(q[1:], w)\n}\n\nfunc TestWill_It_Fly(t *testing.T)\
    \ {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpnnwx0c9s_test.go:62: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075259
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here.\n    max := 0\n    for _,\
    \ v := range q {\n        max += v\n    }\n    if max > w {\n        return false\n\
    \    }\n    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n   \
    \ if sum < max {\n        return true\n    }\n    return false\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmprkvvy0pf_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmprkvvy0pf_test.go:60:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__5\
    \ (0.00s)\n        tmprkvvy0pf_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075255
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        if v > max {\n            max =\
    \ v\n        }\n    }\n    if max <= w {\n        return true\n    }\n    sum\
    \ := 0\n    for _, v := range q {\n        sum += v\n    }\n    return sum <=\
    \ w\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpg3xg40al_test.go:61: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpg3xg40al_test.go:61:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.006s\nFAIL\n"
  timestamp: 1660075259
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ if len(q) == 1 {\n        return q[0] == q[0]\n    }\n    if q[0] != q[len(q)-1]\
    \ {\n        return false\n    }\n    max := 0\n    for i := 0; i < len(q); i++\
    \ {\n        if max < q[i] {\n            max = q[i]\n        }\n    }\n    if\
    \ max < w {\n        return false\n    }\n    sum := 0\n    for i := 0; i < len(q);\
    \ i++ {\n        sum += q[i]\n    }\n    return sum <= w\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmprvws23sn_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075259
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Your code here\n    \n    return true\n}\n\nfunc\
    \ TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual:\
    \ candidate([]int{1, 2}, 5), expected: false },\n     { actual: candidate([]int{3},\
    \ 5), expected: true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n\
    \     { actual: candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmp4p8h4d2j_test.go:47: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmp4p8h4d2j_test.go:47:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmp4p8h4d2j_test.go:47: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075259
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here.\n    \n    return true\n\
    }\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n\
    \     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmp6n21iyvz_test.go:47: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmp6n21iyvz_test.go:47:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmp6n21iyvz_test.go:47: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075260
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max += v\n    }\n    if max > w\
    \ {\n        return false\n    }\n    sum := 0\n    for _, v := range q {\n  \
    \      sum += v\n    }\n    if sum < max {\n        return false\n    }\n    return\
    \ will_it_fly(q[:len(q)-1], w)\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate\
    \ := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 2,\
    \ 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpc2takwr1_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpc2takwr1_test.go:62:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075248
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ if len(q) == 1 {\n        return q[0] == q[0]\n    }\n    if q[0] != q[len(q)-1]\
    \ {\n        return false\n    }\n    max := 0\n    for _, v := range q {\n  \
    \      max += v\n    }\n    if max > w {\n        return false\n    }\n    return\
    \ will_it_fly(q[1:], w)\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate\
    \ := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 2,\
    \ 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpsbpiakqp_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075256
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    if len(q) == 0 {\n  \
    \      return true\n    }\n    if w == 0 {\n        return false\n    }\n    if\
    \ q[0] > w {\n        return false\n    }\n    max := 0\n    for _, v := range\
    \ q {\n        if v > max {\n            max = v\n        }\n    }\n    if max\
    \ <= w {\n        return true\n    }\n    return will_it_fly(q[1:], w)\n}\n\n\
    func TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n\
    \     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpwd9guij3_test.go:64: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpwd9guij3_test.go:64:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075260
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ if len(q) == 1 {\n        return q[0] == q[0]\n    }\n    if q[0] != q[len(q)-1]\
    \ {\n        return false\n    }\n    return will_it_fly(q[1:], w)\n}\n\nfunc\
    \ TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual:\
    \ candidate([]int{1, 2}, 5), expected: false },\n     { actual: candidate([]int{3},\
    \ 5), expected: true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n\
    \     { actual: candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpkt5aqfio_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075253
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ if w == 0 {\n        return false\n    }\n    if q[len(q)-1] != 0 {\n      \
    \  return false\n    }\n    max := 0\n    for i := 0; i < len(q); i++ {\n    \
    \    if q[i] > max {\n            max = q[i]\n        }\n    }\n    if max ==\
    \ 0 {\n        return false\n    }\n    sum := 0\n    for i := 0; i < len(q);\
    \ i++ {\n        sum += q[i]\n    }\n    if sum > w {\n        return false\n\
    \    }\n    return will_it_fly(q[:len(q)-1], w)\n}\n\nfunc TestWill_It_Fly(t *testing.T)\
    \ {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmp0mu8lynh_test.go:70: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmp0mu8lynh_test.go:70:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__5\
    \ (0.00s)\n        tmp0mu8lynh_test.go:70: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075260
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    max := 0\n    for _,\
    \ v := range q {\n        max += v\n    }\n    if max > w {\n        return false\n\
    \    }\n    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n   \
    \ if sum < max {\n        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpz2ae1lk5_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpz2ae1lk5_test.go:60:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075248
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ if q[0] != 0 {\n        return false\n    }\n    max := 0\n    for _, v := range\
    \ q {\n        max += v\n    }\n    if max < w {\n        return false\n    }\n\
    \    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n    return\
    \ sum <= w\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmp2jqzcqzg_test.go:62: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmp2jqzcqzg_test.go:62:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__5\
    \ (0.00s)\n        tmp2jqzcqzg_test.go:62: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n"
  timestamp: 1660075260
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ if w == 0 {\n        return false\n    }\n    if q[len(q)-1] != 0 {\n      \
    \  return false\n    }\n    if w == 1 {\n        return true\n    }\n    max :=\
    \ 0\n    for i := 0; i < len(q); i++ {\n        if max < q[i] {\n            max\
    \ = q[i]\n        }\n    }\n    if max == 0 {\n        return true\n    }\n  \
    \  sum := 0\n    for i := 0; i < len(q); i++ {\n        sum += q[i]\n        if\
    \ sum > w {\n            return false\n        }\n    }\n    return true\n}\n\n\
    func TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n\
    \     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmptgo6tkt7_test.go:73: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmptgo6tkt7_test.go:73:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__5\
    \ (0.00s)\n        tmptgo6tkt7_test.go:73: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075260
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max += v\n    }\n    if max > w\
    \ {\n        return false\n    }\n    sum := 0\n    for _, v := range q {\n  \
    \      sum += v\n    }\n    return sum <= w\n}\n\nfunc TestWill_It_Fly(t *testing.T)\
    \ {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpe0swsoee_test.go:59: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpe0swsoee_test.go:59:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075248
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Your code here\n    max := 0\n    for _, v := range\
    \ q {\n        max += v\n    }\n    if max > w {\n        return false\n    }\n\
    \    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n    if sum\
    \ < max {\n        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpwvk8se7x_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpwvk8se7x_test.go:60:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660075253
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    max := 0\n    for _,\
    \ v := range q {\n        max += v\n    }\n    if max < w {\n        return false\n\
    \    }\n    if max > w {\n        return true\n    }\n    sum := 0\n    for _,\
    \ v := range q {\n        sum += v\n    }\n    if sum < max {\n        return\
    \ false\n    }\n    if sum > max {\n        return true\n    }\n    return true\n\
    }\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n\
    \     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmp4wo8kml7_test.go:66: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmp4wo8kml7_test.go:66:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__3\
    \ (0.00s)\n        tmp4wo8kml7_test.go:66: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmp4wo8kml7_test.go:66:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075260
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    max := 0\n    for _,\
    \ v := range q {\n        max += v\n    }\n    if max > w {\n        return false\n\
    \    }\n    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n   \
    \ if sum < max {\n        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpz2ae1lk5_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpz2ae1lk5_test.go:60:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075248
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) <= 1 {\n        return true\n    }\n   \
    \ if q[0] != len(q)/2 {\n        return false\n    }\n    if w == 0 {\n      \
    \  return true\n    }\n    max := 0\n    for _, v := range q {\n        max +=\
    \ v\n    }\n    if max > w {\n        return false\n    }\n    return will_it_fly(q[1:],\
    \ w)\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpwlt2d6cg_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__1 (0.00s)\n        tmpwlt2d6cg_test.go:61:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.006s\nFAIL\n"
  timestamp: 1660075260
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here.\n    return true\n}\n\nfunc\
    \ TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual:\
    \ candidate([]int{1, 2}, 5), expected: false },\n     { actual: candidate([]int{3},\
    \ 5), expected: true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n\
    \     { actual: candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmp716x6nwg_test.go:46: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmp716x6nwg_test.go:46:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmp716x6nwg_test.go:46: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075248
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    max := 0\n    for _,\
    \ v := range q {\n        max += v\n    }\n    if max > w {\n        return false\n\
    \    }\n    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n   \
    \ if sum < max {\n        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpz2ae1lk5_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpz2ae1lk5_test.go:60:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075248
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) <= 1 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max += v\n    }\n    if max > w\
    \ {\n        return false\n    }\n    sum := 0\n    for _, v := range q {\n  \
    \      sum += v\n    }\n    if sum < max {\n        return false\n    }\n    return\
    \ true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpwphdy2cx_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpwphdy2cx_test.go:62:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075251
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) <= 1 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max += v\n    }\n    if max > w\
    \ {\n        return false\n    }\n    sum := 0\n    for _, v := range q {\n  \
    \      sum += v\n    }\n    if sum < max {\n        return false\n    }\n    return\
    \ true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpwphdy2cx_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpwphdy2cx_test.go:62:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075251
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Your code here\n    max := 0\n    for _, v := range\
    \ q {\n        if v > max {\n            max = v\n        }\n    }\n    sum :=\
    \ 0\n    for _, v := range q {\n        sum += v\n    }\n    if sum < max {\n\
    \        return false\n    }\n    if sum == max {\n        return true\n    }\n\
    \    return false\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmp38v2pkka_test.go:62: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075255
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    if len(q) == 0 {\n  \
    \      return true\n    }\n    max := 0\n    for _, v := range q {\n        max\
    \ = max+v\n    }\n    if max > w {\n        return false\n    }\n    sum := 0\n\
    \    for _, v := range q {\n        sum = sum+v\n    }\n    if sum < max {\n \
    \       return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T)\
    \ {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpckfb7a3m_test.go:63: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpckfb7a3m_test.go:63:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660075260
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max += v\n    }\n    if max > w\
    \ {\n        return false\n    }\n    sum := 0\n    for _, v := range q {\n  \
    \      sum += v\n    }\n    if sum < max {\n        return false\n    }\n    return\
    \ will_it_fly(q[:len(q)-1], w)\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate\
    \ := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 2,\
    \ 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpc2takwr1_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpc2takwr1_test.go:62:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075248
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here.\n    return true\n}\n\nfunc\
    \ TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual:\
    \ candidate([]int{1, 2}, 5), expected: false },\n     { actual: candidate([]int{3},\
    \ 5), expected: true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n\
    \     { actual: candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmp716x6nwg_test.go:46: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmp716x6nwg_test.go:46:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmp716x6nwg_test.go:46: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075248
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ if len(q) == 1 {\n        return q[0] == q[0]\n    }\n    if q[0] != q[len(q)-1]\
    \ {\n        return false\n    }\n    return will_it_fly(q[1:], w)\n}\n\nfunc\
    \ TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual:\
    \ candidate([]int{1, 2}, 5), expected: false },\n     { actual: candidate([]int{3},\
    \ 5), expected: true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n\
    \     { actual: candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpkt5aqfio_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075253
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here.\n    if len(q) == 0 {\n \
    \       return true\n    }\n    max := 0\n    for _, v := range q {\n        max\
    \ += v\n    }\n    if max > w {\n        return false\n    }\n    sum := 0\n \
    \   for _, v := range q {\n        sum += v\n    }\n    if sum < max {\n     \
    \   return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T)\
    \ {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmp2axm66pc_test.go:63: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmp2axm66pc_test.go:63:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660075260
