language: go_test.go
name: HumanEval_159_eat
results:
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    carrots +=\
    \ number\n    carrots += need\n    carrots += remaining\n    carrots %= 1000\n\
    \    if carrots == 0 {\n        carrots = 1000\n    }\n    return []int{carrots,\
    \ carrots - number}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp3e8mrkkb_test.go:67: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=21)\
    \ %!s(int=16)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp3e8mrkkb_test.go:67:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=21) %!s(int=17)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp3e8mrkkb_test.go:67: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=21) %!s(int=20)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp3e8mrkkb_test.go:67: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=18) %!s(int=16)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmp3e8mrkkb_test.go:67: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=16)\
    \ %!s(int=12)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp3e8mrkkb_test.go:67:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=10) %!s(int=6)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075315
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return nil\n    }\n    result := make([]int, 2)\n    carrots\
    \ := 0\n    carrots = number\n    carrots = carrots - need\n    carrots = carrots\
    \ + remaining\n    result[0] = carrots\n    result[1] = remaining\n    return\
    \ result\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp_y9k2ak5_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=9)\
    \ %!s(int=10)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp_y9k2ak5_test.go:66:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=5) %!s(int=9)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp_y9k2ak5_test.go:66: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp_y9k2ak5_test.go:66: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=-4) %!s(int=5)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmp_y9k2ak5_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=6)\
    \ %!s(int=7)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp_y9k2ak5_test.go:66:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=0) %!s(int=1)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075315
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    meals :=\
    \ 0\n    for carrots < number {\n        if meals >= need {\n            meals\
    \ -= need\n            carrots += meals\n        } else {\n            carrots\
    \ += remaining\n        }\n    }\n    return []int{carrots, remaining}\n}\n\n\
    func TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp5g1d6vfa_test.go:69: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=10)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp5g1d6vfa_test.go:69:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=9)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp5g1d6vfa_test.go:69: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp5g1d6vfa_test.go:69: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=5)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp5g1d6vfa_test.go:69: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=7)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp5g1d6vfa_test.go:69:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=1)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075315
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    carrots := 0\n    if number > need {\n        carrots = number-need\n\
    \    } else {\n        carrots = need\n    }\n    if remaining > carrots {\n \
    \       carrots = remaining\n    }\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrot\nfunc\
    \ TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvndgio00_test.go:97:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075314
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    carrots := 0\n    meals := 0\n    carrots = number\n    meals\
    \ = need\n    carrots = carrots - meals\n    carrots = carrots - remaining\n \
    \   if carrots < 0 {\n        carrots = 0\n    }\n    meals = meals - carrots\n\
    \    if meals < 0 {\n        meals = 0\n    }\n    carrots = carrots + meals\n\
    \    if carrots > 1000 {\n        carrots = 1000\n    }\n    return []int{carrots,\
    \ meals}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp7soga9ug_test.go:76: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=6)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp7soga9ug_test.go:76:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=8)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp7soga9ug_test.go:76: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp7soga9ug_test.go:76: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=11) %!s(int=11)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmp7soga9ug_test.go:76: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=5)\
    \ %!s(int=5)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp7soga9ug_test.go:76:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=5) %!s(int=5)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075315
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    carrots +=\
    \ number\n    carrots += need\n    carrots += remaining\n    if carrots > 1000\
    \ {\n        carrots = 1000\n    }\n    if carrots < 0 {\n        carrots = 0\n\
    \    }\n    return []int{carrots, carrots - carrots}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmppvaa8gfn_test.go:69: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=21)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmppvaa8gfn_test.go:69:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=21) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmppvaa8gfn_test.go:69: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=21) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmppvaa8gfn_test.go:69: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=18) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmppvaa8gfn_test.go:69: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=16)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmppvaa8gfn_test.go:69:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075315
- exit_code: 2
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    carrots +=\
    \ number\n    if carrots >= need {\n        carrots -= need\n        return append([]int{carrots,\
    \ 0}, eat(number, need, remaining))\n    }\n    if carrots > remaining {\n   \
    \     carrots = remaining\n        return append([]int{0, carrots}, eat(number,\
    \ need, remaining))\n    }\n    return []int{0, 0}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprtgmldep_test.go:42:42: cannot use eat(number, need, remaining) (value
    of type []int) as type int in argument to append

    /tmp/tmprtgmldep_test.go:46:42: cannot use eat(number, need, remaining) (value
    of type []int) as type int in argument to append

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075315
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    result := make([]int, 2)\n\
    \    carrots := 0\n    if number > need {\n        carrots = number-need\n   \
    \     result[0] = carrots\n        result[1] = remaining\n    } else {\n     \
    \   carrots = need\n        result[0] = need\n        result[1] = remaining\n\
    \    }\n    return result\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpm2oe7_pm_test.go:70: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=10)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpm2oe7_pm_test.go:70:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=9)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpm2oe7_pm_test.go:70: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpm2oe7_pm_test.go:70: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=11) %!s(int=5)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmpm2oe7_pm_test.go:70: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=5)\
    \ %!s(int=7)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpm2oe7_pm_test.go:70:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=5) %!s(int=1)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075315
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    carrots\
    \ := 0\n    carrots += number\n    carrots += need\n    carrots += remaining\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    return []int{carrots,\
    \ carrots - carrots % 1000}\n}\n</code>\n<|/ a tags=algorithm,dynamic-programming,math,combinatorics\
    \ |>\n<| c |>\nI like this solution, but I wonder if there is a way to avoid the\
    \ modulo 1000 operations. I wonder if there is a way to avoid the modulo 1000\
    \ operations. I wonder if there is a way to avoid the modulo 1000 operations.\
    \ I wonder if there is a way to avoid the modulo 1000 operations. I wonder if\
    \ there is a way to avoid the modulo 1000 operations. I wonder if there is a way\
    \ to avoid the modulo 1000 operations. I wonder if there is a way to avoid the\
    \ modulo 1000 operations. I wonder if there is a way to avoid the modulo 1000\
    \ operations. I wonder if there is a way to avoid the modulo 1000 operations.\
    \ I wonder if there is a way to avoid the modulo 1000 operations. I wonder if\
    \ there is a way to avoid the modulo 1000 operations. I wonder if there is a way\
    \ to avoid the modulo 1000 operations. I wonder if there is a way to avoid the\
    \ modulo 1000 operations. I wonder if there is a way to avoid the modulo 1000\
    \ operations. I wonder if there is a way to avoid the modulo 1000 operations.\
    \ I wonder if there is a way to avoid the modulo 1000 operations. I wonder if\
    \ there is a way to avoid the modulo 1000 operations. I wonder if there is a way\
    \ to avoid the modulo 1000 operations. I wonder if there is a way to avoid the\
    \ modulo 1000 operations. I wonder if there is a way to avoid the modulo 1000\
    \ operations. I wonder if there is a way to avoid the modulo 1000 operations.\
    \ I wonder if there is a way to avoid the modulo 1000 operations. I wonder if\
    \ there is a way to avoid the modulo 1000 operations. I wonder if there is a way\
    \ to avoid the modulo 1000 operations. I wonder if there is a way to avoid the\
    \ modulo 1000 operations. I wonder if there is a way to avoid the modulo 1000\
    \ operations. I wonder if there is a way to avoid the modulo 1000 operations.\
    \ I wonder if there is a way to avoid the modulo 1000 operations. I wonder if\
    \ there is a way to avoid the modulo 1000 operations. I wonder if there is a way\
    \ to avoid the modulo 1000 operations. I wonder if there is a way to avoid the\
    \ modulo 1000 operations. I wonder if there is a way to avoid the modulo 1000\
    \ operations. I wonder \nfunc TestEat(t *testing.T) {\n  candidate := eat\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvvkvdgpq_test.go:44:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075314
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    carrots := 0\n    carrots += number\n    carrots += need\n  \
    \  carrots += remaining\n    if carrots > 1000 {\n        carrots = 1000\n   \
    \ }\n    carrots = carrots - number\n    carrots = carrots - need\n    carrots\
    \ = carrots - remaining\n    if carrots < 0 {\n        carrots = 0\n    }\n  \
    \  return []int{carrots, carrots - carrots}\n}\n\nfunc TestEat(t *testing.T) {\n\
    \  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected:\
    \ []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n\
    \     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual:\
    \ candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5,\
    \ 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5,\
    \ 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpnd2vvjrb_test.go:72: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=0)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpnd2vvjrb_test.go:72:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=0) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpnd2vvjrb_test.go:72: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpnd2vvjrb_test.go:72: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpnd2vvjrb_test.go:72: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=0)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpnd2vvjrb_test.go:72:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=0) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075315
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    //\
    \ Your code here\n    carrots := 0\n    if number > 1000 || need > 1000 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    if number == 0 {\n        return\
    \ []int{0, 0}\n    }\n    if need == 0 {\n        return []int{number, 0}\n  \
    \  }\n    if remaining == 0 {\n        return []int{number, 0}\n    }\n    if\
    \ number > need {\n        return []int{0, 0}\n    }\n    if number > remaining\
    \ {\n        return []int{0, 0}\n    }\n    if need > remaining {\n        return\
    \ []int{0, 0}\n    }\n    if number == need {\n        return []int{number, 0}\n\
    \    }\n    if number == remaining {\n        return []int{number, 0}\n    }\n\
    \    if number > need {\n        return []int{0, 0}\n    }\n    if number > remaining\
    \ {\n        return []int{0, 0}\n    }\n    if need > remaining {\n        return\
    \ []int{0, 0}\n    }\n    if number == need {\n        return []int{number, 0}\n\
    \    }\n    if number == remaining {\n        return []int{number, 0}\n    }\n\
    \    if number > need {\n        return []int{0, 0}\n    }\n    if number > remaining\
    \ {\n        return []int{0, 0}\n    }\n    if need > remaining {\n        return\
    \ []int{0, 0}\n    }\n    if number == need {\n        return []int{number, 0}\n\
    \    }\n    if number == remaining {\n        return []int{number, 0}\n    }\n\
    \    if number > need {\n        return []int{0, 0}\n    }\n    if number > remaining\
    \ {\n        return []int{0, 0}\n    }\n    if need > remaining {\n        return\
    \ []int{0, 0}\n    }\n    if number == need {\n        return []int{number, 0}\n\
    \    }\n    if number == remaining {\n        return []int{number, 0}\n    }\n\
    \    if number > need {\n        return []int{0, 0}\n    }\n    if number > remaining\
    \ {\n        return []int{0, 0}\n    }\n    if need > remaining {\n        return\
    \ []int{0, 0}\n    }\n    if number == need {\n        return []int{number, 0}\n\
    \    }\n    if number == remaining {\n        return []int{number, 0}\n    }\n\
    \    if number > need {\n        return []int{0, 0}\n    }\n    if number > remaining\
    \ {\n        return []int{0, 0}\n    }\n    if need > remaining {\n        return\
    \ []int{0, 0}\n    }\n    if number == need {\n        return []int{number, 0}\n\
    \    }\n    if number == remaining {\n        return []int{number, 0}\n    }\n\
    \    if number > need {\n        return []int{0, 0}\n    }\n    if number > remaining\
    \ {\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp2dnw9i55_test.go:143:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075314
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    carrots +=\
    \ number\n    carrots += need\n    carrots += remaining\n    carrots %= 1000\n\
    \    if carrots == 0 {\n        carrots = 1000\n    }\n    carrots -= number\n\
    \    carrots -= need\n    carrots -= remaining\n    carrots %= 1000\n    if carrots\
    \ == 0 {\n        carrots = 1000\n    }\n    carrots -= number\n    carrots -=\
    \ need\n    carrots -= remaining\n    carrots %= 1000\n    if carrots == 0 {\n\
    \        carrots = 1000\n    }\n    carrots -= number\n    carrots -= need\n \
    \   carrots -= remaining\n    carrots %= 1000\n    if carrots == 0 {\n       \
    \ carrots = 1000\n    }\n    carrots -= number\n    carrots -= need\n    carrots\
    \ -= remaining\n    carrots %= 1000\n    if carrots == 0 {\n        carrots =\
    \ 1000\n    }\n    carrots -= number\n    carrots -= need\n    carrots -= remaining\n\
    \    carrots %= 1000\n    if carrots == 0 {\n        carrots = 1000\n    }\n \
    \   carrots -= number\n    carrots -= need\n    carrots -= remaining\n    carrots\
    \ %= 1000\n    if carrots == 0 {\n        carrots = 1000\n    }\n    carrots -=\
    \ number\n    carrots -= need\n    carrots -= remaining\n    carrots %= 1000\n\
    \    if carrots == 0 {\n        carrots = 1000\n    }\n    carrots -= number\n\
    \    carrots -= need\n    carrots -= remaining\n    carrots %= 1000\n    if carrots\
    \ == 0 {\n        carrots = 1000\n    }\n    carrots -= number\n    carrots -=\
    \ need\n    carrots -= remaining\n    carrots %= 1000\n    if carrots == 0 {\n\
    \        carrots = 1000\n    }\n    carrots -= number\n    carrots -= need\n \
    \   carrots -= remaining\n    carrots %= 1000\n    if carrots == 0 {\n       \
    \ carrots = 1000\n    }\n    carrots -= number\n    carrots -= need\n    \nfunc\
    \ TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpib0jtarw_test.go:119:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075314
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    if number\
    \ > need {\n        carrots = number-need\n    } else {\n        carrots = need\n\
    \    }\n    if remaining > carrots {\n        carrots = remaining\n    }\n   \
    \ carrots = carrots + number\n    carrots = carrots + number\n    carrots = carrots\
    \ + number\n    carrots = carrots + number\n    carrots = carrots + number\n \
    \   carrots = carrots + number\n    carrots = carrots + number\n    carrots =\
    \ carrots + number\n    carrots = carrots + number\n    carrots = carrots + number\n\
    \    carrots = carrots + number\n    carrots = carrots + number\n    carrots =\
    \ carrots + number\n    carrots = carrots + number\n    carrots = carrots + number\n\
    \    carrots = carrots + number\n    carrots = carrots + number\n    carrots =\
    \ carrots + number\n    carrots = carrots + number\n    carrots = carrots + number\n\
    \    carrots = carrots + number\n    carrots = carrots + number\n    carrots =\
    \ carrots + number\n    carrots = carrots + number\n    carrots = carrots + number\n\
    \    carrots = carrots + number\n    carrots = carrots + number\n    carrots =\
    \ carrots + number\n    carrots = carrots + number\n    carrots = carrots + number\n\
    \    carrots = carrots + number\n    carrots = carrots + number\n    carrots =\
    \ carrots + number\n    carrots = carrots + number\n    carrots = carrots + number\n\
    \    carrots = carrots + number\n    carrots = carrots + number\n    carrots =\
    \ carrots + number\n    carrots = carrots + number\n    carrots = carrots + number\n\
    \    carrots = carrots + number\n    carrots = carrots + number\n    carrots =\
    \ carrots + number\n    carrots = carrots + number\n    carrots = carrots + number\n\
    \    carrots = carrots + number\n    carrots = carrots + number\n    carrots =\
    \ carrots + number\n    carrot\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp2924lzqy_test.go:96:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075314
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    carrots := 0\n    if number > need {\n        carrots = number-need\n\
    \    } else {\n        carrots = need\n    }\n    if carrots > remaining {\n \
    \       carrots = remaining\n    }\n    return []int{carrots, 0}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpws_g8yx3_test.go:68: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpws_g8yx3_test.go:68:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpws_g8yx3_test.go:68: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpws_g8yx3_test.go:68: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpws_g8yx3_test.go:68: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=5)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpws_g8yx3_test.go:68:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075315
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    //\
    \ Your code here\n    result := make([]int, 2)\n    if number < 0 {\n        result[0]\
    \ = -1\n        result[1] = -1\n        return result\n    }\n    if need < 0\
    \ {\n        result[0] = -1\n        result[1] = -1\n        return result\n \
    \   }\n    if remaining < 0 {\n        result[0] = -1\n        result[1] = -1\n\
    \        return result\n    }\n    if number == 0 {\n        result[0] = 0\n \
    \       result[1] = 0\n        return result\n    }\n    if need == 0 {\n    \
    \    result[0] = 0\n        result[1] = 0\n        return result\n    }\n    if\
    \ remaining == 0 {\n        result[0] = 0\n        result[1] = 0\n        return\
    \ result\n    }\n    if number > need {\n        result[0] = -1\n        result[1]\
    \ = -1\n        return result\n    }\n    if number > remaining {\n        result[0]\
    \ = -1\n        result[1] = -1\n        return result\n    }\n    if need > remaining\
    \ {\n        result[0] = -1\n        result[1] = -1\n        return result\n \
    \   }\n    if number > 1000 {\n        result[0] = -1\n        result[1] = -1\n\
    \        return result\n    }\n    if need > 1000 {\n        result[0] = -1\n\
    \        result[1] = -1\n        return result\n    }\n    if remaining > 1000\
    \ {\n        result[0] = -1\n        result[1] = -1\n        return result\n \
    \   }\n    if number == need {\n        result[0] = number\n        result[1]\
    \ = number\n        return result\n    }\n    if number == remaining {\n     \
    \   result[0] = number\n        result[1] = number\n        return result\n  \
    \  }\n    if need == remaining {\n        result[0] = number\n        result[1]\
    \ = number\n        return result\n    }\n    if number == 1000 {\n        result[0]\
    \ = number\n        result[1] = number\n        return result\n    }\n    if need\
    \ == 1000 {\n        result[0] = number\n        result[1] = number\n        return\
    \ result\n    }\n    if remaining == 1000 {\n        result[0] = number\n    \
    \    result[1] = number\n        return result\n    }\n    if number == need +\
    \ remaining {\n        result[0] = number\n        result[1] = number\n      \
    \  return result\n    }\n    if number == need + number {\n        result[0] =\
    \ number\n        result[1] = number\n        return result\n    }\n    if number\
    \ == number + need {\n        result[0] = number\n        result[1] = number\n\
    \        return result\n    }\n    if number == number + number {\n        result[0]\
    \ = number\n        result[1] = number\n        return result\n    }\n    if number\
    \ == number + number + need {\n        result[0] = number\n        result[1] =\
    \ number\n        return result\n    }\n    if number == number + number + number\
    \ {\n        result[0] = number\n        result[1] = number\n        return result\n\
    \    }\n    if number == number + number + number + need {\n        result[0]\
    \ = number\n        result[1] = number\n        return result\n    }\n    if number\
    \ == number + number + number + number {\n        result[0] = number\n       \
    \ result[1] = number\n        return result\n    }\n    if number == number +\
    \ number + number \nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n\
    \     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual:\
    \ candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp2seecbw6_test.go:168:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075314
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    carrots := 0\n    carrots += number\n    carrots += need\n  \
    \  carrots += remaining\n    carrots -= number\n    carrots -= need\n    carrots\
    \ -= remaining\n    if carrots < 0 {\n        carrots = 0\n    }\n    return []int{carrots,\
    \ carrots - carrots}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpod5nnqh1_test.go:69: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=0)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpod5nnqh1_test.go:69:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=0) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpod5nnqh1_test.go:69: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpod5nnqh1_test.go:69: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpod5nnqh1_test.go:69: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=0)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpod5nnqh1_test.go:69:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=0) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660075315
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return nil\n    }\n    carrots := 0\n    carrots += number\n\
    \    carrots += need\n    carrots += remaining\n    if carrots > 1000 {\n    \
    \    carrots = 1000\n    }\n    return []int{carrots, carrots - carrots}\n}\n\n\
    func TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpkbsfdtbd_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=21)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpkbsfdtbd_test.go:66:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=21) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpkbsfdtbd_test.go:66: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=21) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpkbsfdtbd_test.go:66: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=18) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmpkbsfdtbd_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=16)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpkbsfdtbd_test.go:66:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075315
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    carrots +=\
    \ number\n    carrots += need\n    carrots -= remaining\n    if carrots < 0 {\n\
    \        carrots = 0\n    }\n    if carrots > 1000 {\n        carrots = 1000\n\
    \    }\n    return []int{carrots, carrots - carrots + number}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp3ki1pqjr_test.go:69: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=1)\
    \ %!s(int=5)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp3ki1pqjr_test.go:69:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=3) %!s(int=4)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp3ki1pqjr_test.go:69: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp3ki1pqjr_test.go:69: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=8) %!s(int=2)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp3ki1pqjr_test.go:69: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=2)\
    \ %!s(int=4)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp3ki1pqjr_test.go:69:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=8) %!s(int=4)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660075315
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    carrots +=\
    \ number\n    carrots += need\n    carrots -= remaining\n    if carrots < 0 {\n\
    \        carrots = 0\n    }\n    if carrots > 1000 {\n        carrots = 1000\n\
    \    }\n    return []int{carrots, carrots - carrots}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpnvzdpsvi_test.go:69: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=1)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpnvzdpsvi_test.go:69:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=3) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpnvzdpsvi_test.go:69: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpnvzdpsvi_test.go:69: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=8) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpnvzdpsvi_test.go:69: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=2)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpnvzdpsvi_test.go:69:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=8) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075315
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    result\
    \ := make([]int, 2)\n    if number > 1000 || need > 1000 || remaining > 1000 {\n\
    \        fmt.Println(\"Invalid input\")\n        return nil\n    }\n    if number\
    \ > remaining {\n        result[0] = number\n        result[1] = remaining\n \
    \       return result\n    }\n    if need > remaining {\n        result[0] = need\n\
    \        result[1] = remaining\n        return result\n    }\n    if number ==\
    \ 0 {\n        result[0] = number\n        result[1] = remaining\n        return\
    \ result\n    }\n    if need == 0 {\n        result[0] = number\n        result[1]\
    \ = remaining\n        return result\n    }\n    if number == need {\n       \
    \ result[0] = number\n        result[1] = remaining\n        return result\n \
    \   }\n    if number > need {\n        result[0] = number\n        result[1] =\
    \ need\n        return result\n    }\n    if number == need {\n        result[0]\
    \ = number\n        result[1] = need\n        return result\n    }\n    if need\
    \ > number {\n        result[0] = need\n        result[1] = number\n        return\
    \ result\n    }\n    if need == number {\n        result[0] = need\n        result[1]\
    \ = number\n        return result\n    }\n    if number > need {\n        result[0]\
    \ = number\n        result[1] = need\n        return result\n    }\n    if number\
    \ == need {\n        result[0] = number\n        result[1] = need\n        return\
    \ result\n    }\n    if need > number {\n        result[0] = need\n        result[1]\
    \ = number\n        return result\n    }\n    if need == number {\n        result[0]\
    \ = need\n        result[1] = number\n        return result\n    }\n    if number\
    \ > need {\n        result[0] = number\n        result[1] = need\n        return\
    \ result\n    }\n    if number == need {\n        result[0] = number\n       \
    \ result[1] = need\n        return result\n    }\n    if need > number {\n   \
    \     result[0] = need\n        result[1] = number\n        return result\n  \
    \  }\n    if need == number {\n        result[0] = need\n        result[1] = number\n\
    \        return result\n    }\n    if number > need {\n        result[0] = number\n\
    \        result[1] = need\n        return result\n    }\n    if number == need\
    \ {\n        result[0] = number\n        result[1] = need\n        return result\n\
    \    }\n    if need > number {\n        result[0] = need\n        result[1] =\
    \ number\n        return result\n    }\n    if need == number {\n        result[0]\
    \ = need\n        result[1] = number\n        return result\n    }\n    if number\
    \ > need {\n        result[0] = number\n        result[1] = need\n        return\
    \ result\n    }\n    if number == need {\n        result[0] = number\n       \
    \ result[1] = need\n        return result\n    }\n    if need > number {\n   \
    \     result[0] = need\n        result[1] = number\n        return result\n  \
    \  }\n    if need == number {\n        result[0] = need\n        result[1] = number\n\
    \        return result\n    }\n    if number > need {\n        result[0] = number\n\
    \        result[1] = need\n        return result\n    }\n    if number == need\
    \ {\n        result[0] = number\n\nfunc TestEat(t *testing.T) {\n  candidate :=\
    \ eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp__eslgde_test.go:173:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075314
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    carrots\
    \ := 0\n    carrots += number\n    carrots += need\n    carrots -= remaining\n\
    \    if carrots < 0 {\n        carrots = 0\n    }\n    return []int{carrots, remaining}\n\
    }\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpfflaf03t_test.go:63: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=1)\
    \ %!s(int=10)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpfflaf03t_test.go:63:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=3) %!s(int=9)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpfflaf03t_test.go:63: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpfflaf03t_test.go:63: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=8) %!s(int=5)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpfflaf03t_test.go:63: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=2)\
    \ %!s(int=7)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpfflaf03t_test.go:63:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=8) %!s(int=1)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075315
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    carrots\
    \ := 0\n    if number < 0 || number > 1000 {\n        return []int{0, 0}\n   \
    \ }\n    if need < 0 || need > 1000 {\n        return []int{0, 0}\n    }\n   \
    \ if remaining < 0 || remaining > 1000 {\n        return []int{0, 0}\n    }\n\
    \    if number == 0 {\n        return []int{0, 0}\n    }\n    if need == 0 {\n\
    \        return []int{number, 0}\n    }\n    if remaining == 0 {\n        return\
    \ []int{number, 0}\n    }\n    if number > need {\n        return []int{0, 0}\n\
    \    }\n    if number > remaining {\n        return []int{0, 0}\n    }\n    if\
    \ need > remaining {\n        return []int{0, 0}\n    }\n    if number == need\
    \ {\n        return []int{number, 0}\n    }\n    if number == remaining {\n  \
    \      return []int{number, 0}\n    }\n    if number > remaining {\n        return\
    \ []int{0, 0}\n    }\n    if need > remaining {\n        return []int{0, 0}\n\
    \    }\n    if number == need {\n        return []int{number, 0}\n    }\n    if\
    \ number == remaining {\n        return []int{number, 0}\n    }\n    if number\
    \ > need {\n        return []int{0, 0}\n    }\n    if number > remaining {\n \
    \       return []int{0, 0}\n    }\n    if need > remaining {\n        return []int{0,\
    \ 0}\n    }\n    if number == need {\n        return []int{number, 0}\n    }\n\
    \    if number == remaining {\n        return []int{number, 0}\n    }\n    if\
    \ number > need {\n        return []int{0, 0}\n    }\n    if number > remaining\
    \ {\n        return []int{0, 0}\n    }\n    if need > remaining {\n        return\
    \ []int{0, 0}\n    }\n    if number == need {\n        return []int{number, 0}\n\
    \    }\n    if number == remaining {\n        return []int{number, 0}\n    }\n\
    \    if number > need {\n        return []int{0, 0}\n    }\n    if number > remaining\
    \ {\n        return []int{0, 0}\n    }\n    if need > remaining {\n        return\
    \ []int{0, 0}\n    }\n    if number == need {\n        return []int{number, 0}\n\
    \    }\n    if number == remaining {\n        return []int{number, 0}\n    }\n\
    \    if number > need {\n        return []int{0, 0}\n    }\n    if number > remaining\
    \ {\n        return []int{0, 0}\n    }\n    if need > remaining {\n        return\
    \ []int{0, 0}\n    }\n    if number == need {\n        return []int{number, 0}\n\
    \    }\n    if number == remaining {\n        return []int{number, 0}\n    }\n\
    \    if number > need {\n        return []int{\nfunc TestEat(t *testing.T) {\n\
    \  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected:\
    \ []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n\
    \     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual:\
    \ candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5,\
    \ 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5,\
    \ 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpbsihx3vs_test.go:143:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075314
- exit_code: 2
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{}\n    }\n    result := []int{}\n    if number\
    \ == 0 {\n        return nil\n    }\n    if remaining < need {\n        return\
    \ nil\n    }\n    if number > remaining {\n        number = remaining\n    }\n\
    \    carrots := 0\n    for i := 0; i < number; i++ {\n        carrots += eatCarrot()\n\
    \    }\n    carrots += eatCarrot()\n    result := append(result, carrots)\n  \
    \  if carrots > need {\n        carrots = need\n    }\n    result := append(result,\
    \ carrots)\n    return result\n}\n\nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpk2wzt9xz_test.go:50:20: undefined: eatCarrot

    /tmp/tmpk2wzt9xz_test.go:52:16: undefined: eatCarrot

    /tmp/tmpk2wzt9xz_test.go:53:12: no new variables on left side of :=

    /tmp/tmpk2wzt9xz_test.go:57:12: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075315
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    //\
    \ write your code in JavaScript (Node.js 8.9.4)\n    var arr = []int{0, 0}\n \
    \   var carrots = number\n    var needs = need\n    var remaining = remaining\n\
    \    var carrots_left = remaining\n    \n    while(needs > 0 && carrots > 0){\n\
    \        carrots_left = carrots - carrots_left\n        needs = needs - 1\n  \
    \      carrots = carrots - 1\n        \n        arr = append(arr, carrots_left)\n\
    \    }\n    \n    arr = append(arr, carrots)\n    \n    return arr\n}\n\nfunc\
    \ TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpv7o9604h_test.go:42:36: expected '';'', found ''{''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075315
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    carrots +=\
    \ number\n    carrots += need\n    carrots -= remaining\n    if carrots < 0 {\n\
    \        carrots = 0\n    }\n    return []int{carrots, carrots - number}\n}\n\n\
    func TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpzz6rvvx5_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=1)\
    \ %!s(int=-4)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpzz6rvvx5_test.go:66:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=3) %!s(int=-1)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpzz6rvvx5_test.go:66: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpzz6rvvx5_test.go:66: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=8) %!s(int=6)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpzz6rvvx5_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=2)\
    \ %!s(int=-2)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpzz6rvvx5_test.go:66:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=8) %!s(int=4)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075316
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    carrots := 0\n    carrots += number\n    carrots += need\n  \
    \  carrots += remaining\n    carrots -= number\n    carrots -= need\n    carrots\
    \ -= remaining\n    carrots -= number\n    carrots -= need\n    carrots -= remaining\n\
    \    carrots -= number\n    carrots -= need\n    carrots -= remaining\n    carrots\
    \ -= number\n    carrots -= need\n    carrots -= remaining\n    carrots -= number\n\
    \    carrots -= need\n    carrots -= remaining\n    carrots -= number\n    carrots\
    \ -= need\n    carrots -= remaining\n    carrots -= number\n    carrots -= need\n\
    \    carrots -= remaining\n    carrots -= number\n    carrots -= need\n    carrots\
    \ -= remaining\n    carrots -= number\n    carrots -= need\n    carrots -= remaining\n\
    \    carrots -= number\n    carrots -= need\n    carrots -= remaining\n    carrots\
    \ -= number\n    carrots -= need\n    carrots -= remaining\n    carrots -= number\n\
    \    carrots -= need\n    carrots -= remaining\n    carrots -= number\n    carrots\
    \ -= need\n    carrots -= remaining\n    carrots -= number\n    carrots -= need\n\
    \    carrots -= remaining\n    carrots -= number\n    carrots -= need\n    carrots\
    \ -= remaining\n    carrots -= number\n    carrots -= need\n    carrots -= remaining\n\
    \    carrots -= number\n    carrots -= need\n    carrots -= remaining\n    carrots\
    \ -= number\n    carrots -= need\n    carrots -= remaining\n    carrots -= number\n\
    \    carrots -= need\n    carrots -= remaining\n    carrots -= number\n    carrots\
    \ -= need\n    carrots -= remaining\n    carrots -= number\n    carrots -= need\n\
    \    carrots -= remaining\n    carrots -= number\n    carrots -= need\n    carrots\
    \ -= remaining\n    carrot\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpxi9a1u3m_test.go:109:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075315
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    carrots := 0\n    if number > need {\n        carrots = number-need\n\
    \    } else {\n        carrots = need\n    }\n    if carrots > remaining {\n \
    \       carrots = remaining\n    }\n    return []int{carrots, 0}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpws_g8yx3_test.go:68: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpws_g8yx3_test.go:68:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpws_g8yx3_test.go:68: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpws_g8yx3_test.go:68: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpws_g8yx3_test.go:68: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=5)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpws_g8yx3_test.go:68:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075315
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    meals :=\
    \ 0\n    for i := 0; i < number; i++ {\n        carrots += 3\n        meals++\n\
    \    }\n    for i := 0; i < need; i++ {\n        carrots += 3\n        meals++\n\
    \    }\n    for i := 0; i < remaining; i++ {\n        carrots += 3\n        meals++\n\
    \    }\n    carrots -= meals\n    return []int{carrots, carrots - meals}\n}\n\n\
    func TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpepl66yj4_test.go:74: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=42)\
    \ %!s(int=21)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpepl66yj4_test.go:74:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=42) %!s(int=21)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpepl66yj4_test.go:74: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=42) %!s(int=21)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpepl66yj4_test.go:74: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=36) %!s(int=18)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmpepl66yj4_test.go:74: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=32)\
    \ %!s(int=16)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpepl66yj4_test.go:74:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=20) %!s(int=10)]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075316
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    carrots\
    \ := 0\n    if number < 0 {\n        return []int{0, 0}\n    }\n    if need <\
    \ 0 {\n        return []int{0, 0}\n    }\n    if remaining < 0 {\n        return\
    \ []int{0, 0}\n    }\n    if number > 1000 {\n        return []int{0, 0}\n   \
    \ }\n    if need > 1000 {\n        return []int{0, 0}\n    }\n    if remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    if number == 0 {\n        return\
    \ []int{0, 0}\n    }\n    if need == 0 {\n        return []int{0, 0}\n    }\n\
    \    if remaining == 0 {\n        return []int{0, 0}\n    }\n    if number > need\
    \ {\n        return []int{0, 0}\n    }\n    if number > remaining {\n        return\
    \ []int{0, 0}\n    }\n    if need > remaining {\n        return []int{0, 0}\n\
    \    }\n    if number > 1000 {\n        return []int{0, 0}\n    }\n    if need\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    if remaining > 1000 {\n   \
    \     return []int{0, 0}\n    }\n    if number == 0 {\n        return []int{0,\
    \ 0}\n    }\n    if need == 0 {\n        return []int{0, 0}\n    }\n    if remaining\
    \ == 0 {\n        return []int{0, 0}\n    }\n    if number > need {\n        return\
    \ []int{0, 0}\n    }\n    if number > remaining {\n        return []int{0, 0}\n\
    \    }\n    if need > remaining {\n        return []int{0, 0}\n    }\n    if number\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    if need > 1000 {\n        return\
    \ []int{0, 0}\n    }\n    if remaining > 1000 {\n        return []int{0, 0}\n\
    \    }\n    if number == 0 {\n        return []int{0, 0}\n    }\n    if need ==\
    \ 0 {\n        return []int{0, 0}\n    }\n    if remaining == 0 {\n        return\
    \ []int{0, 0}\n    }\n    if number > need {\n        return []int{0, 0}\n   \
    \ }\n    if number > remaining {\n        return []int{0, 0}\n    }\n    if need\
    \ > remaining {\n        return []int{0, 0}\n    }\n    if number > 1000 {\n \
    \       return []int{0, 0}\n    }\n    if need > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    if remaining > 1000 {\n        return []int{0, 0}\n    }\n  \
    \  if number == 0 {\n        return []int{0, 0}\n    }\n    if need == 0 {\n \
    \       return []int{0, 0}\n    }\n    if remaining == 0 {\n        return []int{0,\
    \ 0}\n    }\n    if number > need {\n        return []int{0, 0}\n    }\n    if\
    \ number \nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpflcdfh67_test.go:148:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075315
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || need < 0 || remaining < 0 {\n        return []int{0, 0}\n    }\n\
    \    if number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    if number == 0 {\n        return []int{0, 0}\n    }\n    if need\
    \ == 0 {\n        return []int{number, 0}\n    }\n    if remaining == 0 {\n  \
    \      return []int{number, 0}\n    }\n    if number > need {\n        return\
    \ []int{0, 0}\n    }\n    if number == need {\n        return []int{number, 0}\n\
    \    }\n    if number > remaining {\n        return []int{0, 0}\n    }\n    if\
    \ number == remaining {\n        return []int{number, 0}\n    }\n    if number\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    if need > 1000 {\n        return\
    \ []int{0, 0}\n    }\n    if remaining > 1000 {\n        return []int{0, 0}\n\
    \    }\n    if number == 1000 {\n        return []int{number, 0}\n    }\n    if\
    \ need == 1000 {\n        return []int{number, 0}\n    }\n    if remaining ==\
    \ 1000 {\n        return []int{number, 0}\n    }\n    if number == need && number\
    \ == remaining {\n        return []int{number, 0}\n    }\n    if number == remaining\
    \ {\n        return []int{number, 0}\n    }\n    if number == 1000 {\n       \
    \ return []int{number, 0}\n    }\n    if need == 1000 {\n        return []int{number,\
    \ 0}\n    }\n    if remaining == 1000 {\n        return []int{number, 0}\n   \
    \ }\n    if number == need && number == remaining {\n        return []int{number,\
    \ 0}\n    }\n    if number == remaining {\n        return []int{number, 0}\n \
    \   }\n    if number == 1000 {\n        return []int{number, 0}\n    }\n    if\
    \ need == 1000 {\n        return []int{number, 0}\n    }\n    if remaining ==\
    \ 1000 {\n        return []int{number, 0}\n    }\n    if number == need && number\
    \ == remaining {\n        return []int{number, 0}\n    }\n    if number == remaining\
    \ {\n        return []int{number, 0}\n    }\n    if number == 1000 {\n       \
    \ return []int{number, 0}\n    }\n    if need == 1000 {\n        return []int{number,\
    \ 0}\n    }\n    if remaining == 1000 {\n        return []int{number, 0}\n   \
    \ }\n    if number == need && number == remaining {\n        return []int{number,\
    \ 0}\n    }\n    if number == remaining {\n        return []int{number, 0}\n \
    \   }\n    if number == 1000 {\n        return []int{number, 0}\n    }\n    if\
    \ need == 1000 {\n        return []int{number, 0}\n    }\n    if remaining ==\
    \ 1000 {\n        return []int{number, \nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp3sao723d_test.go:139:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075315
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    carrots +=\
    \ number\n    carrots += need\n    carrots += remaining\n    if carrots > 1000\
    \ {\n        carrots = 1000\n    }\n    return []int{carrots, carrots - carrots\
    \ + need}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n\
    \     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual:\
    \ candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpfop4e15y_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=21)\
    \ %!s(int=6)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpfop4e15y_test.go:66:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=21) %!s(int=8)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpfop4e15y_test.go:66: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=21) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpfop4e15y_test.go:66: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=18) %!s(int=11)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmpfop4e15y_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=16)\
    \ %!s(int=5)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpfop4e15y_test.go:66:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=10) %!s(int=5)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075316
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    //\
    \ write your code in JavaScript (Node.js 8.9.4)\n    carrots := 0\n    carrots\
    \ += number\n    carrots += need\n    carrots += remaining\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpdc4hbunf_test.go:108:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075315
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    carrots =\
    \ number\n    carrots = carrots - need\n    carrots = carrots - remaining\n  \
    \  carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n\
    \    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots +\
    \ 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp75xjyc0l_test.go:93:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075316
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    carrots\
    \ := 0\n    result := make([]int, 2)\n    if number > 1000 || need > 1000 || remaining\
    \ > 1000 {\n        fmt.Println(\"Invalid input\")\n        return nil\n    }\n\
    \    if number == 0 {\n        result[0] = need\n        result[1] = remaining\n\
    \        return result\n    }\n    if remaining == 0 {\n        result[0] = number\n\
    \        result[1] = need\n        return result\n    }\n    if number > need\
    \ {\n        fmt.Println(\"Invalid input\")\n        return nil\n    }\n    if\
    \ number > remaining {\n        fmt.Println(\"Invalid input\")\n        return\
    \ nil\n    }\n    if number < need {\n        fmt.Println(\"Invalid input\")\n\
    \        return nil\n    }\n    if number < remaining {\n        carrots = number\n\
    \    } else {\n        carrots = remaining\n    }\n    result[0] = number\n  \
    \  result[1] = carrots\n    return result\n}\n\nfunc TestEat(t *testing.T) {\n\
    \  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected:\
    \ []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n\
    \     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual:\
    \ candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5,\
    \ 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5,\
    \ 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "Invalid input\nInvalid input\nInvalid input\nInvalid input\nInvalid input\n\
    Invalid input\n--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpju94ws8q_test.go:91: expected '[%!s(int=11) %!s(int=4)]', got '[]'\n\
    \    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpju94ws8q_test.go:91: expected\
    \ '[%!s(int=12) %!s(int=1)]', got '[]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n\
    \        tmpju94ws8q_test.go:91: expected '[%!s(int=11) %!s(int=0)]', got '[]'\n\
    \    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpju94ws8q_test.go:91: expected\
    \ '[%!s(int=7) %!s(int=0)]', got '[]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmpju94ws8q_test.go:91: expected '[%!s(int=9) %!s(int=2)]', got '[]'\n\
    \    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpju94ws8q_test.go:91: expected\
    \ '[%!s(int=5) %!s(int=0)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660075317
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    carrots := 0\n    carrots += number\n    carrots += need\n  \
    \  carrots -= remaining\n    if carrots < 0 {\n        carrots = 0\n    }\n  \
    \  if carrots > 1000 {\n        carrots = 1000\n    }\n    return []int{carrots,\
    \ carrots - carrots}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp674qvygz_test.go:69: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=1)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp674qvygz_test.go:69:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=3) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp674qvygz_test.go:69: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp674qvygz_test.go:69: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=8) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp674qvygz_test.go:69: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=2)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp674qvygz_test.go:69:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=8) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075317
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    result := make([]int, 2)\n\
    \    carrots := 0\n    if number > need {\n        carrots = number-need\n   \
    \     result[0] = carrots\n        result[1] = remaining\n    } else {\n     \
    \   carrots = need\n        result[0] = need\n        result[1] = remaining\n\
    \    }\n    return result\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpm2oe7_pm_test.go:70: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=10)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpm2oe7_pm_test.go:70:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=9)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpm2oe7_pm_test.go:70: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpm2oe7_pm_test.go:70: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=11) %!s(int=5)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmpm2oe7_pm_test.go:70: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=5)\
    \ %!s(int=7)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpm2oe7_pm_test.go:70:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=5) %!s(int=1)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075315
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    carrots := 0\n    meals := 0\n    for i := 0; i < number; i++\
    \ {\n        carrots += i\n    }\n    for i := 0; i < need; i++ {\n        carrots\
    \ += i\n    }\n    for i := 0; i < remaining; i++ {\n        carrots += i\n  \
    \  }\n    meals = carrots - need\n    carrots = meals - number\n    meals = carrots\
    \ - need\n    carrots = meals - number\n    meals = carrots - need\n    carrots\
    \ = meals - number\n    meals = carrots - need\n    carrots = meals - number\n\
    \    meals = carrots - need\n    carrots = meals - number\n    meals = carrots\
    \ - need\n    carrots = meals - number\n    meals = carrots - need\n    carrots\
    \ = meals - number\n    meals = carrots - need\n    carrots = meals - number\n\
    \    meals = carrots - need\n    carrots = meals - number\n    meals = carrots\
    \ - need\n    carrots = meals - number\n    meals = carrots - need\n    carrots\
    \ = meals - number\n    meals = carrots - need\n    carrots = meals - number\n\
    \    meals = carrots - need\n    carrots = meals - number\n    meals = carrots\
    \ - need\n    carrots = meals - number\n    meals = carrots - need\n    carrots\
    \ = meals - number\n    meals = carrots - need\n    carrots = meals - number\n\
    \    meals = carrots - need\n    carrots = meals - number\n    meals = carrots\
    \ - need\n    carrots = meals - number\n    meals = carrots - need\n    carrots\
    \ = meals - number\n    meals = carrots - need\n    carrots = meals - number\n\
    \    meals = carrots - need\n    carrots = meals - number\n    meals = carrots\
    \ - need\n    carrots = meals - number\n    meals = carrots - need\n    carrots\
    \ = meals - number\n    meals = carrots - need\nfunc TestEat(t *testing.T) {\n\
    \  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected:\
    \ []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n\
    \     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual:\
    \ candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5,\
    \ 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5,\
    \ 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmprhrynns4_test.go:96:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075316
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    carrots\
    \ := 0\n    if number < 0 {\n        return []int{0, 0}\n    }\n    if need <\
    \ 0 {\n        return []int{0, 0}\n    }\n    if remaining < 0 {\n        return\
    \ []int{0, 0}\n    }\n    if number == 0 {\n        return []int{0, 0}\n    }\n\
    \    if need == 0 {\n        return []int{0, 0}\n    }\n    if remaining == 0\
    \ {\n        return []int{number, 0}\n    }\n    if number > remaining {\n   \
    \     return []int{0, 0}\n    }\n    if need > remaining {\n        return []int{0,\
    \ 0}\n    }\n    if number == need {\n        return []int{number, 0}\n    }\n\
    \    if number > need {\n        return []int{0, 0}\n    }\n    if number > remaining\
    \ {\n        return []int{0, 0}\n    }\n    if need > remaining {\n        return\
    \ []int{0, 0}\n    }\n    if number == need {\n        return []int{number, 0}\n\
    \    }\n    if number > need {\n        return []int{0, 0}\n    }\n    if number\
    \ > remaining {\n        return []int{0, 0}\n    }\n    if need > remaining {\n\
    \        return []int{0, 0}\n    }\n    if number == need {\n        return []int{number,\
    \ 0}\n    }\n    if number > need {\n        return []int{0, 0}\n    }\n    if\
    \ number > remaining {\n        return []int{0, 0}\n    }\n    if need > remaining\
    \ {\n        return []int{0, 0}\n    }\n    if number == need {\n        return\
    \ []int{number, 0}\n    }\n    if number > need {\n        return []int{0, 0}\n\
    \    }\n    if number > remaining {\n        return []int{0, 0}\n    }\n    if\
    \ need > remaining {\n        return []int{0, 0}\n    }\n    if number == need\
    \ {\n        return []int{number, 0}\n    }\n    if number > need {\n        return\
    \ []int{0, 0}\n    }\n    if number > remaining {\n        return []int{0, 0}\n\
    \    }\n    if need > remaining {\n        return []int{0, 0}\n    }\n    if number\
    \ == need {\n        return []int{number, 0}\n    }\n    if number > need {\n\
    \        return []int{0, 0}\n    }\n    if number > remaining {\n        return\
    \ []int{0, 0}\n    }\n    if need > remaining {\n        return []int{0, 0}\n\
    \    }\n    if number == need {\n        return []int{number, 0}\n    }\n    if\
    \ number > need {\n        return []int{0, 0}\n    }\n    if number > remaining\
    \ {\n        return []int{0, 0}\n    }\n    if need > remaining {\n        return\
    \ []int{0, 0}\n    }\n    if number == need {\n        return []\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp1odmyl1p_test.go:145:18: expected type, found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075316
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    result\
    \ := make([]int, 2)\n    if number > 1000 || need > 1000 || remaining > 1000 {\n\
    \        fmt.Println(\"Invalid input\")\n        return nil\n    }\n    if number\
    \ == 0 {\n        result[0] = remaining\n        result[1] = remaining\n    }\
    \ else {\n        result[0] = number\n        result[1] = need\n    }\n    return\
    \ result\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1letzeqi_test.go:68: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5)\
    \ %!s(int=6)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1letzeqi_test.go:68:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=8)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1letzeqi_test.go:68: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp1letzeqi_test.go:68: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=2) %!s(int=11)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmp1letzeqi_test.go:68: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4)\
    \ %!s(int=5)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp1letzeqi_test.go:68:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=5)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075317
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    //\
    \ Your code here\n    carrots := 0\n    carrots += number\n    carrots += need\n\
    \    carrots -= remaining\n    return []int{carrots, carrots - number}\n}\n\n\
    func TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmps2qsvy_z_test.go:61: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=1)\
    \ %!s(int=-4)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmps2qsvy_z_test.go:61:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=3) %!s(int=-1)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmps2qsvy_z_test.go:61: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmps2qsvy_z_test.go:61: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=8) %!s(int=6)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmps2qsvy_z_test.go:61: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=2)\
    \ %!s(int=-2)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmps2qsvy_z_test.go:61:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=8) %!s(int=4)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075317
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    if number == 0 {\n        return []int{0, 0}\n    }\n    if need\
    \ == 0 {\n        return []int{number, 0}\n    }\n    if remaining == 0 {\n  \
    \      return []int{number, 0}\n    }\n    if number > need {\n        return\
    \ []int{0, 0}\n    }\n    if number == need {\n        return []int{number, 0}\n\
    \    }\n    if number > remaining {\n        return []int{0, 0}\n    }\n    if\
    \ number == remaining {\n        return []int{number, 0}\n    }\n    if number\
    \ > need {\n        return []int{0, 0}\n    }\n    if number == need {\n     \
    \   return []int{number, 0}\n    }\n    if number > remaining {\n        return\
    \ []int{0, 0}\n    }\n    if number == remaining {\n        return []int{number,\
    \ 0}\n    }\n    if number > need {\n        return []int{0, 0}\n    }\n    if\
    \ number == need {\n        return []int{number, 0}\n    }\n    if number > remaining\
    \ {\n        return []int{0, 0}\n    }\n    if number == remaining {\n       \
    \ return []int{number, 0}\n    }\n    if number > need {\n        return []int{0,\
    \ 0}\n    }\n    if number == need {\n        return []int{number, 0}\n    }\n\
    \    if number > remaining {\n        return []int{0, 0}\n    }\n    if number\
    \ == remaining {\n        return []int{number, 0}\n    }\n    if number > need\
    \ {\n        return []int{0, 0}\n    }\n    if number == need {\n        return\
    \ []int{number, 0}\n    }\n    if number > remaining {\n        return []int{0,\
    \ 0}\n    }\n    if number == remaining {\n        return []int{number, 0}\n \
    \   }\n    if number > need {\n        return []int{0, 0}\n    }\n    if number\
    \ == need {\n        return []int{number, 0}\n    }\n    if number > remaining\
    \ {\n        return []int{0, 0}\n    }\n    if number == remaining {\n       \
    \ return []int{number, 0}\n    }\n    if number > need {\n        return []int{0,\
    \ 0}\n    }\n    if number == need {\n        return []int{number, 0}\n    }\n\
    \    if number > remaining {\n        return []int{0, 0}\n    }\n    if number\
    \ == remaining {\n        return []int{number, 0}\n    }\n    if number > need\
    \ {\n        return []int{0, 0}\n    }\n    if number == need {\n        return\
    \ []int{number, 0}\n    }\n    if number > remaining {\n        return []int{0,\
    \ 0}\n    }\n    if number == remaining {\n        return []int{number, 0}\n \
    \   }\n    if number > \nfunc TestEat(t *testing.T) {\n  candidate := eat\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpf081nuyg_test.go:144:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075316
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    carrots\
    \ := 0\n    if number < 0 || number > 1000 {\n        return []int{0, 0}\n   \
    \ }\n    if need < 0 || need > 1000 {\n        return []int{0, 0}\n    }\n   \
    \ if remaining < 0 || remaining > 1000 {\n        return []int{0, 0}\n    }\n\
    \    if number == 0 {\n        return []int{0, 0}\n    }\n    if need == 0 {\n\
    \        return []int{0, 0}\n    }\n    if remaining == 0 {\n        return []int{0,\
    \ 0}\n    }\n    if number > need {\n        return []int{0, 0}\n    }\n    if\
    \ number > remaining {\n        return []int{0, 0}\n    }\n    if need > remaining\
    \ {\n        return []int{0, 0}\n    }\n    if number == need {\n        return\
    \ []int{0, 0}\n    }\n    if number == remaining {\n        return []int{0, 0}\n\
    \    }\n    if number > remaining {\n        return []int{0, 0}\n    }\n    if\
    \ need > remaining {\n        return []int{0, 0}\n    }\n    if number == need\
    \ {\n        return []int{0, 0}\n    }\n    if number == remaining {\n       \
    \ return []int{0, 0}\n    }\n    if number > need {\n        return []int{0, 0}\n\
    \    }\n    if number > remaining {\n        return []int{0, 0}\n    }\n    if\
    \ need > number {\n        return []int{0, 0}\n    }\n    if need > remaining\
    \ {\n        return []int{0, 0}\n    }\n    if number == need {\n        return\
    \ []int{0, 0}\n    }\n    if number == remaining {\n        return []int{0, 0}\n\
    \    }\n    if number > need {\n        return []int{0, 0}\n    }\n    if number\
    \ > remaining {\n        return []int{0, 0}\n    }\n    if need > number {\n \
    \       return []int{0, 0}\n    }\n    if need > remaining {\n        return []int{0,\
    \ 0}\n    }\n    if number == need {\n        return []int{0, 0}\n    }\n    if\
    \ number == remaining {\n        return []int{0, 0}\n    }\n    if number > need\
    \ {\n        return []int{0, 0}\n    }\n    if number > remaining {\n        return\
    \ []int{0, 0}\n    }\n    if need > number {\n        return []int{0, 0}\n   \
    \ }\n    if need > remaining {\n        return []int{0, 0}\n    }\n    if number\
    \ == need {\n        return []int{0, 0}\n    }\n    if number == remaining {\n\
    \        return []int{0, 0}\n    }\n    if number > need {\n        return []int{0,\
    \ 0}\n    }\n    if number > remaining {\n        return []int{0, 0}\n    }\n\
    \    if need > number {\n        return []int{\nfunc TestEat(t *testing.T) {\n\
    \  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected:\
    \ []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n\
    \     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual:\
    \ candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5,\
    \ 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5,\
    \ 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_qbysct8_test.go:143:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075316
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    carrots := 0\n    carrots += number\n    carrots += need\n  \
    \  carrots += remaining\n    carrots -= number\n    carrots -= need\n    carrots\
    \ -= remaining\n    carrots -= number\n    carrots -= need\n    carrots -= remaining\n\
    \    carrots -= number\n    carrots -= need\n    carrots -= remaining\n    carrots\
    \ -= number\n    carrots -= need\n    carrots -= remaining\n    carrots -= number\n\
    \    carrots -= need\n    carrots -= remaining\n    carrots -= number\n    carrots\
    \ -= need\n    carrots -= remaining\n    carrots -= number\n    carrots -= need\n\
    \    carrots -= remaining\n    carrots -= number\n    carrots -= need\n    carrots\
    \ -= remaining\n    carrots -= number\n    carrots -= need\n    carrots -= remaining\n\
    \    carrots -= number\n    carrots -= need\n    carrots -= remaining\n    carrots\
    \ -= number\n    carrots -= need\n    carrots -= remaining\n    carrots -= number\n\
    \    carrots -= need\n    carrots -= remaining\n    carrots -= number\n    carrots\
    \ -= need\n    carrots -= remaining\n    carrots -= number\n    carrots -= need\n\
    \    carrots -= remaining\n    carrots -= number\n    carrots -= need\n    carrots\
    \ -= remaining\n    carrots -= number\n    carrots -= need\n    carrots -= remaining\n\
    \    carrots -= number\n    carrots -= need\n    carrots -= remaining\n    carrots\
    \ -= number\n    carrots -= need\n    carrots -= remaining\n    carrots -= number\n\
    \    carrots -= need\n    carrots -= remaining\n    carrots -= number\n    carrots\
    \ -= need\n    carrots -= remaining\n    carrots -= number\n    carrots -= need\n\
    \    carrots -= remaining\n    carrots -= number\n    carrots -= need\n    carrots\
    \ -= remaining\n    carrot\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpxi9a1u3m_test.go:109:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075315
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    carrots := 0\n    carrots = number\n    carrots = carrots - need\n\
    \    carrots = carrots - remaining\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n\nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmplc90px1u_test.go:94:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075316
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    carrots := 0\n    meals := 0\n    if remaining > 0 {\n      \
    \  carrots = remaining\n        meals = number\n    } else {\n        carrots\
    \ = need\n        meals = 0\n    }\n    carrots -= meals\n    if carrots > 0 {\n\
    \        return []int{carrots, 0}\n    }\n    return []int{0, 0}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp9rdrg_km_test.go:72: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp9rdrg_km_test.go:72:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=5) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp9rdrg_km_test.go:72: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=9) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp9rdrg_km_test.go:72: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=3) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp9rdrg_km_test.go:72: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=3)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp9rdrg_km_test.go:72:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=0) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075317
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    carrots +=\
    \ number\n    carrots += need\n    carrots -= remaining\n    if carrots < 0 {\n\
    \        carrots = 0\n    }\n    if carrots > 1000 {\n        carrots = 1000\n\
    \    }\n    return []int{carrots, carrots - carrots}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpnvzdpsvi_test.go:69: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=1)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpnvzdpsvi_test.go:69:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=3) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpnvzdpsvi_test.go:69: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpnvzdpsvi_test.go:69: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=8) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpnvzdpsvi_test.go:69: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=2)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpnvzdpsvi_test.go:69:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=8) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075315
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    result := make([]int, 2)\n\
    \    carrots := 0\n    if number > need {\n        carrots = number\n    } else\
    \ {\n        carrots = need\n    }\n    if carrots > remaining {\n        carrots\
    \ = remaining\n    }\n    result[0] = carrots\n    result[1] = remaining\n   \
    \ return result\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n\
    \     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual:\
    \ candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp6mz43ivc_test.go:71: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=10)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp6mz43ivc_test.go:71:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=9)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp6mz43ivc_test.go:71: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp6mz43ivc_test.go:71: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=5)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp6mz43ivc_test.go:71: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=5)\
    \ %!s(int=7)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp6mz43ivc_test.go:71:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=1)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075317
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    carrots := 0\n    meals := 0\n    for carrots < number {\n  \
    \      if meals >= need {\n            meals -= need\n            carrots += meals\n\
    \        } else {\n            carrots += remaining\n        }\n    }\n    return\
    \ []int{carrots, remaining}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate :=\
    \ eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp4il_21gl_test.go:69: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=10)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp4il_21gl_test.go:69:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=9)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp4il_21gl_test.go:69: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp4il_21gl_test.go:69: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=5)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp4il_21gl_test.go:69: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=7)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp4il_21gl_test.go:69:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=1)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075317
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    carrots := 0\n    carrots += number\n    carrots += need\n  \
    \  carrots += remaining\n    if carrots > 1000 {\n        carrots = 1000\n   \
    \ }\n    if carrots < 0 {\n        carrots = 0\n    }\n    carrots = carrots /\
    \ 3\n    carrots = carrots * 3\n    carrots = carrots + 1\n    carrots = carrots\
    \ / 3\n    carrots = carrots * 3\n    carrots = carrots + 1\n    carrots = carrots\
    \ / 3\n    carrots = carrots * 3\n    carrots = carrots + 1\n    carrots = carrots\
    \ / 3\n    carrots = carrots * 3\n    carrots = carrots + 1\n    carrots = carrots\
    \ / 3\n    carrots = carrots * 3\n    carrots = carrots + 1\n    carrots = carrots\
    \ / 3\n    carrots = carrots * 3\n    carrots = carrots + 1\n    carrots = carrots\
    \ / 3\n    carrots = carrots * 3\n    carrots = carrots + 1\n    carrots = carrots\
    \ / 3\n    carrots = carrots * 3\n    carrots = carrots + 1\n    carrots = carrots\
    \ / 3\n    carrots = carrots * 3\n    carrots = carrots + 1\n    carrots = carrots\
    \ / 3\n    carrots = carrots * 3\n    carrots = carrots + 1\n    carrots = carrots\
    \ / 3\n    carrots = carrots * 3\n    carrots = carrots + 1\n    carrots = carrots\
    \ / 3\n    carrots = carrots * 3\n    carrots = carrots + 1\n    carrots = carrots\
    \ / 3\n    carrots = carrots * 3\n    carrots = carrots + 1\n    carrots = carrots\
    \ / 3\n    carrots = carrots * 3\n    carrots = carrots + 1\n    carrots = carrots\
    \ / 3\n    carrots = carrots * 3\n    carrots = carrots + 1\n    carrots = carrots\
    \ / 3\n    carrots = carrots * 3\n    carrots = carrots + 1\n    carrots = car\n\
    func TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmptyrfwo2r_test.go:97:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075316
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{}\n    }\n    carrots := 0\n    carrots += number\n\
    \    carrots += need\n    carrots += remaining\n    if carrots > 1000 {\n    \
    \    carrots = 1000\n    }\n    return []int{carrots, carrots - carrots}\n}\n\n\
    func TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpvahg5cw7_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=21)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpvahg5cw7_test.go:66:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=21) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpvahg5cw7_test.go:66: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=21) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpvahg5cw7_test.go:66: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=18) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmpvahg5cw7_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=16)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpvahg5cw7_test.go:66:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075317
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    carrots\
    \ := 0\n    if number > 1000 || need > 1000 || remaining > 1000 {\n        return\
    \ []int{0, 0}\n    }\n    if number > remaining {\n        carrots = number\n\
    \    } else {\n        carrots = remaining\n    }\n    if carrots > need {\n \
    \       carrots = need\n    }\n    carrots = carrots - need\n    if carrots <\
    \ 0 {\n        carrots = 0\n    }\n    return []int{carrots, carrots}\n}\n\nfunc\
    \ TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpe746n6y1_test.go:72: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=0)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpe746n6y1_test.go:72:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=0) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpe746n6y1_test.go:72: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpe746n6y1_test.go:72: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpe746n6y1_test.go:72: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=0)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpe746n6y1_test.go:72:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=0) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075317
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    carrots := 0\n    if number > need {\n        carrots = number-need\n\
    \    } else {\n        carrots = need\n    }\n    if carrots > remaining {\n \
    \       carrots = remaining\n    }\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrot\nfunc\
    \ TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpw99o_abn_test.go:97:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075316
- exit_code: 2
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    result\
    \ := make([]int, 2)\n    if number < 0 || number > 1000 {\n        fmt.Println(\"\
    Invalid input\")\n        return nil\n    }\n    if need < 0 || need > 1000 {\n\
    \        fmt.Println(\"Invalid input\")\n        return nil\n    }\n    if remaining\
    \ < 0 || remaining > 1000 {\n        fmt.Println(\"Invalid input\")\n        return\
    \ nil\n    }\n    if number == 0 {\n        result[0] = 0\n        result[1] =\
    \ 0\n        return result\n    }\n    if number == need {\n        result[0]\
    \ = number\n        result[1] = 0\n        return result\n    }\n    if number\
    \ > need {\n        fmt.Println(\"Invalid input\")\n        return nil\n    }\n\
    \    if remaining == 0 {\n        result[0] = number\n        result[1] = need\n\
    \        return result\n    }\n    if remaining > need {\n        fmt.Println(\"\
    Invalid input\")\n        return nil\n    }\n    if number > remaining {\n   \
    \     result[0] = number\n        result[1] = remaining\n        return result\n\
    \    }\n    if number == remaining {\n        result[0] = number\n        result[1]\
    \ = need\n        return result\n    }\n    if number < remaining {\n        result[0]\
    \ = number\n        result[1] = remaining\n        return result\n    }\n}\n\n\
    func TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_j6m9fdg_test.go:86:1: missing return

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075317
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    carrots\
    \ := 0\n    if number < 0 {\n        return []int{0, 0}\n    }\n    if need <\
    \ 0 {\n        return []int{0, 0}\n    }\n    if remaining < 0 {\n        return\
    \ []int{0, 0}\n    }\n    if number == 0 {\n        return []int{0, 0}\n    }\n\
    \    if need == 0 {\n        return []int{number, 0}\n    }\n    if remaining\
    \ == 0 {\n        return []int{0, number}\n    }\n    if number > remaining {\n\
    \        return []int{0, number}\n    }\n    if need > remaining {\n        return\
    \ []int{0, number}\n    }\n    if number == need {\n        return []int{number,\
    \ 0}\n    }\n    if number > need {\n        return []int{0, number}\n    }\n\
    \    if need > number {\n        return []int{0, number}\n    }\n    if number\
    \ == need {\n        return []int{number, 0}\n    }\n    if number > need {\n\
    \        return []int{0, number}\n    }\n    if need > number {\n        return\
    \ []int{0, number}\n    }\n    if number == need {\n        return []int{number,\
    \ 0}\n    }\n    if number > need {\n        return []int{0, number}\n    }\n\
    \    if need > number {\n        return []int{0, number}\n    }\n    if number\
    \ == need {\n        return []int{number, 0}\n    }\n    if number > need {\n\
    \        return []int{0, number}\n    }\n    if need > number {\n        return\
    \ []int{0, number}\n    }\n    if number == need {\n        return []int{number,\
    \ 0}\n    }\n    if number > need {\n        return []int{0, number}\n    }\n\
    \    if need > number {\n        return []int{0, number}\n    }\n    if number\
    \ == need {\n        return []int{number, 0}\n    }\n    if number > need {\n\
    \        return []int{0, number}\n    }\n    if need > number {\n        return\
    \ []int{0, number}\n    }\n    if number == need {\n        return []int{number,\
    \ 0}\n    }\n    if number > need {\n        return []int{0, number}\n    }\n\
    \    if need > number {\n        return []int{0, number}\n    }\n    if number\
    \ == need {\n        return []int{number, 0}\n    }\n    if number > need {\n\
    \        return []int{0, number}\n    }\n    if need > number {\n        return\
    \ []int{0, number}\n    }\n    if number == need {\n        return []int{number,\
    \ 0}\n    }\n    if number > need {\n        return []int{0, number}\n    }\n\
    \    if need > number {\n        return []int{0, number}\n    }\n    if number\
    \ == need {\n        return []int{number, 0}\n    }\n    if number > need {\n\
    \        return []\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n\
    \     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual:\
    \ candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpmw6ejbmo_test.go:145:18: expected type, found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075316
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    carrots\
    \ := 0\n    result := []int{}\n    if number > 1000 || need > 1000 || remaining\
    \ > 1000 {\n        fmt.Println(\"Invalid input\")\n    }\n    if number < need\
    \ {\n        fmt.Println(\"Not enough carrots to eat\")\n    }\n    if number\
    \ == need {\n        fmt.Println(\"You already have eaten all carrots, you now\
    \ have \", carrots, \" carrots left\")\n    }\n    if remaining < 0 {\n      \
    \  fmt.Println(\"Invalid input\")\n    }\n    if remaining == 0 {\n        fmt.Println(\"\
    You already have eaten all carrots, you now have \", carrots, \" carrots left\"\
    )\n    }\n    if remaining > number {\n        fmt.Println(\"Not enough carrots\
    \ to eat\")\n    }\n    if number > 0 {\n        carrots = number\n    }\n   \
    \ if need > 0 {\n        carrots = carrots + need\n    }\n    if remaining > 0\
    \ {\n        carrots = carrots - remaining\n    }\n    if carrots > 0 {\n    \
    \    result = append(result, carrots)\n    }\n    return result\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "Not enough carrots to eat\nNot enough carrots to eat\nNot enough carrots\
    \ to eat\nNot enough carrots to eat\nNot enough carrots to eat\nNot enough carrots\
    \ to eat\nNot enough carrots to eat\nNot enough carrots to eat\nNot enough carrots\
    \ to eat\nNot enough carrots to eat\nNot enough carrots to eat\n--- FAIL: TestEat\
    \ (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpew7yackz_test.go:88:\
    \ expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=1)]'\n    --- FAIL: TestEat/test_num__1\
    \ (0.00s)\n        tmpew7yackz_test.go:88: expected '[%!s(int=12) %!s(int=1)]',\
    \ got '[%!s(int=3)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpew7yackz_test.go:88:\
    \ expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpew7yackz_test.go:88: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=8)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpew7yackz_test.go:88:\
    \ expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=2)]'\n    --- FAIL: TestEat/test_num__5\
    \ (0.00s)\n        tmpew7yackz_test.go:88: expected '[%!s(int=5) %!s(int=0)]',\
    \ got '[%!s(int=8)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075317
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    if number\
    \ < need {\n        carrots = number\n    } else {\n        carrots = need\n \
    \   }\n    if carrots > remaining {\n        carrots = remaining\n    }\n    carrots\
    \ = carrots + number\n    carrots = carrots + need\n    carrots = carrots + remaining\n\
    \    carrots = carrots + number\n    carrots = carrots + need\n    carrots = carrots\
    \ + remaining\n    carrots = carrots + number\n    carrots = carrots + need\n\
    \    carrots = carrots + remaining\n    carrots = carrots + number\n    carrots\
    \ = carrots + need\n    carrots = carrots + remaining\n    carrots = carrots +\
    \ number\n    carrots = carrots + need\n    carrots = carrots + remaining\n  \
    \  carrots = carrots + number\n    carrots = carrots + need\n    carrots = carrots\
    \ + remaining\n    carrots = carrots + number\n    carrots = carrots + need\n\
    \    carrots = carrots + remaining\n    carrots = carrots + number\n    carrots\
    \ = carrots + need\n    carrots = carrots + remaining\n    carrots = carrots +\
    \ number\n    carrots = carrots + need\n    carrots = carrots + remaining\n  \
    \  carrots = carrots + number\n    carrots = carrots + need\n    carrots = carrots\
    \ + remaining\n    carrots = carrots + number\n    carrots = carrots + need\n\
    \    carrots = carrots + remaining\n    carrots = carrots + number\n    carrots\
    \ = carrots + need\n    carrots = carrots + remaining\n    carrots = carrots +\
    \ number\n    carrots = carrots + need\n    carrots = carrots + remaining\n  \
    \  carrots = carrots + number\n    carrots = carrots + need\n    carrots = carrots\
    \ + remaining\n    carrots = carrots + number\n    carrots = carrots + need\n\
    \    carrots = carrots + remaining\n    carrots = carrots + number\n    carrots\
    \ = carrots + need\n    carrots = carrots + remaining\n    carrots = car\nfunc\
    \ TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmposb8r9b0_test.go:96:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075317
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    carrots +=\
    \ number\n    carrots += need\n    carrots += remaining\n    if carrots > 1000\
    \ {\n        carrots = 1000\n    }\n    if carrots < 0 {\n        carrots = 0\n\
    \    }\n    carrots = carrots / 2\n    carrots = carrots * 2\n    carrots = carrots\
    \ + 1\n    carrots = carrots / 2\n    carrots = carrots * 2\n    carrots = carrots\
    \ + 1\n    carrots = carrots / 2\n    carrots = carrots * 2\n    carrots = carrots\
    \ + 1\n    carrots = carrots / 2\n    carrots = carrots * 2\n    carrots = carrots\
    \ + 1\n    carrots = carrots / 2\n    carrots = carrots * 2\n    carrots = carrots\
    \ + 1\n    carrots = carrots / 2\n    carrots = carrots * 2\n    carrots = carrots\
    \ + 1\n    carrots = carrots / 2\n    carrots = carrots * 2\n    carrots = carrots\
    \ + 1\n    carrots = carrots / 2\n    carrots = carrots * 2\n    carrots = carrots\
    \ + 1\n    carrots = carrots / 2\n    carrots = carrots * 2\n    carrots = carrots\
    \ + 1\n    carrots = carrots / 2\n    carrots = carrots * 2\n    carrots = carrots\
    \ + 1\n    carrots = carrots / 2\n    carrots = carrots * 2\n    carrots = carrots\
    \ + 1\n    carrots = carrots / 2\n    carrots = carrots * 2\n    carrots = carrots\
    \ + 1\n    carrots = carrots / 2\n    carrots = carrots * 2\n    carrots = carrots\
    \ + 1\n    carrots = carrots / 2\n    carrots = carrots * 2\n    carrots = carrots\
    \ + 1\n    carrots = carrots / 2\n    carrots = carrots * 2\n    carrots = carrots\
    \ + 1\n    carrots = carrots / 2\n    carrots = carrots * 2\n    carrots = car\n\
    func TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp4o2z80lx_test.go:96:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075317
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    //\
    \ Your code here\n    carrots := 0\n    carrots += number\n    carrots += need\n\
    \    carrots += remaining\n    if carrots < 0 {\n        carrots = 0\n    }\n\
    \    if carrots > 1000 {\n        carrots = 1000\n    }\n    if carrots > 100\
    \ {\n        carrots = 100\n    }\n    if carrots > 10 {\n        carrots = 10\n\
    \    }\n    if carrots > 0 {\n        carrots = 1\n    }\n    if carrots < 0 {\n\
    \        carrots = 0\n    }\n    if carrots > 1000 {\n        carrots = 1000\n\
    \    }\n    if carrots > 100 {\n        carrots = 100\n    }\n    if carrots >\
    \ 10 {\n        carrots = 10\n    }\n    if carrots > 0 {\n        carrots = 1\n\
    \    }\n    if carrots < 0 {\n        carrots = 0\n    }\n    if carrots > 1000\
    \ {\n        carrots = 1000\n    }\n    if carrots > 100 {\n        carrots =\
    \ 100\n    }\n    if carrots > 10 {\n        carrots = 10\n    }\n    if carrots\
    \ > 0 {\n        carrots = 1\n    }\n    if carrots < 0 {\n        carrots = 0\n\
    \    }\n    if carrots > 1000 {\n        carrots = 1000\n    }\n    if carrots\
    \ > 100 {\n        carrots = 100\n    }\n    if carrots > 10 {\n        carrots\
    \ = 10\n    }\n    if carrots > 0 {\n        carrots = 1\n    }\n    if carrots\
    \ < 0 {\n        carrots = 0\n    }\n    if carrots > 1000 {\n        carrots\
    \ = 1000\n    }\n    if carrots > 100 {\n        carrots = 100\n    }\n    if\
    \ carrots > 10 {\n        carrots = 10\n    }\n    if carrots > 0 {\n        carrots\
    \ = 1\n    }\n    if carrots < 0 {\n        carrots = 0\n    }\n    if carrots\
    \ > 1000 {\n        carrots = 1000\n    }\n    if carrots > 100 {\n        carrots\
    \ = 100\n    }\n    if carrots > 10 {\n        carrots = 10\n    }\n    if carrots\
    \ > 0 {\n        carrots = 1\n    }\n    if carrots < 0 {\n        carrots = 0\n\
    \    }\n    if carrots > 1000 {\n        carrots = 1000\n    }\n    if carrots\
    \ > 100 {\n        carrots = 100\n    }\n    if carrots > 10 {\n        carrots\
    \ = 10\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_8to01cf_test.go:142:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075317
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    carrots +=\
    \ number\n    carrots += need\n    carrots += remaining\n    carrots %= 1000\n\
    \    if carrots == 0 {\n        carrots = 1000\n    }\n    return []int{carrots,\
    \ carrots - number}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp3e8mrkkb_test.go:67: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=21)\
    \ %!s(int=16)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp3e8mrkkb_test.go:67:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=21) %!s(int=17)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp3e8mrkkb_test.go:67: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=21) %!s(int=20)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp3e8mrkkb_test.go:67: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=18) %!s(int=16)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmp3e8mrkkb_test.go:67: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=16)\
    \ %!s(int=12)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp3e8mrkkb_test.go:67:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=10) %!s(int=6)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075315
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    carrots := 0\n    carrots += number\n    carrots += need\n  \
    \  carrots += remaining\n    carrots -= number\n    carrots -= need\n    carrots\
    \ -= remaining\n    carrots -= number\n    carrots -= need\n    carrots -= remaining\n\
    \    carrots -= number\n    carrots -= need\n    carrots -= remaining\n    carrots\
    \ -= number\n    carrots -= need\n    carrots -= remaining\n    carrots -= number\n\
    \    carrots -= need\n    carrots -= remaining\n    carrots -= number\n    carrots\
    \ -= need\n    carrots -= remaining\n    carrots -= number\n    carrots -= need\n\
    \    carrots -= remaining\n    carrots -= number\n    carrots -= need\n    carrots\
    \ -= remaining\n    carrots -= number\n    carrots -= need\n    carrots -= remaining\n\
    \    carrots -= number\n    carrots -= need\n    carrots -= remaining\n    carrots\
    \ -= number\n    carrots -= need\n    carrots -= remaining\n    carrots -= number\n\
    \    carrots -= need\n    carrots -= remaining\n    carrots -= number\n    carrots\
    \ -= need\n    carrots -= remaining\n    carrots -= number\n    carrots -= need\n\
    \    carrots -= remaining\n    carrots -= number\n    carrots -= need\n    carrots\
    \ -= remaining\n    carrots -= number\n    carrots -= need\n    carrots -= remaining\n\
    \    carrots -= number\n    carrots -= need\n    carrots -= remaining\n    carrots\
    \ -= number\n    carrots -= need\n    carrots -= remaining\n    carrots -= number\n\
    \    carrots -= need\n    carrots -= remaining\n    carrots -= number\n    carrots\
    \ -= need\n    carrots -= remaining\n    carrots -= number\n    carrots -= need\n\
    \    carrots -= remaining\n    carrots -= number\n    carrots -= need\n    carrots\
    \ -= remaining\n    carrot\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpxi9a1u3m_test.go:109:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075315
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || number < 0 || need > 1000 || need < 0 || remaining > 1000 ||\
    \ remaining < 0 {\n        return []int{0, 0}\n    }\n    if number == 0 {\n \
    \       return []int{0, 0}\n    }\n    if need == 0 {\n        return []int{number,\
    \ 0}\n    }\n    if remaining == 0 {\n        return []int{number, 0}\n    }\n\
    \    if number > need {\n        return []int{0, 0}\n    }\n    if number > remaining\
    \ {\n        return []int{0, number}\n    }\n    if need > remaining {\n     \
    \   return []int{0, number}\n    }\n    if number == need {\n        return []int{number,\
    \ 0}\n    }\n    if number == remaining {\n        return []int{number, 0}\n \
    \   }\n    if number > remaining {\n        return []int{0, number}\n    }\n \
    \   if need > remaining {\n        return []int{0, number}\n    }\n    if number\
    \ == need {\n        return []int{number, 0}\n    }\n    if number == remaining\
    \ {\n        return []int{number, 0}\n    }\n    if number > need {\n        return\
    \ []int{0, 0}\n    }\n    if number > remaining {\n        return []int{0, number}\n\
    \    }\n    if need > remaining {\n        return []int{0, number}\n    }\n  \
    \  if number == need {\n        return []int{number, 0}\n    }\n    if number\
    \ == remaining {\n        return []int{number, 0}\n    }\n    if number > need\
    \ {\n        return []int{0, 0}\n    }\n    if number > remaining {\n        return\
    \ []int{0, number}\n    }\n    if need > remaining {\n        return []int{0,\
    \ number}\n    }\n    if number == need {\n        return []int{number, 0}\n \
    \   }\n    if number == remaining {\n        return []int{number, 0}\n    }\n\
    \    if number > need {\n        return []int{0, 0}\n    }\n    if number > remaining\
    \ {\n        return []int{0, number}\n    }\n    if need > remaining {\n     \
    \   return []int{0, number}\n    }\n    if number == need {\n        return []int{number,\
    \ 0}\n    }\n    if number == remaining {\n        return []int{number, 0}\n \
    \   }\n    if number > need {\n        return []int{0, 0}\n    }\n    if number\
    \ > remaining {\n        return []int{0, number}\n    }\n    if need > remaining\
    \ {\n        return []int{0, number}\n    }\n    if number == need {\n       \
    \ return []int{number, 0}\n    }\n    if number == remaining {\n        return\
    \ []int{number, 0}\n    }\n    if number > need {\n        return []int{0, 0}\n\
    \    }\n    if number > remaining {\n        return []int{0, number}\n    }\n\
    \    if need > remaining {\n        return []int\nfunc TestEat(t *testing.T) {\n\
    \  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected:\
    \ []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n\
    \     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual:\
    \ candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5,\
    \ 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5,\
    \ 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp2xpj4iq1_test.go:141:16: expected expression

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075317
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    //\
    \ write your code in JavaScript (Node.js)\n    // let carrots = number\n    //\
    \ let need = need\n    // let remaining = remaining\n    // let result = []\n\
    \    // while carrots > 0 && need > 0 && remaining > 0 {\n    //     carrots -=\
    \ need\n    //     need += remaining\n    //     remaining -= carrots\n    //\
    \     result.push(carrots)\n    // }\n    // return result\n    var carrots =\
    \ number\n    var need = need\n    var remaining = remaining\n    var result =\
    \ []\n    while carrots > 0 && need > 0 && remaining > 0 {\n        carrots -=\
    \ need\n        need += remaining\n        remaining -= carrots\n        result.push(carrots)\n\
    \    }\n    return result\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp0njdrofv_test.go:50:20: expected type, found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075317
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{}\n    }\n    carrots := 0\n    carrots += number\n\
    \    carrots += need\n    carrots += remaining\n    if carrots > 1000 {\n    \
    \    carrots = 1000\n    }\n    if carrots < 0 {\n        carrots = 0\n    }\n\
    \    return []int{carrots, carrots - carrots}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpb31hkqpq_test.go:69: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=21)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpb31hkqpq_test.go:69:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=21) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpb31hkqpq_test.go:69: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=21) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpb31hkqpq_test.go:69: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=18) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmpb31hkqpq_test.go:69: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=16)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpb31hkqpq_test.go:69:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660075318
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    if number\
    \ > need {\n        carrots = number-need\n    } else {\n        carrots = need\n\
    \    }\n    if carrots > remaining {\n        carrots = remaining\n    }\n   \
    \ carrots = carrots + number\n    carrots = carrots + need\n    carrots = carrots\
    \ + remaining\n    return []int{carrots, carrots-carrots}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpftf1xr6t_test.go:71: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=27)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpftf1xr6t_test.go:71:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=29) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpftf1xr6t_test.go:71: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=31) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpftf1xr6t_test.go:71: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=23) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmpftf1xr6t_test.go:71: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=21)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpftf1xr6t_test.go:71:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=11) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075318
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    if number == 0 {\n        return []int{0, 0}\n    }\n    if need\
    \ == 0 {\n        return []int{number, 0}\n    }\n    if remaining == 0 {\n  \
    \      return []int{number, 0}\n    }\n    if number < need {\n        return\
    \ []int{0, 0}\n    }\n    if number == need {\n        return []int{number, 0}\n\
    \    }\n    if number > remaining {\n        return []int{0, 0}\n    }\n    if\
    \ number == remaining {\n        return []int{number, 0}\n    }\n    if number\
    \ > need {\n        return []int{0, 0}\n    }\n    if number == need {\n     \
    \   return []int{number, 0}\n    }\n    if number > remaining {\n        return\
    \ []int{0, 0}\n    }\n    if number == remaining {\n        return []int{number,\
    \ 0}\n    }\n    if number < need {\n        return []int{0, 0}\n    }\n    if\
    \ number == need {\n        return []int{number, 0}\n    }\n    if number > remaining\
    \ {\n        return []int{0, 0}\n    }\n    if number == remaining {\n       \
    \ return []int{number, 0}\n    }\n    if number < need {\n        return []int{0,\
    \ 0}\n    }\n    if number == need {\n        return []int{number, 0}\n    }\n\
    \    if number > remaining {\n        return []int{0, 0}\n    }\n    if number\
    \ == remaining {\n        return []int{number, 0}\n    }\n    if number < need\
    \ {\n        return []int{0, 0}\n    }\n    if number == need {\n        return\
    \ []int{number, 0}\n    }\n    if number > remaining {\n        return []int{0,\
    \ 0}\n    }\n    if number == remaining {\n        return []int{number, 0}\n \
    \   }\n    if number < need {\n        return []int{0, 0}\n    }\n    if number\
    \ == need {\n        return []int{number, 0}\n    }\n    if number > remaining\
    \ {\n        return []int{0, 0}\n    }\n    if number == remaining {\n       \
    \ return []int{number, 0}\n    }\n    if number < need {\n        return []int{0,\
    \ 0}\n    }\n    if number == need {\n        return []int{number, 0}\n    }\n\
    \    if number > remaining {\n        return []int{0, 0}\n    }\n    if number\
    \ == remaining {\n        return []int{number, 0}\n    }\n    if number < need\
    \ {\n        return []int{0, 0}\n    }\n    if number == need {\n        return\
    \ []int{number, 0}\n    }\n    if number > remaining {\n        return []int{0,\
    \ 0}\n    }\n    if number == remaining {\n        return []int{number, 0}\n \
    \   }\n    if number < \nfunc TestEat(t *testing.T) {\n  candidate := eat\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp31qe029h_test.go:144:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075317
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || need < 0 || remaining < 0 {\n        return []int{0, 0}\n    }\n\
    \    if number == 0 && need == 0 {\n        return []int{0, 0}\n    }\n    if\
    \ number == 0 && need > 0 {\n        return []int{need, remaining}\n    }\n  \
    \  if need == 0 && remaining > 0 {\n        return []int{number, 0}\n    }\n \
    \   if number > 0 && need > 0 && remaining > 0 {\n        var result []int\n \
    \       var carrots int\n        if number > need {\n            carrots = number\n\
    \            number = need\n            need = 0\n        } else {\n         \
    \   carrots = need\n            need = number\n            number = 0\n      \
    \  }\n        if carrots > remaining {\n            carrots = remaining\n    \
    \        remaining = 0\n        }\n        result = append(result, carrots)\n\
    \        result = append(result, carrots-need)\n        return result\n    }\n\
    \    return []int{0, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp_zgl6lbe_test.go:88: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=1)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp_zgl6lbe_test.go:88:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=4)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp_zgl6lbe_test.go:88: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp_zgl6lbe_test.go:88: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=3)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp_zgl6lbe_test.go:88: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=5)\
    \ %!s(int=1)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp_zgl6lbe_test.go:88:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=-3)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075318
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    result := []int{0, 0}\n   \
    \ if remaining > 0 {\n        result[0] = number\n        result[1] = remaining\n\
    \    }\n    return result\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpitsrqrqa_test.go:64: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5)\
    \ %!s(int=10)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpitsrqrqa_test.go:64:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=9)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpitsrqrqa_test.go:64: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpitsrqrqa_test.go:64: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=2) %!s(int=5)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpitsrqrqa_test.go:64: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4)\
    \ %!s(int=7)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpitsrqrqa_test.go:64:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=1)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075318
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    //\
    \ write your code here\n    carrots := 0\n    if number < 0 {\n        return\
    \ []int{0, 0}\n    }\n    if need < 0 {\n        return []int{0, 0}\n    }\n \
    \   if remaining < 0 {\n        return []int{0, 0}\n    }\n    if number == 0\
    \ {\n        return []int{0, 0}\n    }\n    if need == 0 {\n        return []int{number,\
    \ 0}\n    }\n    if remaining == 0 {\n        return []int{number, 0}\n    }\n\
    \    if number > remaining {\n        return []int{0, 0}\n    }\n    if need >\
    \ remaining {\n        return []int{0, 0}\n    }\n    if number > need {\n   \
    \     return []int{0, 0}\n    }\n    if number == need {\n        return []int{number,\
    \ 0}\n    }\n    if number > need {\n        return []int{0, 0}\n    }\n    if\
    \ number == need {\n        return []int{number, 0}\n    }\n    if number > need\
    \ {\n        return []int{0, 0}\n    }\n    if number == need {\n        return\
    \ []int{number, 0}\n    }\n    if number > need {\n        return []int{0, 0}\n\
    \    }\n    if number == need {\n        return []int{number, 0}\n    }\n    if\
    \ number > need {\n        return []int{0, 0}\n    }\n    if number == need {\n\
    \        return []int{number, 0}\n    }\n    if number > need {\n        return\
    \ []int{0, 0}\n    }\n    if number == need {\n        return []int{number, 0}\n\
    \    }\n    if number > need {\n        return []int{0, 0}\n    }\n    if number\
    \ == need {\n        return []int{number, 0}\n    }\n    if number > need {\n\
    \        return []int{0, 0}\n    }\n    if number == need {\n        return []int{number,\
    \ 0}\n    }\n    if number > need {\n        return []int{0, 0}\n    }\n    if\
    \ number == need {\n        return []int{number, 0}\n    }\n    if number > need\
    \ {\n        return []int{0, 0}\n    }\n    if number == need {\n        return\
    \ []int{number, 0}\n    }\n    if number > need {\n        return []int{0, 0}\n\
    \    }\n    if number == need {\n        return []int{number, 0}\n    }\n    if\
    \ number > need {\n        return []int{0, 0}\n    }\n    if number == need {\n\
    \        return []int{number, 0}\n    }\n    if number > need {\n        return\
    \ []int{0, 0}\n    }\n    if number == need {\n        return []int{number, 0}\n\
    \    }\n    if number > need {\n        return []int{0, 0}\n    }\n    if number\
    \ == need {\n        return []int{number, 0}\n    }\n    if number \nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpy4qyrknn_test.go:146:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075317
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || number < 0 || need > 1000 || need < 0 || remaining > 1000 ||\
    \ remaining < 0 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    carrots\
    \ += number\n    carrots += need\n    carrots += remaining\n    if carrots > 1000\
    \ {\n        carrots = 1000\n    }\n    return []int{carrots, carrots - carrots}\n\
    }\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpodxtwnq6_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=21)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpodxtwnq6_test.go:66:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=21) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpodxtwnq6_test.go:66: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=21) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpodxtwnq6_test.go:66: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=18) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmpodxtwnq6_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=16)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpodxtwnq6_test.go:66:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075318
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    carrots := 0\n    if number > need {\n        carrots = number\n\
    \    } else {\n        carrots = need\n    }\n    if remaining > 0 {\n       \
    \ carrots = carrots + remaining\n    }\n    return []int{carrots, carrots - number}\n\
    }\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp5cgtr0zy_test.go:68: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=16)\
    \ %!s(int=11)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp5cgtr0zy_test.go:68:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=17) %!s(int=13)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp5cgtr0zy_test.go:68: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=20) %!s(int=19)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp5cgtr0zy_test.go:68: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=16) %!s(int=14)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmp5cgtr0zy_test.go:68: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=12)\
    \ %!s(int=8)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp5cgtr0zy_test.go:68:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=6) %!s(int=2)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075319
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    carrots := 0\n    if remaining > 0 {\n        carrots = remaining\n\
    \    }\n    if number > need {\n        carrots = number-need\n    }\n    if carrots\
    \ == 0 {\n        carrots = number\n    }\n    if carrots > 0 {\n        carrots\
    \ = carrots + 1\n    }\n    if carrots > 1000 {\n        carrots = 1000\n    }\n\
    \    return []int{carrots, carrots-carrots}\n}\n\nfunc TestEat(t *testing.T) {\n\
    \  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected:\
    \ []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n\
    \     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual:\
    \ candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5,\
    \ 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5,\
    \ 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpa1u5bat3_test.go:75: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=11)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpa1u5bat3_test.go:75:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=10) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__3 (0.00s)\n        tmpa1u5bat3_test.go:75: expected\
    \ '[%!s(int=7) %!s(int=0)]', got '[%!s(int=6) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmpa1u5bat3_test.go:75: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=8) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n \
    \       tmpa1u5bat3_test.go:75: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=2)\
    \ %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075319
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    //\
    \ write your code in JavaScript (Node.js)\n    // or whatever you prefer\n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpdb4jgpv8_test.go:286:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075318
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    result\
    \ := make([]int, 2)\n    if number > 1000 || need > 1000 || remaining > 1000 {\n\
    \        fmt.Println(\"Invalid input\")\n    }\n    if number == 0 {\n       \
    \ result[0] = 0\n        result[1] = 0\n        return result\n    }\n    if need\
    \ == 0 {\n        result[0] = number\n        result[1] = 0\n        return result\n\
    \    }\n    if remaining == 0 {\n        result[0] = number\n        result[1]\
    \ = need\n        return result\n    }\n    if number < need {\n        result[0]\
    \ = number\n        result[1] = need\n        return result\n    }\n    if number\
    \ > remaining {\n        result[0] = number\n        result[1] = remaining\n \
    \       return result\n    }\n    if number == need {\n        result[0] = number\n\
    \        result[1] = need\n        return result\n    }\n    if number == remaining\
    \ {\n        result[0] = number\n        result[1] = remaining\n        return\
    \ result\n    }\n    if number > remaining {\n        result[0] = number\n   \
    \     result[1] = remaining\n        return result\n    }\n    if number == need\
    \ {\n        result[0] = number\n        result[1] = need\n        return result\n\
    \    }\n    if number == remaining {\n        result[0] = number\n        result[1]\
    \ = remaining\n        return result\n    }\n    if number < need {\n        result[0]\
    \ = number\n        result[1] = need\n        return result\n    }\n    if number\
    \ < remaining {\n        result[0] = number\n        result[1] = remaining\n \
    \       return result\n    }\n    if number == need {\n        result[0] = number\n\
    \        result[1] = need\n        return result\n    }\n    if number == remaining\
    \ {\n        result[0] = number\n        result[1] = remaining\n        return\
    \ result\n    }\n    if number > need {\n        result[0] = number\n        result[1]\
    \ = need\n        return result\n    }\n    if number > remaining {\n        result[0]\
    \ = number\n        result[1] = remaining\n        return result\n    }\n    if\
    \ number == need {\n        result[0] = number\n        result[1] = need\n   \
    \     return result\n    }\n    if number == remaining {\n        result[0] =\
    \ number\n        result[1] = remaining\n        return result\n    }\n    if\
    \ number < need {\n        result[0] = number\n        result[1] = need\n    \
    \    return result\n    }\n    if number < remaining {\n        result[0] = number\n\
    \        result[1] = remaining\n        return result\n    }\n    if number ==\
    \ need {\n        result[0] = number\n        result[1] = need\n        return\
    \ result\n    }\n    if number == remaining {\n        result[0] = number\n  \
    \      result[1] = remaining\n        return result\n    }\n    if number > need\
    \ {\n        result[0] = number\n        result[1] = need\n        return result\n\
    \    }\n    if number > remaining {\n        result[0] = number\n        result[1]\
    \ = remaining\n        return result\n    }\n    if number == need {\n       \
    \ result[0] = number\n        result[1] = need\n        return result\n    }\n\
    \    if number == remaining {\n        result[0] = number\n        result[1] =\
    \ remaining\n        return result\n    }\n    if number < need {\n        result[0]\
    \ = number\n        result[1] = need\n\nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpgz8kmliy_test.go:173:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075318
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    carrots +=\
    \ number\n    carrots += need\n    carrots += remaining\n    carrots = carrots\
    \ % 100\n    carrots = carrots / 100\n    carrots = carrots + 1\n    carrots =\
    \ carrots % 100\n    carrots = carrots / 100\n    carrots = carrots + 1\n    carrots\
    \ = carrots % 100\n    carrots = carrots / 100\n    carrots = carrots + 1\n  \
    \  carrots = carrots % 100\n    carrots = carrots / 100\n    carrots = carrots\
    \ + 1\n    carrots = carrots % 100\n    carrots = carrots / 100\n    carrots =\
    \ carrots + 1\n    carrots = carrots % 100\n    carrots = carrots / 100\n    carrots\
    \ = carrots + 1\n    carrots = carrots % 100\n    carrots = carrots / 100\n  \
    \  carrots = carrots + 1\n    carrots = carrots % 100\n    carrots = carrots /\
    \ 100\n    carrots = carrots + 1\n    carrots = carrots % 100\n    carrots = carrots\
    \ / 100\n    carrots = carrots + 1\n    carrots = carrots % 100\n    carrots =\
    \ carrots / 100\n    carrots = carrots + 1\n    carrots = carrots % 100\n    carrots\
    \ = carrots / 100\n    carrots = carrots + 1\n    carrots = carrots % 100\n  \
    \  carrots = carrots / 100\n    carrots = carrots + 1\n    carrots = carrots %\
    \ 100\n    carrots = carrots / 100\n    carrots = carrots + 1\n    carrots = carrots\
    \ % 100\n    carrots = carrots / 100\n    carrots = carrots + 1\n    carrots =\
    \ carrots % 100\n    carrots = carrots / 100\n    carrots = carrots + 1\n    carrots\
    \ = carrots % 100\n    carrots = carrots / 100\n    carrots = carrots + 1\n  \
    \  carrots = carrots % \nfunc TestEat(t *testing.T) {\n  candidate := eat\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpfzaelljh_test.go:91:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075318
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 {\n        return []int{0, 0}\n    }\n    if need\
    \ < 0 || need > 1000 {\n        return []int{0, 0}\n    }\n    if remaining <\
    \ 0 || remaining > 1000 {\n        return []int{0, 0}\n    }\n    \n    carrots\
    \ := 0\n    carrots += number\n    carrots += need\n    carrots += remaining\n\
    \    \n    if carrots > 1000 {\n        carrots = 1000\n    }\n    \n    return\
    \ []int{carrots, carrots - carrots}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpy6tg3n5y_test.go:75: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=21)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpy6tg3n5y_test.go:75:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=21) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpy6tg3n5y_test.go:75: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=21) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpy6tg3n5y_test.go:75: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=18) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmpy6tg3n5y_test.go:75: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=16)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpy6tg3n5y_test.go:75:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075320
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    carrots\
    \ := 0\n    if number < 0 {\n        return []int{0, 0}\n    }\n    if need <\
    \ 0 {\n        return []int{0, 0}\n    }\n    if remaining < 0 {\n        return\
    \ []int{0, 0}\n    }\n    if number == 0 {\n        return []int{0, 0}\n    }\n\
    \    if number > 0 && need > 0 && remaining > 0 {\n        carrots = number\n\
    \        carrots = carrots - need\n        carrots = carrots - remaining\n   \
    \     if carrots < 0 {\n            carrots = 0\n        }\n    }\n    if carrots\
    \ == 0 {\n        carrots = number\n    }\n    if carrots > 0 {\n        carrots\
    \ = carrots + 1\n    }\n    return []int{carrots, carrots}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp42nmt7rx_test.go:83: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=6)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp42nmt7rx_test.go:83:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=5) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp42nmt7rx_test.go:83: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=2) %!s(int=2)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp42nmt7rx_test.go:83: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=3) %!s(int=3)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp42nmt7rx_test.go:83: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=5)\
    \ %!s(int=5)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp42nmt7rx_test.go:83:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=5) %!s(int=5)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075320
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    carrots\
    \ := 0\n    if number < 0 || number > 1000 || need < 0 || need > 1000 || remaining\
    \ < 0 || remaining > 1000 {\n        return []int{0, 0}\n    }\n    if number\
    \ == 0 {\n        return []int{0, 0}\n    }\n    if number == need {\n       \
    \ return []int{number, 0}\n    }\n    if number > need {\n        return []int{0,\
    \ 0}\n    }\n    if remaining == 0 {\n        return []int{number, 0}\n    }\n\
    \    if remaining > need {\n        return []int{0, 0}\n    }\n    if remaining\
    \ == number {\n        return []int{number, 0}\n    }\n    if remaining > number\
    \ {\n        return []int{0, 0}\n    }\n    if remaining == 0 {\n        return\
    \ []int{0, 0}\n    }\n    if number > remaining {\n        return []int{0, 0}\n\
    \    }\n    if number == remaining {\n        return []int{number, 0}\n    }\n\
    \    if number > remaining {\n        return []int{0, 0}\n    }\n    if number\
    \ == 0 {\n        return []int{0, 0}\n    }\n    if number > 0 {\n        return\
    \ []int{number, 0}\n    }\n    if number == 0 {\n        return []int{0, 0}\n\
    \    }\n    if number > 0 {\n        return []int{number, 0}\n    }\n    if number\
    \ == 0 {\n        return []int{0, 0}\n    }\n    if number > 0 {\n        return\
    \ []int{number, 0}\n    }\n    if number == 0 {\n        return []int{0, 0}\n\
    \    }\n    if number > 0 {\n        return []int{number, 0}\n    }\n    if number\
    \ == 0 {\n        return []int{0, 0}\n    }\n    if number > 0 {\n        return\
    \ []int{number, 0}\n    }\n    if number == 0 {\n        return []int{0, 0}\n\
    \    }\n    if number > 0 {\n        return []int{number, 0}\n    }\n    if number\
    \ == 0 {\n        return []int{0, 0}\n    }\n    if number > 0 {\n        return\
    \ []int{number, 0}\n    }\n    if number == 0 {\n        return []int{0, 0}\n\
    \    }\n    if number > 0 {\n        return []int{number, 0}\n    }\n    if number\
    \ == 0 {\n        return []int{0, 0}\n    }\n    if number > 0 {\n        return\
    \ []int{number, 0}\n    }\n    if number == 0 {\n        return []int{0, 0}\n\
    \    }\n    if number > 0 {\n        return []int{number, 0}\n    }\n    if number\
    \ == 0 {\n        return []int{0, 0}\n    }\n    if number > 0 {\n        return\
    \ []int{number, 0}\n    }\n    if number == 0 {\n        return []int{0, 0}\n\
    \    }\n    if number > 0 {\n        return []int{number, 0}\n    }\n    if number\
    \ == 0 {\n        return []int{0, 0}\n\nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp1ilouuwa_test.go:147:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075318
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    carrots := 0\n    meals := 0\n    for i := 0; i < number; i++\
    \ {\n        carrots += i\n    }\n    for i := 0; i < need; i++ {\n        carrots\
    \ += i\n    }\n    meals = carrots - need\n    if meals > remaining {\n      \
    \  meals = remaining\n    }\n    return []int{meals, carrots - meals}\n}\n\nfunc\
    \ TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpwx6z5a1s_test.go:71: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=15)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpwx6z5a1s_test.go:71:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=25)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpwx6z5a1s_test.go:71: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=35)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpwx6z5a1s_test.go:71: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=51)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmpwx6z5a1s_test.go:71: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpwx6z5a1s_test.go:71:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=15)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075320
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    result\
    \ := make([]int, 2)\n    if number > 1000 || need > 1000 || remaining > 1000 {\n\
    \        fmt.Println(\"Invalid input\")\n        return nil\n    }\n    if number\
    \ == 0 {\n        result[0] = 0\n        result[1] = 0\n        return result\n\
    \    }\n    if need == 0 {\n        result[0] = number\n        result[1] = 0\n\
    \        return result\n    }\n    if remaining == 0 {\n        result[0] = number\n\
    \        result[1] = need\n        return result\n    }\n    if number > need\
    \ {\n        fmt.Println(\"Invalid input\")\n        return nil\n    }\n    if\
    \ number > remaining {\n        result[0] = number\n        result[1] = need\n\
    \        return result\n    }\n    if need > remaining {\n        result[0] =\
    \ need\n        result[1] = number\n        return result\n    }\n    if number\
    \ == need {\n        result[0] = number\n        result[1] = need\n        return\
    \ result\n    }\n    if number == remaining {\n        result[0] = number\n  \
    \      result[1] = remaining\n        return result\n    }\n    if need == remaining\
    \ {\n        result[0] = need\n        result[1] = remaining\n        return result\n\
    \    }\n    if number > remaining {\n        result[0] = number\n        result[1]\
    \ = remaining\n        return result\n    }\n    if need > remaining {\n     \
    \   result[0] = need\n        result[1] = remaining\n        return result\n \
    \   }\n    if number == need {\n        result[0] = number\n        result[1]\
    \ = need\n        return result\n    }\n    if number == remaining {\n       \
    \ result[0] = number\n        result[1] = remaining\n        return result\n \
    \   }\n    if need == remaining {\n        result[0] = need\n        result[1]\
    \ = remaining\n        return result\n    }\n    if number > remaining {\n   \
    \     result[0] = number\n        result[1] = remaining\n        return result\n\
    \    }\n    if need > remaining {\n        result[0] = need\n        result[1]\
    \ = remaining\n        return result\n    }\n    if number == need {\n       \
    \ result[0] = number\n        result[1] = need\n        return result\n    }\n\
    \    if number == remaining {\n        result[0] = number\n        result[1] =\
    \ remaining\n        return result\n    }\n    if need == remaining {\n      \
    \  result[0] = need\n        result[1] = remaining\n        return result\n  \
    \  }\n    if number > remaining {\n        result[0] = number\n        result[1]\
    \ = remaining\n        return result\n    }\n    if need > remaining {\n     \
    \   result[0] = need\n        result[1] = remaining\n        return result\n \
    \   }\n    if number == need {\n        result[0] = number\n        result[1]\
    \ = need\n        return result\n    }\n    if number == remaining {\n       \
    \ result[0] = number\n        result[1] = remaining\n        return result\n \
    \   }\n    if need == remaining {\n        result[0] = need\n        result[1]\
    \ = remaining\n        return result\n    }\n    if number > remaining {\n   \
    \     result[0] = number\n        result[1] = remaining\n        return result\n\
    \    }\n    if need > remaining {\n        result[0] = need\n        result[1]\
    \ = remaining\n        return result\n    }\n    if number == need {\n       \
    \ result[0] = number\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n\
    \     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual:\
    \ candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmptxu33nzc_test.go:172:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075319
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    meals :=\
    \ 0\n    carrots += number\n    meals += need\n    carrots -= remaining\n    if\
    \ carrots < 0 {\n        carrots = 0\n    }\n    if meals < 0 {\n        meals\
    \ = 0\n    }\n    if carrots == 0 && meals == 0 {\n        return []int{0, 0}\n\
    \    }\n    if carrots == 0 {\n        return []int{meals, 0}\n    }\n    if meals\
    \ == 0 {\n        return []int{carrots, 0}\n    }\n    if carrots > meals {\n\
    \        return []int{carrots, meals}\n    }\n    if meals > carrots {\n     \
    \   return []int{meals, carrots}\n    }\n    return []int{carrots, meals}\n}\n\
    \nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpf3_v1i2x_test.go:85: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpf3_v1i2x_test.go:85:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpf3_v1i2x_test.go:85: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpf3_v1i2x_test.go:85: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=11) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmpf3_v1i2x_test.go:85: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=5)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpf3_v1i2x_test.go:85:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=5) %!s(int=3)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075320
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    carrots\
    \ := 0\n    if number < 0 || number > 1000 {\n        return []int{0, 0}\n   \
    \ }\n    if need < 0 || need > 1000 {\n        return []int{0, 0}\n    }\n   \
    \ if remaining < 0 || remaining > 1000 {\n        return []int{0, 0}\n    }\n\
    \    if number == 0 {\n        return []int{0, 0}\n    }\n    if need == 0 {\n\
    \        return []int{0, 0}\n    }\n    if remaining == 0 {\n        return []int{0,\
    \ 0}\n    }\n    if number > need {\n        return []int{0, 0}\n    }\n    if\
    \ number > remaining {\n        return []int{0, 0}\n    }\n    if need > remaining\
    \ {\n        return []int{0, 0}\n    }\n    if number == need {\n        return\
    \ []int{0, 0}\n    }\n    if number == remaining {\n        return []int{0, 0}\n\
    \    }\n    if number > need {\n        return []int{0, 0}\n    }\n    if number\
    \ > remaining {\n        return []int{0, 0}\n    }\n    if need > remaining {\n\
    \        return []int{0, 0}\n    }\n    if number == need {\n        return []int{0,\
    \ 0}\n    }\n    if number == remaining {\n        return []int{0, 0}\n    }\n\
    \    if number > need {\n        return []int{0, 0}\n    }\n    if number > remaining\
    \ {\n        return []int{0, 0}\n    }\n    if need > remaining {\n        return\
    \ []int{0, 0}\n    }\n    if number == need {\n        return []int{0, 0}\n  \
    \  }\n    if number == remaining {\n        return []int{0, 0}\n    }\n    if\
    \ number > need {\n        return []int{0, 0}\n    }\n    if number > remaining\
    \ {\n        return []int{0, 0}\n    }\n    if need > remaining {\n        return\
    \ []int{0, 0}\n    }\n    if number == need {\n        return []int{0, 0}\n  \
    \  }\n    if number == remaining {\n        return []int{0, 0}\n    }\n    if\
    \ number > need {\n        return []int{0, 0}\n    }\n    if number > remaining\
    \ {\n        return []int{0, 0}\n    }\n    if need > remaining {\n        return\
    \ []int{0, 0}\n    }\n    if number == need {\n        return []int{0, 0}\n  \
    \  }\n    if number == remaining {\n        return []int{0, 0}\n    }\n    if\
    \ number > need {\n        return []int{0, 0}\n    }\n    if number > remaining\
    \ {\n        return []int{0, 0}\n    }\n    if need > remaining {\n        return\
    \ []int{0, 0}\n    }\n    if number == need {\n        return []int{0, 0}\n  \
    \  }\n    if number == remaining {\n        return []int{\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpsk2tz57p_test.go:143:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075318
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    carrots +=\
    \ number\n    carrots += need\n    carrots += remaining\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    \nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpfr04oftk_test.go:108:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075319
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || need < 0 || remaining < 0 {\n        return []int{0, 0}\n    }\n\
    \    if number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    carrots := 0\n    carrots += number\n    carrots += need\n  \
    \  carrots += remaining\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= \nfunc TestEat(t *testing.T) {\n  candidate := eat\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpydevhq2g_test.go:109:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075319
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return nil\n   \
    \ }\n    carrots := 0\n    meals := 0\n    carrots -= number\n    meals += need\n\
    \    carrots += remaining\n    if carrots < 0 {\n        carrots = 0\n    }\n\
    \    if meals < 0 {\n        meals = 0\n    }\n    return []int{carrots, meals}\n\
    }\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp4kw00n9b_test.go:70: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5)\
    \ %!s(int=6)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp4kw00n9b_test.go:70:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=5) %!s(int=8)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp4kw00n9b_test.go:70: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=9) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp4kw00n9b_test.go:70: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=3) %!s(int=11)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmp4kw00n9b_test.go:70: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=3)\
    \ %!s(int=5)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp4kw00n9b_test.go:70:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=0) %!s(int=5)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075320
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    if number == 0 {\n        return\
    \ []int{0, 0}\n    }\n    if remaining < need {\n        return []int{0, 0}\n\
    \    }\n    if number == need {\n        return []int{number, 0}\n    }\n    if\
    \ number > need {\n        return []int{0, number}\n    }\n    result := []int{0,\
    \ 0}\n    carrots := 0\n    for i := 0; i < number; i++ {\n        carrots +=\
    \ i\n    }\n    for i := 0; i < need; i++ {\n        carrots += i\n    }\n   \
    \ for i := 0; i < remaining; i++ {\n        carrots += i\n    }\n    result[0]\
    \ = carrots\n    result[1] = remaining\n    return result\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpwicy0ep8_test.go:84: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=70)\
    \ %!s(int=10)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpwicy0ep8_test.go:84:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=70) %!s(int=9)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpwicy0ep8_test.go:84: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=90) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpwicy0ep8_test.go:84: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpwicy0ep8_test.go:84: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=37)\
    \ %!s(int=7)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpwicy0ep8_test.go:84:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=0) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075320
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    //\
    \ Your code here\n    carrots := 0\n    if number > 1000 || need > 1000 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    if number == 0 {\n        return\
    \ []int{0, 0}\n    }\n    if need == 0 {\n        return []int{number, 0}\n  \
    \  }\n    if remaining == 0 {\n        return []int{number, 0}\n    }\n    if\
    \ number > need {\n        return []int{0, 0}\n    }\n    if number > remaining\
    \ {\n        return []int{0, 0}\n    }\n    if need > remaining {\n        return\
    \ []int{0, 0}\n    }\n    if number == need {\n        return []int{number, 0}\n\
    \    }\n    if number == remaining {\n        return []int{number, 0}\n    }\n\
    \    if number > need {\n        return []int{0, 0}\n    }\n    if number > remaining\
    \ {\n        return []int{0, 0}\n    }\n    if need > remaining {\n        return\
    \ []int{0, 0}\n    }\n    if number == need {\n        return []int{number, 0}\n\
    \    }\n    if number == remaining {\n        return []int{number, 0}\n    }\n\
    \    if number > need {\n        return []int{0, 0}\n    }\n    if number > remaining\
    \ {\n        return []int{0, 0}\n    }\n    if need > remaining {\n        return\
    \ []int{0, 0}\n    }\n    if number == need {\n        return []int{number, 0}\n\
    \    }\n    if number == remaining {\n        return []int{number, 0}\n    }\n\
    \    if number > need {\n        return []int{0, 0}\n    }\n    if number > remaining\
    \ {\n        return []int{0, 0}\n    }\n    if need > remaining {\n        return\
    \ []int{0, 0}\n    }\n    if number == need {\n        return []int{number, 0}\n\
    \    }\n    if number == remaining {\n        return []int{number, 0}\n    }\n\
    \    if number > need {\n        return []int{0, 0}\n    }\n    if number > remaining\
    \ {\n        return []int{0, 0}\n    }\n    if need > remaining {\n        return\
    \ []int{0, 0}\n    }\n    if number == need {\n        return []int{number, 0}\n\
    \    }\n    if number == remaining {\n        return []int{number, 0}\n    }\n\
    \    if number > need {\n        return []int{0, 0}\n    }\n    if number > remaining\
    \ {\n        return []int{0, 0}\n    }\n    if need > remaining {\n        return\
    \ []int{0, 0}\n    }\n    if number == need {\n        return []int{number, 0}\n\
    \    }\n    if number == remaining {\n        return []int{number, 0}\n    }\n\
    \    if number > need {\n        return []int{0, 0}\n    }\n    if number > remaining\
    \ {\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp2dnw9i55_test.go:143:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075314
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    carrots := 0\n    carrots += number\n    carrots += need\n  \
    \  carrots += remaining\n    if carrots > 1000 {\n        carrots = 1000\n   \
    \ }\n    carrots -= number\n    carrots -= need\n    carrots -= remaining\n  \
    \  if carrots < 0 {\n        carrots = 0\n    }\n    return []int{carrots, carrots}\n\
    }\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpksllh4it_test.go:72: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=0)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpksllh4it_test.go:72:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=0) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpksllh4it_test.go:72: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpksllh4it_test.go:72: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpksllh4it_test.go:72: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=0)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpksllh4it_test.go:72:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=0) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075320
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    carrots\
    \ := 0\n    if number < 0 || number > 1000 {\n        return []int{0, 0}\n   \
    \ }\n    if need < 0 || need > 1000 {\n        return []int{0, 0}\n    }\n   \
    \ if remaining < 0 || remaining > 1000 {\n        return []int{0, 0}\n    }\n\
    \    if number > need {\n        return []int{0, 0}\n    }\n    if number == need\
    \ {\n        return []int{number, 0}\n    }\n    if number < need {\n        carrots\
    \ = number\n    } else {\n        carrots = need\n    }\n    if remaining == 0\
    \ {\n        return []int{carrots, 0}\n    }\n    if carrots == 0 {\n        return\
    \ []int{0, remaining}\n    }\n    if carrots < remaining {\n        return []int{carrots,\
    \ remaining}\n    }\n    carrots = remaining\n    if carrots == 0 {\n        return\
    \ []int{0, 0}\n    }\n    if carrots < need {\n        return []int{carrots, 0}\n\
    \    }\n    carrots = need\n    if carrots == 0 {\n        return []int{0, 0}\n\
    \    }\n    if carrots < remaining {\n        return []int{carrots, remaining}\n\
    \    }\n    carrots = remaining\n    if carrots == 0 {\n        return []int{0,\
    \ 0}\n    }\n    if carrots < need {\n        return []int{carrots, 0}\n    }\n\
    \    carrots = need\n    if carrots == 0 {\n        return []int{0, 0}\n    }\n\
    \    if carrots < remaining {\n        return []int{carrots, remaining}\n    }\n\
    \    carrots = remaining\n    if carrots == 0 {\n        return []int{0, 0}\n\
    \    }\n    if carrots < need {\n        return []int{carrots, 0}\n    }\n   \
    \ carrots = need\n    if carrots == 0 {\n        return []int{0, 0}\n    }\n \
    \   if carrots < remaining {\n        return []int{carrots, remaining}\n    }\n\
    \    carrots = remaining\n    if carrots == 0 {\n        return []int{0, 0}\n\
    \    }\n    if carrots < need {\n        return []int{carrots, 0}\n    }\n   \
    \ carrots = need\n    if carrots == 0 {\n        return []int{0, 0}\n    }\n \
    \   if carrots < remaining {\n        return []int{carrots, remaining}\n    }\n\
    \    carrots = remaining\n    if carrots == 0 {\n        return []int{0, 0}\n\
    \    }\n    if carrots < need {\n        return []int{carrots, 0}\n    }\n   \
    \ carrots = need\n    if carrots == 0 {\n        return []int{0, 0}\n    }\nfunc\
    \ TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp1j9_aomr_test.go:132:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075319
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    carrots := 0\n    carrots += number\n    carrots += need\n  \
    \  carrots += remaining\n    carrots += number\n    carrots += need\n    carrots\
    \ += remaining\n    carrots += number\n    carrots += need\n    carrots += remaining\n\
    \    carrots += number\n    carrots += need\n    carrots += remaining\n    carrots\
    \ += number\n    carrots += need\n    carrots += remaining\n    carrots += number\n\
    \    carrots += need\n    carrots += remaining\n    carrots += number\n    carrots\
    \ += need\n    carrots += remaining\n    carrots += number\n    carrots += need\n\
    \    carrots += remaining\n    carrots += number\n    carrots += need\n    carrots\
    \ += remaining\n    carrots += number\n    carrots += need\n    carrots += remaining\n\
    \    carrots += number\n    carrots += need\n    carrots += remaining\n    carrots\
    \ += number\n    carrots += need\n    carrots += remaining\n    carrots += number\n\
    \    carrots += need\n    carrots += remaining\n    carrots += number\n    carrots\
    \ += need\n    carrots += remaining\n    carrots += number\n    carrots += need\n\
    \    carrots += remaining\n    carrots += number\n    carrots += need\n    carrots\
    \ += remaining\n    carrots += number\n    carrots += need\n    carrots += remaining\n\
    \    carrots += number\n    carrots += need\n    carrots += remaining\n    carrots\
    \ += number\n    carrots += need\n    carrots += remaining\n    carrots += number\n\
    \    carrots += need\n    carrots += remaining\n    carrots += number\n    carrots\
    \ += need\n    carrots += remaining\n    carrots += number\n    carrots += need\n\
    \    carrots += remaining\n    carrots += number\n    carrots += need\n    carrots\
    \ += remaining\n    carrots += number\n    carrots += need\n    carrots += remaining\n\
    \    carrots += number\n    carrots += need\n    carrots += remaining\n    carrots\
    \ += number\n    carrots += need\n    carrots += remaining\n    carrots += number\n\
    \    carrots += need\n    carrot\nfunc TestEat(t *testing.T) {\n  candidate :=\
    \ eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpkiirgt9x_test.go:120:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075320
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    carrots\
    \ := 0\n    carrots += number\n    carrots += need\n    carrots += remaining\n\
    \    if carrots > 1000 {\n        carrots = 1000\n    }\n    if carrots < 0 {\n\
    \        carrots = 0\n    }\n    return []int{carrots, carrots - carrots + need}\n\
    }\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpepy1u573_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=21)\
    \ %!s(int=6)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpepy1u573_test.go:66:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=21) %!s(int=8)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpepy1u573_test.go:66: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=21) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpepy1u573_test.go:66: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=18) %!s(int=11)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmpepy1u573_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=16)\
    \ %!s(int=5)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpepy1u573_test.go:66:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=10) %!s(int=5)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075321
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    meals :=\
    \ 0\n    if remaining > 0 {\n        meals = need\n        carrots = remaining\n\
    \    } else {\n        meals = number\n        carrots = need\n    }\n    result\
    \ := make([]int, 2)\n    result[0] = carrots\n    result[1] = meals\n    return\
    \ result\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpxiu6g8ia_test.go:71: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=6)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpxiu6g8ia_test.go:71:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=8)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpxiu6g8ia_test.go:71: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpxiu6g8ia_test.go:71: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=11)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmpxiu6g8ia_test.go:71: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=5)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpxiu6g8ia_test.go:71:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=5)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075321
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    carrots +=\
    \ number\n    carrots += need\n    carrots += remaining\n    if carrots > 1000\
    \ {\n        carrots = 1000\n    }\n    carrots = carrots - number\n    carrots\
    \ = carrots - need\n    carrots = carrots - remaining\n    if carrots < 0 {\n\
    \        carrots = 0\n    }\n    return []int{carrots, carrots}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp0tgmmn4j_test.go:72: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=0)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp0tgmmn4j_test.go:72:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=0) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp0tgmmn4j_test.go:72: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp0tgmmn4j_test.go:72: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp0tgmmn4j_test.go:72: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=0)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp0tgmmn4j_test.go:72:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=0) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075321
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    var carrots int\n    if number\
    \ > need {\n        carrots = number\n    } else {\n        carrots = need\n \
    \   }\n    var carrotsLeft int\n    if carrots > remaining {\n        carrotsLeft\
    \ = carrots - remaining\n    } else {\n        carrotsLeft = remaining\n    }\n\
    \    var result []int\n    if carrotsLeft > 0 {\n        result = append(result,\
    \ carrotsLeft)\n    }\n    if carrots > 0 {\n        result = append(result, carrots)\n\
    \    }\n    return result\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpe6ip11_u_test.go:78: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=6)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpe6ip11_u_test.go:78:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=8)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpe6ip11_u_test.go:78: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpe6ip11_u_test.go:78: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=6) %!s(int=11)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmpe6ip11_u_test.go:78: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=5)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpe6ip11_u_test.go:78:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=5)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075321
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    carrots := 0\n    carrots += number\n    carrots += need\n  \
    \  carrots += remaining\n    carrots -= number\n    carrots -= need\n    carrots\
    \ -= remaining\n    carrots -= number\n    carrots -= need\n    carrots -= remaining\n\
    \    carrots -= number\n    carrots -= need\n    carrots -= remaining\n    carrots\
    \ -= number\n    carrots -= need\n    carrots -= remaining\n    carrots -= number\n\
    \    carrots -= need\n    carrots -= remaining\n    carrots -= number\n    carrots\
    \ -= need\n    carrots -= remaining\n    carrots -= number\n    carrots -= need\n\
    \    carrots -= remaining\n    carrots -= number\n    carrots -= need\n    carrots\
    \ -= remaining\n    carrots -= number\n    carrots -= need\n    carrots -= remaining\n\
    \    carrots -= number\n    carrots -= need\n    carrots -= remaining\n    carrots\
    \ -= number\n    carrots -= need\n    carrots -= remaining\n    carrots -= number\n\
    \    carrots -= need\n    carrots -= remaining\n    carrots -= number\n    carrots\
    \ -= need\n    carrots -= remaining\n    carrots -= number\n    carrots -= need\n\
    \    carrots -= remaining\n    carrots -= number\n    carrots -= need\n    carrots\
    \ -= remaining\n    carrots -= number\n    carrots -= need\n    carrots -= remaining\n\
    \    carrots -= number\n    carrots -= need\n    carrots -= remaining\n    carrots\
    \ -= number\n    carrots -= need\n    carrots -= remaining\n    carrots -= number\n\
    \    carrots -= need\n    carrots -= remaining\n    carrots -= number\n    carrots\
    \ -= need\n    carrots -= remaining\n    carrots -= number\n    carrots -= need\n\
    \    carrots -= remaining\n    carrots -= number\n    carrots -= need\n    carrots\
    \ -= remaining\n    carrot\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpxi9a1u3m_test.go:109:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075315
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || need < 0 || remaining < 0 {\n        return []int{}\n    }\n \
    \   if number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{}\n\
    \    }\n    carrots := 0\n    carrots += number\n    carrots += need\n    carrots\
    \ += remaining\n    if carrots > 1000 {\n        carrots = 1000\n    }\n    return\
    \ []int{carrots, carrots - carrots - number}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp127gdwvw_test.go:69: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=21)\
    \ %!s(int=-5)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp127gdwvw_test.go:69:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=21) %!s(int=-4)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp127gdwvw_test.go:69: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=21) %!s(int=-1)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp127gdwvw_test.go:69: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=18) %!s(int=-2)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmp127gdwvw_test.go:69: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=16)\
    \ %!s(int=-4)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp127gdwvw_test.go:69:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=10) %!s(int=-4)]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075321
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    carrots\
    \ := 0\n    if number > 1000 || need > 1000 || remaining > 1000 {\n        fmt.Println(\"\
    Invalid input\")\n    }\n    if number == 0 {\n        return nil\n    }\n   \
    \ if need == 0 {\n        return nil\n    }\n    if remaining == 0 {\n       \
    \ return nil\n    }\n    if number > need {\n        fmt.Println(\"Invalid input\"\
    )\n    }\n    if number > remaining {\n        fmt.Println(\"Invalid input\")\n\
    \    }\n    if number == need {\n        return nil\n    }\n    if number > need\
    \ {\n        fmt.Println(\"Invalid input\")\n    }\n    if number > remaining\
    \ {\n        fmt.Println(\"Invalid input\")\n    }\n    if number == remaining\
    \ {\n        return nil\n    }\n    if number > remaining {\n        fmt.Println(\"\
    Invalid input\")\n    }\n    if number == remaining {\n        return nil\n  \
    \  }\n    if number > need {\n        fmt.Println(\"Invalid input\")\n    }\n\
    \    if number == need {\n        return nil\n    }\n    if number > remaining\
    \ {\n        fmt.Println(\"Invalid input\")\n    }\n    if number == remaining\
    \ {\n        return nil\n    }\n    if number > need {\n        fmt.Println(\"\
    Invalid input\")\n    }\n    if number == need {\n        return nil\n    }\n\
    \    if number > remaining {\n        fmt.Println(\"Invalid input\")\n    }\n\
    \    if number == remaining {\n        return nil\n    }\n    if number > need\
    \ {\n        fmt.Println(\"Invalid input\")\n    }\n    if number == need {\n\
    \        return nil\n    }\n    if number > remaining {\n        fmt.Println(\"\
    Invalid input\")\n    }\n    if number == remaining {\n        return nil\n  \
    \  }\n    if number > need {\n        fmt.Println(\"Invalid input\")\n    }\n\
    \    if number == need {\n        return nil\n    }\n    if number > remaining\
    \ {\n        fmt.Println(\"Invalid input\")\n    }\n    if number == remaining\
    \ {\n        return nil\n    }\n    if number > need {\n        fmt.Println(\"\
    Invalid input\")\n    }\n    if number == need {\n        return nil\n    }\n\
    \    if number > remaining {\n        fmt.Println(\"Invalid input\")\n    }\n\
    \    if number == remaining {\n        return nil\n    }\n    if number > need\
    \ {\n        fmt.Println(\"Invalid input\")\n    }\n    if number == need {\n\
    \        return nil\n    }\n    if number > remaining {\n        fmt.Println(\"\
    Invalid input\")\n    }\n    if number == remaining {\n        return nil\n  \
    \  }\n    if number > need {\n        fmt.Println(\"Invalid input\")\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpmojch9gy_test.go:147:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075320
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    carrots =\
    \ number\n    carrots = carrots - need\n    if carrots < 0 {\n        carrots\
    \ = 0\n    }\n    if carrots > remaining {\n        carrots = remaining\n    }\n\
    \    return []int{carrots, remaining}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpsxknw379_test.go:68: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=0)\
    \ %!s(int=10)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpsxknw379_test.go:68:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=0) %!s(int=9)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpsxknw379_test.go:68: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=0) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpsxknw379_test.go:68: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=0) %!s(int=5)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpsxknw379_test.go:68: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=0)\
    \ %!s(int=7)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpsxknw379_test.go:68:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=0) %!s(int=1)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660075321
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || number < 0 || need > 1000 || need < 0 || remaining > 1000 ||\
    \ remaining < 0 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    if\
    \ number > remaining {\n        carrots = number\n    } else {\n        carrots\
    \ = remaining\n    }\n    if carrots == 0 {\n        return []int{0, 0}\n    }\n\
    \    if carrots > need {\n        carrots = need\n    }\n    if carrots < need\
    \ {\n        carrots = need\n    }\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrot\nfunc TestEat(t *testing.T) {\n \
    \ candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected:\
    \ []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n\
    \     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual:\
    \ candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5,\
    \ 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5,\
    \ 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpjzdfiwtb_test.go:99:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075320
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    result := make([]int, 2)\n\
    \    if number == 0 {\n        result[0] = 0\n        result[1] = 0\n        return\
    \ result\n    }\n    if number < need {\n        result[0] = number\n        result[1]\
    \ = need\n        return result\n    }\n    if number > remaining {\n        result[0]\
    \ = number\n        result[1] = remaining\n        return result\n    }\n    carrots\
    \ := 0\n    carrots += number\n    carrots += need\n    carrots += remaining\n\
    \    result[0] = carrots\n    result[1] = number-carrots\n    return result\n\
    }\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpdkfgqbya_test.go:81: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5)\
    \ %!s(int=6)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpdkfgqbya_test.go:81:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=8)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpdkfgqbya_test.go:81: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpdkfgqbya_test.go:81: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=2) %!s(int=11)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmpdkfgqbya_test.go:81: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4)\
    \ %!s(int=5)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpdkfgqbya_test.go:81:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=5)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075321
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    meals :=\
    \ 0\n    if number > need {\n        carrots = number\n        meals = need\n\
    \    } else {\n        carrots = need\n        meals = number\n    }\n    carrots\
    \ -= remaining\n    if carrots < 0 {\n        carrots = 0\n    }\n    meals -=\
    \ carrots\n    if meals < 0 {\n        meals = 0\n    }\n    return []int{meals,\
    \ carrots}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n\
    \     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual:\
    \ candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpx35a1382_test.go:76: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpx35a1382_test.go:76:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpx35a1382_test.go:76: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpx35a1382_test.go:76: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=0) %!s(int=6)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpx35a1382_test.go:76: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpx35a1382_test.go:76:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=0) %!s(int=4)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075321
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || need < 0 || remaining < 0 {\n        return []int{0, 0}\n    }\n\
    \    if number == 0 {\n        return []int{0, 0}\n    }\n    if remaining < need\
    \ {\n        return []int{0, 0}\n    }\n    if number == need {\n        return\
    \ []int{number, 0}\n    }\n    if number > need {\n        return []int{0, number}\n\
    \    }\n    carrots := 0\n    carrots += number\n    carrots += need\n    carrots\
    \ += remaining\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\nfunc\
    \ TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmprltsg3xi_test.go:114:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075320
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    result\
    \ := make([]int, 2)\n    if number > 1000 || need > 1000 || remaining > 1000 {\n\
    \        fmt.Println(\"Invalid input\")\n        return nil\n    }\n    if number\
    \ == 0 {\n        result[0] = remaining\n        result[1] = remaining\n    }\
    \ else {\n        if remaining < need {\n            result[0] = remaining\n \
    \           result[1] = need\n        } else {\n            result[0] = need\n\
    \            result[1] = remaining\n        }\n    }\n    return result\n}\n\n\
    func TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmprrd1u8rb_test.go:73: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=10)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmprrd1u8rb_test.go:73:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=9)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmprrd1u8rb_test.go:73: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmprrd1u8rb_test.go:73: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=11)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmprrd1u8rb_test.go:73: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=5)\
    \ %!s(int=7)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmprrd1u8rb_test.go:73:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=5)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075321
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    carrots\
    \ := 0\n    if number < 0 {\n        return []int{0, 0}\n    }\n    if need <\
    \ 0 {\n        return []int{0, 0}\n    }\n    if remaining < 0 {\n        return\
    \ []int{0, 0}\n    }\n    if number == 0 {\n        return []int{0, 0}\n    }\n\
    \    if number > 1000 {\n        return []int{0, 0}\n    }\n    if need > 1000\
    \ {\n        return []int{0, 0}\n    }\n    if remaining > 1000 {\n        return\
    \ []int{0, 0}\n    }\n    if number > need {\n        return []int{0, 0}\n   \
    \ }\n    if number > remaining {\n        return []int{0, 0}\n    }\n    if number\
    \ == need {\n        return []int{0, 0}\n    }\n    if number == remaining {\n\
    \        return []int{0, 0}\n    }\n    if number > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    if need > 1000 {\n        return []int{0, 0}\n    }\n    if remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    if number > need {\n      \
    \  return []int{0, 0}\n    }\n    if number > remaining {\n        return []int{0,\
    \ 0}\n    }\n    if number == need {\n        return []int{0, 0}\n    }\n    if\
    \ number == remaining {\n        return []int{0, 0}\n    }\n    if number > 1000\
    \ {\n        return []int{0, 0}\n    }\n    if need > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    if remaining > 1000 {\n        return []int{0, 0}\n    }\n  \
    \  if number > need {\n        return []int{0, 0}\n    }\n    if number > remaining\
    \ {\n        return []int{0, 0}\n    }\n    if number == need {\n        return\
    \ []int{0, 0}\n    }\n    if number == remaining {\n        return []int{0, 0}\n\
    \    }\n    if number > 1000 {\n        return []int{0, 0}\n    }\n    if need\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    if remaining > 1000 {\n   \
    \     return []int{0, 0}\n    }\n    if number > need {\n        return []int{0,\
    \ 0}\n    }\n    if number > remaining {\n        return []int{0, 0}\n    }\n\
    \    if number == need {\n        return []int{0, 0}\n    }\n    if number ==\
    \ remaining {\n        return []int{0, 0}\n    }\n    if number > 1000 {\n   \
    \     return []int{0, 0}\n    }\n    if need > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    if remaining > 1000 {\n        return []int{0, 0}\n    }\n  \
    \  if number > need {\n        return []int{0, 0}\n    }\n    if number > remaining\
    \ {\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpqgmy9a7x_test.go:145:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075320
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    if number == 0 && need == 0\
    \ {\n        return []int{0, 0}\n    }\n    if number == 0 && need > 0 {\n   \
    \     return []int{0, 0}\n    }\n    if number > 0 && need == 0 {\n        return\
    \ []int{0, 0}\n    }\n    if number > 0 && need > 0 && remaining > 0 {\n     \
    \   return []int{number, remaining - number}\n    }\n    if number > 0 && need\
    \ > 0 && remaining == 0 {\n        return []int{number, 0}\n    }\n    if number\
    \ > 0 && need > 0 && remaining > 0 && number >= need {\n        return []int{number,\
    \ 0}\n    }\n    if number > 0 && need > 0 && remaining == 0 {\n        return\
    \ []int{number, 0}\n    }\n    if number > 0 && need > 0 && remaining > 0 && number\
    \ < need {\n        return []int{number, 0}\n    }\n    if number > 0 && need\
    \ > 0 && remaining > 0 && number == need {\n        return []int{number, 0}\n\
    \    }\n    if number > 0 && need > 0 && remaining > 0 && number > need {\n  \
    \      return []int{number, 0}\n    }\n    if number > 0 && need > 0 && remaining\
    \ > 0 && number == need {\n        return []int{number, 0}\n    }\n    if number\
    \ > 0 && need > 0 && remaining > 0 && number < need {\n        return []int{number,\
    \ 0}\n    }\n    if number > 0 && need > 0 && remaining > 0 && number > need {\n\
    \        return []int{number, 0}\n    }\n    if number > 0 && need > 0 && remaining\
    \ > 0 && number == need {\n        return []int{number, 0}\n    }\n    if number\
    \ > 0 && need > 0 && remaining > 0 && number < need {\n        return []int{number,\
    \ 0}\n    }\n    if number > 0 && need > 0 && remaining > 0 && number > need {\n\
    \        return []int{number, 0}\n    }\n    if number > 0 && need > 0 && remaining\
    \ > 0 && number == need {\n        return []int{number, 0}\n    }\n    if number\
    \ > 0 && need > 0 && remaining > 0 && number < need {\n        return []int{number,\
    \ 0}\n    }\n    if number > 0 && need > 0 && remaining > 0 && number > need {\n\
    \        return []int{number, 0}\n    }\n    if number > 0 && need > 0 && remaining\
    \ > 0 && number == need {\n        return []int{number, 0}\n    }\n    if number\
    \ > 0 && need > 0 && remaining > 0 && number < need {\n        return []int{number,\
    \ 0}\n    }\n    if number > 0 && need > 0 && remaining > 0 && number > need {\n\
    \        return []int{number, 0}\n    }\n    if number > 0 && need > \nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpwu99iu8g_test.go:105:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075320
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    carrots := 0\n    meals := 0\n    for i := 0; i < number; i++\
    \ {\n        carrots += i\n    }\n    for i := 0; i < need; i++ {\n        carrots\
    \ += i\n    }\n    for i := 0; i < remaining; i++ {\n        carrots += i\n  \
    \  }\n    meals = carrots - need\n    if meals < 0 {\n        meals = 0\n    }\n\
    \    meals = meals / number\n    meals = meals - 1\n    carrots = carrots - meals\n\
    \    if carrots < 0 {\n        carrots = 0\n    }\n    carrots = carrots / number\n\
    \    carrots = carrots - 1\n    return []int{carrots, meals}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp5w0vxmnw_test.go:82: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=11)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp5w0vxmnw_test.go:82:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=13) %!s(int=14)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp5w0vxmnw_test.go:82: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=79)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp5w0vxmnw_test.go:82: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=19) %!s(int=26)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmp5w0vxmnw_test.go:82: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=6)\
    \ %!s(int=7)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp5w0vxmnw_test.go:82:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075321
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    carrots := 0\n    meals := 0\n    if number > need {\n      \
    \  carrots = number\n        meals = need\n    } else {\n        carrots = need\n\
    \        meals = number\n    }\n    if carrots > remaining {\n        carrots\
    \ = remaining\n    }\n    if carrots == 0 {\n        return []int{0, 0}\n    }\n\
    \    carrots -= meals\n    meals -= carrots\n    return []int{carrots, meals}\n\
    }\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpywuub_0n_test.go:76: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=1)\
    \ %!s(int=4)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpywuub_0n_test.go:76:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpywuub_0n_test.go:76: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=9) %!s(int=-8)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpywuub_0n_test.go:76: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=3) %!s(int=-1)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmpywuub_0n_test.go:76: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=1)\
    \ %!s(int=3)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpywuub_0n_test.go:76:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=-3) %!s(int=7)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075322
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    carrots := 0\n    carrots += number\n    carrots += need\n  \
    \  carrots += remaining\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrot\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpdldorth3_test.go:109:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075321
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    result\
    \ := make([]int, 2)\n    if number > 1000 || need > 1000 || remaining > 1000 {\n\
    \        fmt.Println(\"Invalid input\")\n        return nil\n    }\n    if number\
    \ == 0 {\n        result[0] = 0\n        result[1] = 0\n        return result\n\
    \    }\n    if need == 0 {\n        result[0] = 0\n        result[1] = 0\n   \
    \     return result\n    }\n    if remaining == 0 {\n        result[0] = number\n\
    \        result[1] = need\n        return result\n    }\n    if number > need\
    \ {\n        result[0] = number\n        result[1] = need\n        return result\n\
    \    }\n    if number > remaining {\n        result[0] = number\n        result[1]\
    \ = remaining\n        return result\n    }\n    if need > remaining {\n     \
    \   result[0] = need\n        result[1] = remaining\n        return result\n \
    \   }\n    if number == need {\n        result[0] = number\n        result[1]\
    \ = need\n        return result\n    }\n    if number == remaining {\n       \
    \ result[0] = number\n        result[1] = remaining\n        return result\n \
    \   }\n    if need == remaining {\n        result[0] = need\n        result[1]\
    \ = remaining\n        return result\n    }\n    if number > remaining {\n   \
    \     result[0] = number\n        result[1] = remaining\n        return result\n\
    \    }\n    if need > remaining {\n        result[0] = need\n        result[1]\
    \ = remaining\n        return result\n    }\n    if number == need {\n       \
    \ result[0] = number\n        result[1] = need\n        return result\n    }\n\
    \    if number == remaining {\n        result[0] = number\n        result[1] =\
    \ remaining\n        return result\n    }\n    if need == remaining {\n      \
    \  result[0] = need\n        result[1] = remaining\n        return result\n  \
    \  }\n    if number > remaining {\n        result[0] = number\n        result[1]\
    \ = remaining\n        return result\n    }\n    if need > remaining {\n     \
    \   result[0] = need\n        result[1] = remaining\n        return result\n \
    \   }\n    if number == need {\n        result[0] = number\n        result[1]\
    \ = need\n        return result\n    }\n    if number == remaining {\n       \
    \ result[0] = number\n        result[1] = remaining\n        return result\n \
    \   }\n    if need == remaining {\n        result[0] = need\n        result[1]\
    \ = remaining\n        return result\n    }\n    if number > remaining {\n   \
    \     result[0] = number\n        result[1] = remaining\n        return result\n\
    \    }\n    if need > remaining {\n        result[0] = need\n        result[1]\
    \ = remaining\n        return result\n    }\n    if number == need {\n       \
    \ result[0] = number\n        result[1] = need\n        return result\n    }\n\
    \    if number == remaining {\n        result[0] = number\n        result[1] =\
    \ remaining\n        return result\n    }\n    if need == remaining {\n      \
    \  result[0] = need\n        result[1] = remaining\n        return result\n  \
    \  }\n    if number > remaining {\n        result[0] = number\n        result[1]\
    \ = remaining\n        return result\n    }\n    if need > remaining {\n     \
    \   result[0] = need\n        result[1] = remaining\n        return result\n \
    \   }\n    if number == need {\n        result[0] = number\n        result\nfunc\
    \ TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpl5kzis72_test.go:173:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075321
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    if remaining\
    \ > 0 {\n        carrots = remaining\n    }\n    if number > need {\n        carrots\
    \ = number-need\n    }\n    if carrots == 0 {\n        carrots = number\n    }\n\
    \    return []int{carrots, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpu2pzo6py_test.go:69: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpu2pzo6py_test.go:69:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpu2pzo6py_test.go:69: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpu2pzo6py_test.go:69: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpu2pzo6py_test.go:69: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpu2pzo6py_test.go:69:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075322
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    result\
    \ := make([]int, 2)\n    if number > 1000 || need > 1000 || remaining > 1000 {\n\
    \        fmt.Println(\"Invalid input\")\n        return nil\n    }\n    if number\
    \ == 0 {\n        result[0] = 0\n        result[1] = 0\n        return result\n\
    \    }\n    if remaining < need {\n        fmt.Println(\"Not enough carrots to\
    \ complete the day's meals\")\n        return nil\n    }\n    carrots := 0\n \
    \   if number > 0 {\n        carrots = number\n    }\n    if need > 0 {\n    \
    \    carrots = carrots + need\n    }\n    if carrots > remaining {\n        carrots\
    \ = remaining\n    }\n    result[0] = carrots\n    result[1] = carrots - need\n\
    \    return result\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "Not enough carrots to complete the day's meals\nNot enough carrots to complete\
    \ the day's meals\n--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0\
    \ (0.00s)\n        tmpax886rky_test.go:82: expected '[%!s(int=11) %!s(int=4)]',\
    \ got '[%!s(int=10) %!s(int=4)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n\
    \        tmpax886rky_test.go:82: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9)\
    \ %!s(int=1)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpax886rky_test.go:82:\
    \ expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__3 (0.00s)\n        tmpax886rky_test.go:82: expected\
    \ '[%!s(int=7) %!s(int=0)]', got '[]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmpax886rky_test.go:82: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=2)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpax886rky_test.go:82:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075322
- exit_code: 2
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    result := []int{0, 0}\n   \
    \ if number == 0 {\n        return result\n    }\n    if remaining < need {\n\
    \        return result\n    }\n    if number > remaining {\n        return result\n\
    \    }\n    carrots := 0\n    for i := 0; i < number; i++ {\n        carrots +=\
    \ eatCarrots(remaining, need)\n    }\n    result[0] = carrots\n    if carrots\
    \ > 0 {\n        result[1] = number-carrots\n    }\n    return result\n}\n\nfunc\
    \ TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfr54fym2_test.go:50:20: undefined: eatCarrots

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075322
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    carrots := 0\n    carrots += number\n    carrots += need\n  \
    \  carrots += remaining\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrot\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpdldorth3_test.go:109:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075321
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    if number == 0 && need == 0 && remaining == 0 {\n        return\
    \ []int{0, 0}\n    }\n    if number > need {\n        return []int{0, 0}\n   \
    \ }\n    if number < need {\n        return []int{0, 0}\n    }\n    if number\
    \ == need && remaining == 0 {\n        return []int{0, 0}\n    }\n    if number\
    \ == need && remaining > 0 {\n        return []int{0, remaining}\n    }\n    if\
    \ number == need && remaining == 0 {\n        return []int{number, 0}\n    }\n\
    \    if number == need && remaining > 0 {\n        return []int{number, remaining}\n\
    \    }\n    if number == need && remaining == 0 {\n        return []int{number,\
    \ number}\n    }\n    if number == need && remaining > 0 {\n        return []int{number,\
    \ number}\n    }\n    if number == need && remaining == 0 {\n        return []int{number,\
    \ number}\n    }\n    if number == need && remaining > 0 {\n        return []int{number,\
    \ number}\n    }\n    if number == need && remaining == 0 {\n        return []int{number,\
    \ number}\n    }\n    if number == need && remaining > 0 {\n        return []int{number,\
    \ number}\n    }\n    if number == need && remaining == 0 {\n        return []int{number,\
    \ number}\n    }\n    if number == need && remaining > 0 {\n        return []int{number,\
    \ number}\n    }\n    if number == need && remaining == 0 {\n        return []int{number,\
    \ number}\n    }\n    if number == need && remaining > 0 {\n        return []int{number,\
    \ number}\n    }\n    if number == need && remaining == 0 {\n        return []int{number,\
    \ number}\n    }\n    if number == need && remaining > 0 {\n        return []int{number,\
    \ number}\n    }\n    if number == need && remaining == 0 {\n        return []int{number,\
    \ number}\n    }\n    if number == need && remaining > 0 {\n        return []int{number,\
    \ number}\n    }\n    if number == need && remaining == 0 {\n        return []int{number,\
    \ number}\n    }\n    if number == need && remaining > 0 {\n        return []int{number,\
    \ number}\n    }\n    if number == need && remaining == 0 {\n        return []int{number,\
    \ number}\n    }\n    if number == need && remaining > 0 {\n        return []int{number,\
    \ number}\n    }\n    if number == need && remaining == 0 {\n        return []int{number,\
    \ number}\n    }\n    if number == need && remaining > 0 {\n        return []int{number,\
    \ number}\n    }\n    if number == need && remaining == 0 {\n        return []int{number,\
    \ number}\n    }\n    if number == need && remaining > 0 {\n        return []int{number,\
    \ number}\n    }\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n\
    \     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual:\
    \ candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpl0qy47af_test.go:125:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075321
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    carrots\
    \ := 0\n    carrots = number\n    carrots = carrots - need\n    carrots = carrots\
    \ - remaining\n    if carrots < 0 {\n        carrots = 0\n    }\n    return []int{carrots,\
    \ remaining}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n\
    \     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual:\
    \ candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmphs5jdrdn_test.go:63: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=0)\
    \ %!s(int=10)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmphs5jdrdn_test.go:63:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=0) %!s(int=9)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmphs5jdrdn_test.go:63: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=0) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmphs5jdrdn_test.go:63: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=0) %!s(int=5)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmphs5jdrdn_test.go:63: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=0)\
    \ %!s(int=7)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmphs5jdrdn_test.go:63:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=0) %!s(int=1)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075322
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    if number == 0 && need == 0 && remaining == 0 {\n        return\
    \ []int{0, 0}\n    }\n    carrots := 0\n    carrots += number\n    carrots +=\
    \ need\n    carrots += remaining\n    carrots %= 1000\n    carrots %= 1000\n \
    \   carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= \nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphetekf2q_test.go:109:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075321
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || number < 0 {\n        return []int{0, 0}\n    }\n    if need\
    \ > 1000 || need < 0 {\n        return []int{0, 0}\n    }\n    if remaining >\
    \ 1000 || remaining < 0 {\n        return []int{0, 0}\n    }\n    if number ==\
    \ 0 {\n        return []int{0, 0}\n    }\n    if need == 0 {\n        return []int{0,\
    \ number}\n    }\n    if remaining == 0 {\n        return []int{number, 0}\n \
    \   }\n    if number > need {\n        return []int{0, 0}\n    }\n    if number\
    \ == need {\n        return []int{number, 0}\n    }\n    if number > remaining\
    \ {\n        return []int{0, number}\n    }\n    if number == remaining {\n  \
    \      return []int{number, 0}\n    }\n    if number > need {\n        return\
    \ []int{0, 0}\n    }\n    if number == need {\n        return []int{number, 0}\n\
    \    }\n    if number > remaining {\n        return []int{0, number}\n    }\n\
    \    if number == remaining {\n        return []int{number, 0}\n    }\n    if\
    \ number > need {\n        return []int{0, 0}\n    }\n    if number == need {\n\
    \        return []int{number, 0}\n    }\n    if number > remaining {\n       \
    \ return []int{0, number}\n    }\n    if number == remaining {\n        return\
    \ []int{number, 0}\n    }\n    if number > need {\n        return []int{0, 0}\n\
    \    }\n    if number == need {\n        return []int{number, 0}\n    }\n    if\
    \ number > remaining {\n        return []int{0, number}\n    }\n    if number\
    \ == remaining {\n        return []int{number, 0}\n    }\n    if number > need\
    \ {\n        return []int{0, 0}\n    }\n    if number == need {\n        return\
    \ []int{number, 0}\n    }\n    if number > remaining {\n        return []int{0,\
    \ number}\n    }\n    if number == remaining {\n        return []int{number, 0}\n\
    \    }\n    if number > need {\n        return []int{0, 0}\n    }\n    if number\
    \ == need {\n        return []int{number, 0}\n    }\n    if number > remaining\
    \ {\n        return []int{0, number}\n    }\n    if number == remaining {\n  \
    \      return []int{number, 0}\n    }\n    if number > need {\n        return\
    \ []int{0, 0}\n    }\n    if number == need {\n        return []int{number, 0}\n\
    \    }\n    if number > remaining {\n        return []int{0, number}\n    }\n\
    \    if number == remaining {\n        return []int{number, 0}\n    }\n    if\
    \ number > need {\n        return []int{0, 0}\n    }\n    if number == need {\n\
    \        return []int{number, 0}\n    }\n    if number \nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpz1ruzbc1_test.go:144:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075321
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    carrots := 0\n    if number > remaining {\n        carrots =\
    \ number\n    } else {\n        carrots = remaining\n    }\n    carrots = carrots\
    \ + need\n    carrots = carrots - 1\n    carrots = carrots + 1\n    carrots =\
    \ carrots - 1\n    carrots = carrots + 1\n    carrots = carrots - 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots - 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots - 1\n    carrots = carrots + 1\n    carrots = carrots - 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots - 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots - 1\n    carrots = carrots + 1\n    carrots = carrots - 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots - 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots - 1\n    carrots = carrots + 1\n    carrots = carrots - 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots - 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots - 1\n    carrots = carrots + 1\n    carrots = carrots - 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots - 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots - 1\n    carrots = carrots + 1\n    carrots = carrots - 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots - 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots - 1\n    carrots = carrots + 1\n    carrots = carrots - 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots - 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots - 1\n    carrots = carrots + 1\n    carrots = carrots - 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots - 1\n    carrots = carrots + 1\n    car\n\
    func TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp9366klyj_test.go:96:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075321
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    carrots := 0\n    meals := 0\n    for carrots < number {\n  \
    \      if meals >= need {\n            meals = 0\n            carrots += remaining\n\
    \        }\n        meals++\n    }\n    return []int{carrots, meals}\n}\n\nfunc\
    \ TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpeokk33wp_test.go:68: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=1)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpeokk33wp_test.go:68:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=1)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpeokk33wp_test.go:68: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpeokk33wp_test.go:68: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpeokk33wp_test.go:68: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=1)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpeokk33wp_test.go:68:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=1)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075322
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    //\
    \ write your code here\n    result := make([]int, 2)\n    if number < 0 || number\
    \ > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining > 1000 {\n \
    \       fmt.Println(\"Invalid input\")\n        return nil\n    }\n    if number\
    \ == 0 {\n        result[0] = remaining\n        result[1] = need\n        return\
    \ result\n    }\n    if need == 0 {\n        result[0] = number\n        result[1]\
    \ = remaining\n        return result\n    }\n    if remaining == 0 {\n       \
    \ result[0] = number\n        result[1] = need\n        return result\n    }\n\
    \    if number > need {\n        result[0] = number\n        result[1] = need\n\
    \        return result\n    }\n    if number > remaining {\n        result[0]\
    \ = remaining\n        result[1] = number\n        return result\n    }\n    if\
    \ need > remaining {\n        result[0] = need\n        result[1] = remaining\n\
    \        return result\n    }\n    if number == need {\n        result[0] = number\n\
    \        result[1] = remaining\n        return result\n    }\n    if number ==\
    \ remaining {\n        result[0] = number\n        result[1] = need\n        return\
    \ result\n    }\n    if need == remaining {\n        result[0] = need\n      \
    \  result[1] = number\n        return result\n    }\n    if number > need && number\
    \ > remaining {\n        result[0] = number\n        result[1] = need\n      \
    \  return result\n    }\n    if need > number && need > remaining {\n        result[0]\
    \ = need\n        result[1] = number\n        return result\n    }\n    if remaining\
    \ > number && remaining > need {\n        result[0] = remaining\n        result[1]\
    \ = number\n        return result\n    }\n    if number > need && need > remaining\
    \ {\n        result[0] = number\n        result[1] = need\n        return result\n\
    \    }\n    if need > number && need > remaining {\n        result[0] = need\n\
    \        result[1] = number\n        return result\n    }\n    if remaining >\
    \ number && remaining > need {\n        result[0] = remaining\n        result[1]\
    \ = number\n        return result\n    }\n    if number > need && need > remaining\
    \ {\n        result[0] = number\n        result[1] = need\n        return result\n\
    \    }\n    if need > number && need > remaining {\n        result[0] = need\n\
    \        result[1] = number\n        return result\n    }\n    if remaining >\
    \ number && remaining > need {\n        result[0] = remaining\n        result[1]\
    \ = number\n        return result\n    }\n    if number > need && need > remaining\
    \ {\n        result[0] = number\n        result[1] = need\n        return result\n\
    \    }\n    if need > number && need > remaining {\n        result[0] = need\n\
    \        result[1] = number\n        return result\n    }\n    if remaining >\
    \ number && remaining > need {\n        result[0] = remaining\n        result[1]\
    \ = number\n        return result\n    }\n    if number > need && need > remaining\
    \ {\n        result[0] = number\n        result[1] = need\n        return result\n\
    \    }\n    if need > number && need > remaining {\n        result[0] = need\n\
    \        result[1] = number\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp4s8j73xb_test.go:154:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075321
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 {\n        return []int{0, 0}\n    }\n    if need\
    \ < 0 || need > 1000 {\n        return []int{0, 0}\n    }\n    if remaining <\
    \ 0 || remaining > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n\
    \    meals := 0\n    carrots = number\n    meals = need\n    carrots = carrots\
    \ - meals\n    if carrots < 0 {\n        carrots = 0\n    }\n    carrots = carrots\
    \ + remaining\n    if carrots < 0 {\n        carrots = 0\n    }\n    carrots =\
    \ carrots + meals\n    if carrots < 0 {\n        carrots = 0\n    }\n    carrots\
    \ = carrots + meals\n    if carrots < 0 {\n        carrots = 0\n    }\n    carrots\
    \ = carrots + meals\n    if carrots < 0 {\n        carrots = 0\n    }\n    carrots\
    \ = carrots + meals\n    if carrots < 0 {\n        carrots = 0\n    }\n    carrots\
    \ = carrots + meals\n    if carrots < 0 {\n        carrots = 0\n    }\n    carrots\
    \ = carrots + meals\n    if carrots < 0 {\n        carrots = 0\n    }\n    carrots\
    \ = carrots + meals\n    if carrots < 0 {\n        carrots = 0\n    }\n    carrots\
    \ = carrots + meals\n    if carrots < 0 {\n        carrots = 0\n    }\n    carrots\
    \ = carrots + meals\n    if carrots < 0 {\n        carrots = 0\n    }\n    carrots\
    \ = carrots + meals\n    if carrots < 0 {\n        carrots = 0\n    }\n    carrots\
    \ = carrots + meals\n    if carrots < 0 {\n        carrots = 0\n    }\n    carrots\
    \ = carrots + meals\n    if carrots < 0 {\n        carrots = 0\n    }\n    carrots\
    \ = carrots + meals\n    if carrots < 0 {\n        carrots = 0\n    }\n    carrots\
    \ = carrots + meals\n    if carrots < 0 {\n        carrots = 0\n    }\n    carrots\
    \ = carrots + meals\n    if carrots < 0 {\n        carrots = 0\n    }\n    carrots\
    \ = carrots + meals\n    if carrots < 0 {\n        carrots = 0\n    }\n    carrots\
    \ = carrots + meals\n    if carrots < 0 {\n        carrots = 0\n    }\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpn4wmdfp5_test.go:124:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075322
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    carrots\
    \ := 0\n    carrots += number\n    if carrots > remaining {\n        carrots =\
    \ remaining\n    }\n    carrots += need\n    if carrots > remaining {\n      \
    \  carrots = remaining\n    }\n    return []int{carrots, remaining}\n}\n\nfunc\
    \ TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp383hpa7t_test.go:65: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=10)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp383hpa7t_test.go:65:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=9)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp383hpa7t_test.go:65: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp383hpa7t_test.go:65: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=5)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp383hpa7t_test.go:65: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=7)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp383hpa7t_test.go:65:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=1)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075323
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    carrots := 0\n    carrots += number\n    carrots += need\n  \
    \  carrots += remaining\n    if carrots > 1000 {\n        carrots = 1000\n   \
    \ }\n    carrots -= number\n    carrots -= need\n    carrots -= remaining\n  \
    \  if carrots < 0 {\n        carrots = 0\n    }\n    carrots -= number\n    carrots\
    \ -= need\n    carrots -= remaining\n    if carrots < 0 {\n        carrots = 0\n\
    \    }\n    carrots -= number\n    carrots -= need\n    carrots -= remaining\n\
    \    if carrots < 0 {\n        carrots = 0\n    }\n    carrots -= number\n   \
    \ carrots -= need\n    carrots -= remaining\n    if carrots < 0 {\n        carrots\
    \ = 0\n    }\n    carrots -= number\n    carrots -= need\n    carrots -= remaining\n\
    \    if carrots < 0 {\n        carrots = 0\n    }\n    carrots -= number\n   \
    \ carrots -= need\n    carrots -= remaining\n    if carrots < 0 {\n        carrots\
    \ = 0\n    }\n    carrots -= number\n    carrots -= need\n    carrots -= remaining\n\
    \    if carrots < 0 {\n        carrots = 0\n    }\n    carrots -= number\n   \
    \ carrots -= need\n    carrots -= remaining\n    if carrots < 0 {\n        carrots\
    \ = 0\n    }\n    carrots -= number\n    carrots -= need\n    carrots -= remaining\n\
    \    if carrots < 0 {\n        carrots = 0\n    }\n    carrots -= number\n   \
    \ carrots -= need\n    carrots -= remaining\n    if carrots < 0 {\n        carrots\
    \ = 0\n    }\n    carrots -= number\n    carrots -= need\n    carrots -= remaining\n\
    \    if carrots < 0 {\n        carrots = 0\n    }\n    carrots -= number\n   \
    \ carrots -= need\n    carrots -= remaining\n    if carrots < 0 {\n        carrots\
    \ = 0\n    }\n    carrots -= number\n    carrots -= need\n    carrots -= remaining\n\
    \    if carrots < 0 {\n        carrots = 0\n    }\n    carrots -= number\n   \
    \ \nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpoc_4a8px_test.go:125:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075322
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    if number\
    \ > need {\n        carrots = number-need\n    } else {\n        carrots = need\n\
    \    }\n    if carrots > remaining {\n        carrots = remaining\n    }\n   \
    \ carrots = carrots + number\n    return []int{carrots, remaining}\n}\n\nfunc\
    \ TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmphn4nnotq_test.go:69: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=11)\
    \ %!s(int=10)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmphn4nnotq_test.go:69:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=12) %!s(int=9)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmphn4nnotq_test.go:69: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=11) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmphn4nnotq_test.go:69: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=7) %!s(int=5)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmphn4nnotq_test.go:69: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=9)\
    \ %!s(int=7)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmphn4nnotq_test.go:69:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=5) %!s(int=1)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075323
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    //\
    \ write your code here\n    carrots := 0\n    carrots += number\n    carrots +=\
    \ need\n    carrots += remaining\n    if carrots > 1000 {\n        carrots = 1000\n\
    \    }\n    if carrots < 0 {\n        carrots = 0\n    }\n    carrots = carrots\
    \ / 2\n    carrots = carrots * 2\n    carrots = carrots + 1\n    carrots = carrots\
    \ / 2\n    carrots = carrots * 2\n    carrots = carrots + 1\n    carrots = carrots\
    \ / 2\n    carrots = carrots * 2\n    carrots = carrots + 1\n    carrots = carrots\
    \ / 2\n    carrots = carrots * 2\n    carrots = carrots + 1\n    carrots = carrots\
    \ / 2\n    carrots = carrots * 2\n    carrots = carrots + 1\n    carrots = carrots\
    \ / 2\n    carrots = carrots * 2\n    carrots = carrots + 1\n    carrots = carrots\
    \ / 2\n    carrots = carrots * 2\n    carrots = carrots + 1\n    carrots = carrots\
    \ / 2\n    carrots = carrots * 2\n    carrots = carrots + 1\n    carrots = carrots\
    \ / 2\n    carrots = carrots * 2\n    carrots = carrots + 1\n    carrots = carrots\
    \ / 2\n    carrots = carrots * 2\n    carrots = carrots + 1\n    carrots = carrots\
    \ / 2\n    carrots = carrots * 2\n    carrots = carrots + 1\n    carrots = carrots\
    \ / 2\n    carrots = carrots * 2\n    carrots = carrots + 1\n    carrots = carrots\
    \ / 2\n    carrots = carrots * 2\n    carrots = carrots + 1\n    carrots = carrots\
    \ / 2\n    carrots = carrots * 2\n    carrots = carrots + 1\n    carrots = carrots\
    \ / 2\n    carrots = carrots * 2\n    carrots = carrots + 1\n    carrots = carrots\
    \ / 2\n    carrots = carrots * 2\n    carrots = carrots + 1\n    carrots = carrots\
    \ / 2\n    carrots = carrots * 2\n    carrots = \nfunc TestEat(t *testing.T) {\n\
    \  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected:\
    \ []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n\
    \     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual:\
    \ candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5,\
    \ 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5,\
    \ 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpu9mtg0mx_test.go:97:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075322
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    //\
    \ Your code here\n    carrots := 0\n    carrots += number\n    carrots += need\n\
    \    carrots -= remaining\n    if carrots < 0 {\n        carrots = 0\n    }\n\
    \    return []int{carrots, carrots - number}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpjctfejh4_test.go:64: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=1)\
    \ %!s(int=-4)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpjctfejh4_test.go:64:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=3) %!s(int=-1)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpjctfejh4_test.go:64: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpjctfejh4_test.go:64: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=8) %!s(int=6)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpjctfejh4_test.go:64: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=2)\
    \ %!s(int=-2)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpjctfejh4_test.go:64:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=8) %!s(int=4)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075323
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    carrots +=\
    \ number\n    carrots += need\n    carrots += remaining\n    if carrots > 1000\
    \ {\n        carrots = 1000\n    }\n    if carrots < 0 {\n        carrots = 0\n\
    \    }\n    return []int{carrots, carrots - carrots + need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp66wmgfxz_test.go:69: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=21)\
    \ %!s(int=6)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp66wmgfxz_test.go:69:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=21) %!s(int=8)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp66wmgfxz_test.go:69: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=21) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp66wmgfxz_test.go:69: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=18) %!s(int=11)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmp66wmgfxz_test.go:69: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=16)\
    \ %!s(int=5)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp66wmgfxz_test.go:69:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=10) %!s(int=5)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075323
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    //\
    \ Your code here\n    carrots := 0\n    carrots = number - need\n    if carrots\
    \ < 0 {\n        carrots = 0\n    }\n    if carrots > remaining {\n        carrots\
    \ = remaining\n    }\n    return []int{carrots, remaining}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1ix_ed7t_test.go:65: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=0)\
    \ %!s(int=10)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1ix_ed7t_test.go:65:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=0) %!s(int=9)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1ix_ed7t_test.go:65: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=0) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp1ix_ed7t_test.go:65: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=0) %!s(int=5)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp1ix_ed7t_test.go:65: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=0)\
    \ %!s(int=7)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp1ix_ed7t_test.go:65:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=0) %!s(int=1)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075323
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    //\
    \ Your code here\n    carrots := 0\n    carrots += number\n    carrots += need\n\
    \    carrots += remaining\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphl7tgbh4_test.go:109:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075322
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || need < 0 || remaining < 0 {\n        return []int{0, 0}\n    }\n\
    \    carrots := 0\n    if number > remaining {\n        carrots = number\n   \
    \ } else {\n        carrots = remaining\n    }\n    if carrots > need {\n    \
    \    carrots = need\n    }\n    carrots = carrots + number\n    carrots = carrots\
    \ - need\n    carrots = carrots + number\n    carrots = carrots - need\n    carrots\
    \ = carrots + number\n    carrots = carrots - need\n    carrots = carrots + number\n\
    \    carrots = carrots - need\n    carrots = carrots + number\n    carrots = carrots\
    \ - need\n    carrots = carrots + number\n    carrots = carrots - need\n    carrots\
    \ = carrots + number\n    carrots = carrots - need\n    carrots = carrots + number\n\
    \    carrots = carrots - need\n    carrots = carrots + number\n    carrots = carrots\
    \ - need\n    carrots = carrots + number\n    carrots = carrots - need\n    carrots\
    \ = carrots + number\n    carrots = carrots - need\n    carrots = carrots + number\n\
    \    carrots = carrots - need\n    carrots = carrots + number\n    carrots = carrots\
    \ - need\n    carrots = carrots + number\n    carrots = carrots - need\n    carrots\
    \ = carrots + number\n    carrots = carrots - need\n    carrots = carrots + number\n\
    \    carrots = carrots - need\n    carrots = carrots + number\n    carrots = carrots\
    \ - need\n    carrots = carrots + number\n    carrots = carrots - need\n    carrots\
    \ = carrots + number\n    carrots = carrots - need\n    carrots = carrots + number\n\
    \    carrots = carrots - need\n    carrots = carrots + number\n    carrots = carrots\
    \ - need\n    carrots = carrots + number\n    carrots = carrots - need\n    carrots\
    \ = carrots + number\n    carrots = carrots - need\n    carrots = carrots + number\n\
    \    carrots = carrots - need\n    carrots = carrots + number\n    carrots = carrots\
    \ - need\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpbbcvfr7z_test.go:97:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075322
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    if number == 0 {\n        return []int{need, remaining}\n   \
    \ }\n    if need == 0 {\n        return []int{number, remaining}\n    }\n    if\
    \ remaining == 0 {\n        return []int{number, 0}\n    }\n    if number > need\
    \ {\n        return []int{0, 0}\n    }\n    if number == need {\n        return\
    \ []int{number, 0}\n    }\n    if number == remaining {\n        return []int{number,\
    \ 0}\n    }\n    if number > remaining {\n        return []int{0, 0}\n    }\n\
    \    if number == remaining {\n        return []int{number, 0}\n    }\n    if\
    \ number > need {\n        return []int{0, 0}\n    }\n    if number == need {\n\
    \        return []int{number, 0}\n    }\n    if number == remaining {\n      \
    \  return []int{number, 0}\n    }\n    if number > remaining {\n        return\
    \ []int{0, 0}\n    }\n    if number == remaining {\n        return []int{number,\
    \ 0}\n    }\n    if number > need {\n        return []int{0, 0}\n    }\n    if\
    \ number == need {\n        return []int{number, 0}\n    }\n    if number == remaining\
    \ {\n        return []int{number, 0}\n    }\n    if number > remaining {\n   \
    \     return []int{0, 0}\n    }\n    if number == remaining {\n        return\
    \ []int{number, 0}\n    }\n    if number > need {\n        return []int{0, 0}\n\
    \    }\n    if number == need {\n        return []int{number, 0}\n    }\n    if\
    \ number == remaining {\n        return []int{number, 0}\n    }\n    if number\
    \ > remaining {\n        return []int{0, 0}\n    }\n    if number == remaining\
    \ {\n        return []int{number, 0}\n    }\n    if number > need {\n        return\
    \ []int{0, 0}\n    }\n    if number == need {\n        return []int{number, 0}\n\
    \    }\n    if number == remaining {\n        return []int{number, 0}\n    }\n\
    \    if number > remaining {\n        return []int{0, 0}\n    }\n    if number\
    \ == remaining {\n        return []int{number, 0}\n    }\n    if number > need\
    \ {\n        return []int{0, 0}\n    }\n    if number == need {\n        return\
    \ []int{number, 0}\n    }\n    if number == remaining {\n        return []int{number,\
    \ 0}\n    }\n    if number > remaining {\n        return []int{0, 0}\n    }\n\
    \    if number == remaining {\n        return []int{number, 0}\n    }\n    if\
    \ number > need {\n        return []int{0, 0}\n    }\n    if number == need {\n\
    \        return []int{number, 0}\n    }\nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmprzf4y9ny_test.go:143:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075322
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    if number == 0 && need == 0 && remaining == 0 {\n        return\
    \ []int{0, 0}\n    }\n    if number == 0 {\n        return []int{need, remaining}\n\
    \    }\n    if need == 0 {\n        return []int{number, remaining}\n    }\n \
    \   if remaining == 0 {\n        return []int{number, need}\n    }\n    if number\
    \ > need {\n        return []int{number, need}\n    }\n    if number > remaining\
    \ {\n        return []int{number, remaining}\n    }\n    if need > remaining {\n\
    \        return []int{need, remaining}\n    }\n    if number == need && need ==\
    \ remaining {\n        return []int{number, 0}\n    }\n    if number == need &&\
    \ need > remaining {\n        return []int{number, need}\n    }\n    if number\
    \ == remaining && remaining == need {\n        return []int{number, 0}\n    }\n\
    \    if number == remaining && remaining > need {\n        return []int{number,\
    \ need}\n    }\n    if number == need && need == remaining {\n        return []int{number,\
    \ 0}\n    }\n    if number == need && need > remaining {\n        return []int{number,\
    \ need}\n    }\n    if number == remaining && remaining == need {\n        return\
    \ []int{number, 0}\n    }\n    if number == remaining && remaining > need {\n\
    \        return []int{number, need}\n    }\n    if number == need && need == remaining\
    \ {\n        return []int{number, 0}\n    }\n    if number == need && need > remaining\
    \ {\n        return []int{number, need}\n    }\n    if number == remaining &&\
    \ remaining == need {\n        return []int{number, 0}\n    }\n    if number ==\
    \ remaining && remaining > need {\n        return []int{number, need}\n    }\n\
    \    if number == need && need == remaining {\n        return []int{number, 0}\n\
    \    }\n    if number == need && need > remaining {\n        return []int{number,\
    \ need}\n    }\n    if number == remaining && remaining == need {\n        return\
    \ []int{number, 0}\n    }\n    if number == remaining && remaining > need {\n\
    \        return []int{number, need}\n    }\n    if number == need && need == remaining\
    \ {\n        return []int{number, 0}\n    }\n    if number == need && need > remaining\
    \ {\n        return []int{number, need}\n    }\n    if number == remaining &&\
    \ remaining == need {\n        return []int{number, 0}\n    }\n    if number ==\
    \ remaining && remaining > need {\n        return []int{number, need}\n    }\n\
    \    if number == need && need == remaining {\n\nfunc TestEat(t *testing.T) {\n\
    \  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected:\
    \ []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n\
    \     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual:\
    \ candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5,\
    \ 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5,\
    \ 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpep9fj9x1_test.go:121:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075322
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    carrots\
    \ := 0\n    carrots += number\n    carrots += need\n    carrots += remaining\n\
    \    if carrots > 1000 {\n        carrots = 1000\n    }\n    if carrots < 0 {\n\
    \        carrots = 0\n    }\n    return []int{carrots, carrots - carrots + need}\n\
    }\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpepy1u573_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=21)\
    \ %!s(int=6)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpepy1u573_test.go:66:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=21) %!s(int=8)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpepy1u573_test.go:66: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=21) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpepy1u573_test.go:66: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=18) %!s(int=11)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmpepy1u573_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=16)\
    \ %!s(int=5)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpepy1u573_test.go:66:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=10) %!s(int=5)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075321
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    carrots\
    \ := 0\n    if number < 0 || number > 1000 {\n        return nil\n    }\n    if\
    \ need < 0 || need > 1000 {\n        return nil\n    }\n    if remaining < 0 ||\
    \ remaining > 1000 {\n        return nil\n    }\n    if number == 0 {\n      \
    \  return []int{0, 0}\n    }\n    if need == 0 {\n        return []int{number,\
    \ 0}\n    }\n    if remaining == 0 {\n        return []int{number, 0}\n    }\n\
    \    if number > need {\n        return []int{0, 0}\n    }\n    if number > remaining\
    \ {\n        return []int{number, 0}\n    }\n    if need > remaining {\n     \
    \   return []int{0, 0}\n    }\n    if number > 0 {\n        carrots = number\n\
    \    }\n    if need > 0 {\n        carrots = need\n    }\n    if remaining > 0\
    \ {\n        carrots = remaining\n    }\n    if carrots == 0 {\n        return\
    \ []int{0, 0}\n    }\n    if carrots == number {\n        return []int{number,\
    \ 0}\n    }\n    if carrots == need {\n        return []int{number, 0}\n    }\n\
    \    if carrots == remaining {\n        return []int{number, 0}\n    }\n    if\
    \ carrots > number {\n        return []int{0, 0}\n    }\n    if carrots > need\
    \ {\n        return []int{0, 0}\n    }\n    if carrots > remaining {\n       \
    \ return []int{0, 0}\n    }\n    if carrots > 0 {\n        carrots = number\n\
    \    }\n    if carrots > need {\n        carrots = need\n    }\n    if carrots\
    \ > remaining {\n        carrots = remaining\n    }\n    if carrots == 0 {\n \
    \       return []int{0, 0}\n    }\n    if carrots == number {\n        return\
    \ []int{number, 0}\n    }\n    if carrots == need {\n        return []int{number,\
    \ 0}\n    }\n    if carrots == remaining {\n        return []int{number, 0}\n\
    \    }\n    if carrots > number {\n        return []int{0, 0}\n    }\n    if carrots\
    \ > need {\n        return []int{0, 0}\n    }\n    if carrots > remaining {\n\
    \        return []int{0, 0}\n    }\n    if carrots > 0 {\n        carrots = number\n\
    \    }\n    if carrots > need {\n        carrots = need\n    }\n    if carrots\
    \ > remaining {\n        carrots = remaining\n    }\n    if carrots == 0 {\n \
    \       return []int{0, 0}\n    }\n    if carrots == number {\n        return\
    \ []int{number, 0}\n    }\n    if carrots == need {\n        return []int{number,\
    \ 0}\n    }\n    if carrot\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp2w2oj_io_test.go:142:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075322
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    carrots +=\
    \ number\n    if carrots > need {\n        carrots = need\n    }\n    if carrots\
    \ < remaining {\n        carrots = remaining\n    }\n    return []int{carrots,\
    \ carrots - number}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp0milgcul_test.go:67: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=5)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp0milgcul_test.go:67:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp0milgcul_test.go:67: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp0milgcul_test.go:67: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=3)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp0milgcul_test.go:67: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=3)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp0milgcul_test.go:67:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075323
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || number < 0 {\n        return []int{0, 0}\n    }\n    if need\
    \ > 1000 || need < 0 {\n        return []int{0, 0}\n    }\n    if remaining >\
    \ 1000 || remaining < 0 {\n        return []int{0, 0}\n    }\n    carrots := 0\n\
    \    if number > remaining {\n        carrots = number - remaining\n    } else\
    \ {\n        carrots = remaining\n    }\n    if carrots > need {\n        carrots\
    \ = need\n    }\n    if carrots == 0 {\n        return []int{0, 0}\n    }\n  \
    \  carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n\
    \    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots +\
    \ 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = car\n\
    func TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpevxnfbz9_test.go:101:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075322
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    carrots +=\
    \ number\n    carrots += need\n    carrots += remaining\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    \nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpfr04oftk_test.go:108:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075319
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{}\n    }\n    carrots := 0\n    carrots = number\n\
    \    carrots = carrots - need\n    if carrots < 0 {\n        carrots = 0\n   \
    \ }\n    carrots = carrots + remaining\n    if carrots > 1000 {\n        carrots\
    \ = 1000\n    }\n    return []int{carrots, remaining}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpu9mx8xfz_test.go:69: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=10)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpu9mx8xfz_test.go:69:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=9)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpu9mx8xfz_test.go:69: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpu9mx8xfz_test.go:69: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=5)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpu9mx8xfz_test.go:69: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=7)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpu9mx8xfz_test.go:69:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=1)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075324
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    carrots := 0\n    if number > remaining {\n        carrots =\
    \ number\n    } else {\n        carrots = remaining\n    }\n    if carrots ==\
    \ 0 {\n        return []int{0, 0}\n    }\n    if carrots > need {\n        carrots\
    \ = need\n    }\n    if carrots == need {\n        return []int{carrots, 0}\n\
    \    }\n    if carrots > remaining {\n        carrots = remaining\n    }\n   \
    \ if carrots == remaining {\n        return []int{carrots, 0}\n    }\n    if carrots\
    \ > need {\n        carrots = need\n    }\n    if carrots == need {\n        return\
    \ []int{carrots, 0}\n    }\n    if carrots > remaining {\n        carrots = remaining\n\
    \    }\n    if carrots == remaining {\n        return []int{carrots, 0}\n    }\n\
    \    if carrots > need {\n        carrots = need\n    }\n    if carrots == need\
    \ {\n        return []int{carrots, 0}\n    }\n    if carrots > remaining {\n \
    \       carrots = remaining\n    }\n    if carrots == remaining {\n        return\
    \ []int{carrots, 0}\n    }\n    if carrots > need {\n        carrots = need\n\
    \    }\n    if carrots == need {\n        return []int{carrots, 0}\n    }\n  \
    \  if carrots > remaining {\n        carrots = remaining\n    }\n    if carrots\
    \ == remaining {\n        return []int{carrots, 0}\n    }\n    if carrots > need\
    \ {\n        carrots = need\n    }\n    if carrots == need {\n        return []int{carrots,\
    \ 0}\n    }\n    if carrots > remaining {\n        carrots = remaining\n    }\n\
    \    if carrots == remaining {\n        return []int{carrots, 0}\n    }\n    if\
    \ carrots > need {\n        carrots = need\n    }\n    if carrots == need {\n\
    \        return []int{carrots, 0}\n    }\n    if carrots > remaining {\n     \
    \   carrots = remaining\n    }\n    if carrots == remaining {\n        return\
    \ []int{carrots, 0}\n    }\n    if carrots > need {\n        carrots = need\n\
    \    }\n    if carrots == need {\n        return []int{carrots, 0}\n    }\n  \
    \  if carrots > remaining {\n        carrots = remaining\n    }\n    if carrots\
    \ == remaining {\n        return []int{carrots, 0}\n    }\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphx0k93am_test.go:131:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075323
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    if number == 0 && need == 0 && remaining == 0 {\n        return\
    \ []int{0, 0}\n    }\n    if number > need {\n        return []int{0, 0}\n   \
    \ }\n    if number == need && remaining == 0 {\n        return []int{0, 0}\n \
    \   }\n    if number == 0 && need > remaining {\n        return []int{0, 0}\n\
    \    }\n    if number == 0 && need == 0 && remaining > 0 {\n        return []int{0,\
    \ 0}\n    }\n    if number > 0 && need > 0 && remaining > 0 {\n        return\
    \ []int{0, 0}\n    }\n    if number > 0 && need > 0 && remaining == 0 {\n    \
    \    return []int{0, 0}\n    }\n    if number == 0 && need > 0 && remaining >\
    \ 0 {\n        return []int{0, 0}\n    }\n    if number > 0 && need == 0 && remaining\
    \ > 0 {\n        return []int{0, 0}\n    }\n    if number > 0 && need > 0 && remaining\
    \ == 0 {\n        return []int{0, 0}\n    }\n    if number == 0 && need > 0 &&\
    \ remaining > 0 {\n        return []int{0, 0}\n    }\n    if number > 0 && need\
    \ > 0 && remaining > 0 {\n        return []int{0, 0}\n    }\n    if number > 0\
    \ && need == 0 && remaining > 0 {\n        return []int{0, 0}\n    }\n    if number\
    \ == 0 && need > 0 && remaining > 0 {\n        return []int{0, 0}\n    }\n   \
    \ if number > 0 && need > 0 && remaining == 0 {\n        return []int{0, 0}\n\
    \    }\n    if number > 0 && need == 0 && remaining > 0 {\n        return []int{0,\
    \ 0}\n    }\n    if number > 0 && need > 0 && remaining > 0 {\n        return\
    \ []int{0, 0}\n    }\n    if number > 0 && need == 0 && remaining == 0 {\n   \
    \     return []int{0, 0}\n    }\n    if number > 0 && need > 0 && remaining ==\
    \ 0 {\n        return []int{0, 0}\n    }\n    if number == 0 && need > 0 && remaining\
    \ > 0 {\n        return []int{0, 0}\n    }\n    if number > 0 && need > 0 && remaining\
    \ == 0 {\n        return []int{0, 0}\n    }\n    if number > 0 && need == 0 &&\
    \ remaining > 0 {\n        return []int{0, 0}\n    }\n    if number > 0 && need\
    \ > 0 && remaining > 0 {\n        return []int{0, 0}\n    }\n    if number > 0\
    \ && need == 0 && remaining == 0 {\n        return []int{0, 0}\n    }\n    if\
    \ number > 0 && need > 0 && remaining > 0 {\n        return []int{0, 0}\n    }\n\
    \    if number > 0 && need == 0 && remaining == 0 {\n        return []int{0, 0}\n\
    \    }\n    if number > 0 && need \nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpgc2dqidn_test.go:117:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075323
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    carrots +=\
    \ number\n    carrots += need\n    carrots += remaining\n    if carrots > 1000\
    \ {\n        carrots = 1000\n    }\n    carrots -= number\n    carrots -= need\n\
    \    carrots -= remaining\n    if carrots < 0 {\n        carrots = 0\n    }\n\
    \    return []int{carrots, carrots}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpctjdhx78_test.go:72: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=0)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpctjdhx78_test.go:72:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=0) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpctjdhx78_test.go:72: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpctjdhx78_test.go:72: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpctjdhx78_test.go:72: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=0)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpctjdhx78_test.go:72:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=0) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075324
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    meals :=\
    \ 0\n    carrots = number\n    meals = need\n    carrots = carrots - meals\n \
    \   carrots = carrots - remaining\n    carrots = carrots + meals\n    carrots\
    \ = carrots + remaining\n    carrots = carrots + meals\n    carrots = carrots\
    \ + remaining\n    carrots = carrots + meals\n    carrots = carrots + remaining\n\
    \    carrots = carrots + meals\n    carrots = carrots + remaining\n    carrots\
    \ = carrots + meals\n    carrots = carrots + remaining\n    carrots = carrots\
    \ + meals\n    carrots = carrots + remaining\n    carrots = carrots + meals\n\
    \    carrots = carrots + remaining\n    carrots = carrots + meals\n    carrots\
    \ = carrots + remaining\n    carrots = carrots + meals\n    carrots = carrots\
    \ + remaining\n    carrots = carrots + meals\n    carrots = carrots + remaining\n\
    \    carrots = carrots + meals\n    carrots = carrots + remaining\n    carrots\
    \ = carrots + meals\n    carrots = carrots + remaining\n    carrots = carrots\
    \ + meals\n    carrots = carrots + remaining\n    carrots = carrots + meals\n\
    \    carrots = carrots + remaining\n    carrots = carrots + meals\n    carrots\
    \ = carrots + remaining\n    carrots = carrots + meals\n    carrots = carrots\
    \ + remaining\n    carrots = carrots + meals\n    carrots = carrots + remaining\n\
    \    carrots = carrots + meals\n    carrots = carrots + remaining\n    carrots\
    \ = carrots + meals\n    carrots = carrots + remaining\n    carrots = carrots\
    \ + meals\n    carrots = carrots + remaining\n    carrots = carrots + meals\n\
    \    carrots = carrots + remaining\n    carrots = carrots + meals\n    carrots\
    \ = carrots + remaining\n    carrots = carrots + meals\n    carrots = carrots\
    \ + remaining\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp1mdc51gx_test.go:90:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075323
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    result\
    \ := make([]int, 2)\n    if number < 0 || number > 1000 || need < 0 || need >\
    \ 1000 || remaining < 0 || remaining > 1000 {\n        fmt.Println(\"Invalid input\"\
    )\n    }\n    if number == 0 {\n        result[0] = remaining\n        result[1]\
    \ = remaining\n    } else {\n        if remaining >= need {\n            result[0]\
    \ = remaining\n            result[1] = remaining\n        } else {\n         \
    \   result[0] = remaining\n            result[1] = need\n        }\n    }\n  \
    \  return result\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n\
    \     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual:\
    \ candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmplr65tuo6_test.go:72: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=10)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmplr65tuo6_test.go:72:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=9)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmplr65tuo6_test.go:72: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmplr65tuo6_test.go:72: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=11)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmplr65tuo6_test.go:72: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=7)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmplr65tuo6_test.go:72:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=5)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075324
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    carrots\
    \ := 0\n    carrots += number\n    carrots += need\n    carrots += remaining\n\
    \    if carrots > 1000 {\n        carrots = 1000\n    }\n    return []int{carrots,\
    \ carrots - carrots + 1}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpu53_jvyr_test.go:63: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=21)\
    \ %!s(int=1)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpu53_jvyr_test.go:63:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=21) %!s(int=1)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpu53_jvyr_test.go:63: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=21) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpu53_jvyr_test.go:63: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=18) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmpu53_jvyr_test.go:63: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=16)\
    \ %!s(int=1)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpu53_jvyr_test.go:63:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075324
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    //\
    \ Your code here\n    carrots := 0\n    carrots += number\n    carrots += need\n\
    \    carrots += remaining\n    if carrots > 1000 {\n        carrots = 1000\n \
    \   }\n    if carrots < 0 {\n        carrots = 0\n    }\n    return []int{carrots,\
    \ carrots - carrots + need}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate :=\
    \ eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp2ptztsgv_test.go:67: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=21)\
    \ %!s(int=6)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp2ptztsgv_test.go:67:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=21) %!s(int=8)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp2ptztsgv_test.go:67: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=21) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp2ptztsgv_test.go:67: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=18) %!s(int=11)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmp2ptztsgv_test.go:67: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=16)\
    \ %!s(int=5)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp2ptztsgv_test.go:67:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=10) %!s(int=5)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075324
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || need < 0 || remaining < 0 {\n        return []int{0, 0}\n    }\n\
    \    if number == 0 && need == 0 && remaining == 0 {\n        return []int{0,\
    \ 0}\n    }\n    if number == 0 && need == 0 {\n        return []int{0, number}\n\
    \    }\n    if number == 0 && remaining == 0 {\n        return []int{0, number}\n\
    \    }\n    if number == 0 && need > remaining {\n        return []int{0, number}\n\
    \    }\n    if need > remaining {\n        return []int{0, number}\n    }\n  \
    \  if number > need {\n        return []int{0, number}\n    }\n    carrots :=\
    \ 0\n    carrots += number\n    carrots += need\n    carrots += remaining\n  \
    \  carrots += number\n    carrots += need\n    carrots += remaining\n    carrots\
    \ += number\n    carrots += need\n    carrots += remaining\n    carrots += number\n\
    \    carrots += need\n    carrots += remaining\n    carrots += number\n    carrots\
    \ += need\n    carrots += remaining\n    carrots += number\n    carrots += need\n\
    \    carrots += remaining\n    carrots += number\n    carrots += need\n    carrots\
    \ += remaining\n    carrots += number\n    carrots += need\n    carrots += remaining\n\
    \    carrots += number\n    carrots += need\n    carrots += remaining\n    carrots\
    \ += number\n    carrots += need\n    carrots += remaining\n    carrots += number\n\
    \    carrots += need\n    carrots += remaining\n    carrots += number\n    carrots\
    \ += need\n    carrots += remaining\n    carrots += number\n    carrots += need\n\
    \    carrots += remaining\n    carrots += number\n    carrots += need\n    carrots\
    \ += remaining\n    carrots += number\n    carrots += need\n    carrots += remaining\n\
    \    carrots += number\n    carrots += need\n    carrots += remaining\n    carrots\
    \ += number\n    carrots += need\n    carrots += remaining\n    carrots += number\n\
    \    carrots += need\n    carrots += remaining\n    carrots += number\n    carrots\
    \ += need\n    carrots += remaining\n    carrots += number\n    carrots += need\n\
    \    carrots += remaining\n    carrots += number\n    carrots += need\n    carrots\
    \ += remaining\n    carrots += number\n    carrots += need\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmppn0w91hf_test.go:123:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075323
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || need < 0 || remaining < 0 {\n        return []int{0, 0}\n    }\n\
    \    if number == 0 && need == 0 {\n        return []int{0, 0}\n    }\n    if\
    \ number == 0 && need > 0 {\n        return []int{need, remaining}\n    }\n  \
    \  if need == 0 {\n        return []int{number, remaining}\n    }\n    if remaining\
    \ == 0 {\n        return []int{number, 0}\n    }\n    if number > need {\n   \
    \     return []int{0, 0}\n    }\n    if number > remaining {\n        return []int{number,\
    \ 0}\n    }\n    if number == need && remaining == 0 {\n        return []int{number,\
    \ 0}\n    }\n    if number == remaining && need == 0 {\n        return []int{0,\
    \ number}\n    }\n    if number == remaining && need > 0 {\n        return []int{need,\
    \ 0}\n    }\n    if number == remaining && need == 0 {\n        return []int{0,\
    \ number}\n    }\n    if number == remaining && need == 0 {\n        return []int{0,\
    \ number}\n    }\n    if number == remaining && need == 0 {\n        return []int{0,\
    \ number}\n    }\n    if number == remaining && need == 0 {\n        return []int{0,\
    \ number}\n    }\n    if number == remaining && need == 0 {\n        return []int{0,\
    \ number}\n    }\n    if number == remaining && need == 0 {\n        return []int{0,\
    \ number}\n    }\n    if number == remaining && need == 0 {\n        return []int{0,\
    \ number}\n    }\n    if number == remaining && need == 0 {\n        return []int{0,\
    \ number}\n    }\n    if number == remaining && need == 0 {\n        return []int{0,\
    \ number}\n    }\n    if number == remaining && need == 0 {\n        return []int{0,\
    \ number}\n    }\n    if number == remaining && need == 0 {\n        return []int{0,\
    \ number}\n    }\n    if number == remaining && need == 0 {\n        return []int{0,\
    \ number}\n    }\n    if number == remaining && need == 0 {\n        return []int{0,\
    \ number}\n    }\n    if number == remaining && need == 0 {\n        return []int{0,\
    \ number}\n    }\n    if number == remaining && need == 0 {\n        return []int{0,\
    \ number}\n    }\n    if number == remaining && need == 0 {\n        return []int{0,\
    \ number}\n    }\n    if number == remaining && need == 0 {\n        return []int{0,\
    \ number}\n    }\n    if number == remaining && need == 0 {\n        return []int{0,\
    \ number}\n    }\n    if number == remaining && need == 0 {\n        return []int{0,\
    \ number}\n    }\n    if number == remaining && need == 0 {\n        return []int{0,\
    \ number}\n    }\n    if number == remaining && need == 0 {\n        return []int\n\
    func TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp2ic_sx3m_test.go:126:16: expected expression

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075323
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    result\
    \ := make([]int, 2)\n    if number > 1000 || need > 1000 || remaining > 1000 {\n\
    \        fmt.Println(\"Invalid input\")\n    }\n    if number == 0 && need ==\
    \ 0 && remaining == 0 {\n        result[0] = 0\n        result[1] = 0\n      \
    \  return result\n    }\n    if number > need {\n        fmt.Println(\"Invalid\
    \ input\")\n    }\n    if number > remaining {\n        fmt.Println(\"Invalid\
    \ input\")\n    }\n    if number == 0 && need == 0 && remaining == 0 {\n     \
    \   result[0] = 0\n        result[1] = 0\n        return result\n    }\n    if\
    \ number == 0 && need > remaining {\n        fmt.Println(\"Invalid input\")\n\
    \    }\n    if number == 0 && need == 0 && remaining > 0 {\n        fmt.Println(\"\
    Invalid input\")\n    }\n    if number > 0 && need == 0 && remaining == 0 {\n\
    \        result[0] = 0\n        result[1] = 0\n        return result\n    }\n\
    \    if number > 0 && need > remaining {\n        fmt.Println(\"Invalid input\"\
    )\n    }\n    if number > 0 && need == 0 && remaining > 0 {\n        fmt.Println(\"\
    Invalid input\")\n    }\n    if number > 0 && need > 0 && remaining == 0 {\n \
    \       result[0] = 0\n        result[1] = 0\n        return result\n    }\n \
    \   if number > 0 && need > 0 && remaining > 0 {\n        result[0] = number -\
    \ need\n        result[1] = remaining\n    }\n    return result\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "Invalid input\nInvalid input\nInvalid input\n--- FAIL: TestEat (0.00s)\n\
    \    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpsztt7v6o_test.go:102: expected\
    \ '[%!s(int=11) %!s(int=4)]', got '[%!s(int=-1) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__1\
    \ (0.00s)\n        tmpsztt7v6o_test.go:102: expected '[%!s(int=12) %!s(int=1)]',\
    \ got '[%!s(int=-4) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n\
    \        tmpsztt7v6o_test.go:102: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=-9)\
    \ %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpsztt7v6o_test.go:102:\
    \ expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=-9) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__4 (0.00s)\n        tmpsztt7v6o_test.go:102: expected\
    \ '[%!s(int=9) %!s(int=2)]', got '[%!s(int=-1) %!s(int=7)]'\n    --- FAIL: TestEat/test_num__5\
    \ (0.00s)\n        tmpsztt7v6o_test.go:102: expected '[%!s(int=5) %!s(int=0)]',\
    \ got '[%!s(int=-1) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660075324
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    result := make([]int, 2)\n\
    \    carrots := 0\n    carrots += number\n    carrots += need\n    carrots -=\
    \ remaining\n    if carrots < 0 {\n        carrots = 0\n    }\n    result[0] =\
    \ carrots\n    result[1] = remaining\n    return result\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1_a126nq_test.go:69: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=1)\
    \ %!s(int=10)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1_a126nq_test.go:69:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=3) %!s(int=9)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1_a126nq_test.go:69: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp1_a126nq_test.go:69: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=8) %!s(int=5)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp1_a126nq_test.go:69: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=2)\
    \ %!s(int=7)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp1_a126nq_test.go:69:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=8) %!s(int=1)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075325
- exit_code: 2
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    //\
    \ write your code here\n    result := make([]int, 2)\n    if number < 0 || number\
    \ > 1000 {\n        fmt.Println(\"Invalid input\")\n        return nil\n    }\n\
    \    if need < 0 || need > 1000 {\n        fmt.Println(\"Invalid input\")\n  \
    \      return nil\n    }\n    if remaining < 0 || remaining > 1000 {\n       \
    \ fmt.Println(\"Invalid input\")\n        return nil\n    }\n    if number ==\
    \ 0 {\n        result[0] = number\n        result[1] = remaining\n        return\
    \ result\n    }\n    if number > need {\n        result[0] = number\n        result[1]\
    \ = remaining\n        return result\n    }\n    if number < need {\n        result[0]\
    \ = number\n        result[1] = need\n        return result\n    }\n    if number\
    \ == need {\n        result[0] = number\n        result[1] = remaining\n     \
    \   return result\n    }\n    if number > remaining {\n        result[0] = number\n\
    \        result[1] = remaining\n        return result\n    }\n    if number <\
    \ remaining {\n        result[0] = number\n        result[1] = need\n        return\
    \ result\n    }\n    if number == remaining {\n        result[0] = number\n  \
    \      result[1] = remaining\n        return result\n    }\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpiptf58z7_test.go:84:1: missing return

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075324
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    carrots +=\
    \ number\n    carrots += need\n    carrots += remaining\n    if carrots > 1000\
    \ {\n        carrots = 1000\n    }\n    carrots -= number\n    carrots -= need\n\
    \    carrots -= remaining\n    if carrots < 0 {\n        carrots = 0\n    }\n\
    \    return []int{carrots, carrots}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpctjdhx78_test.go:72: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=0)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpctjdhx78_test.go:72:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=0) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpctjdhx78_test.go:72: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpctjdhx78_test.go:72: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpctjdhx78_test.go:72: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=0)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpctjdhx78_test.go:72:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=0) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075324
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    carrots +=\
    \ number\n    carrots += need\n    carrots += remaining\n    if carrots > 1000\
    \ {\n        carrots = 1000\n    }\n    if carrots < 0 {\n        carrots = 0\n\
    \    }\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = car\n\
    func TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpyo3wv47s_test.go:96:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075324
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    result := []int{0, 0}\n    if number > need {\n        number\
    \ = need\n    }\n    if remaining > 0 {\n        result[0] = remaining\n    }\n\
    \    if number > 0 {\n        result[1] = number\n    }\n    return result\n}\n\
    \nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpywlldscb_test.go:69: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=5)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpywlldscb_test.go:69:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=4)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpywlldscb_test.go:69: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpywlldscb_test.go:69: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=2)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpywlldscb_test.go:69: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=4)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpywlldscb_test.go:69:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=4)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075324
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    carrots := 0\n    carrots += number\n    carrots += need\n  \
    \  carrots += remaining\n    if carrots > 1000 {\n        carrots = 1000\n   \
    \ }\n    carrots = carrots - number\n    carrots = carrots - need\n    carrots\
    \ = carrots - remaining\n    if carrots < 0 {\n        carrots = 0\n    }\n  \
    \  carrots = carrots / 2\n    carrots = carrots * 2\n    carrots = carrots + 1\n\
    \    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots +\
    \ 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = car\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpxmf_2sp0_test.go:97:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075324
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    carrots =\
    \ number\n    carrots = carrots - need\n    carrots = carrots - remaining\n  \
    \  carrots = carrots + need\n    carrots = carrots + remaining\n    carrots =\
    \ carrots + need\n    carrots = carrots + remaining\n    carrots = carrots + need\n\
    \    carrots = carrots + remaining\n    carrots = carrots + need\n    carrots\
    \ = carrots + remaining\n    carrots = carrots + need\n    carrots = carrots +\
    \ remaining\n    carrots = carrots + need\n    carrots = carrots + remaining\n\
    \    carrots = carrots + need\n    carrots = carrots + remaining\n    carrots\
    \ = carrots + need\n    carrots = carrots + remaining\n    carrots = carrots +\
    \ need\n    carrots = carrots + remaining\n    carrots = carrots + need\n    carrots\
    \ = carrots + remaining\n    carrots = carrots + need\n    carrots = carrots +\
    \ remaining\n    carrots = carrots + need\n    carrots = carrots + remaining\n\
    \    carrots = carrots + need\n    carrots = carrots + remaining\n    carrots\
    \ = carrots + need\n    carrots = carrots + remaining\n    carrots = carrots +\
    \ need\n    carrots = carrots + remaining\n    carrots = carrots + need\n    carrots\
    \ = carrots + remaining\n    carrots = carrots + need\n    carrots = carrots +\
    \ remaining\n    carrots = carrots + need\n    carrots = carrots + remaining\n\
    \    carrots = carrots + need\n    carrots = carrots + remaining\n    carrots\
    \ = carrots + need\n    carrots = carrots + remaining\n    carrots = carrots +\
    \ need\n    carrots = carrots + remaining\n    carrots = carrots + need\n    carrots\
    \ = carrots + remaining\n    carrots = carrots + need\n    carrots = carrots +\
    \ remaining\n    carrots = carrots + need\n    carrots = carrots + remaining\n\
    \    carrots = carrots + need\n    carrots = carrots + remaining\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp722nexxb_test.go:93:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075324
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 {\n        return []int{0, 0}\n    }\n    if need\
    \ < 0 || need > 1000 {\n        return []int{0, 0}\n    }\n    if remaining <\
    \ 0 || remaining > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n\
    \    carrots += number\n    carrots += need\n    carrots -= remaining\n    if\
    \ carrots < 0 {\n        carrots = 0\n    }\n    if carrots > 1000 {\n       \
    \ carrots = 1000\n    }\n    return []int{carrots, carrots - carrots}\n}\n\nfunc\
    \ TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpgy5u14h9_test.go:75: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=1)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpgy5u14h9_test.go:75:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=3) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpgy5u14h9_test.go:75: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpgy5u14h9_test.go:75: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=8) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpgy5u14h9_test.go:75: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=2)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpgy5u14h9_test.go:75:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=8) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075325
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || number < 0 || need > 1000 || need < 0 || remaining > 1000 ||\
    \ remaining < 0 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    carrots\
    \ += number\n    carrots += need\n    carrots += remaining\n    if carrots > 1000\
    \ {\n        carrots = 1000\n    }\n    return []int{carrots, carrots - carrots\
    \ - number}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n\
    \     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual:\
    \ candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpv3dj6pim_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=21)\
    \ %!s(int=-5)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpv3dj6pim_test.go:66:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=21) %!s(int=-4)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpv3dj6pim_test.go:66: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=21) %!s(int=-1)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpv3dj6pim_test.go:66: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=18) %!s(int=-2)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmpv3dj6pim_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=16)\
    \ %!s(int=-4)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpv3dj6pim_test.go:66:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=10) %!s(int=-4)]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075325
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    carrots := 0\n    if number > need {\n        carrots = number-need\n\
    \    } else {\n        carrots = need\n    }\n    if carrots > remaining {\n \
    \       carrots = remaining\n    }\n    return []int{carrots, 0}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpws_g8yx3_test.go:68: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpws_g8yx3_test.go:68:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpws_g8yx3_test.go:68: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpws_g8yx3_test.go:68: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpws_g8yx3_test.go:68: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=5)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpws_g8yx3_test.go:68:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075315
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    carrots +=\
    \ number\n    carrots += need\n    carrots -= remaining\n    if carrots < 0 {\n\
    \        carrots = 0\n    }\n    if carrots > 1000 {\n        carrots = 1000\n\
    \    }\n    return []int{carrots, carrots - carrots}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpnvzdpsvi_test.go:69: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=1)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpnvzdpsvi_test.go:69:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=3) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpnvzdpsvi_test.go:69: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpnvzdpsvi_test.go:69: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=8) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpnvzdpsvi_test.go:69: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=2)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpnvzdpsvi_test.go:69:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=8) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075315
- exit_code: 2
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    carrots := 0\n    meals := 0\n    for carrots < number {\n  \
    \      meals += 1\n        carrots += eatCarrot(remaining, need)\n    }\n    return\
    \ []int{meals, carrots - meals}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfq1e_y9__test.go:42:20: undefined: eatCarrot

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075326
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    //\
    \ Your code here\n    carrots := 0\n    carrots += number\n    carrots += need\n\
    \    carrots -= remaining\n    if carrots < 0 {\n        carrots = 0\n    }\n\
    \    if carrots > 1000 {\n        carrots = 1000\n    }\n    carrots -= number\n\
    \    carrots -= need\n    carrots -= remaining\n    if carrots < 0 {\n       \
    \ carrots = 0\n    }\n    if carrots > 1000 {\n        carrots = 1000\n    }\n\
    \    carrots -= number\n    carrots -= need\n    carrots -= remaining\n    if\
    \ carrots < 0 {\n        carrots = 0\n    }\n    if carrots > 1000 {\n       \
    \ carrots = 1000\n    }\n    carrots -= number\n    carrots -= need\n    carrots\
    \ -= remaining\n    if carrots < 0 {\n        carrots = 0\n    }\n    if carrots\
    \ > 1000 {\n        carrots = 1000\n    }\n    carrots -= number\n    carrots\
    \ -= need\n    carrots -= remaining\n    if carrots < 0 {\n        carrots = 0\n\
    \    }\n    if carrots > 1000 {\n        carrots = 1000\n    }\n    carrots -=\
    \ number\n    carrots -= need\n    carrots -= remaining\n    if carrots < 0 {\n\
    \        carrots = 0\n    }\n    if carrots > 1000 {\n        carrots = 1000\n\
    \    }\n    carrots -= number\n    carrots -= need\n    carrots -= remaining\n\
    \    if carrots < 0 {\n        carrots = 0\n    }\n    if carrots > 1000 {\n \
    \       carrots = 1000\n    }\n    carrots -= number\n    carrots -= need\n  \
    \  carrots -= remaining\n    if carrots < 0 {\n        carrots = 0\n    }\n  \
    \  if carrots > 1000 {\n        carrots = 1000\n    }\n    carrots -= number\n\
    \    carrots -= need\n    carrots -= remaining\n    if carrots < 0 {\n       \
    \ carrots = 0\n    }\n    if carrots > 1000 {\n        carrots = 1000\n    }\n\
    \    carrots -= number\n    carrots -= need\n    carrots -= remaining\n    if\
    \ carrots < 0 {\n        carrots = 0\n    }\n    if carrots > 1000 {\n       \
    \ carrots = 1000\n    }\n    carrots -= number\n    carrots -= \nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp2vohllaj_test.go:129:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075325
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    if number == 0 {\n        return\
    \ []int{0, 0}\n    }\n    if remaining < need {\n        return []int{0, 0}\n\
    \    }\n    if remaining == 0 {\n        return []int{number, 0}\n    }\n    if\
    \ number == need {\n        return []int{number, 0}\n    }\n    if number > need\
    \ {\n        return []int{0, 0}\n    }\n    if number == remaining {\n       \
    \ return []int{number, 0}\n    }\n    if number > remaining {\n        return\
    \ []int{0, 0}\n    }\n    if number == remaining {\n        return []int{number,\
    \ 0}\n    }\n    if number > remaining {\n        return []int{0, 0}\n    }\n\
    \    if number == remaining {\n        return []int{number, 0}\n    }\n    if\
    \ number > remaining {\n        return []int{0, 0}\n    }\n    if number == remaining\
    \ {\n        return []int{number, 0}\n    }\n    if number > remaining {\n   \
    \     return []int{0, 0}\n    }\n    if number == remaining {\n        return\
    \ []int{number, 0}\n    }\n    if number > remaining {\n        return []int{0,\
    \ 0}\n    }\n    if number == remaining {\n        return []int{number, 0}\n \
    \   }\n    if number > remaining {\n        return []int{0, 0}\n    }\n    if\
    \ number == remaining {\n        return []int{number, 0}\n    }\n    if number\
    \ > remaining {\n        return []int{0, 0}\n    }\n    if number == remaining\
    \ {\n        return []int{number, 0}\n    }\n    if number > remaining {\n   \
    \     return []int{0, 0}\n    }\n    if number == remaining {\n        return\
    \ []int{number, 0}\n    }\n    if number > remaining {\n        return []int{0,\
    \ 0}\n    }\n    if number == remaining {\n        return []int{number, 0}\n \
    \   }\n    if number > remaining {\n        return []int{0, 0}\n    }\n    if\
    \ number == remaining {\n        return []int{number, 0}\n    }\n    if number\
    \ > remaining {\n        return []int{0, 0}\n    }\n    if number == remaining\
    \ {\n        return []int{number, 0}\n    }\n    if number > remaining {\n   \
    \     return []int{0, 0}\n    }\n    if number == remaining {\n        return\
    \ []int{number, 0}\n    }\n    if number > remaining {\n        return []int{0,\
    \ 0}\n    }\n    if number == remaining {\n        return []int{number, 0}\n \
    \   }\n    if number > remaining {\n        return []int{0, 0}\n    }\n    if\
    \ number == remaining {\n        return []int{number, 0}\n    }\n    if number\
    \ > remaining {\n        return []\nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp0y9y465l_test.go:141:18: expected type, found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075325
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    result\
    \ := make([]int, 2)\n    if number < 0 || number > 1000 {\n        fmt.Println(\"\
    Invalid input\")\n        return nil\n    }\n    if need < 0 || need > 1000 {\n\
    \        fmt.Println(\"Invalid input\")\n        return nil\n    }\n    if remaining\
    \ < 0 || remaining > 1000 {\n        fmt.Println(\"Invalid input\")\n        return\
    \ nil\n    }\n    if number == 0 {\n        result[0] = 0\n        result[1] =\
    \ 0\n        return result\n    }\n    if number > need {\n        fmt.Println(\"\
    Invalid input\")\n        return nil\n    }\n    if remaining == 0 {\n       \
    \ result[0] = number\n        result[1] = need\n        return result\n    }\n\
    \    if number > remaining {\n        fmt.Println(\"Invalid input\")\n       \
    \ return nil\n    }\n    if number == need {\n        result[0] = number\n   \
    \     result[1] = need\n        return result\n    }\n    if number > need {\n\
    \        fmt.Println(\"Invalid input\")\n        return nil\n    }\n    if number\
    \ == remaining {\n        result[0] = number\n        result[1] = need\n     \
    \   return result\n    }\n    if number > remaining {\n        fmt.Println(\"\
    Invalid input\")\n        return nil\n    }\n    if number == need {\n       \
    \ result[0] = number\n        result[1] = need\n        return result\n    }\n\
    \    if number > need {\n        fmt.Println(\"Invalid input\")\n        return\
    \ nil\n    }\n    if number == remaining {\n        result[0] = number\n     \
    \   result[1] = need\n        return result\n    }\n    if number > remaining\
    \ {\n        fmt.Println(\"Invalid input\")\n        return nil\n    }\n    if\
    \ number == need {\n        result[0] = number\n        result[1] = need\n   \
    \     return result\n    }\n    if number > need {\n        fmt.Println(\"Invalid\
    \ input\")\n        return nil\n    }\n    if number == remaining {\n        result[0]\
    \ = number\n        result[1] = need\n        return result\n    }\n    if number\
    \ > remaining {\n        fmt.Println(\"Invalid input\")\n        return nil\n\
    \    }\n    if number == need {\n        result[0] = number\n        result[1]\
    \ = need\n        return result\n    }\n    if number > need {\n        fmt.Println(\"\
    Invalid input\")\n        return nil\n    }\n    if number == remaining {\n  \
    \      result[0] = number\n        result[1] = need\n        return result\n \
    \   }\n    if number > remaining {\n        fmt.Println(\"Invalid input\")\n \
    \       return nil\n    }\n    if number == need {\n        result[0] = number\n\
    \        result[1] = need\n        return result\n    }\n    if number > need\
    \ {\n        fmt.Println(\"Invalid input\")\n        return nil\n    }\n    if\
    \ number == remaining {\n        result[0] = number\n        result[1] = need\n\
    \        return result\n    }\n    if number > remaining {\n        fmt.Println(\"\
    Invalid input\")\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n\
    \     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual:\
    \ candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpkf6de56__test.go:155:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075325
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    result := []int{0, 0}\n   \
    \ carrots := 0\n    if remaining > 0 {\n        carrots = remaining\n    }\n \
    \   if carrots > 0 {\n        result[0] = carrots\n    }\n    if carrots < need\
    \ {\n        result[1] = carrots - need\n    }\n    return result\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpq4hxubnu_test.go:70: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpq4hxubnu_test.go:70:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpq4hxubnu_test.go:70: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpq4hxubnu_test.go:70: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=-6)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmpq4hxubnu_test.go:70: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpq4hxubnu_test.go:70:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=-4)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075326
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    result := make([]int, 2)\n\
    \    if remaining == 0 {\n        result[0] = 0\n        result[1] = 0\n    }\
    \ else {\n        result[0] = number\n        result[1] = remaining\n    }\n \
    \   return result\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n\
    \     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual:\
    \ candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpcxkmb9g8_test.go:67: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5)\
    \ %!s(int=10)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpcxkmb9g8_test.go:67:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=9)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpcxkmb9g8_test.go:67: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpcxkmb9g8_test.go:67: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=2) %!s(int=5)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpcxkmb9g8_test.go:67: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4)\
    \ %!s(int=7)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpcxkmb9g8_test.go:67:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=1)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075326
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    carrots +=\
    \ number\n    carrots += need\n    carrots += remaining\n    carrots %= 1000\n\
    \    if carrots == 0 {\n        carrots = 1000\n    }\n    return []int{carrots,\
    \ carrots - number}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp3e8mrkkb_test.go:67: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=21)\
    \ %!s(int=16)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp3e8mrkkb_test.go:67:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=21) %!s(int=17)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp3e8mrkkb_test.go:67: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=21) %!s(int=20)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp3e8mrkkb_test.go:67: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=18) %!s(int=16)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmp3e8mrkkb_test.go:67: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=16)\
    \ %!s(int=12)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp3e8mrkkb_test.go:67:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=10) %!s(int=6)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075315
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    result\
    \ := make([]int, 2)\n    if number > 1000 || need > 1000 || remaining > 1000 {\n\
    \        fmt.Println(\"Invalid input\")\n        return nil\n    }\n    if number\
    \ < need {\n        fmt.Println(\"Invalid input\")\n        return nil\n    }\n\
    \    if number == 0 {\n        result[0] = remaining\n        result[1] = remaining\n\
    \    } else {\n        result[0] = number\n        result[1] = need\n    }\n \
    \   return result\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n\
    \     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual:\
    \ candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "Invalid input\nInvalid input\nInvalid input\nInvalid input\nInvalid input\n\
    Invalid input\n--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpvsweix3m_test.go:72: expected '[%!s(int=11) %!s(int=4)]', got '[]'\n\
    \    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpvsweix3m_test.go:72: expected\
    \ '[%!s(int=12) %!s(int=1)]', got '[]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n\
    \        tmpvsweix3m_test.go:72: expected '[%!s(int=11) %!s(int=0)]', got '[]'\n\
    \    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpvsweix3m_test.go:72: expected\
    \ '[%!s(int=7) %!s(int=0)]', got '[]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmpvsweix3m_test.go:72: expected '[%!s(int=9) %!s(int=2)]', got '[]'\n\
    \    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpvsweix3m_test.go:72: expected\
    \ '[%!s(int=5) %!s(int=0)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660075326
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    if number\
    \ > need {\n        carrots = number-need\n    } else {\n        carrots = remaining\n\
    \    }\n    if carrots == 0 {\n        return []int{number, 0}\n    }\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = \nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpijmn_swa_test.go:96:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075325
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    carrots := 0\n    carrots += number\n    carrots += need\n  \
    \  carrots += remaining\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrot\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpdldorth3_test.go:109:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075321
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    if number == 0 {\n        return []int{0, 0}\n    }\n    if need\
    \ == 0 {\n        return []int{number, 0}\n    }\n    if remaining == 0 {\n  \
    \      return []int{number, number}\n    }\n    if number < need {\n        return\
    \ []int{0, 0}\n    }\n    if number > remaining {\n        return []int{0, number}\n\
    \    }\n    if number == need {\n        return []int{number, number}\n    }\n\
    \    if number > need {\n        return []int{number, number}\n    }\n    if number\
    \ == remaining {\n        return []int{number, 0}\n    }\n    if number == 0 {\n\
    \        return []int{0, 0}\n    }\n    if need == 0 {\n        return []int{number,\
    \ 0}\n    }\n    if remaining == 0 {\n        return []int{number, number}\n \
    \   }\n    if number < need {\n        return []int{0, 0}\n    }\n    if number\
    \ > remaining {\n        return []int{0, number}\n    }\n    if number == need\
    \ {\n        return []int{number, number}\n    }\n    if number > need {\n   \
    \     return []int{number, number}\n    }\n    if number == remaining {\n    \
    \    return []int{number, 0}\n    }\n    if number == 0 {\n        return []int{0,\
    \ 0}\n    }\n    if need == 0 {\n        return []int{number, 0}\n    }\n    if\
    \ remaining == 0 {\n        return []int{number, number}\n    }\n    if number\
    \ < need {\n        return []int{0, 0}\n    }\n    if number > remaining {\n \
    \       return []int{0, number}\n    }\n    if number == need {\n        return\
    \ []int{number, number}\n    }\n    if number > need {\n        return []int{number,\
    \ number}\n    }\n    if number == remaining {\n        return []int{number, 0}\n\
    \    }\n    if number == 0 {\n        return []int{0, 0}\n    }\n    if need ==\
    \ 0 {\n        return []int{number, 0}\n    }\n    if remaining == 0 {\n     \
    \   return []int{number, number}\n    }\n    if number < need {\n        return\
    \ []int{0, 0}\n    }\n    if number > remaining {\n        return []int{0, number}\n\
    \    }\n    if number == need {\n        return []int{number, number}\n    }\n\
    \    if number > need {\n        return []int{number, number}\n    }\n    if number\
    \ == remaining {\n        return []int{number, 0}\n    }\n    if number == 0 {\n\
    \        return []int{0, 0}\n    }\n    if need == 0 {\n        return []int{number,\
    \ 0}\n    }\n    if remaining == 0 {\n        return []int{number, number}\n \
    \   }\n    if number < need {\n        return []int{0, 0}\n    }\n    if \nfunc\
    \ TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpui7zglbd_test.go:147:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075325
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    if number == 0 {\n        return\
    \ []int{0, 0}\n    }\n    if remaining < need {\n        return []int{0, 0}\n\
    \    }\n    if number > remaining {\n        return []int{0, 0}\n    }\n    if\
    \ number == need {\n        return []int{number, 0}\n    }\n    if number > need\
    \ {\n        return []int{0, number}\n    }\n    if number == remaining {\n  \
    \      return []int{number, number}\n    }\n    carrots := 0\n    carrots += number\n\
    \    carrots += need\n    carrots += remaining\n    carrots += number\n    carrots\
    \ += need\n    carrots += remaining\n    carrots += number\n    carrots += need\n\
    \    carrots += remaining\n    carrots += number\n    carrots += need\n    carrots\
    \ += remaining\n    carrots += number\n    carrots += need\n    carrots += remaining\n\
    \    carrots += number\n    carrots += need\n    carrots += remaining\n    carrots\
    \ += number\n    carrots += need\n    carrots += remaining\n    carrots += number\n\
    \    carrots += need\n    carrots += remaining\n    carrots += number\n    carrots\
    \ += need\n    carrots += remaining\n    carrots += number\n    carrots += need\n\
    \    carrots += remaining\n    carrots += number\n    carrots += need\n    carrots\
    \ += remaining\n    carrots += number\n    carrots += need\n    carrots += remaining\n\
    \    carrots += number\n    carrots += need\n    carrots += remaining\n    carrots\
    \ += number\n    carrots += need\n    carrots += remaining\n    carrots += number\n\
    \    carrots += need\n    carrots += remaining\n    carrots += number\n    carrots\
    \ += need\n    carrots += remaining\n    carrots += number\n    carrots += need\n\
    \    carrots += remaining\n    carrots += number\n    carrots += need\n    carrots\
    \ += remaining\n    carrots += number\n    carrots += need\n    carrots += remaining\n\
    \    carrots += number\n    carrots += need\n    carrots += remaining\n    carrots\
    \ += number\n    carrots += need\n    carrots += remaining\n    carrots += number\n\
    \    carrots += need\n    \nfunc TestEat(t *testing.T) {\n  candidate := eat\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpqhihbddr_test.go:123:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075325
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    carrots := 0\n    carrots += number\n    carrots += need\n  \
    \  carrots += remaining\n    if carrots > 1000 {\n        carrots = 1000\n   \
    \ }\n    carrots -= number\n    carrots -= need\n    carrots -= remaining\n  \
    \  if carrots < 0 {\n        carrots = 0\n    }\n    return []int{carrots, carrots}\n\
    }\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpksllh4it_test.go:72: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=0)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpksllh4it_test.go:72:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=0) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpksllh4it_test.go:72: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpksllh4it_test.go:72: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpksllh4it_test.go:72: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=0)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpksllh4it_test.go:72:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=0) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075320
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    //\
    \ write your code here\n    carrots := 0\n    if number < need {\n        carrots\
    \ = number\n    } else {\n        carrots = need\n    }\n    if carrots > remaining\
    \ {\n        carrots = remaining\n    }\n    return []int{carrots, remaining}\n\
    }\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpmrrmgeoe_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5)\
    \ %!s(int=10)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpmrrmgeoe_test.go:66:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=9)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpmrrmgeoe_test.go:66: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpmrrmgeoe_test.go:66: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=2) %!s(int=5)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpmrrmgeoe_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4)\
    \ %!s(int=7)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpmrrmgeoe_test.go:66:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=1)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075326
- exit_code: 2
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    result\
    \ := make([]int, 2)\n    if number < 0 || number > 1000 || need < 0 || need >\
    \ 1000 || remaining < 0 || remaining > 1000 {\n        fmt.Println(\"Invalid input\"\
    )\n    }\n    if number == 0 {\n        result[0] = need\n        result[1] =\
    \ remaining\n        return result\n    }\n    if need == 0 {\n        result[0]\
    \ = number\n        result[1] = remaining\n        return result\n    }\n    if\
    \ remaining == 0 {\n        result[0] = number\n        result[1] = need\n   \
    \     return result\n    }\n    if number > need {\n        result[0] = number\n\
    \        result[1] = remaining\n        return result\n    }\n    if number <\
    \ need {\n        result[0] = need\n        result[1] = remaining\n        return\
    \ result\n    }\n    if number == need {\n        result[0] = number\n       \
    \ result[1] = remaining\n        return result\n    }\n    if number > remaining\
    \ {\n        result[0] = number\n        result[1] = need\n        return result\n\
    \    }\n    if number < remaining {\n        result[0] = remaining\n        result[1]\
    \ = need\n        return result\n    }\n}\n\nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpm90nwjwd_test.go:79:1: missing return

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075326
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    meals :=\
    \ 0\n    if number > remaining {\n        meals = number - remaining\n       \
    \ carrots = remaining\n    } else {\n        meals = need\n        carrots = number\n\
    \    }\n    result := make([]int, 2)\n    result[0] = meals\n    result[1] = carrots\n\
    \    return result\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpseegjrpd_test.go:71: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=5)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpseegjrpd_test.go:71:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=4)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpseegjrpd_test.go:71: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpseegjrpd_test.go:71: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=11) %!s(int=2)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmpseegjrpd_test.go:71: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=5)\
    \ %!s(int=4)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpseegjrpd_test.go:71:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=3) %!s(int=1)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075326
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || need < 0 || remaining < 0 {\n        return []int{}\n    }\n \
    \   if number == 0 && need == 0 && remaining == 0 {\n        return []int{0, 0}\n\
    \    }\n    if number == 0 && need == 0 {\n        return []int{0, remaining}\n\
    \    }\n    if number == 0 && remaining == 0 {\n        return []int{number, 0}\n\
    \    }\n    if need == 0 {\n        return []int{number, remaining}\n    }\n \
    \   if remaining == 0 {\n        return []int{number, need}\n    }\n    if number\
    \ > need {\n        return []int{number, need}\n    }\n    if number > remaining\
    \ {\n        return []int{number, remaining}\n    }\n    if need > remaining {\n\
    \        return []int{number, need}\n    }\n    if number == need && remaining\
    \ == 0 {\n        return []int{number, 0}\n    }\n    if number == need && remaining\
    \ > 0 {\n        return []int{number, remaining}\n    }\n    if number == remaining\
    \ && need == 0 {\n        return []int{number, 0}\n    }\n    if number == remaining\
    \ && need > 0 {\n        return []int{number, need}\n    }\n    if number == remaining\
    \ && need == 0 && remaining > 0 {\n        return []int{number, remaining}\n \
    \   }\n    if number == remaining && need == 0 && remaining == 0 {\n        return\
    \ []int{number, 0}\n    }\n    if number == remaining && need > 0 && remaining\
    \ > 0 {\n        return []int{number, need}\n    }\n    if number == remaining\
    \ && need > 0 && remaining == 0 {\n        return []int{number, 0}\n    }\n  \
    \  if number == remaining && need == 0 && remaining > 0 {\n        return []int{number,\
    \ remaining}\n    }\n    if number == remaining && need == 0 && remaining == 0\
    \ {\n        return []int{number, 0}\n    }\n    if number == remaining && need\
    \ > 0 && remaining > 0 {\n        return []int{number, need}\n    }\n    if number\
    \ == remaining && need > 0 && remaining == 0 {\n        return []int{number, 0}\n\
    \    }\n    if number == remaining && need == 0 && remaining > 0 {\n        return\
    \ []int{number, remaining}\n    }\n    if number == remaining && need == 0 &&\
    \ remaining == 0 {\n        return []int{number, 0}\n    }\n    if number == remaining\
    \ && need > 0 && remaining > 0 {\n        return []int{number, need}\n    }\n\
    \    if number == remaining && need > 0 && remaining == 0 {\n        return []int{number,\
    \ 0}\n    }\n    if number == remaining && need == 0 && remaining > 0 {\n    \
    \    return []int{number, remaining}\n    }\n    if number == remaining && need\
    \ == 0 && remaining == 0 {\n        return []int{number, 0}\n    }\n    if number\
    \ == remaining && need > 0 && remaining > 0 {\n        return []\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6pbrdal6_test.go:117:18: expected type, found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075325
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    carrots +=\
    \ number\n    carrots += need\n    carrots -= remaining\n    if carrots < 0 {\n\
    \        carrots = 0\n    }\n    return []int{carrots, remaining}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpw717zhue_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=1)\
    \ %!s(int=10)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpw717zhue_test.go:66:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=3) %!s(int=9)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpw717zhue_test.go:66: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpw717zhue_test.go:66: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=8) %!s(int=5)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpw717zhue_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=2)\
    \ %!s(int=7)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpw717zhue_test.go:66:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=8) %!s(int=1)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075327
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    result := make([]int, 2)\n\
    \    carrots := 0\n    if number > need {\n        carrots = number-need\n   \
    \     result[0] = carrots\n        result[1] = remaining\n    } else {\n     \
    \   carrots = need\n        result[0] = number\n        result[1] = remaining\n\
    \    }\n    return result\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpjarv9qq8_test.go:70: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5)\
    \ %!s(int=10)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpjarv9qq8_test.go:70:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=9)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpjarv9qq8_test.go:70: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpjarv9qq8_test.go:70: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=2) %!s(int=5)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpjarv9qq8_test.go:70: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4)\
    \ %!s(int=7)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpjarv9qq8_test.go:70:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=1)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075327
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    carrots := 0\n    carrots += number\n    carrots += need\n  \
    \  carrots += remaining\n    if carrots > 1000 {\n        carrots = 1000\n   \
    \ }\n    carrots -= number\n    carrots -= need\n    carrots -= remaining\n  \
    \  if carrots < 0 {\n        carrots = 0\n    }\n    return []int{carrots, carrots}\n\
    }\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpksllh4it_test.go:72: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=0)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpksllh4it_test.go:72:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=0) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpksllh4it_test.go:72: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpksllh4it_test.go:72: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpksllh4it_test.go:72: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=0)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpksllh4it_test.go:72:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=0) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075320
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    result\
    \ := make([]int, 2)\n    if number < 0 || number > 1000 || need < 0 || need >\
    \ 1000 || remaining < 0 || remaining > 1000 {\n        fmt.Println(\"Invalid input\"\
    )\n    }\n    if number > remaining {\n        result[0] = number\n        result[1]\
    \ = remaining\n    } else {\n        result[0] = remaining\n        result[1]\
    \ = number\n    }\n    return result\n}\n\nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpjd902so2_test.go:67: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=5)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpjd902so2_test.go:67:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=4)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpjd902so2_test.go:67: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpjd902so2_test.go:67: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=2)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpjd902so2_test.go:67: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=4)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpjd902so2_test.go:67:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=1)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075327
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    result\
    \ := make([]int, 2)\n    if number < 0 || number > 1000 || need < 0 || need >\
    \ 1000 || remaining < 0 || remaining > 1000 {\n        fmt.Println(\"Invalid input\"\
    )\n    }\n    if number == 0 {\n        result[0] = remaining\n        result[1]\
    \ = remaining\n    } else {\n        result[0] = remaining\n        result[1]\
    \ = need\n    }\n    return result\n}\n\nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpowqoiir5_test.go:67: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=6)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpowqoiir5_test.go:67:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=8)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpowqoiir5_test.go:67: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpowqoiir5_test.go:67: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=11)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmpowqoiir5_test.go:67: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=5)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpowqoiir5_test.go:67:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=5)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075327
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    //\
    \ Your code here\n    carrots := 0\n    carrots += number\n    carrots += need\n\
    \    carrots += remaining\n    if carrots > 1000 {\n        carrots = 1000\n \
    \   }\n    if carrots < 0 {\n        carrots = 0\n    }\n    carrots = carrots\
    \ % 1000\n    carrots = carrots / 1000\n    carrots = carrots + 1\n    carrots\
    \ = carrots % 1000\n    carrots = carrots / 1000\n    carrots = carrots + 1\n\
    \    carrots = carrots % 1000\n    carrots = carrots / 1000\n    carrots = carrots\
    \ + 1\n    carrots = carrots % 1000\n    carrots = carrots / 1000\n    carrots\
    \ = carrots + 1\n    carrots = carrots % 1000\n    carrots = carrots / 1000\n\
    \    carrots = carrots + 1\n    carrots = carrots % 1000\n    carrots = carrots\
    \ / 1000\n    carrots = carrots + 1\n    carrots = carrots % 1000\n    carrots\
    \ = carrots / 1000\n    carrots = carrots + 1\n    carrots = carrots % 1000\n\
    \    carrots = carrots / 1000\n    carrots = carrots + 1\n    carrots = carrots\
    \ % 1000\n    carrots = carrots / 1000\n    carrots = carrots + 1\n    carrots\
    \ = carrots % 1000\n    carrots = carrots / 1000\n    carrots = carrots + 1\n\
    \    carrots = carrots % 1000\n    carrots = carrots / 1000\n    carrots = carrots\
    \ + 1\n    carrots = carrots % 1000\n    carrots = carrots / 1000\n    carrots\
    \ = carrots + 1\n    carrots = carrots % 1000\n    carrots = carrots / 1000\n\
    \    carrots = carrots + 1\n    carrots = carrots % 1000\n    carrots = carrots\
    \ / 1000\n    carrots = carrots + 1\n    carrots = carrots % 1000\n    carrots\
    \ = carrots / 1000\n    carrots = carrots + 1\n    carrots = carrots % 1000\n\
    \    carrots = carrots / 1000\n    carrots = carrots + 1\n    carrots = carrot\n\
    func TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp9y7tdu_7_test.go:95:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075326
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    carrots := 0\n    carrots += number\n    carrots += need\n  \
    \  carrots -= remaining\n    if carrots < 0 {\n        carrots = 0\n    }\n  \
    \  return []int{carrots, remaining}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpgmtnqkym_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=1)\
    \ %!s(int=10)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpgmtnqkym_test.go:66:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=3) %!s(int=9)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpgmtnqkym_test.go:66: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpgmtnqkym_test.go:66: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=8) %!s(int=5)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpgmtnqkym_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=2)\
    \ %!s(int=7)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpgmtnqkym_test.go:66:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=8) %!s(int=1)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075327
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    carrots := 0\n    carrots += number\n    carrots += need\n  \
    \  carrots += remaining\n    carrots = carrots % 1000\n    carrots = carrots /\
    \ 1000\n    carrots = carrots + 1\n    carrots = carrots % 1000\n    carrots =\
    \ carrots / 1000\n    carrots = carrots + 1\n    carrots = carrots % 1000\n  \
    \  carrots = carrots / 1000\n    carrots = carrots + 1\n    carrots = carrots\
    \ % 1000\n    carrots = carrots / 1000\n    carrots = carrots + 1\n    carrots\
    \ = carrots % 1000\n    carrots = carrots / 1000\n    carrots = carrots + 1\n\
    \    carrots = carrots % 1000\n    carrots = carrots / 1000\n    carrots = carrots\
    \ + 1\n    carrots = carrots % 1000\n    carrots = carrots / 1000\n    carrots\
    \ = carrots + 1\n    carrots = carrots % 1000\n    carrots = carrots / 1000\n\
    \    carrots = carrots + 1\n    carrots = carrots % 1000\n    carrots = carrots\
    \ / 1000\n    carrots = carrots + 1\n    carrots = carrots % 1000\n    carrots\
    \ = carrots / 1000\n    carrots = carrots + 1\n    carrots = carrots % 1000\n\
    \    carrots = carrots / 1000\n    carrots = carrots + 1\n    carrots = carrots\
    \ % 1000\n    carrots = carrots / 1000\n    carrots = carrots + 1\n    carrots\
    \ = carrots % 1000\n    carrots = carrots / 1000\n    carrots = carrots + 1\n\
    \    carrots = carrots % 1000\n    carrots = carrots / 1000\n    carrots = carrots\
    \ + 1\n    carrots = carrots % 1000\n    carrots = carrots / 1000\n    carrots\
    \ = carrots + 1\n    carrots = carrots % 1000\n    carrots = carrots / 1000\n\
    \    carrots = carrots + 1\n    carrots = carrots % 1000\n    carrots = carrots\
    \ / \nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpn1x90d5o_test.go:92:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075326
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    carrots +=\
    \ number\n    carrots += need\n    carrots += remaining\n    carrots %= 1000\n\
    \    if carrots == 0 {\n        carrots = 1000\n    }\n    carrots -= number\n\
    \    carrots -= need\n    carrots -= remaining\n    carrots %= 1000\n    if carrots\
    \ == 0 {\n        carrots = 1000\n    }\n    return []int{carrots, carrots - carrots\
    \ % 1000}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n\
    \     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual:\
    \ candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpauwafnlw_test.go:74: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=1000)\
    \ %!s(int=1000)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpauwafnlw_test.go:74:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=1000) %!s(int=1000)]'\n \
    \   --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpauwafnlw_test.go:74: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1000) %!s(int=1000)]'\n    --- FAIL:\
    \ TestEat/test_num__3 (0.00s)\n        tmpauwafnlw_test.go:74: expected '[%!s(int=7)\
    \ %!s(int=0)]', got '[%!s(int=1000) %!s(int=1000)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmpauwafnlw_test.go:74: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=1000) %!s(int=1000)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n\
    \        tmpauwafnlw_test.go:74: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1000)\
    \ %!s(int=1000)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075327
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    //\
    \ write your code in JavaScript (Node.js 8.9.4)\n    // let carrots = number\n\
    \    // let need = need\n    // let remaining = remaining\n    // let result =\
    \ []\n    // while carrots > 0 {\n    //     let carrots = carrots - need\n  \
    \  //     result.push(carrots)\n    // }\n    // while carrots > 0 {\n    // \
    \    carrots = carrots - remaining\n    //     result.push(carrots)\n    // }\n\
    \    // while carrots > 0 {\n    //     carrots = carrots - remaining\n    //\
    \     result.push(carrots)\n    // }\n    // while carrots > 0 {\n    //     carrots\
    \ = carrots - remaining\n    //     result.push(carrots)\n    // }\n    // while\
    \ carrots > 0 {\n    //     carrots = carrots - remaining\n    //     result.push(carrots)\n\
    \    // }\n    // while carrots > 0 {\n    //     carrots = carrots - remaining\n\
    \    //     result.push(carrots)\n    // }\n    // while carrots > 0 {\n    //\
    \     carrots = carrots - remaining\n    //     result.push(carrots)\n    // }\n\
    \    // while carrots > 0 {\n    //     carrots = carrots - remaining\n    //\
    \     result.push(carrots)\n    // }\n    // while carrots > 0 {\n    //     carrots\
    \ = carrots - remaining\n    //     result.push(carrots)\n    // }\n    // while\
    \ carrots > 0 {\n    //     carrots = carrots - remaining\n    //     result.push(carrots)\n\
    \    // }\n    // while carrots > 0 {\n    //     carrots = carrots - remaining\n\
    \    //     result.push(carrots)\n    // }\n    // while carrots > 0 {\n    //\
    \     carrots = carrots - remaining\n    //     result.push(carrots)\n    // }\n\
    \    // while carrots > 0 {\n    //     carrots = carrots - remaining\n    //\
    \     result.push(carrots)\n    // }\n    // while carrots > 0 {\n    //     carrots\
    \ = carrots - remaining\n    //     result.push(carrots)\n    // }\n    // while\
    \ carrots > 0 {\n    //     carrots = carrots - remaining\n    //     result.push(carrots)\n\
    \    // }\n    // while carrots > 0 {\n    //     carrots = carrots - remaining\n\
    \    //     result.push(carrots)\n    // }\n    // while carrots > 0 {\n    //\
    \     carrot\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpz77a5znc_test.go:106:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075326
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    carrots := 0\n    carrots += number\n    carrots += need\n  \
    \  carrots += remaining\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrot\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpdldorth3_test.go:109:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075321
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    result\
    \ := make([]int, 2)\n    if number > 1000 || need > 1000 || remaining > 1000 {\n\
    \        fmt.Println(\"Invalid input\")\n    }\n    if number < need {\n     \
    \   fmt.Println(\"Not enough carrots to eat\")\n    }\n    if number == need {\n\
    \        result[0] = number\n        result[1] = remaining\n    }\n    if number\
    \ > remaining {\n        result[0] = number\n        result[1] = remaining\n \
    \   }\n    return result\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "Not enough carrots to eat\nNot enough carrots to eat\nNot enough carrots\
    \ to eat\nNot enough carrots to eat\nNot enough carrots to eat\nNot enough carrots\
    \ to eat\n--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmper8fqahg_test.go:71: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=0)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmper8fqahg_test.go:71:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=0) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmper8fqahg_test.go:71: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmper8fqahg_test.go:71: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmper8fqahg_test.go:71: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=0)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmper8fqahg_test.go:71:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=1)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075327
- exit_code: 2
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    result\
    \ := make([]int, 2)\n    if number < 0 || number > 1000 || need < 0 || need >\
    \ 1000 || remaining < 0 || remaining > 1000 {\n        fmt.Println(\"Invalid input\"\
    )\n    }\n    if number == 0 {\n        result[0] = 0\n        result[1] = 0\n\
    \        return result\n    }\n    if remaining == 0 {\n        result[0] = number\n\
    \        result[1] = 0\n        return result\n    }\n    if number > need {\n\
    \        result[0] = number\n        result[1] = need\n        return result\n\
    \    }\n    if number < need {\n        result[0] = need\n        result[1] =\
    \ number\n        return result\n    }\n    if number == need {\n        result[0]\
    \ = number\n        result[1] = need\n        return result\n    }\n    if number\
    \ > remaining {\n        result[0] = number\n        result[1] = remaining\n \
    \       return result\n    }\n    if number < remaining {\n        result[0] =\
    \ remaining\n        result[1] = number\n        return result\n    }\n}\n\nfunc\
    \ TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmppt5px9ia_test.go:74:1: missing return

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075327
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    if number\
    \ > need {\n        carrots = number-need\n    } else {\n        carrots = need\n\
    \    }\n    if carrots > remaining {\n        carrots = remaining\n    }\n   \
    \ return []int{carrots, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate :=\
    \ eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp17cprwly_test.go:68: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp17cprwly_test.go:68:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp17cprwly_test.go:68: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp17cprwly_test.go:68: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp17cprwly_test.go:68: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=5)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp17cprwly_test.go:68:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075327
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    result\
    \ := make([]int, 2)\n    if number > 1000 || need > 1000 || remaining > 1000 {\n\
    \        fmt.Println(\"Invalid input\")\n        return nil\n    }\n    if number\
    \ == 0 {\n        result[0] = 0\n        result[1] = 0\n        return result\n\
    \    }\n    if need == 0 {\n        result[0] = 0\n        result[1] = number\n\
    \        return result\n    }\n    if remaining == 0 {\n        result[0] = number\n\
    \        result[1] = 0\n        return result\n    }\n    if number > need {\n\
    \        result[0] = number\n        result[1] = need\n        return result\n\
    \    }\n    if number < need {\n        result[0] = need\n        result[1] =\
    \ number\n        return result\n    }\n    if number == need {\n        result[0]\
    \ = number\n        result[1] = number\n        return result\n    }\n    if number\
    \ > remaining {\n        result[0] = number\n        result[1] = remaining\n \
    \       return result\n    }\n    if number < remaining {\n        result[0] =\
    \ remaining\n        result[1] = number\n        return result\n    }\n    if\
    \ number == remaining {\n        result[0] = number\n        result[1] = number\n\
    \        return result\n    }\n    if number > need && number < remaining {\n\
    \        result[0] = number\n        result[1] = remaining\n        return result\n\
    \    }\n    if number < need && number > remaining {\n        result[0] = remaining\n\
    \        result[1] = need\n        return result\n    }\n    if number == need\
    \ && number == remaining {\n        result[0] = number\n        result[1] = number\n\
    \        return result\n    }\n    if number > need && number == remaining {\n\
    \        result[0] = number\n        result[1] = need\n        return result\n\
    \    }\n    if number < need && number == remaining {\n        result[0] = need\n\
    \        result[1] = number\n        return result\n    }\n    if number == need\
    \ && number > remaining {\n        result[0] = need\n        result[1] = remaining\n\
    \        return result\n    }\n    if number > need && number == remaining {\n\
    \        result[0] = remaining\n        result[1] = need\n        return result\n\
    \    }\n    if number < need && number > remaining {\n        result[0] = remaining\n\
    \        result[1] = need\n        return result\n    }\n    if number == need\
    \ && number > remaining {\n        result[0] = need\n        result[1] = remaining\n\
    \        return result\n    }\n    if number > need && number == remaining {\n\
    \        result[0] = need\n        result[1] = remaining\n        return result\n\
    \    }\n    if number < need && number > remaining {\n        result[0] = need\n\
    \        result[1] = remaining\n        return result\n    }\n    if number ==\
    \ need && number > remaining {\n        result[0] = need\n        result[1] =\
    \ remaining\n        return result\n    }\n    if number > need && number == remaining\
    \ {\n        result[0] = need\n        result[1] = remaining\n        return result\n\
    \    }\n    if number < need && number > remaining {\n        result[0] = need\n\
    \        result[1] = remaining\n        return result\n    }\n    if number ==\
    \ need && number > remaining {\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpdwi185p1_test.go:156:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075326
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    result\
    \ := make([]int, 2)\n    if number > 1000 || need > 1000 || remaining > 1000 {\n\
    \        fmt.Println(\"Invalid input\")\n        return nil\n    }\n    carrots\
    \ := 0\n    if number > 0 {\n        carrots = number\n    }\n    if need > 0\
    \ {\n        carrots += need\n    }\n    if carrots > remaining {\n        carrots\
    \ = remaining\n    }\n    if carrots == 0 {\n        result[0] = 0\n        result[1]\
    \ = 0\n    } else {\n        result[0] = carrots\n        result[1] = carrots\
    \ - need\n    }\n    return result\n}\n\nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp0ns4ylwj_test.go:78: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=4)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp0ns4ylwj_test.go:78:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=1)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp0ns4ylwj_test.go:78: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp0ns4ylwj_test.go:78: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=-6)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmp0ns4ylwj_test.go:78: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=2)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp0ns4ylwj_test.go:78:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=-4)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075327
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    //\
    \ Your code here\n    carrots := 0\n    if number < 0 {\n        return []int{0,\
    \ 0}\n    }\n    if need < 0 {\n        return []int{0, 0}\n    }\n    if remaining\
    \ < 0 {\n        return []int{0, 0}\n    }\n    if number == 0 {\n        return\
    \ []int{0, 0}\n    }\n    if need == 0 {\n        return []int{number, 0}\n  \
    \  }\n    if remaining == 0 {\n        return []int{number, 0}\n    }\n    if\
    \ number > need {\n        return []int{0, 0}\n    }\n    if number > remaining\
    \ {\n        return []int{0, 0}\n    }\n    if number == need {\n        return\
    \ []int{number, 0}\n    }\n    if number == remaining {\n        return []int{number,\
    \ 0}\n    }\n    if number > need {\n        return []int{0, 0}\n    }\n    if\
    \ number > remaining {\n        return []int{0, 0}\n    }\n    if number == need\
    \ {\n        return []int{number, 0}\n    }\n    if number == remaining {\n  \
    \      return []int{number, 0}\n    }\n    if number > need {\n        return\
    \ []int{0, 0}\n    }\n    if number > remaining {\n        return []int{0, 0}\n\
    \    }\n    if number == need {\n        return []int{number, 0}\n    }\n    if\
    \ number == remaining {\n        return []int{number, 0}\n    }\n    if number\
    \ > need {\n        return []int{0, 0}\n    }\n    if number > remaining {\n \
    \       return []int{0, 0}\n    }\n    if number == need {\n        return []int{number,\
    \ 0}\n    }\n    if number == remaining {\n        return []int{number, 0}\n \
    \   }\n    if number > need {\n        return []int{0, 0}\n    }\n    if number\
    \ > remaining {\n        return []int{0, 0}\n    }\n    if number == need {\n\
    \        return []int{number, 0}\n    }\n    if number == remaining {\n      \
    \  return []int{number, 0}\n    }\n    if number > need {\n        return []int{0,\
    \ 0}\n    }\n    if number > remaining {\n        return []int{0, 0}\n    }\n\
    \    if number == need {\n        return []int{number, 0}\n    }\n    if number\
    \ == remaining {\n        return []int{number, 0}\n    }\n    if number > need\
    \ {\n        return []int{0, 0}\n    }\n    if number > remaining {\n        return\
    \ []int{0, 0}\n    }\n    if number == need {\n        return []int{number, 0}\n\
    \    }\n    if number == remaining {\n        return []int{number, 0}\n    }\n\
    \    if number > need {\n        return []int{0, 0}\n    }\n    if number > remaining\
    \ {\n        return []int{0, 0}\n    }\n    if number \nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpqgtfjfn8_test.go:146:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075326
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    result\
    \ := make([]int, 2)\n    if number > 1000 || need > 1000 || remaining > 1000 {\n\
    \        fmt.Println(\"Invalid input\")\n        return nil\n    }\n    if number\
    \ == 0 {\n        result[0] = 0\n        result[1] = 0\n        return result\n\
    \    }\n    if need == 0 {\n        result[0] = 0\n        result[1] = number\n\
    \        return result\n    }\n    if remaining == 0 {\n        result[0] = number\n\
    \        result[1] = need\n        return result\n    }\n    if number > need\
    \ {\n        result[0] = number\n        result[1] = need\n        return result\n\
    \    }\n    if number > remaining {\n        result[0] = number\n        result[1]\
    \ = remaining\n        return result\n    }\n    if need > remaining {\n     \
    \   result[0] = need\n        result[1] = remaining\n        return result\n \
    \   }\n    if number == need {\n        result[0] = number\n        result[1]\
    \ = need\n        return result\n    }\n    if number == remaining {\n       \
    \ result[0] = number\n        result[1] = remaining\n        return result\n \
    \   }\n    if need == remaining {\n        result[0] = need\n        result[1]\
    \ = remaining\n        return result\n    }\n    if number > need && number >\
    \ remaining {\n        result[0] = number\n        result[1] = need\n        return\
    \ result\n    }\n    if need > number && need > remaining {\n        result[0]\
    \ = need\n        result[1] = remaining\n        return result\n    }\n    if\
    \ remaining > number && remaining > need {\n        result[0] = remaining\n  \
    \      result[1] = need\n        return result\n    }\n    if number > need &&\
    \ remaining > need {\n        result[0] = number\n        result[1] = remaining\n\
    \        return result\n    }\n    if need > number && need > remaining {\n  \
    \      result[0] = need\n        result[1] = remaining\n        return result\n\
    \    }\n    if remaining > number && remaining > need {\n        result[0] = remaining\n\
    \        result[1] = need\n        return result\n    }\n    if number == need\
    \ && remaining > need {\n        result[0] = number\n        result[1] = remaining\n\
    \        return result\n    }\n    if number == remaining && need > need {\n \
    \       result[0] = number\n        result[1] = need\n        return result\n\
    \    }\n    if need == remaining && need > remaining {\n        result[0] = need\n\
    \        result[1] = remaining\n        return result\n    }\n    if number >\
    \ need && need == remaining {\n        result[0] = number\n        result[1] =\
    \ need\n        return result\n    }\n    if number > remaining && number == remaining\
    \ {\n        result[0] = number\n        result[1] = remaining\n        return\
    \ result\n    }\n    if need > number && need == remaining {\n        result[0]\
    \ = need\n        result[1] = remaining\n        return result\n    }\n    if\
    \ need > remaining && number == remaining {\n        result[0] = need\n      \
    \  result[1] = remaining\n        return result\n    }\n    if remaining > number\
    \ && number == remaining {\n        result[0] = remaining\n        result[1] =\
    \ need\n        return result\n    }\n    if remaining > need && number == remaining\
    \ {\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmprbzxlzzs_test.go:156:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075327
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    carrots := 0\n    meals := 0\n    for carrots < number {\n  \
    \      if meals < need {\n            meals++\n            carrots++\n       \
    \ } else {\n            carrots = remaining\n        }\n    }\n    return []int{carrots,\
    \ remaining}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n\
    \     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual:\
    \ candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpm2x101y1_test.go:69: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5)\
    \ %!s(int=10)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpm2x101y1_test.go:69:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=9)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpm2x101y1_test.go:69: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpm2x101y1_test.go:69: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=2) %!s(int=5)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpm2x101y1_test.go:69: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4)\
    \ %!s(int=7)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpm2x101y1_test.go:69:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=1)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075327
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    carrots := 0\n    if remaining > 0 {\n        carrots = remaining\n\
    \    }\n    if number > need {\n        carrots = number-need\n    }\n    if carrots\
    \ > 0 {\n        return []int{carrots, 0}\n    }\n    return []int{0, 0}\n}\n\n\
    func TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp56uut_sy_test.go:69: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp56uut_sy_test.go:69:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp56uut_sy_test.go:69: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp56uut_sy_test.go:69: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp56uut_sy_test.go:69: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp56uut_sy_test.go:69:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075327
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    result := make([]int, 2)\n\
    \    if number == 0 {\n        result[0] = 0\n        result[1] = 0\n        return\
    \ result\n    }\n    if remaining == 0 {\n        result[0] = number\n       \
    \ result[1] = need\n        return result\n    }\n    if number > need {\n   \
    \     result[0] = number\n        result[1] = need\n        return result\n  \
    \  }\n    if number > remaining {\n        result[0] = number\n        result[1]\
    \ = remaining\n        return result\n    }\n    if need > remaining {\n     \
    \   result[0] = need\n        result[1] = remaining\n        return result\n \
    \   }\n    if number > need && number > remaining {\n        result[0] = number\n\
    \        result[1] = need\n        return result\n    }\n    if number > need\
    \ && number > remaining {\n        result[0] = need\n        result[1] = remaining\n\
    \        return result\n    }\n    if need > number && need > remaining {\n  \
    \      result[0] = need\n        result[1] = number\n        return result\n \
    \   }\n    if need > number && need > remaining {\n        result[0] = need\n\
    \        result[1] = remaining\n        return result\n    }\n    if number >\
    \ need && number > remaining {\n        result[0] = number\n        result[1]\
    \ = need\n        return result\n    }\n    if number > need && number > remaining\
    \ {\n        result[0] = need\n        result[1] = remaining\n        return result\n\
    \    }\n    if number > need && number > remaining {\n        result[0] = number\n\
    \        result[1] = need\n        return result\n    }\n    if number > need\
    \ && number > remaining {\n        result[0] = need\n        result[1] = remaining\n\
    \        return result\n    }\n    if number > need && number > remaining {\n\
    \        result[0] = number\n        result[1] = need\n        return result\n\
    \    }\n    if number > need && number > remaining {\n        result[0] = need\n\
    \        result[1] = remaining\n        return result\n    }\n    if number >\
    \ need && number > remaining {\n        result[0] = number\n        result[1]\
    \ = need\n        return result\n    }\n    if number > need && number > remaining\
    \ {\n        result[0] = need\n        result[1] = remaining\n        return result\n\
    \    }\n    if number > need && number > remaining {\n        result[0] = number\n\
    \        result[1] = need\n        return result\n    }\n    if number > need\
    \ && number > remaining {\n        result[0] = need\n        result[1] = remaining\n\
    \        return result\n    }\n    if number > need && number > remaining {\n\
    \        result[0] = number\n        result[1] = need\n        return result\n\
    \    }\n    if number > need && number > remaining {\n        result[0] = need\n\
    \        result[1] = remaining\n        return result\n    }\n    if number >\
    \ need && number > remaining {\n        result[0] = number\n        result[1]\
    \ = need\n        return result\n    }\n    if number > need && number > remaining\
    \ {\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpln3lpo6k_test.go:151:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075327
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    if remaining == 0 {\n     \
    \   return []int{number, 0}\n    }\n    if number == 0 {\n        return []int{need,\
    \ 0}\n    }\n    if need == 0 {\n        return []int{0, remaining}\n    }\n \
    \   if number > need {\n        return []int{0, 0}\n    }\n    if number == need\
    \ {\n        return []int{number, 0}\n    }\n    if number > need {\n        return\
    \ []int{0, 0}\n    }\n    if number == need {\n        return []int{number, 0}\n\
    \    }\n    if number > need {\n        return []int{0, 0}\n    }\n    if number\
    \ == need {\n        return []int{number, 0}\n    }\n    if number > need {\n\
    \        return []int{0, 0}\n    }\n    if number == need {\n        return []int{number,\
    \ 0}\n    }\n    if number > need {\n        return []int{0, 0}\n    }\n    if\
    \ number == need {\n        return []int{number, 0}\n    }\n    if number > need\
    \ {\n        return []int{0, 0}\n    }\n    if number == need {\n        return\
    \ []int{number, 0}\n    }\n    if number > need {\n        return []int{0, 0}\n\
    \    }\n    if number == need {\n        return []int{number, 0}\n    }\n    if\
    \ number > need {\n        return []int{0, 0}\n    }\n    if number == need {\n\
    \        return []int{number, 0}\n    }\n    if number > need {\n        return\
    \ []int{0, 0}\n    }\n    if number == need {\n        return []int{number, 0}\n\
    \    }\n    if number > need {\n        return []int{0, 0}\n    }\n    if number\
    \ == need {\n        return []int{number, 0}\n    }\n    if number > need {\n\
    \        return []int{0, 0}\n    }\n    if number == need {\n        return []int{number,\
    \ 0}\n    }\n    if number > need {\n        return []int{0, 0}\n    }\n    if\
    \ number == need {\n        return []int{number, 0}\n    }\n    if number > need\
    \ {\n        return []int{0, 0}\n    }\n    if number == need {\n        return\
    \ []int{number, 0}\n    }\n    if number > need {\n        return []int{0, 0}\n\
    \    }\n    if number == need {\n        return []int{number, 0}\n    }\n    if\
    \ number > need {\n        return []int{0, 0}\n    }\n    if number == need {\n\
    \        return []int{number, 0}\n    }\n    if number > need {\n        return\
    \ []int{0, 0}\n    }\n    if number == need {\n\nfunc TestEat(t *testing.T) {\n\
    \  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected:\
    \ []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n\
    \     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual:\
    \ candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5,\
    \ 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5,\
    \ 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmppbso1la5_test.go:142:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075327
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    carrots +=\
    \ number\n    carrots += need\n    carrots += remaining\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    \nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpfr04oftk_test.go:108:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075319
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    carrots\
    \ := 0\n    carrots = number - need\n    if carrots < 0 {\n        carrots = -carrots\n\
    \    }\n    carrots = carrots + remaining\n    if carrots > 1000 {\n        carrots\
    \ = 1000\n    }\n    carrots = carrots - carrots % 10\n    carrots = carrots +\
    \ carrots % 10\n    carrots = carrots + carrots % 10\n    carrots = carrots +\
    \ carrots % 10\n    carrots = carrots + carrots % 10\n    carrots = carrots +\
    \ carrots % 10\n    carrots = carrots + carrots % 10\n    carrots = carrots +\
    \ carrots % 10\n    carrots = carrots + carrots % 10\n    carrots = carrots +\
    \ carrots % 10\n    carrots = carrots + carrots % 10\n    carrots = carrots +\
    \ carrots % 10\n    carrots = carrots + carrots % 10\n    carrots = carrots +\
    \ carrots % 10\n    carrots = carrots + carrots % 10\n    carrots = carrots +\
    \ carrots % 10\n    carrots = carrots + carrots % 10\n    carrots = carrots +\
    \ carrots % 10\n    carrots = carrots + carrots % 10\n    carrots = carrots +\
    \ carrots % 10\n    carrots = carrots + carrots % 10\n    carrots = carrots +\
    \ carrots % 10\n    carrots = carrots + carrots % 10\n    carrots = carrots +\
    \ carrots % 10\n    carrots = carrots + carrots % 10\n    carrots = carrots +\
    \ carrots % 10\n    carrots = carrots + carrots % 10\n    carrots = carrots +\
    \ carrots % 10\n    carrots = carrots + carrots % 10\n    carrots = carrots +\
    \ carrots % 10\n    carrots = carrots + carrots % 10\n    carrots = carrots +\
    \ carrots % 10\n    carrots = carrots + carrots % 10\n    carrots = carrots +\
    \ carrots % 10\n    carrots = carrots + carrots % 10\n    \nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvz6th574_test.go:80:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075327
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    carrots := 0\n    meals := 0\n    for i := 0; i < number; i++\
    \ {\n        carrots += i\n    }\n    for i := 0; i < need; i++ {\n        carrots\
    \ += i\n    }\n    for i := 0; i < remaining; i++ {\n        carrots += i\n  \
    \  }\n    meals = carrots - need\n    return []int{meals, carrots - meals}\n}\n\
    \nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp6y3arb1a_test.go:71: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=64)\
    \ %!s(int=6)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp6y3arb1a_test.go:71:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=62) %!s(int=8)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp6y3arb1a_test.go:71: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=80) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp6y3arb1a_test.go:71: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=55) %!s(int=11)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmp6y3arb1a_test.go:71: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=32)\
    \ %!s(int=5)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp6y3arb1a_test.go:71:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=11) %!s(int=5)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075327
