language: go_test.go
name: HumanEval_1_separate_paren_groups
results:
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n\
    \    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"\
    {}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    \nfunc\
    \ TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8bpr93_n_test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074002
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_group_strings := []string{}\n    paren_group_string\
    \ := \"\"\n    paren_group_count := 0\n    paren_group_open_braces := 0\n    paren_group_close_braces\
    \ := 0\n    paren_group_open_parens := 0\n    paren_group_close_parens := 0\n\
    \    paren_group_string := \"\"\n    paren_group_string := \"\"\n    paren_group_string\
    \ := \"\"\n    paren_group_string := \"\"\n    paren_group_string := \"\"\n  \
    \  paren_group_string := \"\"\n    paren_group_string := \"\"\n    paren_group_string\
    \ := \"\"\n    paren_group_string := \"\"\n    paren_group_string := \"\"\n  \
    \  paren_group_string := \"\"\n    paren_group_string := \"\"\n    paren_group_string\
    \ := \"\"\n    paren_group_string := \"\"\n    paren_group_string := \"\"\n  \
    \  paren_group_string := \"\"\n    paren_group_string := \"\"\n    paren_group_string\
    \ := \"\"\n    paren_group_string := \"\"\n    paren_group_string := \"\"\n  \
    \  paren_group_string := \"\"\n    paren_group_string := \"\"\n    paren_group_string\
    \ := \"\"\n    paren_group_string := \"\"\n    paren_group_string := \"\"\n  \
    \  paren_group_string := \"\"\n    paren_group_string := \"\"\n    paren_group_string\
    \ := \"\"\n    paren_group_string := \"\"\n    paren_group_string := \"\"\n  \
    \  paren_group_string := \"\"\n    paren_group_string := \"\"\n    paren_group_string\
    \ := \"\"\n    paren_group_string := \"\"\n    paren_group_string := \"\"\n  \
    \  paren_group_string := \"\"\n    paren_group_string := \"\"\n    paren_group_string\
    \ := \"\"\n    paren_group_string := \"\"\n    paren_group_string := \"\"\n  \
    \  paren_group_string := \"\"\n    paren_group_string := \"\"\n    paren_group_string\
    \ := \"\"\n    paren_group_string := \"\"\n    paren_group_string := \"\"\n  \
    \  paren_group_string := \"\"\n    paren_group_string := \"\"\n    paren_group_string\
    \ := \"\"\n    paren_group_string := \"\"\n    paren_group_string := \"\"\n  \
    \  paren_group_string := \"\"\n    paren_group_string := \"\"\n    paren_group_string\
    \ := \"\"\n    paren_group_string := \"\"\n    paren_group_string := \"\"\n  \
    \  paren_\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpipdjcxvl_test.go:78:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074116
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_string += \"{}\"\n    paren_string = paren_string[:len(paren_string)-1]\n\
    \    paren_string = strings.Replace(paren_string, \"( )\", \"()\", -1)\n    paren_string\
    \ = strings.Replace(paren_string, \"( )\", \"()\", -1)\n    paren_string = strings.Replace(paren_string,\
    \ \"( )\", \"()\", -1)\n    paren_string = strings.Replace(paren_string, \"( )\"\
    , \"()\", -1)\n    paren_string = strings.Replace(paren_string, \"( )\", \"()\"\
    , -1)\n    paren_string = strings.Replace(paren_string, \"( )\", \"()\", -1)\n\
    \    paren_string = strings.Replace(paren_string, \"( )\", \"()\", -1)\n    paren_string\
    \ = strings.Replace(paren_string, \"( )\", \"()\", -1)\n    paren_string = strings.Replace(paren_string,\
    \ \"( )\", \"()\", -1)\n    paren_string = strings.Replace(paren_string, \"( )\"\
    , \"()\", -1)\n    paren_string = strings.Replace(paren_string, \"( )\", \"()\"\
    , -1)\n    paren_string = strings.Replace(paren_string, \"( )\", \"()\", -1)\n\
    \    paren_string = strings.Replace(paren_string, \"( )\", \"()\", -1)\n    paren_string\
    \ = strings.Replace(paren_string, \"( )\", \"()\", -1)\n    paren_string = strings.Replace(paren_string,\
    \ \"( )\", \"()\", -1)\n    paren_string = strings.Replace(paren_string, \"( )\"\
    , \"()\", -1)\n    paren_string = strings.Replace(paren_string, \"( )\", \"()\"\
    , -1)\n    paren_string = strings.Replace(paren_string, \"( )\", \"()\", -1)\n\
    \    paren_string = strings.Replace(paren_string, \"( )\", \"()\", -1)\n    paren_string\
    \ = strings.Replace(paren_string, \"( )\", \"()\", -1)\n    paren_string = strings.Replace(paren_string,\
    \ \"( )\", \"()\", -1)\n    paren_string = strings.Replace(paren_string, \"( )\"\
    , \"()\", -1)\n    paren_string = strings.Replace(paren_string, \"( )\", \"()\"\
    , -1)\n    paren_string = strings.Replace(paren_string, \"( )\", \"()\", -1)\n\
    \    paren_string = strings.Replace(paren_string, \"( )\", \"()\", -1)\n    paren_string\
    \ = strings.Replace(paren_string, \"( )\", \"()\", -1)\n    paren_string = strings.Replace(paren_string,\
    \ \"( )\", \"()\", -1)\n    paren_string = strings.Replace(paren_string, \"( )\"\
    , \"()\", -1)\n    paren_string = strings.Replace(paren_string, \"( )\", \"()\"\
    , -1)\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpsf4bolzk_test.go:46:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074116
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_group_strings := []string{}\n    paren_group_strings\
    \ = append(paren_group_strings, paren_string)\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_group_strings = append(paren_group_strings, paren_string)\n    paren_group_strings\
    \ = append(paren_group_strings, paren_string)\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_group_strings = append(paren_group_strings, paren_string)\n    paren_group_strings\
    \ = append(paren_group_strings, paren_string)\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_group_strings = append(paren_group_strings, paren_string)\n    paren_group_strings\
    \ = append(paren_group_strings, paren_string)\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_group_strings = append(paren_group_strings, paren_string)\n    paren_group_strings\
    \ = append(paren_group_strings, paren_string)\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_group_strings = append(paren_group_strings, paren_string)\n    paren_group_strings\
    \ = append(paren_group_strings, paren_string)\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_group_strings = append(paren_group_strings, paren_string)\n    paren_group_strings\
    \ = append(paren_group_strings, paren_string)\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_group_strings = append(paren_group_strings, paren_string)\n    paren_group_strings\
    \ = append(paren_group_strings, paren_string)\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_group_string\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpo3h5w7pi_test.go:48:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074002
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    result := []string{}\n    stacks := make(map[string]bool)\n\
    \    stack := \"\"\n    for _, char := range paren_string {\n        if char ==\
    \ '(' {\n            if stack == \"\" {\n                stack = char\n      \
    \      } else {\n                stacks[stack] = true\n            }\n       \
    \ } else if char == ')' {\n            if stacks[stack] {\n                stacks[stack]\
    \ = false\n            } else {\n                fmt.Println(\"Unbalanced parenthesis\"\
    )\n            }\n        } else {\n            if stacks[stack] {\n         \
    \       stack = char\n            } else {\n                fmt.Println(\"Unbalanced\
    \ parenthesis\")\n            }\n        }\n    }\n    for _, stack := range stacks\
    \ {\n        result = append(result, stack)\n    }\n    return result\n}\n\nfunc\
    \ TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0o23q6o6_test.go:21:25: cannot use char (variable of type rune) as type
    string in assignment

    /tmp/tmp0o23q6o6_test.go:33:25: cannot use char (variable of type rune) as type
    string in assignment

    /tmp/tmp0o23q6o6_test.go:40:33: cannot use stack (variable of type bool) as type
    string in argument to append

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074117
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_group_strings := []string{}\n    paren_group_strings\
    \ = append(paren_group_strings, paren_string)\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_group_strings = append(paren_group_strings, paren_string)\n    paren_group_strings\
    \ = append(paren_group_strings, paren_string)\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_group_strings = append(paren_group_strings, paren_string)\n    paren_group_strings\
    \ = append(paren_group_strings, paren_string)\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_group_strings = append(paren_group_strings, paren_string)\n    paren_group_strings\
    \ = append(paren_group_strings, paren_string)\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_group_strings = append(paren_group_strings, paren_string)\n    paren_group_strings\
    \ = append(paren_group_strings, paren_string)\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_group_strings = append(paren_group_strings, paren_string)\n    paren_group_strings\
    \ = append(paren_group_strings, paren_string)\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_group_strings = append(paren_group_strings, paren_string)\n    paren_group_strings\
    \ = append(paren_group_strings, paren_string)\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_group_strings = append(paren_group_strings, paren_string)\n    paren_group_strings\
    \ = append(paren_group_strings, paren_string)\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_group_string\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpo3h5w7pi_test.go:48:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074002
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_group_strings := []string{}\n    paren_group_string\
    \ := \"\"\n    paren_group_open := false\n    paren_group_closed := false\n  \
    \  paren_group_count := 0\n    for _, character := range paren_string {\n    \
    \    if character == '(' {\n            if paren_group_open {\n              \
    \  fmt.Println(\"Error: unexpected open paren group\")\n                return\
    \ nil\n            }\n            paren_group_open = true\n            paren_group_string\
    \ += character\n            paren_group_count += 1\n        } else if character\
    \ == ')' {\n            if paren_group_closed {\n                fmt.Println(\"\
    Error: unexpected close paren group\")\n                return nil\n         \
    \   }\n            paren_group_closed = true\n            paren_group_string +=\
    \ character\n            paren_group_count += 1\n        } else if character ==\
    \ ' ' {\n            if paren_group_open && paren_group_closed {\n           \
    \     fmt.Println(\"Error: unexpected space in paren group\")\n              \
    \  return nil\n            }\n            paren_group_string += character\n  \
    \      } else {\n            paren_group_string += character\n        }\n    }\n\
    \    if paren_group_count != 1 {\n        fmt.Println(\"Error: unexpected number\
    \ of paren groups\")\n        return nil\n    }\n    paren_group_strings = append(paren_group_strings,\
    \ paren_group_string)\n    return paren_group_strings\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7hvxw1s7_test.go:27:13: invalid operation: paren_group_string += character
    (mismatched types string and rune)

    /tmp/tmp7hvxw1s7_test.go:35:13: invalid operation: paren_group_string += character
    (mismatched types string and rune)

    /tmp/tmp7hvxw1s7_test.go:42:13: invalid operation: paren_group_string += character
    (mismatched types string and rune)

    /tmp/tmp7hvxw1s7_test.go:44:13: invalid operation: paren_group_string += character
    (mismatched types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074117
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_group_regex := regexp.MustCompile(\"\\\\(|\\\\\
    )\")\n    paren_groups := paren_group_regex.Split(paren_string, -1)\n    result\
    \ := make([]string, len(paren_groups))\n    for i, paren_group := range paren_groups\
    \ {\n        if paren_group == \"\" {\n            continue\n        }\n     \
    \   paren_group_string := paren_group_regex.ReplaceAllString(paren_group, \"\"\
    )\n        if paren_group_string != \"\" {\n            result[i] = paren_group_string\n\
    \        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5l5lgbps_test.go:15:26: undefined: regexp

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074117
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n\
    \    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"\
    {}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    \nfunc\
    \ TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8bpr93_n_test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074002
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_group_strings := []string{}\n    paren_group_string\
    \ := \"\"\n    paren_group_open := false\n    paren_group_closed := false\n  \
    \  paren_group_count := 0\n    for _, char := range paren_string {\n        if\
    \ paren_group_open {\n            if char == ')' {\n                paren_group_closed--\n\
    \                if paren_group_closed == 0 {\n                    paren_group_strings\
    \ = append(paren_group_strings, paren_group_string)\n                    paren_group_string\
    \ = \"\"\n                    paren_group_open = false\n                    paren_group_closed\
    \ = false\n                    paren_group_count = 0\n                } else {\n\
    \                    paren_group_count++\n                }\n            } else\
    \ {\n                paren_group_string = paren_group_string+char\n          \
    \  }\n        } else if char == '(' {\n            paren_group_open = true\n \
    \           paren_group_count++\n        } else if char == ')' {\n           \
    \ paren_group_open = false\n            paren_group_closed = paren_group_count\n\
    \            paren_group_strings = append(paren_group_strings, paren_group_string)\n\
    \            paren_group_string = \"\"\n            paren_group_open = false\n\
    \            paren_group_closed = false\n            paren_group_count = 0\n \
    \       } else {\n            paren_group_string = paren_group_string+char\n \
    \       }\n    }\n    return paren_group_strings\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvnoke78e_test.go:23:17: invalid operation: paren_group_closed-- (non-numeric
    type bool)

    /tmp/tmpvnoke78e_test.go:24:42: invalid operation: paren_group_closed == 0 (mismatched
    types bool and untyped int)

    /tmp/tmpvnoke78e_test.go:34:38: invalid operation: paren_group_string + char (mismatched
    types string and rune)

    /tmp/tmpvnoke78e_test.go:41:34: cannot use paren_group_count (variable of type
    int) as type bool in assignment

    /tmp/tmpvnoke78e_test.go:48:34: invalid operation: paren_group_string + char (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074117
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_group_strings := []string{}\n    paren_group_string\
    \ := \"\"\n    paren_group_open_braces := 0\n    paren_group_close_braces := 0\n\
    \    paren_group_open_parens := 0\n    paren_group_close_parens := 0\n\n    for\
    \ _, character := range paren_string {\n        if character == \"(\" {\n    \
    \        paren_group_open_braces++\n        } else if character == \")\" {\n \
    \           paren_group_close_braces++\n        } else if character == \"(\" {\n\
    \            paren_group_open_parens++\n        } else if character == \")\" {\n\
    \            paren_group_close_parens++\n        }\n\n        if paren_group_open_braces\
    \ == paren_group_close_braces && paren_group_open_braces == paren_group_open_parens\
    \ && paren_group_close_braces == paren_group_close_parens {\n            paren_group_string\
    \ = paren_group_string[:len(paren_group_string)-1]\n            paren_group_strings\
    \ = append(paren_group_strings, paren_group_string)\n            paren_group_string\
    \ = \"\"\n            paren_group_open_braces = 0\n            paren_group_close_braces\
    \ = 0\n            paren_group_open_parens = 0\n            paren_group_close_parens\
    \ = 0\n        }\n\n        paren_group_string = paren_group_string + character\n\
    \    }\n\n    paren_group_strings = append(paren_group_strings, paren_group_string)\n\
    \    return paren_group_strings\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmppg9fr0rz_test.go:23:25: invalid operation: character == "(" (mismatched
    types rune and untyped string)

    /tmp/tmppg9fr0rz_test.go:25:32: invalid operation: character == ")" (mismatched
    types rune and untyped string)

    /tmp/tmppg9fr0rz_test.go:27:32: invalid operation: character == "(" (mismatched
    types rune and untyped string)

    /tmp/tmppg9fr0rz_test.go:29:32: invalid operation: character == ")" (mismatched
    types rune and untyped string)

    /tmp/tmppg9fr0rz_test.go:43:30: invalid operation: paren_group_string + character
    (mismatched types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074117
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_group_regex := regexp.MustCompile(\"\\\\(|\\\\\
    )\")\n    paren_groups := paren_group_regex.Split(paren_string, -1)\n    result\
    \ := make([]string, len(paren_groups))\n    for index, group := range paren_groups\
    \ {\n        if group == \"\" {\n            continue\n        }\n        result\
    \ [index] = group\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpp9ugulqx_test.go:15:26: undefined: regexp

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074117
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_groups = make([]string, 0)\n    paren_groups =\
    \ append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphobsgs_v_test.go:54:32: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074004
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_string += \")\"\n    paren_string += \"(\"\n \
    \   paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string += \")\"\
    \n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string += \"\
    )\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string +=\
    \ \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_\n\
    func TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpcvtu_s7s_test.go:80:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074002
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_groups = make([]string, 0)\n    paren_groups =\
    \ append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphobsgs_v_test.go:54:32: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074004
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_string += \")\"\n    paren_string += \"(\"\n \
    \   paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string += \")\"\
    \n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string += \"\
    )\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string +=\
    \ \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_\n\
    func TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpcvtu_s7s_test.go:80:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074002
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_groups = make([]string, 0)\n    paren_groups =\
    \ append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphobsgs_v_test.go:54:32: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074004
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_groups := []string{}\n    paren_stack := []string{}\n\
    \    paren_stack_strings := []string{}\n    paren_stack_strings_index := 0\n \
    \   paren_stack_strings_length := 0\n    paren_stack_strings_capacity := 0\n \
    \   paren_stack_strings_capacity := len(paren_stack_strings)\n\n    for _, char\
    \ := range paren_string {\n        if char == '(' {\n            paren_stack_strings[paren_stack_strings_index]\
    \ = \"\"\n            paren_stack_strings_index++\n            paren_stack_strings_length++\n\
    \            paren_stack_strings_capacity++\n            paren_stack_strings[paren_stack_strings_capacity-1]\
    \ = paren_stack_strings[paren_stack_strings_capacity-1] + char\n        } else\
    \ if char == ')' {\n            paren_stack_strings_index--\n            paren_stack_strings_length--\n\
    \            if paren_stack_strings_length == 0 {\n                paren_stack_strings\
    \ = append(paren_stack_strings, paren_stack_strings[paren_stack_strings_index])\n\
    \                paren_stack_strings_capacity--\n            }\n        } else\
    \ if char == ' ' {\n            paren_stack_strings_capacity--\n        }\n  \
    \  }\n\n    for _, string := range paren_stack_strings {\n        paren_groups\
    \ = append(paren_groups, string)\n    }\n\n    return paren_groups\n}\n\nfunc\
    \ TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxtqauk2x_test.go:16:5: paren_stack declared but not used

    /tmp/tmpxtqauk2x_test.go:21:34: no new variables on left side of :=

    /tmp/tmpxtqauk2x_test.go:29:67: invalid operation: paren_stack_strings[paren_stack_strings_capacity
    - 1] + char (mismatched types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074117
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_groups = make([]string, 0)\n    paren_groups =\
    \ append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphobsgs_v_test.go:54:32: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074004
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    // Initialize a stack to store all groups of parentheses\n\
    \    stack := make([]string, 0)\n\n    // Initialize a result to store all groups\
    \ of parentheses found\n    result := make([]string, 0)\n\n    // Iterate over\
    \ all characters in the input string\n    for _, char := range paren_string {\n\
    \        // If the character is a left parenthesis, push it to the stack\n   \
    \     if char == '(' {\n            stack = append(stack, char)\n        }\n\n\
    \        // If the character is a right parenthesis, pop it from the stack\n \
    \       if char == ')' {\n            stack := stack[:len(stack)-1]\n        }\n\
    \n        // If the stack is empty, then the parentheses has been found\n    \
    \    if len(stack) == 0 {\n            result = append(result, char)\n       \
    \ }\n    }\n\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp81zktdo2_test.go:25:35: cannot use char (variable of type rune) as type
    string in argument to append

    /tmp/tmp81zktdo2_test.go:30:13: stack declared but not used

    /tmp/tmp81zktdo2_test.go:35:37: cannot use char (variable of type rune) as type
    string in argument to append

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074117
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_group_strings := []string{}\n    paren_group_string\
    \ := \"\"\n    paren_group_open := false\n    paren_group_closed := false\n  \
    \  for _, char := range paren_string {\n        if char == '(' {\n           \
    \ if paren_group_open {\n                fmt.Println(\"Error: unexpected open\
    \ paren group\")\n            }\n            paren_group_open = true\n       \
    \     paren_group_string += char\n        } else if char == ')' {\n          \
    \  if paren_group_closed {\n                fmt.Println(\"Error: unexpected close\
    \ paren group\")\n            }\n            paren_group_closed = true\n     \
    \       paren_group_string += char\n        } else if char == ' ' {\n        \
    \    if paren_group_open && paren_group_closed {\n                paren_group_strings\
    \ = append(paren_group_strings, paren_group_string)\n                paren_group_string\
    \ = \"\"\n            }\n        } else {\n            paren_group_string += char\n\
    \        }\n    }\n    if paren_group_open {\n        fmt.Println(\"Error: unexpected\
    \ open paren group\")\n    }\n    if paren_group_closed {\n        fmt.Println(\"\
    Error: unexpected close paren group\")\n    }\n    return paren_group_strings\n\
    }\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpwwmb5bu9_test.go:25:13: invalid operation: paren_group_string += char
    (mismatched types string and rune)

    /tmp/tmpwwmb5bu9_test.go:31:13: invalid operation: paren_group_string += char
    (mismatched types string and rune)

    /tmp/tmpwwmb5bu9_test.go:38:13: invalid operation: paren_group_string += char
    (mismatched types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074117
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_groups = make(map[string][]string)\n    paren_stack\
    \ = make([]string, 0)\n    paren_stack = append(paren_stack, paren_string)\n \
    \   for len(paren_stack) > 0 {\n        paren_str = paren_stack[len(paren_stack)-1]\n\
    \        paren_stack = paren_stack[:len(paren_stack)-1]\n        paren_groups[paren_str]\
    \ = append(paren_groups[paren_str], paren_str)\n    }\n    return paren_groups[\"\
    \"]\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmez2dy0z_test.go:15:5: undefined: paren_groups

    /tmp/tmpmez2dy0z_test.go:16:5: undefined: paren_stack

    /tmp/tmpmez2dy0z_test.go:17:26: undefined: paren_stack

    /tmp/tmpmez2dy0z_test.go:18:13: undefined: paren_stack

    /tmp/tmpmez2dy0z_test.go:19:9: undefined: paren_str

    /tmp/tmpmez2dy0z_test.go:19:21: undefined: paren_stack

    /tmp/tmpmez2dy0z_test.go:20:23: undefined: paren_stack

    /tmp/tmpmez2dy0z_test.go:21:9: undefined: paren_groups

    /tmp/tmpmez2dy0z_test.go:21:42: undefined: paren_groups

    /tmp/tmpmez2dy0z_test.go:21:55: undefined: paren_str

    /tmp/tmpmez2dy0z_test.go:21:9: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074117
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_string += \")\"\n    paren_string += \"(\"\n \
    \   paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\
    \n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string += \"\
    (\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8clhzg06_test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074002
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_string += \"{}\"\n    paren_string = paren_string[:len(paren_string)-1]\n\
    \    paren_string = paren_string[:len(paren_string)-1]\n    paren_string = paren_string[:len(paren_string)-1]\n\
    \    paren_string = paren_string[:len(paren_string)-1]\n    paren_string = paren_string[:len(paren_string)-1]\n\
    \    paren_string = paren_string[:len(paren_string)-1]\n    paren_string = paren_string[:len(paren_string)-1]\n\
    \    paren_string = paren_string[:len(paren_string)-1]\n    paren_string = paren_string[:len(paren_string)-1]\n\
    \    paren_string = paren_string[:len(paren_string)-1]\n    paren_string = paren_string[:len(paren_string)-1]\n\
    \    paren_string = paren_string[:len(paren_string)-1]\n    paren_string = paren_string[:len(paren_string)-1]\n\
    \    paren_string = paren_string[:len(paren_string)-1]\n    paren_string = paren_string[:len(paren_string)-1]\n\
    \    paren_string = paren_string[:len(paren_string)-1]\n    paren_string = paren_string[:len(paren_string)-1]\n\
    \    paren_string = paren_string[:len(paren_string)-1]\n    paren_string = paren_string[:len(paren_string)-1]\n\
    \    paren_string = paren_string[:len(paren_string)-1]\n    paren_string = paren_string[:len(paren_string)-1]\n\
    \    paren_string = paren_string[:len(paren_string)-1]\n    paren_string = paren_string[:len(paren_string)-1]\n\
    \    paren_string = paren_string[:len(paren_string)-1]\n    paren_string = paren_string[:len(paren_string)-1]\n\
    \    paren_string = paren_string[:len(paren_string)-1]\n    paren_string = paren_string[:len(paren_string)-1]\n\
    \    paren_string = paren_string[:len(paren_string)-1]\n    paren_string = paren_string[:len(paren_string)-1]\n\
    \    paren_string = paren_string[:len(paren_string)-1]\n    paren_string = paren_string[:len(paren_string)-1]\n\
    \    paren_string = paren_string[:len(paren_string)-1]\n    paren_string = paren_string[:len(paren_string)-1]\n\
    \    paren_string = paren_string[:len(paren_string)-1]\n    paren_string = paren_string[:len(paren_string)-1]\n\
    \    paren_string = paren_string[:len(paren_string)-1]\n    paren_string = paren_string[:len(paren_string)-1]\n\
    \    paren_string = paren_string[:len(paren_string)-1]\n    paren_string = paren_string[:len(paren_string)\n\
    func TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpjck4ocpw_test.go:54:51: expected '']'', found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074116
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    var result []string\n    stacks := make(map[string]bool)\n\
    \    stack := \"\"\n    for _, char := range paren_string {\n        if char ==\
    \ '(' {\n            stacks[stack] = true\n            stack = stack + char\n\
    \        } else if char == ')' {\n            if stacks[stack] {\n           \
    \     stack = stack[:len(stack)-1]\n            } else {\n                result\
    \ = append(result, stack)\n                stack = \"\"\n            }\n     \
    \       stacks[stack] = false\n        } else {\n            stack = stack + char\n\
    \        }\n    }\n    if stack != \"\" {\n        result = append(result, stack)\n\
    \    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n\
    \  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvb_yukzk_test.go:21:21: invalid operation: stack + char (mismatched types
    string and rune)

    /tmp/tmpvb_yukzk_test.go:31:21: invalid operation: stack + char (mismatched types
    string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074117
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    result := []string{}\n    stack := []string{}\n    open_braces\
    \ := 0\n    close_braces := 0\n    brace_count := 0\n    brace_count := 0\n  \
    \  for _, char := range paren_string {\n        if char == '(' {\n           \
    \ open_braces++\n            stack = append(stack, char)\n        } else if char\
    \ == ')' {\n            close_braces++\n            if open_braces != close_braces\
    \ {\n                fmt.Println(\"Mismatch in brace count\")\n            }\n\
    \            if open_braces == close_braces {\n                brace_count++\n\
    \            }\n            if open_braces > close_braces {\n                fmt.Println(\"\
    Mismatch in brace count\")\n            }\n            if open_braces == close_braces\
    \ {\n                brace_count++\n            }\n            if open_braces\
    \ == close_braces {\n                brace_count++\n            }\n          \
    \  if open_braces == close_braces {\n                brace_count++\n         \
    \   }\n            if open_braces == close_braces {\n                brace_count++\n\
    \            }\n            if open_braces == close_braces {\n               \
    \ brace_count++\n            }\n            if open_braces == close_braces {\n\
    \                brace_count++\n            }\n            if open_braces == close_braces\
    \ {\n                brace_count++\n            }\n            if open_braces\
    \ == close_braces {\n                brace_count++\n            }\n          \
    \  if open_braces == close_braces {\n                brace_count++\n         \
    \   }\n            if open_braces == close_braces {\n                brace_count++\n\
    \            }\n            if open_braces == close_braces {\n               \
    \ brace_count++\n            }\n            if open_braces == close_braces {\n\
    \                brace_count++\n            }\n            if open_braces == close_braces\
    \ {\n                brace_count++\n            }\n            if open_braces\
    \ == close_braces {\n                brace_count++\n            }\n          \
    \  if open_braces == close_braces {\n                brace_count++\n         \
    \   }\n            if open_braces == close_braces {\n                brace_count++\n\
    \            }\n            if open_braces == close_braces {\n               \
    \ brace_count++\n            }\n            if open_braces == close_braces {\n\
    \                brace_count++\n            }\n            if open_braces == close_braces\
    \ {\n                brace_count++\n            }\n            if open_braces\
    \ == close_braces {\n                brace_count\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpc6qnndf3_test.go:95:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074116
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_string += \")\"\n    paren_string += \"(\"\n \
    \   paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\
    \n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string += \"\
    (\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8clhzg06_test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074002
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_groups := []string{}\n    paren_group := \"\"\n\
    \    paren_group_count := 0\n    for _, char := range paren_string {\n       \
    \ if char == '(' {\n            paren_group += char\n            paren_group_count++\n\
    \        } else if char == ')' {\n            paren_group += char\n          \
    \  paren_group_count--\n            if paren_group_count == 0 {\n            \
    \    paren_groups = append(paren_groups, paren_group)\n                paren_group\
    \ = \"\"\n            }\n        }\n    }\n    return paren_groups\n}\n\nfunc\
    \ TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpgn6een6v_test.go:20:13: invalid operation: paren_group += char (mismatched
    types string and rune)

    /tmp/tmpgn6een6v_test.go:23:13: invalid operation: paren_group += char (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074117
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    result := []string{}\n    stack := []string{}\n    open_braces\
    \ := 0\n    close_braces := 0\n    brace_count := 0\n    brace_type := 0\n   \
    \ brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type :=\
    \ 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpzyk5wn5l_test.go:88:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074002
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_string += \")\"\n    paren_string += \"(\"\n \
    \   paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\
    \n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string += \"\
    (\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8clhzg06_test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074002
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_group_strings := []string{}\n    paren_group_string\
    \ := \"\"\n    paren_group_open := false\n    paren_group_closed := false\n  \
    \  paren_group_string += \"(\"\n    paren_group_open = true\n    for _, char :=\
    \ range paren_string {\n        if paren_group_open {\n            if char ==\
    \ \")\" {\n                paren_group_open = false\n                paren_group_closed\
    \ = true\n                paren_group_string += \")\"\n            } else {\n\
    \                paren_group_string += char\n            }\n        } else if\
    \ char == \" \" {\n            if paren_group_closed {\n                paren_group_strings\
    \ = append(paren_group_strings, paren_group_string)\n                paren_group_string\
    \ = \"\"\n            }\n        } else {\n            paren_group_string += char\n\
    \        }\n    }\n    if paren_group_string != \"\" {\n        paren_group_strings\
    \ = append(paren_group_strings, paren_group_string)\n    }\n    return paren_group_strings\n\
    }\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpl7st29eh_test.go:23:24: invalid operation: char == ")" (mismatched types
    rune and untyped string)

    /tmp/tmpl7st29eh_test.go:28:17: invalid operation: paren_group_string += char
    (mismatched types string and rune)

    /tmp/tmpl7st29eh_test.go:30:27: invalid operation: char == " " (mismatched types
    rune and untyped string)

    /tmp/tmpl7st29eh_test.go:36:13: invalid operation: paren_group_string += char
    (mismatched types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074117
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_group_strings := []string{}\n    paren_group_string\
    \ := \"\"\n    paren_group_open := false\n    paren_group_closed := false\n  \
    \  for _, char := range paren_string {\n        if char == '(' {\n           \
    \ if paren_group_open {\n                fmt.Println(\"Error: unexpected open\
    \ paren group\")\n                fmt.Println(\"Paren group string:\", paren_group_string)\n\
    \                fmt.Println(\"Paren group open:\", paren_group_open)\n      \
    \          fmt.Println(\"Paren group closed:\", paren_group_closed)\n        \
    \        fmt.Println(\"Paren group strings:\", paren_group_strings)\n        \
    \        fmt.Println(\"Paren group string:\", paren_group_string)\n          \
    \      fmt.Println(\"Paren group open:\", paren_group_open)\n                fmt.Println(\"\
    Paren group closed:\", paren_group_closed)\n                return nil\n     \
    \       }\n            paren_group_open = true\n            paren_group_string\
    \ += char\n        } else if char == ')' {\n            if paren_group_closed\
    \ {\n                fmt.Println(\"Error: unexpected close paren group\")\n  \
    \              fmt.Println(\"Paren group string:\", paren_group_string)\n    \
    \            fmt.Println(\"Paren group open:\", paren_group_open)\n          \
    \      fmt.Println(\"Paren group closed:\", paren_group_closed)\n            \
    \    fmt.Println(\"Paren group strings:\", paren_group_strings)\n            \
    \    fmt.Println(\"Paren group string:\", paren_group_string)\n              \
    \  fmt.Println(\"Paren group open:\", paren_group_open)\n                fmt.Println(\"\
    Paren group closed:\", paren_group_closed)\n                return nil\n     \
    \       }\n            paren_group_closed = true\n            paren_group_string\
    \ += char\n        } else if char == ' ' {\n            if paren_group_open {\n\
    \                paren_group_string = paren_group_string[:len(paren_group_string)-1]\n\
    \                paren_group_strings = append(paren_group_strings, paren_group_string)\n\
    \                paren_group_string = \"\"\n                paren_group_open =\
    \ false\n            }\n        } else if char == ')' {\n            if paren_group_closed\
    \ {\n                paren_group_string = paren_group_string[:len(paren_group_string)-1]\n\
    \                paren_group_strings = append(paren_group_strings, paren_group_string)\n\
    \                paren_group_string = \"\"\n                paren_group_closed\
    \ = false\n            }\n        } else {\n            paren_group_string +=\
    \ char\n        }\n    }\n    if paren_group_\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpku0g0bfc_test.go:67:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074116
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_string += \")\"\n    paren_string += \"(\"\n \
    \   paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\
    \n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string += \"\
    (\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8clhzg06_test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074002
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_string += \")\"\n    paren_string += \"(\"\n \
    \   paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string += \")\"\
    \n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string += \"\
    )\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string +=\
    \ \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_\n\
    func TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpcvtu_s7s_test.go:80:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074002
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_group_strings := []string{}\n    paren_group_string\
    \ := \"\"\n    paren_group_open := false\n    paren_group_closed := false\n  \
    \  for _, char := range paren_string {\n        if char == '(' {\n           \
    \ if paren_group_open {\n                fmt.Println(\"Error: unexpected open\
    \ paren group\")\n            }\n            paren_group_open = true\n       \
    \     paren_group_string += char\n        } else if char == ')' {\n          \
    \  if paren_group_closed {\n                fmt.Println(\"Error: unexpected close\
    \ paren group\")\n            }\n            paren_group_closed = true\n     \
    \       paren_group_string += char\n        } else if char == ' ' {\n        \
    \    if paren_group_open {\n                paren_group_string += char\n     \
    \       } else if paren_group_closed {\n                paren_group_strings =\
    \ append(paren_group_strings, paren_group_string)\n                paren_group_string\
    \ = \"\"\n                paren_group_open = false\n                paren_group_closed\
    \ = false\n            } else {\n                fmt.Println(\"Error: unexpected\
    \ space\")\n            }\n        } else {\n            paren_group_string +=\
    \ char\n        }\n    }\n    if paren_group_open {\n        fmt.Println(\"Error:\
    \ unexpected open paren group\")\n    }\n    if paren_group_closed {\n       \
    \ fmt.Println(\"Error: unexpected close paren group\")\n    }\n    return paren_group_strings\n\
    }\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpywsnlyjh_test.go:25:13: invalid operation: paren_group_string += char
    (mismatched types string and rune)

    /tmp/tmpywsnlyjh_test.go:31:13: invalid operation: paren_group_string += char
    (mismatched types string and rune)

    /tmp/tmpywsnlyjh_test.go:34:17: invalid operation: paren_group_string += char
    (mismatched types string and rune)

    /tmp/tmpywsnlyjh_test.go:44:13: invalid operation: paren_group_string += char
    (mismatched types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074117
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_string += \")\"\n    paren_string += \"(\"\n \
    \   paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\
    \n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string += \"\
    (\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8clhzg06_test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074002
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_group_strings := []string{}\n    paren_group_string\
    \ := \"\"\n    paren_group_open_braces := 0\n    paren_group_close_braces := 0\n\
    \    for _, character := range paren_string {\n        if character == '(' {\n\
    \            paren_group_open_braces++\n        } else if character == ')' {\n\
    \            paren_group_close_braces++\n        } else if character == ' ' {\n\
    \            continue\n        } else if paren_group_open_braces > 0 && paren_group_close_braces\
    \ > 0 {\n            if paren_group_open_braces > paren_group_close_braces {\n\
    \                paren_group_string = paren_group_string + character\n       \
    \     } else {\n                paren_group_strings = append(paren_group_strings,\
    \ paren_group_string)\n                paren_group_string = \"\"\n           \
    \     paren_group_open_braces = 0\n                paren_group_close_braces =\
    \ 0\n            }\n        } else if paren_group_open_braces > 0 {\n        \
    \    paren_group_string = paren_group_string + character\n        } else {\n \
    \           paren_group_strings = append(paren_group_strings, paren_group_string)\n\
    \            paren_group_string = \"\"\n            paren_group_open_braces =\
    \ 0\n            paren_group_close_braces = 0\n        }\n    }\n    paren_group_strings\
    \ = append(paren_group_strings, paren_group_string)\n    return paren_group_strings\n\
    }\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0apuljh8_test.go:28:38: invalid operation: paren_group_string + character
    (mismatched types string and rune)

    /tmp/tmp0apuljh8_test.go:36:34: invalid operation: paren_group_string + character
    (mismatched types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074117
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    // Initialize a list to store the result\n    result\
    \ := make([]string, 0)\n\n    // Iterate over each character in the string\n \
    \   for _, c := range paren_string {\n        // If the character is a left paren,\
    \ add it to the list\n        if c == '(' {\n            result = append(result,\
    \ c)\n        }\n\n        // If the character is a right paren, remove it from\
    \ the list\n        if c == ')' {\n            result = removeElementFromList(result,\
    \ c)\n        }\n    }\n\n    // Return the result\n    return result\n}\n\nfunc\
    \ TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphf_zfjyj_test.go:22:37: cannot use c (variable of type rune) as type string
    in argument to append

    /tmp/tmphf_zfjyj_test.go:27:22: undefined: removeElementFromList

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074117
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_group_strings := []string{}\n    paren_group_string\
    \ := \"\"\n    paren_group_open := false\n    paren_group_closed := false\n  \
    \  paren_group_string += \"(\"\n    paren_group_open = true\n    for _, char :=\
    \ range paren_string {\n        if char == \")\" {\n            if paren_group_open\
    \ {\n                paren_group_string += \")\"\n                paren_group_open\
    \ = false\n                paren_group_closed = true\n            } else {\n \
    \               paren_group_strings = append(paren_group_strings, paren_group_string)\n\
    \                paren_group_string = \"\"\n                paren_group_open =\
    \ false\n                paren_group_closed = false\n            }\n        }\
    \ else if char == \"(\" {\n            if paren_group_open {\n               \
    \ paren_group_string += \"(\"\n                paren_group_open = true\n     \
    \       } else {\n                paren_group_strings = append(paren_group_strings,\
    \ paren_group_string)\n                paren_group_string = \"\"\n           \
    \     paren_group_open = true\n                paren_group_closed = false\n  \
    \          }\n        } else if char == \" \" {\n            if paren_group_open\
    \ {\n                paren_group_string += \" \"\n            } else {\n     \
    \           paren_group_strings = append(paren_group_strings, paren_group_string)\n\
    \                paren_group_string = \"\"\n                paren_group_open =\
    \ false\n                paren_group_closed = false\n            }\n        }\
    \ else {\n            if paren_group_open {\n                paren_group_string\
    \ += string(char)\n            } else {\n                paren_group_strings =\
    \ append(paren_group_strings, paren_group_string)\n                paren_group_string\
    \ = \"\"\n                paren_group_open = false\n                paren_group_closed\
    \ = false\n            }\n        }\n    }\n    if paren_group_open {\n      \
    \  paren_group_strings = append(paren_group_strings, paren_group_string)\n   \
    \ }\n    return paren_group_strings\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_e3p038l_test.go:18:5: paren_group_closed declared but not used

    /tmp/tmp_e3p038l_test.go:22:20: invalid operation: char == ")" (mismatched types
    rune and untyped string)

    /tmp/tmp_e3p038l_test.go:33:27: invalid operation: char == "(" (mismatched types
    rune and untyped string)

    /tmp/tmp_e3p038l_test.go:43:27: invalid operation: char == " " (mismatched types
    rune and untyped string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074117
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    result := []string{}\n    stacks := [][]string{}\n \
    \   stack := []string{}\n    open_braces := 0\n    close_braces := 0\n    brace_count\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type \nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpjt6yvk4n_test.go:88:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074116
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n\
    \    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"\
    {}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    \nfunc\
    \ TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8bpr93_n_test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074002
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_group_strings := []string{}\n    paren_group_string\
    \ := \"\"\n    paren_group_open := false\n    paren_group_closed := false\n  \
    \  for _, char := range paren_string {\n        if char == '(' {\n           \
    \ if paren_group_open {\n                fmt.Println(\"Error: unexpected open\
    \ paren group\")\n            }\n            paren_group_open = true\n       \
    \     paren_group_string += char\n        } else if char == ')' {\n          \
    \  if paren_group_closed {\n                fmt.Println(\"Error: unexpected close\
    \ paren group\")\n            }\n            paren_group_closed = true\n     \
    \       paren_group_string += char\n        } else if char == ' ' {\n        \
    \    if paren_group_open {\n                paren_group_string += char\n     \
    \       } else if paren_group_closed {\n                paren_group_strings =\
    \ append(paren_group_strings, paren_group_string)\n                paren_group_string\
    \ = \"\"\n                paren_group_open = false\n                paren_group_closed\
    \ = false\n            } else {\n                fmt.Println(\"Error: unexpected\
    \ space\")\n            }\n        } else {\n            paren_group_string +=\
    \ char\n        }\n    }\n    if paren_group_open {\n        fmt.Println(\"Error:\
    \ unexpected open paren group\")\n    }\n    if paren_group_closed {\n       \
    \ fmt.Println(\"Error: unexpected close paren group\")\n    }\n    return paren_group_strings\n\
    }\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpywsnlyjh_test.go:25:13: invalid operation: paren_group_string += char
    (mismatched types string and rune)

    /tmp/tmpywsnlyjh_test.go:31:13: invalid operation: paren_group_string += char
    (mismatched types string and rune)

    /tmp/tmpywsnlyjh_test.go:34:17: invalid operation: paren_group_string += char
    (mismatched types string and rune)

    /tmp/tmpywsnlyjh_test.go:44:13: invalid operation: paren_group_string += char
    (mismatched types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074117
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n\
    \    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"\
    {}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    \nfunc\
    \ TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8bpr93_n_test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074002
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_groups := []string{}\n    paren_group := \"\"\n\
    \    paren_group_is_open := false\n    for _, char := range paren_string {\n \
    \       if char == '(' {\n            if paren_group_is_open {\n             \
    \   fmt.Println(\"Found open paren group\", paren_group)\n                paren_groups\
    \ = append(paren_groups, paren_group)\n                paren_group = \"\"\n  \
    \              paren_group_is_open = false\n            }\n            paren_group_is_open\
    \ = true\n        } else if char == ')' {\n            if paren_group_is_open\
    \ {\n                fmt.Println(\"Found close paren group\", paren_group)\n \
    \               paren_groups = append(paren_groups, paren_group)\n           \
    \     paren_group = \"\"\n                paren_group_is_open = false\n      \
    \      }\n        } else if char == ' ' {\n            if paren_group_is_open\
    \ {\n                fmt.Println(\"Found space in paren group\", paren_group)\n\
    \                paren_groups = append(paren_groups, paren_group)\n          \
    \      paren_group = \"\"\n                paren_group_is_open = false\n     \
    \       }\n        } else {\n            paren_group += char\n        }\n    }\n\
    \    if paren_group_is_open {\n        fmt.Println(\"Found open paren group\"\
    , paren_group)\n        paren_groups = append(paren_groups, paren_group)\n   \
    \ }\n    return paren_groups\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp76ps3syh_test.go:42:13: invalid operation: paren_group += char (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074118
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_string += \")\"\n    paren_string += \"(\"\n \
    \   paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\
    \n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string += \"\
    (\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8clhzg06_test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074002
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_group_strings := []string{}\n    paren_group_string\
    \ := \"\"\n    paren_group_open := false\n    paren_group_closed := false\n  \
    \  paren_group_string += \"(\"\n    paren_group_open = true\n    for _, char :=\
    \ range paren_string {\n        if paren_group_open {\n            paren_group_string\
    \ += char\n            if char == \")\" {\n                paren_group_open =\
    \ false\n                paren_group_closed = true\n                paren_group_strings\
    \ = append(paren_group_strings, paren_group_string)\n                paren_group_string\
    \ = \"\"\n            } else if char == \" \" {\n                paren_group_string\
    \ = \"\"\n            } else {\n                paren_group_string = \"\"\n  \
    \          }\n        } else {\n            if char == \")\" {\n             \
    \   paren_group_open = true\n                paren_group_closed = false\n    \
    \            paren_group_strings = append(paren_group_strings, paren_group_string)\n\
    \                paren_group_string = \"\"\n            } else {\n           \
    \     paren_group_string = \"\"\n            }\n        }\n    }\n    if paren_group_open\
    \ {\n        paren_group_strings = append(paren_group_strings, paren_group_string)\n\
    \    }\n    return paren_group_strings\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpzn9k7xj5_test.go:18:5: paren_group_closed declared but not used

    /tmp/tmpzn9k7xj5_test.go:23:13: invalid operation: paren_group_string += char
    (mismatched types string and rune)

    /tmp/tmpzn9k7xj5_test.go:24:24: invalid operation: char == ")" (mismatched types
    rune and untyped string)

    /tmp/tmpzn9k7xj5_test.go:29:31: invalid operation: char == " " (mismatched types
    rune and untyped string)

    /tmp/tmpzn9k7xj5_test.go:35:24: invalid operation: char == ")" (mismatched types
    rune and untyped string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074118
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_group_strings := []string{}\n    paren_group_string\
    \ := \"\"\n    paren_group_open := false\n    paren_group_closed := false\n  \
    \  for _, char := range paren_string {\n        if char == '(' {\n           \
    \ if paren_group_open {\n                fmt.Println(\"Error: unexpected open\
    \ paren group\")\n            }\n            paren_group_open = true\n       \
    \     paren_group_string += char\n        } else if char == ')' {\n          \
    \  if paren_group_closed {\n                fmt.Println(\"Error: unexpected close\
    \ paren group\")\n            }\n            paren_group_closed = true\n     \
    \       paren_group_string += char\n        } else if char == ' ' {\n        \
    \    if paren_group_open && paren_group_closed {\n                paren_group_strings\
    \ = append(paren_group_strings, paren_group_string)\n                paren_group_string\
    \ = \"\"\n            }\n        } else {\n            paren_group_string += char\n\
    \        }\n    }\n    if paren_group_open {\n        fmt.Println(\"Error: unexpected\
    \ open paren group\")\n    }\n    if paren_group_closed {\n        fmt.Println(\"\
    Error: unexpected close paren group\")\n    }\n    return paren_group_strings\n\
    }\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpwwmb5bu9_test.go:25:13: invalid operation: paren_group_string += char
    (mismatched types string and rune)

    /tmp/tmpwwmb5bu9_test.go:31:13: invalid operation: paren_group_string += char
    (mismatched types string and rune)

    /tmp/tmpwwmb5bu9_test.go:38:13: invalid operation: paren_group_string += char
    (mismatched types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074117
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    // Initialize a stack to keep track of which parenthesis\
    \ we're currently in\n    var paren_stack = []string{}\n\n    // Initialize a\
    \ result list to hold the result\n    var result_list []string\n\n    // Iterate\
    \ over the input string and add each character to the stack\n    for _, c := range\
    \ paren_string {\n        if c == '(' {\n            // If we're currently in\
    \ a parenthesis, add it to the stack\n            if paren_stack[len(paren_stack)-1]\
    \ != \"\" {\n                paren_stack = append(paren_stack, \"\")\n       \
    \     }\n        } else if c == ')' {\n            // If we're currently in a\
    \ parenthesis, pop the stack\n            if paren_stack[len(paren_stack)-1] !=\
    \ \"\" {\n                paren_stack = paren_stack[:len(paren_stack)-1]\n   \
    \         }\n        } else {\n            // If we're not in a parenthesis, just\
    \ add the character to the stack\n            paren_stack = append(paren_stack,\
    \ c)\n        }\n    }\n\n    // Iterate over the stack and add each element to\
    \ the result list\n    for _, s := range paren_stack {\n        if s != \"\" {\n\
    \            result_list = append(result_list, s)\n        }\n    }\n\n    return\
    \ result_list\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpsmnb2r0__test.go:35:47: cannot use c (variable of type rune) as type string
    in argument to append

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074118
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_group_strings := make([]string, 0)\n    paren_group_strings\
    \ = append(paren_group_strings, paren_string)\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_group_strings = append(paren_group_strings, paren_string)\n    paren_group_strings\
    \ = append(paren_group_strings, paren_string)\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_group_strings = append(paren_group_strings, paren_string)\n    paren_group_strings\
    \ = append(paren_group_strings, paren_string)\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_group_strings = append(paren_group_strings, paren_string)\n    paren_group_strings\
    \ = append(paren_group_strings, paren_string)\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_group_strings = append(paren_group_strings, paren_string)\n    paren_group_strings\
    \ = append(paren_group_strings, paren_string)\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_group_strings = append(paren_group_strings, paren_string)\n    paren_group_strings\
    \ = append(paren_group_strings, paren_string)\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_group_strings = append(paren_group_strings, paren_string)\n    paren_group_strings\
    \ = append(paren_group_strings, paren_string)\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_group_strings = append(paren_group_strings, paren_string)\n    paren_group_strings\
    \ = append(paren_group_strings, paren_string)\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp705dn0ck_test.go:48:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074117
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    result := []string{}\n    stack := []string{}\n    open_braces\
    \ := 0\n    close_braces := 0\n    for _, char := range paren_string {\n     \
    \   if char == '(' {\n            open_braces++\n            stack = append(stack,\
    \ char)\n        } else if char == ')' {\n            close_braces++\n       \
    \     if open_braces == close_braces {\n                open_braces = 0\n    \
    \            stack = stack[:len(stack)-1]\n                result := append(result,\
    \ string(stack))\n            }\n        }\n    }\n    return result\n}\n\nfunc\
    \ TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpljq0rj7z_test.go:22:35: cannot use char (variable of type rune) as type
    string in argument to append

    /tmp/tmpljq0rj7z_test.go:28:17: result declared but not used

    /tmp/tmpljq0rj7z_test.go:28:49: cannot convert stack (variable of type []string)
    to type string

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074118
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_string += \")\"\n    paren_string += \"(\"\n \
    \   paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\
    \n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string += \"\
    (\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8clhzg06_test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074002
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    // Initialize a slice to hold our results\n    result\
    \ := make([]string, 0)\n\n    // Iterate over the input string\n    for _, character\
    \ := range paren_string {\n        // If the character is a left paren, add it\
    \ to the result slice\n        if character == '(' {\n            result = append(result,\
    \ character)\n        }\n        // If the character is a right paren, remove\
    \ it from the result slice\n        if character == ')' {\n            result\
    \ = removeElement(result, character)\n        }\n    }\n\n    // Return the result\
    \ slice\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpgdaiylj2_test.go:22:37: cannot use character (variable of type rune) as
    type string in argument to append

    /tmp/tmpgdaiylj2_test.go:26:22: undefined: removeElement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074118
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_string += \")\"\n    paren_string += \"(\"\n \
    \   paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\
    \n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string += \"\
    (\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8clhzg06_test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074002
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    result := make([]string, 0)\n    stack := make([]string,\
    \ 0)\n    open_braces := 0\n    close_braces := 0\n    brace_count := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    bra\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpre1ad6uy_test.go:88:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074009
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_group_strings := []string{}\n    paren_group :=\
    \ \"\"\n    paren_group_open := false\n    paren_group_closed := false\n    paren_group_string\
    \ := \"\"\n    paren_group_string := \"\"\n    paren_group_string := \"\"\n  \
    \  paren_group_string := \"\"\n    paren_group_string := \"\"\n    paren_group_string\
    \ := \"\"\n    paren_group_string := \"\"\n    paren_group_string := \"\"\n  \
    \  paren_group_string := \"\"\n    paren_group_string := \"\"\n    paren_group_string\
    \ := \"\"\n    paren_group_string := \"\"\n    paren_group_string := \"\"\n  \
    \  paren_group_string := \"\"\n    paren_group_string := \"\"\n    paren_group_string\
    \ := \"\"\n    paren_group_string := \"\"\n    paren_group_string := \"\"\n  \
    \  paren_group_string := \"\"\n    paren_group_string := \"\"\n    paren_group_string\
    \ := \"\"\n    paren_group_string := \"\"\n    paren_group_string := \"\"\n  \
    \  paren_group_string := \"\"\n    paren_group_string := \"\"\n    paren_group_string\
    \ := \"\"\n    paren_group_string := \"\"\n    paren_group_string := \"\"\n  \
    \  paren_group_string := \"\"\n    paren_group_string := \"\"\n    paren_group_string\
    \ := \"\"\n    paren_group_string := \"\"\n    paren_group_string := \"\"\n  \
    \  paren_group_string := \"\"\n    paren_group_string := \"\"\n    paren_group_string\
    \ := \"\"\n    paren_group_string := \"\"\n    paren_group_string := \"\"\n  \
    \  paren_group_string := \"\"\n    paren_group_string := \"\"\n    paren_group_string\
    \ := \"\"\n    paren_group_string := \"\"\n    paren_group_string := \"\"\n  \
    \  paren_group_string := \"\"\n    paren_group_string := \"\"\n    paren_group_string\
    \ := \"\"\n    paren_group_string := \"\"\n    paren_group_string := \"\"\n  \
    \  paren_group_string := \"\"\n    paren_group_string := \"\"\n    paren_group_string\
    \ := \"\"\n    paren_group_string := \"\"\n    paren_group_string := \"\"\n  \
    \  paren_group_string := \"\"\n    paren_group_string := \"\"\n    paren_group_string\
    \ := \"\"\n    paren_group_string := \"\"\n    paren_group_string := \"\"\n  \
    \  paren_group_string := \"\"\n    paren_group_string := \nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp0wosim9k_test.go:79:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074118
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n\
    \    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"\
    {}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    \nfunc\
    \ TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8bpr93_n_test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074002
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    // Initialize a stack to keep track of open and closed\
    \ brackets\n    stack := make([]string, 0)\n    // Initialize a slice to hold\
    \ the result\n    result := make([]string, 0)\n    // Iterate over each character\
    \ in the string\n    for _, c := range paren_string {\n        // If the character\
    \ is a left parenthesis, push it to the stack\n        if c == '(' {\n       \
    \     stack = append(stack, c) // Add it to the stack\n        // If the character\
    \ is a right parenthesis, pop it from the stack\n        } else if c == ')' {\n\
    \            // If the stack is empty, that means we have reached the end of the\
    \ parenthesis group\n            if len(stack) == 0 {\n                // Throw\
    \ an error if the input string is not properly balanced\n                fmt.Println(\"\
    Error: Input string is not properly balanced\")\n                fmt.Println(\"\
    Input string: \" + paren_string)\n                fmt.Println(\"Stack: \" + string(stack))\n\
    \                fmt.Println(\"Stack length: \" + strconv.Itoa(len(stack)))\n\
    \                fmt.Println(\"Stack contents: \" + string(stack))\n         \
    \       fmt.Println(\"Stack contents: \" + string(stack))\n                fmt.Println(\"\
    Stack contents: \" + string(stack))\n                fmt.Println(\"Stack contents:\
    \ \" + string(stack))\n                fmt.Println(\"Stack contents: \" + string(stack))\n\
    \                fmt.Println(\"Stack contents: \" + string(stack))\n         \
    \       fmt.Println(\"Stack contents: \" + string(stack))\n                fmt.Println(\"\
    Stack contents: \" + string(stack))\n                fmt.Println(\"Stack contents:\
    \ \" + string(stack))\n                fmt.Println(\"Stack contents: \" + string(stack))\n\
    \                fmt.Println(\"Stack contents: \" + string(stack))\n         \
    \       fmt.Println(\"Stack contents: \" + string(stack))\n                fmt.Println(\"\
    Stack contents: \" + string(stack))\n                fmt.Println(\"Stack contents:\
    \ \" + string(stack))\n                fmt.Println(\"Stack contents: \" + string(stack))\n\
    \                fmt.Println(\"Stack contents: \" + string(stack))\n         \
    \       fmt.Println(\"Stack contents: \" + string(stack))\n                fmt.Println(\"\
    Stack contents: \" + string(stack))\n                fmt.Println(\"Stack contents:\
    \ \" + string(stack))\n                fmt.Println(\"Stack contents: \" + string(stack))\n\
    \                fmt.Println(\"Stack contents: \" + string(stack))\n         \
    \       fmt.Println(\"Stack contents: \" + string(stack))\n                fmt.Println(\"\
    Stack contents: \" + string(stack))\n                fmt.Println(\"Stack contents:\
    \ \" + string(stack))\n                fmt.Println(\"Stack contents: \" + \nfunc\
    \ TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpip714hda_test.go:58:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074118
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_string += \")\"\n    paren_string += \"(\"\n \
    \   paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\
    \n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string += \"\
    (\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8clhzg06_test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074002
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_group_strings := []string{}\n    paren_group_string\
    \ := \"\"\n    paren_group_open := false\n    paren_group_closed := false\n  \
    \  paren_group_string += paren_string\n    for _, character := range paren_string\
    \ {\n        if character == '(' {\n            if paren_group_open {\n      \
    \          fmt.Println(\"Error: unexpected open paren group\")\n            }\n\
    \            paren_group_open = true\n            paren_group_string += character\n\
    \        } else if character == ')' {\n            if paren_group_closed {\n \
    \               fmt.Println(\"Error: unexpected close paren group\")\n       \
    \     }\n            paren_group_closed = true\n            paren_group_string\
    \ += character\n        } else if character == ' ' {\n            if paren_group_open\
    \ {\n                paren_group_string += character\n            } else if paren_group_closed\
    \ {\n                paren_group_string += character\n            } else {\n \
    \               paren_group_strings = append(paren_group_strings, paren_group_string)\n\
    \                paren_group_string = \"\"\n                paren_group_open =\
    \ false\n                paren_group_closed = false\n            }\n        }\
    \ else {\n            paren_group_string = paren_group_string + character\n  \
    \      }\n    }\n    paren_group_strings = append(paren_group_strings, paren_group_string)\n\
    \    return paren_group_strings\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjs6n9x9r_test.go:26:13: invalid operation: paren_group_string += character
    (mismatched types string and rune)

    /tmp/tmpjs6n9x9r_test.go:32:13: invalid operation: paren_group_string += character
    (mismatched types string and rune)

    /tmp/tmpjs6n9x9r_test.go:35:17: invalid operation: paren_group_string += character
    (mismatched types string and rune)

    /tmp/tmpjs6n9x9r_test.go:37:17: invalid operation: paren_group_string += character
    (mismatched types string and rune)

    /tmp/tmpjs6n9x9r_test.go:45:34: invalid operation: paren_group_string + character
    (mismatched types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074119
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n\
    \    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"\
    {}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    \nfunc\
    \ TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8bpr93_n_test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074002
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_groups := []string{}\n    paren_group := \"\"\n\
    \    paren_group_is_open := false\n    for _, char := range paren_string {\n \
    \       if char == '(' {\n            if paren_group_is_open {\n             \
    \   fmt.Println(\"Error: unexpected open paren group\")\n                return\
    \ nil\n            }\n            paren_group_is_open = true\n            paren_group\
    \ = paren_group + char\n        } else if char == ')' {\n            if paren_group_is_open\
    \ {\n                paren_groups = append(paren_groups, paren_group)\n      \
    \          paren_group_is_open = false\n                paren_group = paren_group\
    \ + char\n            } else {\n                fmt.Println(\"Error: unexpected\
    \ close paren group\")\n                return nil\n            }\n        } else\
    \ {\n            paren_group = paren_group + char\n        }\n    }\n    if paren_group_is_open\
    \ {\n        paren_groups = append(paren_groups, paren_group)\n    }\n    return\
    \ paren_groups\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpv0wy80e7_test.go:25:27: invalid operation: paren_group + char (mismatched
    types string and rune)

    /tmp/tmpv0wy80e7_test.go:30:31: invalid operation: paren_group + char (mismatched
    types string and rune)

    /tmp/tmpv0wy80e7_test.go:36:27: invalid operation: paren_group + char (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074119
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_group_strings := []string{}\n    paren_group_string\
    \ := \"\"\n    paren_group_open := false\n    paren_group_closed := false\n  \
    \  paren_group_count := 0\n    for _, character := range paren_string {\n    \
    \    if character == \"(\" {\n            if paren_group_open {\n            \
    \    paren_group_closed--\n            } else {\n                paren_group_open\
    \ = true\n                paren_group_closed++\n            }\n        } else\
    \ if character == \")\" {\n            if paren_group_closed {\n             \
    \   paren_group_open--\n            } else {\n                paren_group_closed\
    \ = true\n                paren_group_open = false\n            }\n        } else\
    \ if character == \" \" {\n            if paren_group_open {\n               \
    \ paren_group_closed--\n            } else {\n                paren_group_open\
    \ = true\n                paren_group_closed++\n            }\n        } else\
    \ {\n            paren_group_count++\n            paren_group_string += character\n\
    \        }\n        if paren_group_count == 2 {\n            paren_group_strings\
    \ = append(paren_group_strings, paren_group_string)\n            paren_group_string\
    \ = \"\"\n            paren_group_count = 0\n        }\n    }\n    return paren_group_strings\n\
    }\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_un3f7yf_test.go:21:25: invalid operation: character == "(" (mismatched
    types rune and untyped string)

    /tmp/tmp_un3f7yf_test.go:23:17: invalid operation: paren_group_closed-- (non-numeric
    type bool)

    /tmp/tmp_un3f7yf_test.go:26:17: invalid operation: paren_group_closed++ (non-numeric
    type bool)

    /tmp/tmp_un3f7yf_test.go:28:32: invalid operation: character == ")" (mismatched
    types rune and untyped string)

    /tmp/tmp_un3f7yf_test.go:30:17: invalid operation: paren_group_open-- (non-numeric
    type bool)

    /tmp/tmp_un3f7yf_test.go:35:32: invalid operation: character == " " (mismatched
    types rune and untyped string)

    /tmp/tmp_un3f7yf_test.go:37:17: invalid operation: paren_group_closed-- (non-numeric
    type bool)

    /tmp/tmp_un3f7yf_test.go:40:17: invalid operation: paren_group_closed++ (non-numeric
    type bool)

    /tmp/tmp_un3f7yf_test.go:44:13: invalid operation: paren_group_string += character
    (mismatched types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074119
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    // Initialize a list to store the result\n    result\
    \ := make([]string, 0)\n\n    // Iterate through each character in the string\n\
    \    for _, character := range paren_string {\n        // If the character is\
    \ a left paren, add it to the list\n        if character == '(' {\n          \
    \  result = append(result, character)\n        }\n\n        // If the character\
    \ is a right paren, remove it from the list\n        if character == ')' {\n \
    \           result = remove_brace(result, character)\n        }\n    }\n\n   \
    \ // Return the result\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpgewe929w_test.go:22:37: cannot use character (variable of type rune) as
    type string in argument to append

    /tmp/tmpgewe929w_test.go:27:22: undefined: remove_brace

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074119
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_group_strings := []string{}\n    paren_group_string\
    \ := \"\"\n    paren_group_open := false\n    paren_group_closed := false\n  \
    \  paren_group_count := 0\n    for _, char := range paren_string {\n        if\
    \ paren_group_open {\n            paren_group_string += char\n            if char\
    \ == \")\" {\n                paren_group_open = false\n                paren_group_closed\
    \ = true\n                paren_group_count--\n            }\n        } else {\n\
    \            if char == \"(\" {\n                paren_group_open = true\n   \
    \             paren_group_closed = false\n                paren_group_count++\n\
    \            }\n            if char == \")\" {\n                paren_group_open\
    \ = false\n                paren_group_closed = true\n                paren_group_count--\n\
    \            }\n            paren_group_string += char\n        }\n        if\
    \ paren_group_closed {\n            paren_group_strings = append(paren_group_strings,\
    \ paren_group_string)\n            paren_group_string = \"\"\n            paren_group_open\
    \ = false\n            paren_group_closed = false\n            paren_group_count\
    \ = 0\n        }\n    }\n    return paren_group_strings\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8084376v_test.go:22:13: invalid operation: paren_group_string += char
    (mismatched types string and rune)

    /tmp/tmp8084376v_test.go:23:24: invalid operation: char == ")" (mismatched types
    rune and untyped string)

    /tmp/tmp8084376v_test.go:29:24: invalid operation: char == "(" (mismatched types
    rune and untyped string)

    /tmp/tmp8084376v_test.go:34:24: invalid operation: char == ")" (mismatched types
    rune and untyped string)

    /tmp/tmp8084376v_test.go:39:13: invalid operation: paren_group_string += char
    (mismatched types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074119
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_group_strings := []string{}\n    paren_group_string\
    \ := \"\"\n    brace_count := 0\n    open_paren_count := 0\n    close_paren_count\
    \ := 0\n    paren_group_string += \"(\"\n    for _, char := range paren_string\
    \ {\n        if char == '(' {\n            open_paren_count++\n            paren_group_string\
    \ += char\n        } else if char == ')' {\n            close_paren_count++\n\
    \            paren_group_string += char\n        } else if char == ' ' {\n   \
    \         paren_group_string += char\n        } else {\n            if open_paren_count\
    \ == close_paren_count {\n                paren_group_strings = append(paren_group_strings,\
    \ paren_group_string)\n                paren_group_string = \"\"\n           \
    \     open_paren_count = 0\n                close_paren_count = 0\n          \
    \  }\n            paren_group_string += char\n        }\n    }\n    if open_paren_count\
    \ > close_paren_count {\n        paren_group_strings = append(paren_group_strings,\
    \ paren_group_string)\n    }\n    return paren_group_strings\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpe5dubrq5_test.go:17:5: brace_count declared but not used

    /tmp/tmpe5dubrq5_test.go:24:13: invalid operation: paren_group_string += char
    (mismatched types string and rune)

    /tmp/tmpe5dubrq5_test.go:27:13: invalid operation: paren_group_string += char
    (mismatched types string and rune)

    /tmp/tmpe5dubrq5_test.go:29:13: invalid operation: paren_group_string += char
    (mismatched types string and rune)

    /tmp/tmpe5dubrq5_test.go:37:13: invalid operation: paren_group_string += char
    (mismatched types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074119
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_group_strings := []string{}\n    paren_group_count\
    \ := 0\n    paren_group_string := \"\"\n    paren_group_open := false\n    paren_group_closed\
    \ := false\n    paren_group_string += \"(\"\n    for _, character := range paren_string\
    \ {\n        if character == \"(\" {\n            if paren_group_open {\n    \
    \            fmt.Println(\"Found open paren group\", paren_group_string)\n   \
    \             paren_group_string += character\n                paren_group_count\
    \ += 1\n            } else {\n                paren_group_open = true\n      \
    \          paren_group_string += character\n            }\n        } else if character\
    \ == \")\" {\n            if paren_group_closed {\n                fmt.Println(\"\
    Found closed paren group\", paren_group_string)\n                paren_group_string\
    \ += character\n                paren_group_count += 1\n            } else {\n\
    \                paren_group_closed = true\n                paren_group_string\
    \ += character\n            }\n        } else if character == \" \" {\n      \
    \      if paren_group_open {\n                paren_group_string += character\n\
    \            } else {\n                paren_group_string += character\n     \
    \       }\n        } else {\n            paren_group_string += character\n   \
    \     }\n    }\n    if paren_group_count > 0 {\n        paren_group_strings =\
    \ append(paren_group_strings, paren_group_string)\n    }\n    return paren_group_strings\n\
    }\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphwydn8o7_test.go:22:25: invalid operation: character == "(" (mismatched
    types rune and untyped string)

    /tmp/tmphwydn8o7_test.go:25:17: invalid operation: paren_group_string += character
    (mismatched types string and rune)

    /tmp/tmphwydn8o7_test.go:29:17: invalid operation: paren_group_string += character
    (mismatched types string and rune)

    /tmp/tmphwydn8o7_test.go:31:32: invalid operation: character == ")" (mismatched
    types rune and untyped string)

    /tmp/tmphwydn8o7_test.go:34:17: invalid operation: paren_group_string += character
    (mismatched types string and rune)

    /tmp/tmphwydn8o7_test.go:38:17: invalid operation: paren_group_string += character
    (mismatched types string and rune)

    /tmp/tmphwydn8o7_test.go:40:32: invalid operation: character == " " (mismatched
    types rune and untyped string)

    /tmp/tmphwydn8o7_test.go:42:17: invalid operation: paren_group_string += character
    (mismatched types string and rune)

    /tmp/tmphwydn8o7_test.go:44:17: invalid operation: paren_group_string += character
    (mismatched types string and rune)

    /tmp/tmphwydn8o7_test.go:47:13: invalid operation: paren_group_string += character
    (mismatched types string and rune)

    /tmp/tmphwydn8o7_test.go:47:13: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074119
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    // Your code here\n    paren_string := paren_string\n\
    \    paren_string := strings.Replace(paren_string, \"( )\", \" \", -1)\n    paren_string\
    \ := strings.Replace(paren_string, \" ( \", \" \", -1)\n    paren_string := strings.Replace(paren_string,\
    \ \" ( )\", \" \", -1)\n    paren_string := strings.Replace(paren_string, \" (\
    \ ) \", \" \", -1)\n    paren_string := strings.Replace(paren_string, \" ( ) \"\
    , \" \", -1)\n    paren_string := strings.Replace(paren_string, \" ( ) \", \"\
    \ \", -1)\n    paren_string := strings.Replace(paren_string, \" ( ) \", \" \"\
    , -1)\n    paren_string := strings.Replace(paren_string, \" ( ) \", \" \", -1)\n\
    \    paren_string := strings.Replace(paren_string, \" ( ) \", \" \", -1)\n   \
    \ paren_string := strings.Replace(paren_string, \" ( ) \", \" \", -1)\n    paren_string\
    \ := strings.Replace(paren_string, \" ( ) \", \" \", -1)\n    paren_string :=\
    \ strings.Replace(paren_string, \" ( ) \", \" \", -1)\n    paren_string := strings.Replace(paren_string,\
    \ \" ( ) \", \" \", -1)\n    paren_string := strings.Replace(paren_string, \"\
    \ ( ) \", \" \", -1)\n    paren_string := strings.Replace(paren_string, \" ( )\
    \ \", \" \", -1)\n    paren_string := strings.Replace(paren_string, \" ( ) \"\
    , \" \", -1)\n    paren_string := strings.Replace(paren_string, \" ( ) \", \"\
    \ \", -1)\n    paren_string := strings.Replace(paren_string, \" ( ) \", \" \"\
    , -1)\n    paren_string := strings.Replace(paren_string, \" ( ) \", \" \", -1)\n\
    \    paren_string := strings.Replace(paren_string, \" ( ) \", \" \", -1)\n   \
    \ paren_string := strings.Replace(paren_string, \" ( ) \", \" \", -1)\n    paren_string\
    \ := strings.Replace(paren_string, \" ( ) \", \" \", -1)\n    paren_string :=\
    \ strings.Replace(paren_string, \" ( ) \", \" \", -1)\n    paren_string := strings.Replace(paren_string,\
    \ \" ( ) \", \" \", -1)\n    paren_string := strings.Replace(paren_string, \"\
    \ ( ) \", \" \", -1)\n    paren_string := strings.Replace(paren_string, \" ( )\
    \ \", \" \", -1)\n    paren_string := strings.Replace\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp0suzb1qc_test.go:44:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074118
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_string += \"{}\"\n    paren_string = strings.Replace(paren_string,\
    \ \"( )\", \"()\", -1)\n    paren_string = strings.Replace(paren_string, \" (\
    \ \", \" ()\", -1)\n    paren_string = strings.Replace(paren_string, \" ( )\"\
    , \" ()\", -1)\n    paren_string = strings.Replace(paren_string, \" ( ) \", \"\
    \ ()\", -1)\n    paren_string = strings.Replace(paren_string, \" ( ) ( )\", \"\
    \ ()()\", -1)\n    paren_string = strings.Replace(paren_string, \" ( ) ( ) \"\
    , \" ()()()\", -1)\n    paren_string = strings.Replace(paren_string, \" ( ) (\
    \ ) ( )\", \" ()()()()\", -1)\n    paren_string = strings.Replace(paren_string,\
    \ \" ( ) ( ) ( ) \", \" ()()()()()\", -1)\n    paren_string = strings.Replace(paren_string,\
    \ \" ( ) ( ) ( ) ( )\", \" ()()()()()\", -1)\n    paren_string = strings.Replace(paren_string,\
    \ \" ( ) ( ) ( ) ( ) \", \" ()()()()()()\", -1)\n    paren_string = strings.Replace(paren_string,\
    \ \" ( ) ( ) ( ) ( ) ( )\", \" ()()()()()()()\", -1)\n    paren_string = strings.Replace(paren_string,\
    \ \" ( ) ( ) ( ) ( ) ( ) \", \" ()()()()()()()()\", -1)\n    paren_string = strings.Replace(paren_string,\
    \ \" ( ) ( ) ( ) ( ) ( ) ( ) \", \" ()()()()()()()()()\", -1)\n    paren_string\
    \ = strings.Replace(paren_string, \" ( ) ( ) ( ) ( ) ( ) ( ) ( ) \", \" ()()()()()()()()()()()\"\
    , -1)\n    paren_string = strings.Replace(paren_string, \" ( ) ( ) ( ) ( ) ( )\
    \ ( ) ( ) ( ) \", \" ()()()()()()()()()()()\", -1)\n    paren_string = strings.Replace(paren_string,\
    \ \" ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) ( ) \", \" ()()()()()()()()()()()()\", -1)\n\
    \    paren_string = strings.Replace(paren_string, \" ( ) ( ) ( ) ( ) ( ) ( ) (\
    \ ) ( ) ( ) ( ) \", \" ()()()()()()()()\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpjriggfex_test.go:32:95: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074118
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_group_strings := make([]string, 0)\n    paren_group_stack\
    \ := make([]string, 0)\n    paren_group_stack_strings := make([]string, 0)\n \
    \   paren_group_stack_strings_count := 0\n    paren_group_stack_strings_count\
    \ += len(paren_group_stack_strings)\n    paren_group_stack_strings = append(paren_group_stack_strings,\
    \ paren_group_stack_strings...)\n    paren_group_stack_strings_count += len(paren_group_stack_strings)\n\
    \    paren_group_stack_strings = append(paren_group_stack_strings, paren_group_stack_strings...)\n\
    \    paren_group_stack_strings_count += len(paren_group_stack_strings)\n    paren_group_stack_strings\
    \ = append(paren_group_stack_strings, paren_group_stack_strings...)\n    paren_group_stack_strings_count\
    \ += len(paren_group_stack_strings)\n    paren_group_stack_strings = append(paren_group_stack_strings,\
    \ paren_group_stack_strings...)\n    paren_group_stack_strings_count += len(paren_group_stack_strings)\n\
    \    paren_group_stack_strings = append(paren_group_stack_strings, paren_group_stack_strings...)\n\
    \    paren_group_stack_strings_count += len(paren_group_stack_strings)\n    paren_group_stack_strings\
    \ = append(paren_group_stack_strings, paren_group_stack_strings...)\n    paren_group_stack_strings_count\
    \ += len(paren_group_stack_strings)\n    paren_group_stack_strings = append(paren_group_stack_strings,\
    \ paren_group_stack_strings...)\n    paren_group_stack_strings_count += len(paren_group_stack_strings)\n\
    \    paren_group_stack_strings = append(paren_group_stack_strings, paren_group_stack_strings...)\n\
    \    paren_group_stack_strings_count += len(paren_group_stack_strings)\n    paren_group_stack_strings\
    \ = append(paren_group_stack_strings, paren_group_stack_strings...)\n    paren_group_stack_strings_count\
    \ += len(paren_group_stack_strings)\n    paren_group_stack_strings = append(paren_group_stack_strings,\
    \ paren_group_stack_strings...)\n    paren_group_stack_strings_count += len(paren_group_stack_strings)\n\
    \    paren_group_stack_strings = append(paren_group_stack_strings, paren_group_stack_strings...)\n\
    \    paren_group_stack_strings_count += len(paren_group_stack_strings)\n    paren_group_stack_strings\
    \ = append(paren_group_stack_strings, paren_group_stack_strings...)\n    paren_group_stack_string\n\
    func TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmppbnw7vax_test.go:44:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074118
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    result := []string{}\n    stack := []string{}\n    stack\
    \ := append(stack, paren_string)\n    index := 0\n    for len(stack) > 0 {\n \
    \       index += 1\n        current := stack[len(stack)-1]\n        stack = stack[:len(stack)-1]\n\
    \        if current == \"(\" {\n            stack = append(stack, current)\n \
    \       } else if current == \")\" {\n            open_brace := stack[len(stack)-2]\n\
    \            if open_brace == \"(\" {\n                stack = append(stack, current)\n\
    \            } else {\n                stack = append(stack, open_brace)\n   \
    \             stack = append(stack, current)\n            }\n        } else {\n\
    \            stack = append(stack, current)\n        }\n    }\n    return result\n\
    }\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp25ej96wy_test.go:17:11: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074119
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    var result []string\n    stack := make([]string, 0)\n\
    \    stack := append(stack, paren_string)\n    depth := 0\n    depth := 0\n  \
    \  for len(stack) > 0 {\n        depth += 1\n        s := stack[len(stack)-1]\n\
    \        stack = stack[:len(stack)-1]\n        if s == \")\" {\n            depth\
    \ -= 1\n            if depth == 0 {\n                result := append(result,\
    \ s)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmptyzf005j_test.go:17:11: no new variables on left side of :=

    /tmp/tmptyzf005j_test.go:19:11: no new variables on left side of :=

    /tmp/tmptyzf005j_test.go:27:17: result declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074119
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_group_regex := regexp.MustCompile(`\\((?P<paren_group>.*?)\\\
    )`)\n    paren_groups := paren_group_regex.FindAllStringSubmatch(paren_string,\
    \ -1)\n    paren_groups := append(paren_groups, []string{})\n    paren_groups\
    \ := paren_groups[0 : len(paren_groups)-1]\n    paren_groups := paren_groups[0\
    \ : len(paren_groups)-1]\n    paren_groups := paren_groups[0 : len(paren_groups)-1]\n\
    \    paren_groups := paren_groups[0 : len(paren_groups)-1]\n    paren_groups :=\
    \ paren_groups[0 : len(paren_groups)-1]\n    paren_groups := paren_groups[0 :\
    \ len(paren_groups)-1]\n    paren_groups := paren_groups[0 : len(paren_groups)-1]\n\
    \    paren_groups := paren_groups[0 : len(paren_groups)-1]\n    paren_groups :=\
    \ paren_groups[0 : len(paren_groups)-1]\n    paren_groups := paren_groups[0 :\
    \ len(paren_groups)-1]\n    paren_groups := paren_groups[0 : len(paren_groups)-1]\n\
    \    paren_groups := paren_groups[0 : len(paren_groups)-1]\n    paren_groups :=\
    \ paren_groups[0 : len(paren_groups)-1]\n    paren_groups := paren_groups[0 :\
    \ len(paren_groups)-1]\n    paren_groups := paren_groups[0 : len(paren_groups)-1]\n\
    \    paren_groups := paren_groups[0 : len(paren_groups)-1]\n    paren_groups :=\
    \ paren_groups[0 : len(paren_groups)-1]\n    paren_groups := paren_groups[0 :\
    \ len(paren_groups)-1]\n    paren_groups := paren_groups[0 : len(paren_groups)-1]\n\
    \    paren_groups := paren_groups[0 : len(paren_groups)-1]\n    paren_groups :=\
    \ paren_groups[0 : len(paren_groups)-1]\n    paren_groups := paren_groups[0 :\
    \ len(paren_groups)-1]\n    paren_groups := paren_groups[0 : len(paren_groups)-1]\n\
    \    paren_groups := paren_groups[0 : len(paren_groups)-1]\n    paren_groups :=\
    \ paren_groups[0 : len(paren_groups)-1]\n    paren_groups := paren_groups[0 :\
    \ len(paren_groups)-1]\n    paren_groups := paren_groups[0 : len(\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpq6wk7gz3_test.go:45:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074118
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_group_strings := make([]string, 0)\n    paren_group_strings\
    \ = append(paren_group_strings, paren_string)\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_group_strings = append(paren_group_strings, paren_string)\n    paren_group_strings\
    \ = append(paren_group_strings, paren_string)\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_group_strings = append(paren_group_strings, paren_string)\n    paren_group_strings\
    \ = append(paren_group_strings, paren_string)\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_group_strings = append(paren_group_strings, paren_string)\n    paren_group_strings\
    \ = append(paren_group_strings, paren_string)\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_group_strings = append(paren_group_strings, paren_string)\n    paren_group_strings\
    \ = append(paren_group_strings, paren_string)\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_group_strings = append(paren_group_strings, paren_string)\n    paren_group_strings\
    \ = append(paren_group_strings, paren_string)\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_group_strings = append(paren_group_strings, paren_string)\n    paren_group_strings\
    \ = append(paren_group_strings, paren_string)\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_group_strings = append(paren_group_strings, paren_string)\n    paren_group_strings\
    \ = append(paren_group_strings, paren_string)\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp705dn0ck_test.go:48:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074117
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_group_strings := []string{}\n    paren_group_strings\
    \ = append(paren_group_strings, paren_string)\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_group_strings = append(paren_group_strings, paren_string)\n    paren_group_strings\
    \ = append(paren_group_strings, paren_string)\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_group_strings = append(paren_group_strings, paren_string)\n    paren_group_strings\
    \ = append(paren_group_strings, paren_string)\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_group_strings = append(paren_group_strings, paren_string)\n    paren_group_strings\
    \ = append(paren_group_strings, paren_string)\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_group_strings = append(paren_group_strings, paren_string)\n    paren_group_strings\
    \ = append(paren_group_strings, paren_string)\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_group_strings = append(paren_group_strings, paren_string)\n    paren_group_strings\
    \ = append(paren_group_strings, paren_string)\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_group_strings = append(paren_group_strings, paren_string)\n    paren_group_strings\
    \ = append(paren_group_strings, paren_string)\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_group_strings = append(paren_group_strings, paren_string)\n    paren_group_strings\
    \ = append(paren_group_strings, paren_string)\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_group_string\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpo3h5w7pi_test.go:48:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074002
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_group_regex := regexp.MustCompile(`\\((?P<group>\\\
    ()|(?P<group>\\))|(?P<group>\\))\\)`)\n    result := []string{}\n    for _, match\
    \ := range paren_group_regex.FindAllStringSubmatch(paren_string, -1) {\n     \
    \   if match[1] == \"\" {\n            result = append(result, match[2])\n   \
    \     } else {\n            result = append(result, match[1])\n        }\n   \
    \ }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n\
    \  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpwqzm2yh6_test.go:15:26: undefined: regexp

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074119
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_string += \")\"\n    paren_string += \"(\"\n \
    \   paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\
    \n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string += \"\
    (\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8clhzg06_test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074002
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_string += \")\"\n    paren_string += \"(\"\n \
    \   paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string += \")\"\
    \n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string += \"\
    )\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string +=\
    \ \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_\n\
    func TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpcvtu_s7s_test.go:80:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074002
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_string += \")\"\n    paren_string += \"(\"\n \
    \   paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\
    \n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string += \"\
    (\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8clhzg06_test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074002
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_string += \")\"\n    paren_string += \"(\"\n \
    \   paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string += \")\"\
    \n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string += \"\
    )\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string +=\
    \ \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_\n\
    func TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpcvtu_s7s_test.go:80:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074002
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    var result []string\n    stack := make([]string, 0)\n\
    \    stack := append(stack, paren_string)\n    for len(stack) > 0 {\n        current\
    \ := stack[len(stack)-1]\n        stack = stack[:len(stack)-1]\n        if current\
    \ == \")\" {\n            stack = append(stack, \"(\")\n        } else {\n   \
    \         stack = append(stack, current)\n        }\n    }\n    for _, s := range\
    \ stack {\n        result = append(result, s)\n    }\n    return result\n}\n\n\
    func TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5cvfmn9w_test.go:17:11: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074119
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_string += \")\"\n    paren_string += \"(\"\n \
    \   paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\
    \n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string += \"\
    (\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8clhzg06_test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074002
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_group_regex := regexp.MustCompile(`\\((?P<paren_group>[^\\\
    (\\)]+)\\)`)\n    paren_groups := paren_group_regex.FindAllStringSubmatch(paren_string,\
    \ -1)\n    paren_groups := paren_group_regex.FindAllStringSubmatch(paren_string,\
    \ -1)\n    paren_groups := paren_group_regex.FindAllStringSubmatch(paren_string,\
    \ -1)\n    paren_groups := paren_group_regex.FindAllStringSubmatch(paren_string,\
    \ -1)\n    paren_groups := paren_group_regex.FindAllStringSubmatch(paren_string,\
    \ -1)\n    paren_groups := paren_group_regex.FindAllStringSubmatch(paren_string,\
    \ -1)\n    paren_groups := paren_group_regex.FindAllStringSubmatch(paren_string,\
    \ -1)\n    paren_groups := paren_group_regex.FindAllStringSubmatch(paren_string,\
    \ -1)\n    paren_groups := paren_group_regex.FindAllStringSubmatch(paren_string,\
    \ -1)\n    paren_groups := paren_group_regex.FindAllStringSubmatch(paren_string,\
    \ -1)\n    paren_groups := paren_group_regex.FindAllStringSubmatch(paren_string,\
    \ -1)\n    paren_groups := paren_group_regex.FindAllStringSubmatch(paren_string,\
    \ -1)\n    paren_groups := paren_group_regex.FindAllStringSubmatch(paren_string,\
    \ -1)\n    paren_groups := paren_group_regex.FindAllStringSubmatch(paren_string,\
    \ -1)\n    paren_groups := paren_group_regex.FindAllStringSubmatch(paren_string,\
    \ -1)\n    paren_groups := paren_group_regex.FindAllStringSubmatch(paren_string,\
    \ -1)\n    paren_groups := paren_group_regex.FindAllStringSubmatch(paren_string,\
    \ -1)\n    paren_groups := paren_group_regex.FindAllStringSubmatch(paren_string,\
    \ -1)\n    paren_groups := paren_group_regex.FindAllStringSubmatch(paren_string,\
    \ -1)\n    paren_groups := paren_group_regex.FindAllStringSubmatch(paren_string,\
    \ -1)\n    paren_groups := paren_group_regex.FindAllStringSubmatch(paren_string,\
    \ -1)\n    paren_groups := paren_group_regex.FindAllStringSubmatch(paren_string,\
    \ -1)\n    paren_groups := paren_group_regex.FindAllStringSubmatch(paren_string,\
    \ -1)\n    paren_groups := paren_group_regex.FindAllStringSubmatch(paren_string,\
    \ -1)\n    paren_\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpsk4h9hg0_test.go:41:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074119
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_string += \")\"\n    paren_string += \"(\"\n \
    \   paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string += \")\"\
    \n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string += \"\
    )\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string +=\
    \ \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_\n\
    func TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpcvtu_s7s_test.go:80:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074002
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    // Initialize a list to store our results\n    result\
    \ := make([]string, 0)\n\n    // Iterate over each character in the input string\n\
    \    for _, char := range paren_string {\n        // If the character is a left\
    \ paren, add it to the list\n        if char == '(' {\n            result = append(result,\
    \ char)\n        }\n\n        // If the character is a right paren, remove it\
    \ from the list\n        if char == ')' {\n            result = remove_bracket(result,\
    \ char)\n        }\n    }\n\n    // Return the list of results\n    return result\n\
    }\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpuhxw5ydx_test.go:22:37: cannot use char (variable of type rune) as type
    string in argument to append

    /tmp/tmpuhxw5ydx_test.go:27:22: undefined: remove_bracket

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074121
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_groups = make(map[string][]string)\n    paren_groups\
    \ [\"(\"] = make([]string, 0)\n    paren_groups [\")\"] = make([]string, 0)\n\
    \    paren_groups [\"(\"] = append(paren_groups [\"(\"], paren_string)\n    paren_groups\
    \ [\")\"] = append(paren_groups [\")\"], paren_string)\n    paren_groups [\"(\"\
    ] = append(paren_groups [\"(\"], paren_string)\n    paren_groups [\")\"] = append(paren_groups\
    \ [\")\"], paren_string)\n    paren_groups [\"(\"] = append(paren_groups [\"(\"\
    ], paren_string)\n    paren_groups [\")\"] = append(paren_groups [\")\"], paren_string)\n\
    \    paren_groups [\"(\"] = append(paren_groups [\"(\"], paren_string)\n    paren_groups\
    \ [\")\"] = append(paren_groups [\")\"], paren_string)\n    paren_groups [\"(\"\
    ] = append(paren_groups [\"(\"], paren_string)\n    paren_groups [\")\"] = append(paren_groups\
    \ [\")\"], paren_string)\n    paren_groups [\"(\"] = append(paren_groups [\"(\"\
    ], paren_string)\n    paren_groups [\")\"] = append(paren_groups [\")\"], paren_string)\n\
    \    paren_groups [\"(\"] = append(paren_groups [\"(\"], paren_string)\n    paren_groups\
    \ [\")\"] = append(paren_groups [\")\"], paren_string)\n    paren_groups [\"(\"\
    ] = append(paren_groups [\"(\"], paren_string)\n    paren_groups [\")\"] = append(paren_groups\
    \ [\")\"], paren_string)\n    paren_groups [\"(\"] = append(paren_groups [\"(\"\
    ], paren_string)\n    paren_groups [\")\"] = append(paren_groups [\")\"], paren_string)\n\
    \    paren_groups [\"(\"] = append(paren_groups [\"(\"], paren_string)\n    paren_groups\
    \ [\")\"] = append(paren_groups [\")\"], paren_string)\n    paren_groups [\"(\"\
    ] = append(paren_groups [\"(\"], paren_string)\n    paren_groups [\")\"] = append(paren_groups\
    \ [\")\"], paren_string)\n    paren_groups [\"(\"] = append(paren_groups [\"(\"\
    ], paren_string)\n    paren_groups [\")\"] = append(paren_groups [\")\"], paren_string)\n\
    \    paren_groups [\"(\"] = append(paren_groups [\"(\"], paren_string)\n    paren_groups\
    \ [\")\"] = append(paren_groups [\")\"], paren_string)\n    paren_groups [\"\n\
    func TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpg5r66gy3_test.go:44:19: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074120
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_string += \")\"\n    paren_string += \"(\"\n \
    \   paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\
    \n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string += \"\
    (\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8clhzg06_test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074002
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    // Initialize a slice to store our result\n    result\
    \ := make([]string, 0)\n\n    // Iterate over each character in the string\n \
    \   for _, character := range paren_string {\n        // If the character is a\
    \ left paren, push it onto the stack\n        if character == '(' {\n        \
    \    result = append(result, character)\n        }\n\n        // If the character\
    \ is a right paren, pop it off the stack\n        if character == ')' {\n    \
    \        result := append(result, result[len(result)-1])\n            result =\
    \ result[:len(result)-1]\n        }\n    }\n\n    // Return the result\n    return\
    \ result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate :=\
    \ separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\",\
    \ \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected:\
    \ []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"\
    ( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp00ykjq_l_test.go:22:37: cannot use character (variable of type rune) as
    type string in argument to append

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074121
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_string += \")\"\n    paren_string += \"(\"\n \
    \   paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string += \")\"\
    \n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string += \"\
    )\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string +=\
    \ \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_\n\
    func TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpcvtu_s7s_test.go:80:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074002
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_group_regex := regexp.MustCompile(`\\((?P<paren_group>[^\\\
    (\\)]+)\\)`)\n    paren_groups := paren_group_regex.FindAllStringSubmatch(paren_string,\
    \ -1)\n    result := make([]string, len(paren_groups))\n    for index, paren_group\
    \ := range paren_groups {\n        result[index] = paren_group[0]\n    }\n   \
    \ return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0zwnguhl_test.go:15:26: undefined: regexp

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074009
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_string += \")\"\n    paren_string += \"(\"\n \
    \   paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\
    \n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string += \"\
    (\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8clhzg06_test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074002
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_string += \")\"\n    paren_string += \"(\"\n \
    \   paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\
    \n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string += \"\
    (\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8clhzg06_test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074002
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_string += \")\"\n    paren_string += \"(\"\n \
    \   paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string += \")\"\
    \n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string += \"\
    )\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string +=\
    \ \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_\n\
    func TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpcvtu_s7s_test.go:80:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074002
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    result := []string{}\n    stack := []string{}\n    open_braces\
    \ := 0\n    close_braces := 0\n    brace_count := 0\n    brace_open := false\n\
    \    brace_close := false\n    brace_count := 0\n    brace_open := false\n   \
    \ brace_close := false\n    brace_count := 0\n    brace_open := false\n    brace_close\
    \ := false\n    brace_count := 0\n    brace_open := false\n    brace_close :=\
    \ false\n    brace_count := 0\n    brace_open := false\n    brace_close := false\n\
    \    brace_count := 0\n    brace_open := false\n    brace_close := false\n   \
    \ brace_count := 0\n    brace_open := false\n    brace_close := false\n    brace_count\
    \ := 0\n    brace_open := false\n    brace_close := false\n    brace_count :=\
    \ 0\n    brace_open := false\n    brace_close := false\n    brace_count := 0\n\
    \    brace_open := false\n    brace_close := false\n    brace_count := 0\n   \
    \ brace_open := false\n    brace_close := false\n    brace_count := 0\n    brace_open\
    \ := false\n    brace_close := false\n    brace_count := 0\n    brace_open :=\
    \ false\n    brace_close := false\n    brace_count := 0\n    brace_open := false\n\
    \    brace_close := false\n    brace_count := 0\n    brace_open := false\n   \
    \ brace_close := false\n    brace_count := 0\n    brace_open := false\n    brace_close\
    \ := false\n    brace_count := 0\n    brace_open := false\n    brace_close :=\
    \ false\n    brace_count := 0\n    brace_open := false\n    brace_close := false\n\
    \    brace_count := 0\n    brace_open := false\n    brace_close := false\n   \
    \ brace_count := 0\n    brace_open := false\n    brace_close := false\n    brace_count\
    \ := 0\n    brace_open := false\n    brace_close := false\n    brace_count :=\
    \ 0\n    brace_open := false\n    brace_close := false\n    brace_count := 0\n\
    \    brace_open := false\n    brace_close := false\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpxr42qrg__test.go:88:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074120
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_group_strings := []string{}\n    paren_group_string\
    \ := \"\"\n    paren_group_open_braces := 0\n    paren_group_close_braces := 0\n\
    \    paren_group_is_closed := false\n    for _, character := range paren_string\
    \ {\n        if character == \")\" {\n            paren_group_is_closed = false\n\
    \            if paren_group_open_braces == 0 {\n                paren_group_string\
    \ = paren_group_string[:len(paren_group_string)-1]\n                paren_group_strings\
    \ = append(paren_group_strings, paren_group_string)\n                paren_group_string\
    \ = \"\"\n            }\n            paren_group_open_braces--\n        } else\
    \ if character == \"(\" {\n            paren_group_is_closed = true\n        \
    \    paren_group_open_braces++\n        } else if character == \" \" {\n     \
    \       if paren_group_open_braces > 0 {\n                paren_group_string =\
    \ paren_group_string[:len(paren_group_string)-1]\n                paren_group_strings\
    \ = append(paren_group_strings, paren_group_string)\n                paren_group_string\
    \ = \"\"\n            }\n        } else {\n            if paren_group_open_braces\
    \ > 0 {\n                paren_group_string = paren_group_string[:len(paren_group_string)+1]\
    \ + character\n                paren_group_strings = append(paren_group_strings,\
    \ paren_group_string)\n                paren_group_string = \"\"\n           \
    \ }\n        }\n        if paren_group_is_closed {\n            paren_group_close_braces++\n\
    \        }\n    }\n    if paren_group_open_braces > 0 {\n        paren_group_string\
    \ = paren_group_string[:len(paren_group_string)+1]\n        paren_group_strings\
    \ = append(paren_group_strings, paren_group_string)\n    }\n    return paren_group_strings\n\
    }\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpga7lm8vt_test.go:21:25: invalid operation: character == ")" (mismatched
    types rune and untyped string)

    /tmp/tmpga7lm8vt_test.go:29:32: invalid operation: character == "(" (mismatched
    types rune and untyped string)

    /tmp/tmpga7lm8vt_test.go:32:32: invalid operation: character == " " (mismatched
    types rune and untyped string)

    /tmp/tmpga7lm8vt_test.go:40:56: invalid operation: paren_group_string[:len(paren_group_string)
    + 1] + character (mismatched types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074120
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_string += \")\"\n    paren_string += \"(\"\n \
    \   paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\
    \n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string += \"\
    (\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8clhzg06_test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074002
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_string += \")\"\n    paren_string += \"(\"\n \
    \   paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string += \")\"\
    \n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string += \"\
    )\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string +=\
    \ \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_\n\
    func TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpcvtu_s7s_test.go:80:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074002
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_string += \")\"\n    paren_string += \"(\"\n \
    \   paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string += \")\"\
    \n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string += \"\
    )\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string +=\
    \ \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_\n\
    func TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpcvtu_s7s_test.go:80:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074002
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_group_strings := []string{}\n    paren_group_string\
    \ := \"\"\n    paren_group_open := false\n    paren_group_closed := false\n  \
    \  paren_group_string += paren_string\n    for i := 0; i < len(paren_string);\
    \ i++ {\n        if paren_group_open {\n            if paren_group_closed {\n\
    \                paren_group_strings = append(paren_group_strings, paren_group_string)\n\
    \                paren_group_string = \"\"\n                paren_group_open =\
    \ false\n                paren_group_closed = false\n            } else {\n  \
    \              paren_group_string += paren_string[i]\n            }\n        }\
    \ else if paren_group_closed {\n            if paren_string[i] == ')' {\n    \
    \            paren_group_open = true\n                paren_group_closed = true\n\
    \            } else {\n                paren_group_string += paren_string[i]\n\
    \            }\n        } else {\n            if paren_string[i] == '(' {\n  \
    \              paren_group_open = true\n                paren_group_closed = false\n\
    \            } else {\n                paren_group_string += paren_string[i]\n\
    \            }\n        }\n    }\n    paren_group_strings = append(paren_group_strings,\
    \ paren_group_string)\n    return paren_group_strings\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_2dw254i_test.go:28:17: invalid operation: paren_group_string += paren_string[i]
    (mismatched types string and byte)

    /tmp/tmp_2dw254i_test.go:35:17: invalid operation: paren_group_string += paren_string[i]
    (mismatched types string and byte)

    /tmp/tmp_2dw254i_test.go:42:17: invalid operation: paren_group_string += paren_string[i]
    (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074121
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    // Initialize a list to store our results\n    result\
    \ := make([]string, 0)\n\n    // Iterate over the input string\n    for _, char\
    \ := range paren_string {\n        // If the current character is a left paren,\
    \ add it to the list\n        if char == '(' {\n            result = append(result,\
    \ char)\n        }\n\n        // If the current character is a right paren, remove\
    \ it from the list\n        if char == ')' {\n            result = removeElement(result,\
    \ char)\n        }\n    }\n\n    // Return the list of results\n    return result\n\
    }\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkiemjj6l_test.go:22:37: cannot use char (variable of type rune) as type
    string in argument to append

    /tmp/tmpkiemjj6l_test.go:27:22: undefined: removeElement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074121
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n\
    \    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"\
    {}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    \nfunc\
    \ TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8bpr93_n_test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074002
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    var result []string\n    stack := make([]string, 0)\n\
    \    stack := append(stack, paren_string)\n    for len(stack) > 0 {\n        length\
    \ := len(stack)\n        result := make([]string, length)\n        for i := 0;\
    \ i < length; i++ {\n            result := append(result, stack[len(stack)-i-1])\n\
    \        }\n        stack = stack[:len(stack)-length]\n    }\n    return result\n\
    }\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpt00cx7ss_test.go:17:11: no new variables on left side of :=

    /tmp/tmpt00cx7ss_test.go:22:13: result declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074007
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_group_strings := make([]string, 0)\n    paren_group_count\
    \ := 0\n    paren_group_string := \"\"\n    paren_group_open_braces := 0\n   \
    \ paren_group_close_braces := 0\n    paren_group_open_parens := 0\n    paren_group_close_parens\
    \ := 0\n    paren_group_is_closed := false\n    for _, char := range paren_string\
    \ {\n        if char == '(' {\n            paren_group_open_braces++\n       \
    \ } else if char == ')' {\n            paren_group_close_braces++\n        } else\
    \ if char == ' ' {\n            continue\n        } else if char == '{' {\n  \
    \          paren_group_open_parens++\n        } else if char == '}' {\n      \
    \      paren_group_close_parens++\n        } else if char == ')' {\n         \
    \   paren_group_is_closed = true\n        }\n\n        if paren_group_is_closed\
    \ {\n            if paren_group_open_braces == paren_group_close_braces {\n  \
    \              paren_group_string = paren_group_string[:len(paren_group_string)-len(char)]\n\
    \                paren_group_strings = append(paren_group_strings, paren_group_string)\n\
    \                paren_group_string = \"\"\n                paren_group_open_braces\
    \ = 0\n                paren_group_close_braces = 0\n                paren_group_open_parens\
    \ = 0\n                paren_group_close_parens = 0\n                paren_group_is_closed\
    \ = false\n            } else if paren_group_open_parens == paren_group_close_parens\
    \ {\n                paren_group_string = paren_group_string[:len(paren_group_string)-len(char)]\n\
    \                paren_group_strings = append(paren_group_strings, paren_group_string)\n\
    \                paren_group_string = \"\"\n                paren_group_open_braces\
    \ = 0\n                paren_group_close_braces = 0\n                paren_group_open_parens\
    \ = 0\n                paren_group_close_parens = 0\n                paren_group_is_closed\
    \ = false\n            } else {\n                paren_group_string = paren_group_string[:len(paren_group_string)-len(char)]\n\
    \                paren_group_strings = append(paren_group_strings, paren_group_string)\n\
    \                paren_group_string = \"\"\n                paren_group_open_braces\
    \ = 0\n                paren_group_close_braces = 0\n                paren_group_open_parens\
    \ = 0\n                paren_group_close_parens = 0\n                paren_group_is_closed\
    \ = false\n            }\n        } else {\n            paren_group_string\nfunc\
    \ TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpbdo2vpqs_test.go:69:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074120
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_string += \")\"\n    paren_string += \"(\"\n \
    \   paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\
    \n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string += \"\
    (\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8clhzg06_test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074002
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    result := []string{}\n    stack := []string{}\n    open_braces\
    \ := 0\n    close_braces := 0\n    brace_count := 0\n    brace_type := \"\"\n\
    \    brace_type := \"\"\n    brace_type := \"\"\n    brace_type := \"\"\n    brace_type\
    \ := \"\"\n    brace_type := \"\"\n    brace_type := \"\"\n    brace_type := \"\
    \"\n    brace_type := \"\"\n    brace_type := \"\"\n    brace_type := \"\"\n \
    \   brace_type := \"\"\n    brace_type := \"\"\n    brace_type := \"\"\n    brace_type\
    \ := \"\"\n    brace_type := \"\"\n    brace_type := \"\"\n    brace_type := \"\
    \"\n    brace_type := \"\"\n    brace_type := \"\"\n    brace_type := \"\"\n \
    \   brace_type := \"\"\n    brace_type := \"\"\n    brace_type := \"\"\n    brace_type\
    \ := \"\"\n    brace_type := \"\"\n    brace_type := \"\"\n    brace_type := \"\
    \"\n    brace_type := \"\"\n    brace_type := \"\"\n    brace_type := \"\"\n \
    \   brace_type := \"\"\n    brace_type := \"\"\n    brace_type := \"\"\n    brace_type\
    \ := \"\"\n    brace_type := \"\"\n    brace_type := \"\"\n    brace_type := \"\
    \"\n    brace_type := \"\"\n    brace_type := \"\"\n    brace_type := \"\"\n \
    \   brace_type := \"\"\n    brace_type := \"\"\n    brace_type := \"\"\n    brace_type\
    \ := \"\"\n    brace_type := \"\"\n    brace_type := \"\"\n    brace_type := \"\
    \"\n    brace_type := \"\"\n    brace_type := \"\"\n    brace_type := \"\"\n \
    \   brace_type := \"\"\n    brace_type := \"\"\n    brace_type := \"\"\n    brace_type\
    \ := \"\"\n    brace_type := \"\"\n    brace_type := \"\"\n    brace_type := \"\
    \"\n    brace_type := \"\"\n    brace_type := \"\"\n    brace_type := \"\"\n \
    \   brace_type := \"\"\n    brace_type := \"\"\n    brace_type := \"\"\n    brace_type\
    \ := \"\"\n    brace_type := \"\"\n    brace_type := \"\"\n    brace_type := \"\
    \"\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpfyab_l0d_test.go:88:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074009
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_string += \")\"\n    paren_string += \"(\"\n \
    \   paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\
    \n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string += \"\
    (\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8clhzg06_test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074002
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_group_strings := make([]string, 0)\n    paren_group_strings\
    \ = append(paren_group_strings, paren_string)\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_group_strings = append(paren_group_strings, paren_string)\n    paren_group_strings\
    \ = append(paren_group_strings, paren_string)\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_group_strings = append(paren_group_strings, paren_string)\n    paren_group_strings\
    \ = append(paren_group_strings, paren_string)\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_group_strings = append(paren_group_strings, paren_string)\n    paren_group_strings\
    \ = append(paren_group_strings, paren_string)\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_group_strings = append(paren_group_strings, paren_string)\n    paren_group_strings\
    \ = append(paren_group_strings, paren_string)\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_group_strings = append(paren_group_strings, paren_string)\n    paren_group_strings\
    \ = append(paren_group_strings, paren_string)\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_group_strings = append(paren_group_strings, paren_string)\n    paren_group_strings\
    \ = append(paren_group_strings, paren_string)\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_group_strings = append(paren_group_strings, paren_string)\n    paren_group_strings\
    \ = append(paren_group_strings, paren_string)\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp705dn0ck_test.go:48:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074117
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_string += \")\"\n    paren_string += \"(\"\n \
    \   paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\
    \n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string += \"\
    (\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8clhzg06_test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074002
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_string += \")\"\n    paren_string += \"(\"\n \
    \   paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\
    \n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string += \"\
    (\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8clhzg06_test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074002
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_group_regex := regexp.MustCompile(`\\((?P<group>.*?)\\\
    )`)\n    result := make([]string, 0)\n    matches := paren_group_regex.FindAllStringSubmatch(paren_string,\
    \ -1)\n    for _, match := range matches {\n        result := append(result, match[1])\n\
    \    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n\
    \  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpcte1nfdh_test.go:15:26: undefined: regexp

    /tmp/tmpcte1nfdh_test.go:19:9: result declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074120
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    result := []string{}\n    stack := []string{}\n    open_braces\
    \ := 0\n    close_braces := 0\n    brace_count := 0\n    brace_count += count_open_braces(paren_string)\n\
    \    brace_count += count_close_braces(paren_string)\n    open_braces += count_open_braces(paren_string)\n\
    \    close_braces += count_close_braces(paren_string)\n    stack = append(stack,\
    \ paren_string)\n    for len(stack) > 0 {\n        paren_string := stack[len(stack)-1]\n\
    \        stack = stack[:len(stack)-1]\n        if open_braces > close_braces {\n\
    \            result += append(result, paren_string)\n        } else {\n      \
    \      open_braces -= close_braces\n            close_braces = 0\n           \
    \ brace_count -= count_open_braces(paren_string)\n            brace_count -= count_close_braces(paren_string)\n\
    \            open_braces += count_open_braces(paren_string)\n            close_braces\
    \ += count_close_braces(paren_string)\n            stack = append(stack, paren_string)\n\
    \        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0tz9wtvv_test.go:20:20: undefined: count_open_braces

    /tmp/tmp0tz9wtvv_test.go:21:20: undefined: count_close_braces

    /tmp/tmp0tz9wtvv_test.go:22:20: undefined: count_open_braces

    /tmp/tmp0tz9wtvv_test.go:23:21: undefined: count_close_braces

    /tmp/tmp0tz9wtvv_test.go:29:13: invalid operation: operator + not defined on result
    (variable of type []string)

    /tmp/tmp0tz9wtvv_test.go:33:28: undefined: count_open_braces

    /tmp/tmp0tz9wtvv_test.go:34:28: undefined: count_close_braces

    /tmp/tmp0tz9wtvv_test.go:35:28: undefined: count_open_braces

    /tmp/tmp0tz9wtvv_test.go:36:29: undefined: count_close_braces

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074121
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_string += \")\"\n    paren_string += \"(\"\n \
    \   paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\
    \n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string += \"\
    (\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8clhzg06_test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074002
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n\
    \    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"\
    {}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    \nfunc\
    \ TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8bpr93_n_test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074002
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_group_strings := []string{}\n    paren_group_strings\
    \ = append(paren_group_strings, paren_string)\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_group_strings = append(paren_group_strings, paren_string)\n    paren_group_strings\
    \ = append(paren_group_strings, paren_string)\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_group_strings = append(paren_group_strings, paren_string)\n    paren_group_strings\
    \ = append(paren_group_strings, paren_string)\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_group_strings = append(paren_group_strings, paren_string)\n    paren_group_strings\
    \ = append(paren_group_strings, paren_string)\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_group_strings = append(paren_group_strings, paren_string)\n    paren_group_strings\
    \ = append(paren_group_strings, paren_string)\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_group_strings = append(paren_group_strings, paren_string)\n    paren_group_strings\
    \ = append(paren_group_strings, paren_string)\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_group_strings = append(paren_group_strings, paren_string)\n    paren_group_strings\
    \ = append(paren_group_strings, paren_string)\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_group_strings = append(paren_group_strings, paren_string)\n    paren_group_strings\
    \ = append(paren_group_strings, paren_string)\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_group_string\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpo3h5w7pi_test.go:48:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074002
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_group_strings := []string{}\n    paren_group_string\
    \ := \"\"\n    paren_group_open := false\n    for _, char := range paren_string\
    \ {\n        if char == '(' {\n            if paren_group_open {\n           \
    \     fmt.Println(\"Found nested group\")\n                fmt.Println(paren_group_string)\n\
    \                fmt.Println(paren_group_strings)\n                fmt.Println(\"\
    \ \")\n            }\n            paren_group_open = true\n            paren_group_string\
    \ = paren_group_string[:0]\n        } else if char == ')' {\n            if paren_group_open\
    \ {\n                paren_group_string = append(paren_group_string, char)\n \
    \               paren_group_open = false\n            } else {\n             \
    \   fmt.Println(\"Found unclosed group\")\n                fmt.Println(\" \")\n\
    \            }\n        } else if char == ' ' {\n            if paren_group_open\
    \ {\n                paren_group_string = append(paren_group_string, char)\n \
    \           } else {\n                fmt.Println(\"Found space in group\")\n\
    \                fmt.Println(\" \")\n            }\n        } else {\n       \
    \     paren_group_string = append(paren_group_string, char)\n        }\n    }\n\
    \    if paren_group_open {\n        fmt.Println(\"Found unclosed group\")\n  \
    \      fmt.Println(\" \")\n    }\n    return paren_group_strings\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4xot4_te_test.go:30:45: first argument to append must be a slice; have
    paren_group_string (variable of type string)

    /tmp/tmp4xot4_te_test.go:38:45: first argument to append must be a slice; have
    paren_group_string (variable of type string)

    /tmp/tmp4xot4_te_test.go:44:41: first argument to append must be a slice; have
    paren_group_string (variable of type string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074121
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_group_strings := []string{}\n    paren_group_string\
    \ := \"\"\n    paren_group_open := false\n    paren_group_closed := false\n  \
    \  paren_group_string += paren_string\n    for _, char := range paren_string {\n\
    \        if char == '(' {\n            if paren_group_open {\n               \
    \ fmt.Println(\"Error: open paren group found after closed paren group\")\n  \
    \          }\n            paren_group_open = true\n            paren_group_string\
    \ += char\n        } else if char == ')' {\n            if paren_group_closed\
    \ {\n                fmt.Println(\"Error: closed paren group found after open\
    \ paren group\")\n            }\n            paren_group_closed = true\n     \
    \       paren_group_string += char\n        } else if char == ' ' {\n        \
    \    if paren_group_open && paren_group_closed {\n                fmt.Println(\"\
    Error: space found between open and closed paren groups\")\n            }\n  \
    \          paren_group_string += char\n        } else {\n            paren_group_string\
    \ += char\n        }\n    }\n    paren_group_strings = append(paren_group_strings,\
    \ paren_group_string)\n    return paren_group_strings\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8hl2lyiq_test.go:26:13: invalid operation: paren_group_string += char
    (mismatched types string and rune)

    /tmp/tmp8hl2lyiq_test.go:32:13: invalid operation: paren_group_string += char
    (mismatched types string and rune)

    /tmp/tmp8hl2lyiq_test.go:37:13: invalid operation: paren_group_string += char
    (mismatched types string and rune)

    /tmp/tmp8hl2lyiq_test.go:39:13: invalid operation: paren_group_string += char
    (mismatched types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074121
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_groups = make([]string, 0)\n    paren_groups =\
    \ append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphobsgs_v_test.go:54:32: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074004
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    result := []string{}\n    paren_string += \")\"\n  \
    \  paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\
    \n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string += \"\
    (\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmph15g1xmi_test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074004
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n\
    \    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"\
    {}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    \nfunc\
    \ TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8bpr93_n_test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074002
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_string += \")\"\n    paren_string += \"(\"\n \
    \   paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string += \")\"\
    \n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string += \"\
    )\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string +=\
    \ \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_\n\
    func TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpcvtu_s7s_test.go:80:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074002
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_group_strings := make([]string, 0)\n    paren_group_string\
    \ := \"\"\n    paren_group_open_brace := false\n    paren_group_close_brace :=\
    \ false\n    paren_group_string += paren_string\n    for i := 0; i < len(paren_string);\
    \ i++ {\n        if paren_group_open_brace {\n            if paren_group_close_brace\
    \ {\n                paren_group_string += paren_string[i]\n                paren_group_strings\
    \ = append(paren_group_strings, paren_group_string)\n                paren_group_string\
    \ = \"\"\n                paren_group_open_brace = false\n                paren_group_close_brace\
    \ = false\n            } else {\n                paren_group_string += paren_string[i]\n\
    \                paren_group_close_brace = true\n            }\n        } else\
    \ if paren_group_close_brace {\n            paren_group_string += paren_string[i]\n\
    \            paren_group_open_brace = true\n            paren_group_close_brace\
    \ = false\n        } else {\n            paren_group_string += paren_string[i]\n\
    \        }\n    }\n    return paren_group_strings\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2mjibeib_test.go:23:17: invalid operation: paren_group_string += paren_string[i]
    (mismatched types string and byte)

    /tmp/tmp2mjibeib_test.go:29:17: invalid operation: paren_group_string += paren_string[i]
    (mismatched types string and byte)

    /tmp/tmp2mjibeib_test.go:33:13: invalid operation: paren_group_string += paren_string[i]
    (mismatched types string and byte)

    /tmp/tmp2mjibeib_test.go:37:13: invalid operation: paren_group_string += paren_string[i]
    (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074121
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    // Initialize a stack to keep track of open parens\n\
    \    stack := make([]bool, len(paren_string))\n\n    // Initialize a result list\
    \ to hold the result\n    result := make([]string, 0)\n\n    // Iterate over each\
    \ character in the input string\n    for _, c := range paren_string {\n      \
    \  // If the character is a left paren, push it onto the stack\n        if c ==\
    \ '(' {\n            stack = append(stack, false)\n        }\n\n        // If\
    \ the character is a right paren, pop it from the stack\n        if c == ')' {\n\
    \            stack := stack[:len(stack)-1]\n        }\n\n        // If the stack\
    \ is empty, then the character is a left paren\n        if stack == nil {\n  \
    \          result = append(result, c)\n        }\n\n        // If the stack is\
    \ not empty, then the character is a right paren\n        if stack != nil {\n\
    \            // If the stack is empty, then the character is a left paren\n  \
    \          if stack[len(stack)-1] == false {\n                stack = stack[:len(stack)-1]\n\
    \            }\n\n            // If the stack is not empty, then the character\
    \ is a right paren\n            if stack[len(stack)-1] == true {\n           \
    \     stack = stack[:len(stack)-1]\n            }\n        }\n    }\n\n    //\
    \ Return the result list\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp94_2t3fw_test.go:30:13: stack declared but not used

    /tmp/tmp94_2t3fw_test.go:35:37: cannot use c (variable of type rune) as type string
    in argument to append

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074121
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_string += \")\"\n    paren_string += \"(\"\n \
    \   paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\
    \n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string += \"\
    (\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8clhzg06_test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074002
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_string += \"{}\"\n    paren_string = strings.Replace(paren_string,\
    \ \"( )\", \"{\", -1)\n    paren_string = strings.Replace(paren_string, \" {\"\
    , \"{\", -1)\n    paren_string = strings.Replace(paren_string, \"( )\", \"{\"\
    , -1)\n    paren_string = strings.Replace(paren_string, \" {\", \"{\", -1)\n \
    \   paren_string = strings.Replace(paren_string, \"( )\", \"{\", -1)\n    paren_string\
    \ = strings.Replace(paren_string, \" {\", \"{\", -1)\n    paren_string = strings.Replace(paren_string,\
    \ \"( )\", \"{\", -1)\n    paren_string = strings.Replace(paren_string, \" {\"\
    , \"{\", -1)\n    paren_string = strings.Replace(paren_string, \"( )\", \"{\"\
    , -1)\n    paren_string = strings.Replace(paren_string, \" {\", \"{\", -1)\n \
    \   paren_string = strings.Replace(paren_string, \"( )\", \"{\", -1)\n    paren_string\
    \ = strings.Replace(paren_string, \" {\", \"{\", -1)\n    paren_string = strings.Replace(paren_string,\
    \ \"( )\", \"{\", -1)\n    paren_string = strings.Replace(paren_string, \" {\"\
    , \"{\", -1)\n    paren_string = strings.Replace(paren_string, \"( )\", \"{\"\
    , -1)\n    paren_string = strings.Replace(paren_string, \" {\", \"{\", -1)\n \
    \   paren_string = strings.Replace(paren_string, \"( )\", \"{\", -1)\n    paren_string\
    \ = strings.Replace(paren_string, \" {\", \"{\", -1)\n    paren_string = strings.Replace(paren_string,\
    \ \"( )\", \"{\", -1)\n    paren_string = strings.Replace(paren_string, \" {\"\
    , \"{\", -1)\n    paren_string = strings.Replace(paren_string, \"( )\", \"{\"\
    , -1)\n    paren_string = strings.Replace(paren_string, \" {\", \"{\", -1)\n \
    \   paren_string = strings.Replace(paren_string, \"( )\", \"{\", -1)\n    paren_string\
    \ = strings.Replace(paren_string, \" {\", \"{\", -1)\n    paren_string = strings.Replace(paren_string,\
    \ \"( )\", \"{\", -1)\n    paren_string = strings.Replace(paren_string, \" {\"\
    , \"{\", -1)\n    paren_string = strings.Replace(paren_string, \"( )\", \"{\"\
    , -1)\n    paren_string = strings.Replace(paren_string, \" {\", \"{\", -1)\n \
    \   paren_string = strings.Replace(paren_string, \"( )\", \"{\", -1)\n    paren_string\
    \ = strings.Replace(paren_string, \" {\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpyx75v8c2_test.go:45:50: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074121
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_string += \")\"\n    paren_string += \"(\"\n \
    \   paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string += \")\"\
    \n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string += \"\
    )\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string +=\
    \ \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_\n\
    func TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpcvtu_s7s_test.go:80:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074002
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_string += \")\"\n    paren_string += \"(\"\n \
    \   paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\
    \n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string += \"\
    (\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8clhzg06_test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074002
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_group_strings := []string{}\n    paren_group :=\
    \ \"\"\n    paren_group_open := false\n    paren_group_closed := false\n    paren_group_string\
    \ := \"\"\n    paren_group_string := \"\"\n    paren_group_string := \"\"\n  \
    \  for _, char := range paren_string {\n        if char == '(' {\n           \
    \ if paren_group_open {\n                fmt.Println(\"Error: unexpected open\
    \ paren group\")\n            }\n            paren_group_open = true\n       \
    \     paren_group_string += char\n        } else if char == ')' {\n          \
    \  if paren_group_closed {\n                fmt.Println(\"Error: unexpected close\
    \ paren group\")\n            }\n            paren_group_closed = true\n     \
    \       paren_group_string += char\n        } else if char == ' ' {\n        \
    \    if paren_group_open && paren_group_closed {\n                fmt.Println(\"\
    Error: unexpected space between paren groups\")\n            }\n            paren_group_string\
    \ += char\n        } else {\n            if paren_group_open && paren_group_closed\
    \ {\n                paren_group_strings = append(paren_group_strings, paren_group_string)\n\
    \                paren_group_string = \"\"\n                paren_group_open =\
    \ false\n                paren_group_closed = false\n            }\n         \
    \   paren_group_string = paren_group_string + char\n        }\n    }\n    if paren_group_open\
    \ {\n        fmt.Println(\"Error: unexpected open paren group\")\n    }\n    if\
    \ paren_group_closed {\n        fmt.Println(\"Error: unexpected close paren group\"\
    )\n    }\n    if paren_group_strings != nil {\n        paren_group_strings = append(paren_group_strings,\
    \ paren_group_string)\n    }\n    return paren_group_strings\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbzvu1c7w_test.go:16:5: paren_group declared but not used

    /tmp/tmpbzvu1c7w_test.go:20:24: no new variables on left side of :=

    /tmp/tmpbzvu1c7w_test.go:21:24: no new variables on left side of :=

    /tmp/tmpbzvu1c7w_test.go:28:13: invalid operation: paren_group_string += char
    (mismatched types string and rune)

    /tmp/tmpbzvu1c7w_test.go:34:13: invalid operation: paren_group_string += char
    (mismatched types string and rune)

    /tmp/tmpbzvu1c7w_test.go:39:13: invalid operation: paren_group_string += char
    (mismatched types string and rune)

    /tmp/tmpbzvu1c7w_test.go:47:34: invalid operation: paren_group_string + char (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074121
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_group_regex := regexp.MustCompile(`\\((?P<paren_group>[^\\\
    (\\)]+)\\)`)\n    paren_groups := paren_group_regex.FindAllStringSubmatch(paren_string,\
    \ -1)\n    result := []string{}\n    for _, paren_group := range paren_groups\
    \ {\n        result := append(result, paren_group[1])\n    }\n    return result\n\
    }\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpe4cpopl4_test.go:15:26: undefined: regexp

    /tmp/tmpe4cpopl4_test.go:19:9: result declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074121
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n\
    \    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"\
    {}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    \nfunc\
    \ TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8bpr93_n_test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074002
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n\
    \    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"\
    {}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    \nfunc\
    \ TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8bpr93_n_test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074002
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_string += \")\"\n    paren_string += \"(\"\n \
    \   paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\
    \n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string += \"\
    (\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8clhzg06_test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074002
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    // Initialize a slice to hold the result\n    result\
    \ := make([]string, 0)\n\n    // Iterate over the input string and add each group\
    \ to the result slice\n    paren_string := paren_string\n    for _, group := range\
    \ paren_string.([]string) {\n        // If this group is empty, skip it\n    \
    \    if len(group) == 0 {\n            continue\n        }\n\n        // If the\
    \ last group is empty, add this group to the result slice\n        if len(result)\
    \ == 0 {\n            result = append(result, group)\n            continue\n \
    \       }\n\n        // If the last group is not empty, check if this group is\
    \ balanced\n        ok := balanced(group, result[len(result)-1])\n        if !ok\
    \ {\n            // If this group is not balanced, add it to the result slice\n\
    \            result = append(result, group)\n        }\n    }\n\n    // Return\
    \ the result slice\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbrw1ielj_test.go:19:18: no new variables on left side of :=

    /tmp/tmpbrw1ielj_test.go:20:27: invalid operation: paren_string (variable of type
    string) is not an interface

    /tmp/tmpbrw1ielj_test.go:33:15: undefined: balanced

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074121
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_string += \")\"\n    paren_string += \"(\"\n \
    \   paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\
    \n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string += \"\
    (\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8clhzg06_test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074002
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    var result []string\n    stack := make([]string, 0)\n\
    \    stack := append(stack, paren_string)\n    depth := 0\n    for len(stack)\
    \ > 0 {\n        depth += 1\n        stack := stack[:0]\n        for _, s := range\
    \ stack {\n            depth += strings.Count(s, \"(\")\n            depth +=\
    \ strings.Count(s, \")\")\n            stack = append(stack, strings.Replace(s,\
    \ \"(\", \"(\", -1))\n            stack = append(stack, strings.Replace(s, \"\
    )\", \")\", -1))\n        }\n        result = append(result, stack...)\n    }\n\
    \    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmptof63b8j_test.go:17:11: no new variables on left side of :=

    /tmp/tmptof63b8j_test.go:23:22: undefined: strings

    /tmp/tmptof63b8j_test.go:24:22: undefined: strings

    /tmp/tmptof63b8j_test.go:25:35: undefined: strings

    /tmp/tmptof63b8j_test.go:26:35: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074121
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_group_regex := regexp.MustCompile(`\\((?P<paren_group>[^\\\
    (\\)]+)\\)`)\n    paren_groups := paren_group_regex.FindAllStringSubmatch(paren_string,\
    \ -1)\n    result := make([]string, len(paren_groups))\n    for index, paren_group\
    \ := range paren_groups {\n        result[index] = paren_group[0]\n    }\n   \
    \ return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0zwnguhl_test.go:15:26: undefined: regexp

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074009
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_group_strings := []string{}\n    paren_group_string\
    \ := \"\"\n    paren_group_open := false\n    paren_group_closed := false\n  \
    \  for _, char := range paren_string {\n        if char == '(' {\n           \
    \ if paren_group_open {\n                fmt.Println(\"Error: unexpected open\
    \ paren group\")\n                return nil\n            }\n            paren_group_open\
    \ = true\n            paren_group_string += char\n        } else if char == ')'\
    \ {\n            if paren_group_closed {\n                fmt.Println(\"Error:\
    \ unexpected close paren group\")\n                return nil\n            }\n\
    \            paren_group_closed = true\n            paren_group_string += char\n\
    \        } else if char == ' ' {\n            if paren_group_open && paren_group_closed\
    \ {\n                fmt.Println(\"Error: unexpected space in paren group\")\n\
    \                return nil\n            }\n            paren_group_string +=\
    \ char\n        } else {\n            if paren_group_open && paren_group_closed\
    \ {\n                paren_group_strings = append(paren_group_strings, paren_group_string)\n\
    \                paren_group_string = \"\"\n                paren_group_open =\
    \ false\n                paren_group_closed = false\n            }\n         \
    \   paren_group_string += char\n        }\n    }\n    if paren_group_open {\n\
    \        fmt.Println(\"Error: unexpected open paren group\")\n        return nil\n\
    \    }\n    if paren_group_closed {\n        fmt.Println(\"Error: unexpected close\
    \ paren group\")\n        return nil\n    }\n    paren_group_strings = append(paren_group_strings,\
    \ paren_group_string)\n    return paren_group_strings\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpovc7dtma_test.go:26:13: invalid operation: paren_group_string += char
    (mismatched types string and rune)

    /tmp/tmpovc7dtma_test.go:33:13: invalid operation: paren_group_string += char
    (mismatched types string and rune)

    /tmp/tmpovc7dtma_test.go:39:13: invalid operation: paren_group_string += char
    (mismatched types string and rune)

    /tmp/tmpovc7dtma_test.go:47:13: invalid operation: paren_group_string += char
    (mismatched types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074121
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_string += \")\"\n    paren_string += \"(\"\n \
    \   paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\
    \n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string += \"\
    (\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8clhzg06_test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074002
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_string += \")\"\n    paren_string += \"(\"\n \
    \   paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string += \")\"\
    \n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string += \"\
    )\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string +=\
    \ \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_\n\
    func TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpcvtu_s7s_test.go:80:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074002
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_string += \")\"\n    paren_string += \"(\"\n \
    \   paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\
    \n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string += \"\
    (\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8clhzg06_test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074002
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_groups := make([]string, 0)\n    paren_group :=\
    \ \"\"\n    paren_group_is_open := false\n    for _, char := range paren_string\
    \ {\n        if char == '(' {\n            if paren_group_is_open {\n        \
    \        fmt.Println(\"Found open paren group\", paren_group)\n              \
    \  paren_groups = append(paren_groups, paren_group)\n                paren_group\
    \ = \"\"\n                paren_group_is_open = false\n            }\n       \
    \     paren_group_is_open = true\n        } else if char == ')' {\n          \
    \  if paren_group_is_open {\n                fmt.Println(\"Found closed paren\
    \ group\", paren_group)\n                paren_groups = append(paren_groups, paren_group)\n\
    \                paren_group = \"\"\n                paren_group_is_open = false\n\
    \            }\n        } else if char == ' ' {\n            // Ignore spaces\
    \ in paren group\n        } else {\n            paren_group += string(char)\n\
    \        }\n    }\n    if paren_group_is_open {\n        fmt.Println(\"Found open\
    \ paren group\", paren_group)\n        paren_groups = append(paren_groups, paren_group)\n\
    \    }\n    return paren_groups\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "Found open paren group \nFound closed paren group \nFound closed paren\
    \ group \nFound open paren group \nFound open paren group \nFound closed paren\
    \ group \nFound closed paren group \nFound open paren group \nFound open paren\
    \ group \nFound closed paren group \nFound closed paren group \nFound closed paren\
    \ group \nFound closed paren group \nFound open paren group \nFound closed paren\
    \ group \nFound open paren group \nFound open paren group \nFound closed paren\
    \ group \nFound open paren group \nFound open paren group \nFound open paren group\
    \ \nFound closed paren group \nFound open paren group \nFound closed paren group\
    \ \nFound open paren group \nFound closed paren group \nFound open paren group\
    \ \nFound open paren group \nFound closed paren group \nFound closed paren group\
    \ \nFound open paren group \nFound closed paren group \nFound open paren group\
    \ \nFound closed paren group \nFound closed paren group \n--- FAIL: TestSeparate_Paren_Groups\
    \ (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n     \
    \   tmp9k8_yvtp_test.go:63: expected '[(()()) ((())) () ((())()())]', got '[ \
    \          ]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n \
    \       tmp9k8_yvtp_test.go:63: expected '[() (()) ((())) (((())))]', got '[ \
    \        ]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n   \
    \     tmp9k8_yvtp_test.go:63: expected '[(()(())((())))]', got '[      ]'\n  \
    \  --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmp9k8_yvtp_test.go:63:\
    \ expected '[() (()) (()())]', got '[     ]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074122
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    result := []string{}\n    stack := []string{}\n    open_braces\
    \ := 0\n    close_braces := 0\n    brace_count := 0\n    for _, char := range\
    \ paren_string {\n        if char == '(' {\n            open_braces++\n      \
    \      stack = append(stack, char)\n        } else if char == ')' {\n        \
    \    close_braces++\n            if open_braces != close_braces {\n          \
    \      fmt.Printf(\"Mismatched braces: %v %v\\n\", open_braces, close_braces)\n\
    \            }\n            if open_braces == close_braces {\n               \
    \ stack = stack[:len(stack)-1]\n                result := append(result, string(stack))\n\
    \                stack = stack[:len(stack)-1]\n            }\n        } else if\
    \ char == ' ' {\n            brace_count++\n        }\n    }\n    if open_braces\
    \ != close_braces {\n        fmt.Printf(\"Mismatched braces: %v %v\\n\", open_braces,\
    \ close_braces)\n    }\n    if open_braces != brace_count {\n        fmt.Printf(\"\
    Mismatched braces: %v %v\\n\", open_braces, brace_count)\n    }\n    return result\n\
    }\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprt42u_y6_test.go:23:35: cannot use char (variable of type rune) as type
    string in argument to append

    /tmp/tmprt42u_y6_test.go:31:17: result declared but not used

    /tmp/tmprt42u_y6_test.go:31:49: cannot convert stack (variable of type []string)
    to type string

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074121
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_group_strings := []string{}\n    paren_group_string\
    \ := \"\"\n    paren_group_open := false\n    paren_group_closed := false\n  \
    \  paren_group_is_empty := false\n    for _, character := range paren_string {\n\
    \        if character == '(' {\n            if paren_group_is_empty {\n      \
    \          paren_group_string = fmt.Sprintf(\"%s\", character)\n            }\
    \ else {\n                paren_group_string = fmt.Sprintf(\"%s%s\", paren_group_string,\
    \ character)\n            }\n            paren_group_open = true\n           \
    \ paren_group_is_empty = false\n        } else if character == ')' {\n       \
    \     if paren_group_open {\n                paren_group_string = fmt.Sprintf(\"\
    %s%s\", paren_group_string, character)\n            } else {\n               \
    \ paren_group_string = fmt.Sprintf(\"%s\", character)\n            }\n       \
    \     paren_group_closed = true\n            paren_group_is_empty = false\n  \
    \      } else if character == ' ' {\n            if paren_group_open {\n     \
    \           paren_group_string = fmt.Sprintf(\"%s%s\", paren_group_string, character)\n\
    \            } else {\n                paren_group_string = fmt.Sprintf(\"%s\"\
    , character)\n            }\n            paren_group_is_empty = true\n       \
    \ } else {\n            if paren_group_open {\n                paren_group_string\
    \ = fmt.Sprintf(\"%s%s\", paren_group_string, character)\n            } else {\n\
    \                paren_group_string = fmt.Sprintf(\"%s\", character)\n       \
    \     }\n            paren_group_is_empty = true\n        }\n    }\n    if paren_group_string\
    \ != \"\" {\n        paren_group_strings = append(paren_group_strings, paren_group_string)\n\
    \    }\n    return paren_group_strings\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpgw3sskrz_test.go:18:5: paren_group_closed declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074121
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_string += \")\"\n    paren_string += \"(\"\n \
    \   paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\
    \n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string += \"\
    (\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8clhzg06_test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074002
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_string += \")\"\n    paren_string += \"(\"\n \
    \   paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\
    \n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string += \"\
    (\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8clhzg06_test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074002
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_string += \")\"\n    paren_string += \"(\"\n \
    \   paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\
    \n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string += \"\
    (\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8clhzg06_test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074002
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_group_strings := []string{}\n    paren_group_string\
    \ := \"\"\n    paren_group_open := false\n    paren_group_closed := false\n  \
    \  for _, char := range paren_string {\n        if char == '(' {\n           \
    \ if paren_group_open {\n                fmt.Println(\"Error: unexpected open\
    \ paren group\")\n                fmt.Println(paren_string)\n                fmt.Println(paren_group_open)\n\
    \                fmt.Println(paren_group_closed)\n                fmt.Println(paren_group_string)\n\
    \                fmt.Println(paren_group_strings)\n                return nil\n\
    \            }\n            paren_group_open = true\n            paren_group_string\
    \ = paren_group_string[:0]\n            paren_group_closed = false\n        }\
    \ else if char == ')' {\n            if paren_group_closed {\n               \
    \ fmt.Println(\"Error: unexpected close paren group\")\n                fmt.Println(paren_string)\n\
    \                fmt.Println(paren_group_open)\n                fmt.Println(paren_group_closed)\n\
    \                fmt.Println(paren_group_string)\n                fmt.Println(paren_group_strings)\n\
    \                return nil\n            }\n            paren_group_closed = true\n\
    \            paren_group_string = paren_group_string[:0]\n            paren_group_open\
    \ = false\n        } else if char == ' ' {\n            paren_group_string = paren_group_string[:0]\n\
    \        } else {\n            paren_group_string = append(paren_group_string,\
    \ char)\n        }\n    }\n    if paren_group_open {\n        fmt.Println(\"Error:\
    \ unexpected open paren group\")\n        fmt.Println(paren_string)\n        fmt.Println(paren_group_open)\n\
    \        fmt.Println(paren_group_closed)\n        fmt.Println(paren_group_string)\n\
    \        fmt.Println(paren_group_strings)\n        return nil\n    }\n    if paren_group_closed\
    \ {\n        fmt.Println(\"Error: unexpected close paren group\")\n        fmt.Println(paren_string)\n\
    \        fmt.Println(paren_group_open)\n        fmt.Println(paren_group_closed)\n\
    \        fmt.Println(paren_group_string)\n        fmt.Println(paren_group_strings)\n\
    \        return nil\n    }\n    paren_group_strings = append(paren_group_strings,\
    \ paren_group_string)\n    return paren_group_strings\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpl5i2vecz_test.go:49:41: first argument to append must be a slice; have
    paren_group_string (variable of type string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074122
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    // Initialize a stack to keep track of open parens\n\
    \    stack := make([]bool, len(paren_string))\n    // Initialize a result list\
    \ to store our results\n    result := make([]string, 0)\n    // Iterate over each\
    \ character in the string\n    for _, c := range paren_string {\n        // If\
    \ the character is a left paren, push it to the stack\n        if c == '(' {\n\
    \            stack = append(stack, c)\n        // If the character is a right\
    \ paren, pop it from the stack\n        } else if c == ')' {\n            // If\
    \ we pop a left paren without popping a right paren, that's a syntax error\n \
    \           if !stack[len(stack)-1] {\n                fmt.Println(\"Syntax error\"\
    )\n                fmt.Println(paren_string)\n                fmt.Println(stack)\n\
    \                panic(\"Syntax error\")\n            }\n            stack = stack[:len(stack)-1]\n\
    \        }\n        // If the character is a left paren, push it to the stack\n\
    \        if c == '{' {\n            stack = append(stack, c)\n        // If the\
    \ character is a right paren, pop it from the stack\n        } else if c == '}'\
    \ {\n            // If we pop a left paren without popping a right paren, that's\
    \ a syntax error\n            if !stack[len(stack)-1] {\n                fmt.Println(\"\
    Syntax error\")\n                fmt.Println(paren_string)\n                fmt.Println(stack)\n\
    \                panic(\"Syntax error\")\n            }\n            stack = stack[:len(stack)-1]\n\
    \        }\n        // If the character is a space\n        if c == ' ' {\n  \
    \          // If we have an open paren, add it to the result\n            if stack[len(stack)-1]\
    \ {\n                result = append(result, string(stack[len(stack)-1]))\n  \
    \              // If we have an open brace, add it to the result\n           \
    \     if stack[len(stack)-2] {\n                    result = append(result, string(stack[len(stack)-2]))\n\
    \                }\n                // If we have an open brace, add it to the\
    \ result\n                if stack[len(stack)-3] {\n                    result\
    \ = append(result, string(stack[len(stack)-3]))\n                }\n         \
    \       // If we have an open brace, add it to the result\n                if\
    \ stack[len(stack)-4] {\n                    result = append(result, string(stack[len(stack)-4]))\n\
    \                }\n                // If we have an open brace, add it to the\
    \ result\n                if stack[len(stack)-5] {\n                    result\
    \ = append(result, string(stack[len(stack)-5]))\n                }\n         \
    \       // If we have an open brace, add it to the result\n                if\
    \ stack[len(stack)-6] {\n                    result = append(result, string(stack[len(stack)-6]))\n\
    \                }\n                // If we have an open bra\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpcyfqr_5i_test.go:75:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074121
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_group_strings := []string{}\n    paren_group_strings\
    \ = append(paren_group_strings, paren_string)\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_group_strings = append(paren_group_strings, paren_string)\n    return\
    \ paren_group_strings\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n \
    \ candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmpp1q7mzsi_test.go:39: expected '[(()()) ((())) () ((())()())]',\
    \ got '[(()()) ((())) () ((())()()) (()()) ((())) () ((())()()) (()()) ((()))\
    \ () ((())()()) (()()) ((())) () ((())()())]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1\
    \ (0.00s)\n        tmpp1q7mzsi_test.go:39: expected '[() (()) ((())) (((())))]',\
    \ got '[() (()) ((())) (((()))) () (()) ((())) (((()))) () (()) ((())) (((())))\
    \ () (()) ((())) (((())))]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2\
    \ (0.00s)\n        tmpp1q7mzsi_test.go:39: expected '[(()(())((())))]', got '[(()(())((())))\
    \ (()(())((()))) (()(())((()))) (()(())((())))]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmpp1q7mzsi_test.go:39: expected '[() (()) (()())]', got '[(\
    \ ) (( )) (( )( )) ( ) (( )) (( )( )) ( ) (( )) (( )( )) ( ) (( )) (( )( ))]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074122
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_groups = make([]string, 0)\n    paren_stack =\
    \ make([]string, 0)\n    paren_stack = append(paren_stack, paren_string)\n   \
    \ for len(paren_stack) > 0 {\n        paren_str = paren_stack[len(paren_stack)-1]\n\
    \        paren_stack = paren_stack[:len(paren_stack)-1]\n        paren_groups\
    \ = append(paren_groups, paren_str)\n    }\n    return paren_groups\n}\n\nfunc\
    \ TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0amy3prb_test.go:15:5: undefined: paren_groups

    /tmp/tmp0amy3prb_test.go:16:5: undefined: paren_stack

    /tmp/tmp0amy3prb_test.go:17:26: undefined: paren_stack

    /tmp/tmp0amy3prb_test.go:18:13: undefined: paren_stack

    /tmp/tmp0amy3prb_test.go:19:9: undefined: paren_str

    /tmp/tmp0amy3prb_test.go:19:21: undefined: paren_stack

    /tmp/tmp0amy3prb_test.go:20:23: undefined: paren_stack

    /tmp/tmp0amy3prb_test.go:21:9: undefined: paren_groups

    /tmp/tmp0amy3prb_test.go:21:31: undefined: paren_groups

    /tmp/tmp0amy3prb_test.go:21:45: undefined: paren_str

    /tmp/tmp0amy3prb_test.go:21:9: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074123
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    result := []string{}\n    stack := []string{}\n    open_braces\
    \ := 0\n    close_braces := 0\n    brace_count := 0\n    brace_type := 0\n   \
    \ brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type :=\
    \ 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpzyk5wn5l_test.go:88:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074002
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n\
    \    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"\
    {}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    \nfunc\
    \ TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8bpr93_n_test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074002
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_string += \")\"\n    paren_string += \"(\"\n \
    \   paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\
    \n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string += \"\
    (\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8clhzg06_test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074002
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_groups = make([]string, 0)\n    paren_stack =\
    \ make([]string, 0)\n    paren_stack = append(paren_stack, paren_string)\n   \
    \ paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, \nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpo_o6qnc0_test.go:55:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074122
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    // Initialize a list to hold our results\n    result\
    \ := make([]string, 0)\n\n    // Iterate through each character in the string\n\
    \    for _, char := range paren_string {\n        // If the character is a left\
    \ paren, add it to the list\n        if char == '(' {\n            result = append(result,\
    \ char)\n        }\n\n        // If the character is a right paren, remove it\
    \ from the list\n        if char == ')' {\n            result = remove_bracket(result,\
    \ char)\n        }\n    }\n\n    // Return the list of results\n    return result\n\
    }\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5a1f8o1s_test.go:22:37: cannot use char (variable of type rune) as type
    string in argument to append

    /tmp/tmp5a1f8o1s_test.go:27:22: undefined: remove_bracket

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074123
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    result := []string{}\n    stack := []string{}\n    open_braces\
    \ := 0\n    close_braces := 0\n    brace_count := 0\n    brace_type := 0\n   \
    \ brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type :=\
    \ 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpzyk5wn5l_test.go:88:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074002
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_string += \")\"\n    paren_string += \"(\"\n \
    \   paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string += \")\"\
    \n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string += \"\
    )\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string +=\
    \ \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_\n\
    func TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpcvtu_s7s_test.go:80:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074002
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_groups = make([]string, 0)\n    paren_groups =\
    \ append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphobsgs_v_test.go:54:32: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074004
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    // Initialize a stack to keep track of open parens\n\
    \    stack := make([]bool, len(paren_string))\n\n    // Initialize a result list\
    \ to hold our result\n    result := make([]string, 0)\n\n    // Iterate through\
    \ our input string\n    for i, char := range paren_string {\n        // If the\
    \ character is a left paren, push it onto the stack\n        if char == '(' {\n\
    \            stack[i] = true\n        }\n\n        // If the character is a right\
    \ paren, pop it off the stack\n        if char == ')' {\n            stack[i]\
    \ = false\n        }\n\n        // If the stack is empty, we've found our result\n\
    \        if stack[i] == false {\n            result = append(result, string(char))\n\
    \        }\n    }\n\n    return result\n}\n</code>\n<|/ a tags=string,go |>\n\
    <| c |>\nThis solution doesn't work if there are multiple groups of parenthesis\
    \ inside each other. For example: `\"( ( ( ) ) )\"` will result in `[]string{\"\
    ()\", \"(())\", \"(()())\"}`\n<|/ c |>\n<| c |>\nYes, I realized that after I\
    \ posted my comment. I've updated my answer to account for that case.\n<|/ c |>\n\
    <| a tags=string,go |>\n<code>\npackage main\n\nimport (\n    \"fmt\"\n    \"\
    strings\"\n)\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate :=\
    \ separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\",\
    \ \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected:\
    \ []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"\
    ( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpx09u3cvj_test.go:41:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074122
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_string += \")\"\n    paren_string += \"(\"\n \
    \   paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\
    \n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string += \"\
    (\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8clhzg06_test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074002
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_group_regex := regexp.MustCompile(`\\((?P<paren_group>.*?)\\\
    )`)\n    paren_groups := paren_group_regex.FindAllStringSubmatch(paren_string,\
    \ -1)\n    result := make([]string, len(paren_groups))\n    for i := range paren_groups\
    \ {\n        result[i] = paren_groups[i].Groups[\"paren_group\"].Value\n    }\n\
    \    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6i75zdbi_test.go:15:26: undefined: regexp

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074123
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_string += \")\"\n    paren_string += \"(\"\n \
    \   paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\
    \n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string += \"\
    (\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8clhzg06_test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074002
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_group_strings := []string{}\n    paren_group_string\
    \ := \"\"\n    paren_group_open_brace := false\n    paren_group_close_brace :=\
    \ false\n    paren_group_open_paren := false\n    paren_group_close_paren := false\n\
    \    paren_group_string := \"\"\n    paren_group_string := \"\"\n    paren_group_string\
    \ := \"\"\n    paren_group_string := \"\"\n    paren_group_string := \"\"\n  \
    \  paren_group_string := \"\"\n    paren_group_string := \"\"\n    paren_group_string\
    \ := \"\"\n    paren_group_string := \"\"\n    paren_group_string := \"\"\n  \
    \  paren_group_string := \"\"\n    paren_group_string := \"\"\n    paren_group_string\
    \ := \"\"\n    paren_group_string := \"\"\n    paren_group_string := \"\"\n  \
    \  paren_group_string := \"\"\n    paren_group_string := \"\"\n    paren_group_string\
    \ := \"\"\n    paren_group_string := \"\"\n    paren_group_string := \"\"\n  \
    \  paren_group_string := \"\"\n    paren_group_string := \"\"\n    paren_group_string\
    \ := \"\"\n    paren_group_string := \"\"\n    paren_group_string := \"\"\n  \
    \  paren_group_string := \"\"\n    paren_group_string := \"\"\n    paren_group_string\
    \ := \"\"\n    paren_group_string := \"\"\n    paren_group_string := \"\"\n  \
    \  paren_group_string := \"\"\n    paren_group_string := \"\"\n    paren_group_string\
    \ := \"\"\n    paren_group_string := \"\"\n    paren_group_string := \"\"\n  \
    \  paren_group_string := \"\"\n    paren_group_string := \"\"\n    paren_group_string\
    \ := \"\"\n    paren_group_string := \"\"\n    paren_group_string := \"\"\n  \
    \  paren_group_string := \"\"\n    paren_group_string := \"\"\n    paren_group_string\
    \ := \"\"\n    paren_group_string := \"\"\n    paren_group_string := \"\"\n  \
    \  paren_group_string := \"\"\n    paren_group_string := \"\"\n    paren_group_string\
    \ := \"\"\n    paren_group_string := \"\"\n    paren_group_string := \"\"\n  \
    \  paren_group_string := \"\"\n    paren_group_string := \"\"\n    paren_group_string\
    \ := \"\"\n    paren_group_string := \"\"\n    paren_group_string := \"\"\n  \
    \  paren_group_string := \"\"\n    paren_\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpgw2273_s_test.go:78:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074122
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_string += \")\"\n    paren_string += \"(\"\n \
    \   paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\
    \n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string += \"\
    (\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8clhzg06_test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074002
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_string += \")\"\n    paren_string += \"(\"\n \
    \   paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\
    \n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string += \"\
    (\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8clhzg06_test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074002
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_string += \")\"\n    paren_string += \"(\"\n \
    \   paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string += \")\"\
    \n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string += \"\
    )\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string +=\
    \ \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_\n\
    func TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpcvtu_s7s_test.go:80:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074002
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_groups := []string{}\n    paren_stacks := [][]string{}\n\
    \    paren_stack := []string{}\n    paren_stack_length := 0\n    paren_stack_max\
    \ := 0\n    paren_stack_max_index := 0\n    paren_stack_max_length := 0\n    paren_stack_max_index\
    \ := 0\n    paren_stack_max_length := 0\n    paren_stack_max_index := 0\n    paren_stack_max_length\
    \ := 0\n    paren_stack_max_index := 0\n    paren_stack_max_length := 0\n    paren_stack_max_index\
    \ := 0\n    paren_stack_max_length := 0\n    paren_stack_max_index := 0\n    paren_stack_max_length\
    \ := 0\n    paren_stack_max_index := 0\n    paren_stack_max_length := 0\n    paren_stack_max_index\
    \ := 0\n    paren_stack_max_length := 0\n    paren_stack_max_index := 0\n    paren_stack_max_length\
    \ := 0\n    paren_stack_max_index := 0\n    paren_stack_max_length := 0\n    paren_stack_max_index\
    \ := 0\n    paren_stack_max_length := 0\n    paren_stack_max_index := 0\n    paren_stack_max_length\
    \ := 0\n    paren_stack_max_index := 0\n    paren_stack_max_length := 0\n    paren_stack_max_index\
    \ := 0\n    paren_stack_max_length := 0\n    paren_stack_max_index := 0\n    paren_stack_max_length\
    \ := 0\n    paren_stack_max_index := 0\n    paren_stack_max_length := 0\n    paren_stack_max_index\
    \ := 0\n    paren_stack_max_length := 0\n    paren_stack_max_index := 0\n    paren_stack_max_length\
    \ := 0\n    paren_stack_max_index := 0\n    paren_stack_max_length := 0\n    paren_stack_max_index\
    \ := 0\n    paren_stack_max_length := 0\n    paren_stack_max_index := 0\n    paren_stack_max_length\
    \ := 0\n    paren_stack_max_index := 0\n    paren_stack_max_length := 0\n    paren_stack_max_index\
    \ := 0\n    paren_stack_max_length := 0\n    paren_stack_max_index := 0\n    paren_stack_max_length\
    \ := 0\n    paren_stack_max_index := 0\n    paren_stack_max_length := 0\n    paren_stack_max_index\
    \ := 0\n    paren_stack_max_length := 0\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmprsolpax7_test.go:72:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074122
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    var result []string\n    paren_string += \")\"\n   \
    \ paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n\
    \    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string += \"\
    (\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren\n\
    func TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpzuib3dyo_test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074122
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_group_strings := []string{}\n    paren_group_string\
    \ := \"\"\n    paren_group_open := false\n    for _, character := range paren_string\
    \ {\n        if character == \"(\" {\n            if paren_group_open {\n    \
    \            fmt.Println(\"Error: unexpected open paren group\")\n           \
    \     return nil\n            }\n            paren_group_open = true\n       \
    \     paren_group_string += character\n        } else if character == \")\" {\n\
    \            if paren_group_open {\n                paren_group_open = false\n\
    \                paren_group_strings = append(paren_group_strings, paren_group_string)\n\
    \                paren_group_string = \"\"\n            } else {\n           \
    \     fmt.Println(\"Error: unexpected close paren group\")\n                return\
    \ nil\n            }\n        } else {\n            paren_group_string += character\n\
    \        }\n    }\n    if paren_group_open {\n        fmt.Println(\"Error: unexpected\
    \ open paren group\")\n        return nil\n    }\n    paren_group_strings = append(paren_group_strings,\
    \ paren_group_string)\n    return paren_group_strings\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmptkzk2lal_test.go:19:25: invalid operation: character == "(" (mismatched
    types rune and untyped string)

    /tmp/tmptkzk2lal_test.go:25:13: invalid operation: paren_group_string += character
    (mismatched types string and rune)

    /tmp/tmptkzk2lal_test.go:26:32: invalid operation: character == ")" (mismatched
    types rune and untyped string)

    /tmp/tmptkzk2lal_test.go:36:13: invalid operation: paren_group_string += character
    (mismatched types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074123
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_string += \")\"\n    paren_string += \"(\"\n \
    \   paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string += \")\"\
    \n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string += \"\
    )\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string +=\
    \ \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_\n\
    func TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpcvtu_s7s_test.go:80:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074002
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_string += \")\"\n    paren_string += \"(\"\n \
    \   paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\
    \n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string += \"\
    (\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8clhzg06_test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074002
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    // Initialize a stack to keep track of open parens\n\
    \    stack := make([]string, 0)\n\n    // Initialize a result list to hold the\
    \ result\n    result := make([]string, 0)\n\n    // Iterate over each character\
    \ in the input string\n    for _, char := range paren_string {\n        // If\
    \ the character is a left paren, push it to the stack\n        if char == '('\
    \ {\n            stack = append(stack, char)\n        }\n\n        // If the character\
    \ is a right paren, pop it from the stack\n        if char == ')' {\n        \
    \    stack := stack[:len(stack)-1]\n        }\n\n        // If the stack is empty,\
    \ add the character to the result list\n        if len(stack) == 0 {\n       \
    \     result = append(result, char)\n        }\n    }\n\n    // Return the result\
    \ list\n    return result\n}\n</code>\n<|/ a dscore=1 |>\n<| a |>\n<code>\npackage\
    \ main\n\nimport (\n    \"fmt\"\n    \"strings\"\n)\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpdl37ik49_test.go:42:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074123
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n\
    \    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"\
    {}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    \nfunc\
    \ TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8bpr93_n_test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074002
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_group_strings := []string{}\n    paren_group_count\
    \ := 0\n    paren_group_string := \"\"\n    paren_group_string += \"(\"\n    paren_group_string\
    \ += paren_string\n    paren_group_string += \")\"\n    paren_group_count += 2\n\
    \    paren_group_strings = append(paren_group_strings, paren_group_string)\n \
    \   for paren_group_count < len(paren_string) {\n        paren_group_string +=\
    \ paren_string[paren_group_count]\n        paren_group_string += \")\"\n     \
    \   paren_group_count += 2\n        paren_group_strings = append(paren_group_strings,\
    \ paren_group_string)\n    }\n    return paren_group_strings\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmptzuf536u_test.go:24:9: invalid operation: paren_group_string += paren_string[paren_group_count]
    (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074123
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    var result []string\n    stack := make([]string, 0)\n\
    \    stack := append(stack, paren_string)\n    for len(stack) > 0 {\n        current\
    \ := stack[len(stack)-1]\n        stack = stack[:len(stack)-1]\n        if current\
    \ == \")\" {\n            result = append(result, current)\n        } else {\n\
    \            stack = append(stack, current)\n        }\n    }\n    return result\n\
    }\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9_lttjye_test.go:17:11: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074005
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_group_strings := []string{}\n    paren_group_string\
    \ := \"\"\n    paren_group_open := false\n    paren_group_closed := false\n  \
    \  for _, character := range paren_string {\n        if character == \"(\" {\n\
    \            if paren_group_open {\n                fmt.Println(\"Found nested\
    \ paren group\")\n                fmt.Println(paren_group_string)\n          \
    \      fmt.Println(paren_group_strings)\n                fmt.Println(\"\")\n \
    \               panic(\"Found nested paren group\")\n            }\n         \
    \   paren_group_open = true\n            paren_group_string = paren_group_string\
    \ + character\n        } else if character == \")\" {\n            if paren_group_closed\
    \ {\n                fmt.Println(\"Found nested paren group\")\n             \
    \   fmt.Println(paren_group_string)\n                fmt.Println(paren_group_strings)\n\
    \                fmt.Println(\"\")\n                panic(\"Found nested paren\
    \ group\")\n            }\n            paren_group_closed = true\n           \
    \ paren_group_string = paren_group_string + character\n        } else if character\
    \ == \" \" {\n            if paren_group_open {\n                paren_group_string\
    \ = paren_group_string + character\n            } else {\n                paren_group_strings\
    \ = append(paren_group_strings, paren_group_string)\n                paren_group_string\
    \ = \"\"\n                paren_group_open = false\n                paren_group_closed\
    \ = false\n            }\n        } else {\n            paren_group_string = paren_group_string\
    \ + character\n        }\n    }\n    paren_group_strings = append(paren_group_strings,\
    \ paren_group_string)\n    return paren_group_strings\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_erycmfq_test.go:20:25: invalid operation: character == "(" (mismatched
    types rune and untyped string)

    /tmp/tmp_erycmfq_test.go:29:34: invalid operation: paren_group_string + character
    (mismatched types string and rune)

    /tmp/tmp_erycmfq_test.go:30:32: invalid operation: character == ")" (mismatched
    types rune and untyped string)

    /tmp/tmp_erycmfq_test.go:39:34: invalid operation: paren_group_string + character
    (mismatched types string and rune)

    /tmp/tmp_erycmfq_test.go:40:32: invalid operation: character == " " (mismatched
    types rune and untyped string)

    /tmp/tmp_erycmfq_test.go:42:38: invalid operation: paren_group_string + character
    (mismatched types string and rune)

    /tmp/tmp_erycmfq_test.go:50:34: invalid operation: paren_group_string + character
    (mismatched types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074123
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    result := []string{}\n    stack := []string{}\n    paren_string\
    \ += \")\"\n    for _, char := range paren_string {\n        if char == '(' {\n\
    \            stack = append(stack, char)\n        } else if char == ')' {\n  \
    \          if len(stack) == 0 {\n                fmt.Println(\"Stack empty\")\n\
    \                return nil\n            }\n            stack = stack[:len(stack)-1]\n\
    \            result := append(result, string(stack))\n            stack = stack[:len(stack)-1]\n\
    \        } else {\n            stack = append(stack, char)\n        }\n    }\n\
    \    if len(stack) > 0 {\n        fmt.Println(\"Stack not empty\")\n    }\n  \
    \  return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp81xn5r_m_test.go:20:35: cannot use char (variable of type rune) as type
    string in argument to append

    /tmp/tmp81xn5r_m_test.go:27:13: result declared but not used

    /tmp/tmp81xn5r_m_test.go:27:45: cannot convert stack (variable of type []string)
    to type string

    /tmp/tmp81xn5r_m_test.go:30:35: cannot use char (variable of type rune) as type
    string in argument to append

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074123
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_group_strings := []string{}\n    paren_group_string\
    \ := \"\"\n    paren_group_open := false\n    paren_group_closed := false\n  \
    \  paren_group_count := 0\n    for _, character := range paren_string {\n    \
    \    if character == '(' {\n            if paren_group_open {\n              \
    \  fmt.Printf(\"Found an open brace group after an already open group\\n\")\n\
    \            }\n            paren_group_open = true\n            paren_group_string\
    \ += character\n            paren_group_count += 1\n        } else if character\
    \ == ')' {\n            if paren_group_closed {\n                fmt.Printf(\"\
    Found an open brace group after an already closed group\\n\")\n            }\n\
    \            paren_group_closed = true\n            paren_group_string += character\n\
    \            paren_group_count += 1\n        } else if paren_group_open && paren_group_closed\
    \ {\n            fmt.Printf(\"Found an open brace group after an already closed\
    \ group\\n\")\n        }\n        if paren_group_count == 0 {\n            paren_group_strings\
    \ = append(paren_group_strings, paren_group_string)\n            paren_group_string\
    \ = \"\"\n            paren_group_open = false\n            paren_group_closed\
    \ = false\n            paren_group_count = 0\n        }\n    }\n    return paren_group_strings\n\
    }\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpeisku1r6_test.go:26:13: invalid operation: paren_group_string += character
    (mismatched types string and rune)

    /tmp/tmpeisku1r6_test.go:33:13: invalid operation: paren_group_string += character
    (mismatched types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074123
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n\
    \    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"\
    {}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    \nfunc\
    \ TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8bpr93_n_test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074002
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_string += \")\"\n    paren_string += \"(\"\n \
    \   paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\
    \n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string += \"\
    (\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8clhzg06_test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074002
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_group_strings := []string{}\n    paren_group_strings\
    \ = append(paren_group_strings, paren_string)\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_group_strings = append(paren_group_strings, paren_string)\n    paren_group_strings\
    \ = append(paren_group_strings, paren_string)\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_group_strings = append(paren_group_strings, paren_string)\n    paren_group_strings\
    \ = append(paren_group_strings, paren_string)\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_group_strings = append(paren_group_strings, paren_string)\n    paren_group_strings\
    \ = append(paren_group_strings, paren_string)\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_group_strings = append(paren_group_strings, paren_string)\n    paren_group_strings\
    \ = append(paren_group_strings, paren_string)\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_group_strings = append(paren_group_strings, paren_string)\n    paren_group_strings\
    \ = append(paren_group_strings, paren_string)\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_group_strings = append(paren_group_strings, paren_string)\n    paren_group_strings\
    \ = append(paren_group_strings, paren_string)\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_group_strings = append(paren_group_strings, paren_string)\n    paren_group_strings\
    \ = append(paren_group_strings, paren_string)\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_group_string\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpo3h5w7pi_test.go:48:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074002
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_group_strings := make([]string, 0)\n    paren_group_string\
    \ := \"\"\n    paren_group_open := false\n    paren_group_closed := false\n  \
    \  paren_group_count := 0\n    for _, char := range paren_string {\n        if\
    \ char == '(' {\n            if paren_group_open {\n                fmt.Println(\"\
    Found open paren group with count \", paren_group_count, \" at \", paren_group_string)\n\
    \                paren_group_closed--\n                paren_group_open = false\n\
    \                paren_group_count--\n            }\n            paren_group_open\
    \ = true\n            paren_group_count++\n            paren_group_string = paren_group_string[:len(paren_group_string)-1]\
    \ + char\n        } else if char == ')' {\n            if paren_group_closed {\n\
    \                fmt.Println(\"Found closed paren group with count \", paren_group_count,\
    \ \" at \", paren_group_string)\n                paren_group_open = false\n  \
    \              paren_group_closed++\n                paren_group_count--\n   \
    \         }\n            paren_group_closed = true\n            paren_group_count++\n\
    \            paren_group_string = paren_group_string[:len(paren_group_string)-1]\
    \ + char\n        } else if char == ' ' {\n            fmt.Println(\"Found space\
    \ at \", paren_group_string)\n            paren_group_string = paren_group_string[:len(paren_group_string)-1]\
    \ + char\n        } else {\n            paren_group_string = paren_group_string[:len(paren_group_string)-1]\
    \ + char\n        }\n    }\n    if paren_group_open {\n        fmt.Println(\"\
    Found open paren group with count \", paren_group_count, \" at \", paren_group_string)\n\
    \        paren_group_closed--\n        paren_group_open = false\n        paren_group_count--\n\
    \    }\n    if paren_group_closed {\n        fmt.Println(\"Found closed paren\
    \ group with count \", paren_group_count, \" at \", paren_group_string)\n    \
    \    paren_group_open = false\n        paren_group_closed++\n        paren_group_count--\n\
    \    }\n    return paren_group_strings\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpub8iimfd_test.go:24:17: invalid operation: paren_group_closed-- (non-numeric
    type bool)

    /tmp/tmpub8iimfd_test.go:30:52: invalid operation: paren_group_string[:len(paren_group_string)
    - 1] + char (mismatched types string and rune)

    /tmp/tmpub8iimfd_test.go:35:17: invalid operation: paren_group_closed++ (non-numeric
    type bool)

    /tmp/tmpub8iimfd_test.go:40:52: invalid operation: paren_group_string[:len(paren_group_string)
    - 1] + char (mismatched types string and rune)

    /tmp/tmpub8iimfd_test.go:43:52: invalid operation: paren_group_string[:len(paren_group_string)
    - 1] + char (mismatched types string and rune)

    /tmp/tmpub8iimfd_test.go:45:52: invalid operation: paren_group_string[:len(paren_group_string)
    - 1] + char (mismatched types string and rune)

    /tmp/tmpub8iimfd_test.go:50:9: invalid operation: paren_group_closed-- (non-numeric
    type bool)

    /tmp/tmpub8iimfd_test.go:57:9: invalid operation: paren_group_closed++ (non-numeric
    type bool)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074123
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n\
    \    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"\
    {}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    \nfunc\
    \ TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8bpr93_n_test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074002
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_group_regex := regexp.MustCompile(`\\((?P<paren_group>.+)\\\
    )`)\n    paren_groups := paren_group_regex.FindAllStringSubmatch(paren_string,\
    \ -1)\n    result := make([]string, len(paren_groups))\n    for index, paren_group\
    \ := range paren_groups {\n        result[index] = paren_group[0]\n    }\n   \
    \ return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkum4nqgj_test.go:15:26: undefined: regexp

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074123
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_group_strings := make([]string, 0)\n    paren_group_count\
    \ := 0\n    paren_group_string := \"\"\n    paren_group_open_brace := false\n\
    \    for _, char := range paren_string {\n        if char == '(' {\n         \
    \   if paren_group_open_brace {\n                fmt.Printf(\"Found unclosed brace\
    \ at position %d\\n\", paren_group_count)\n                return nil\n      \
    \      }\n            paren_group_open_brace = true\n            paren_group_count\
    \ += 1\n            paren_group_string += char\n        } else if char == ')'\
    \ {\n            if paren_group_open_brace {\n                fmt.Printf(\"Found\
    \ unclosed brace at position %d\\n\", paren_group_count)\n                return\
    \ nil\n            }\n            paren_group_open_brace = false\n           \
    \ paren_group_count += 1\n            paren_group_string += char\n        } else\
    \ if char == ' ' {\n            // Do nothing\n        } else {\n            paren_group_string\
    \ += char\n        }\n    }\n    paren_group_strings = append(paren_group_strings,\
    \ paren_group_string)\n    return paren_group_strings\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpy4m4joce_test.go:27:13: invalid operation: paren_group_string += char
    (mismatched types string and rune)

    /tmp/tmpy4m4joce_test.go:35:13: invalid operation: paren_group_string += char
    (mismatched types string and rune)

    /tmp/tmpy4m4joce_test.go:39:13: invalid operation: paren_group_string += char
    (mismatched types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074123
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_groups = make(map[string][]string)\n    paren_groups\
    \ [\"(\"] = paren_groups [\")\"] = paren_groups [\"{\"] = paren_groups [\"}\"\
    ] = []string{}\n    paren_groups [\"(\"] = append(paren_groups [\"(\"], paren_string)\n\
    \    paren_groups [\")\"] = append(paren_groups [\")\"], paren_string)\n    paren_groups\
    \ [\"{\"] = append(paren_groups [\"{\"], paren_string)\n    paren_groups [\"}\"\
    ] = append(paren_groups [\"}\"], paren_string)\n    paren_groups [\"(\"] = append(paren_groups\
    \ [\"(\"], paren_string)\n    paren_groups [\")\"] = append(paren_groups [\")\"\
    ], paren_string)\n    paren_groups [\"{\"] = append(paren_groups [\"{\"], paren_string)\n\
    \    paren_groups [\"}\"] = append(paren_groups [\"}\"], paren_string)\n    paren_groups\
    \ [\"(\"] = append(paren_groups [\"(\"], paren_string)\n    paren_groups [\")\"\
    ] = append(paren_groups [\")\"], paren_string)\n    paren_groups [\"{\"] = append(paren_groups\
    \ [\"{\"], paren_string)\n    paren_groups [\"}\"] = append(paren_groups [\"}\"\
    ], paren_string)\n    paren_groups [\"(\"] = append(paren_groups [\"(\"], paren_string)\n\
    \    paren_groups [\")\"] = append(paren_groups [\")\"], paren_string)\n    paren_groups\
    \ [\"{\"] = append(paren_groups [\"{\"], paren_string)\n    paren_groups [\"}\"\
    ] = append(paren_groups [\"}\"], paren_string)\n    paren_groups [\"(\"] = append(paren_groups\
    \ [\"(\"], paren_string)\n    paren_groups [\")\"] = append(paren_groups [\")\"\
    ], paren_string)\n    paren_groups [\"{\"] = append(paren_groups [\"{\"], paren_string)\n\
    \    paren_groups [\"}\"] = append(paren_groups [\"}\"], paren_string)\n    paren_groups\
    \ [\"(\"] = append(paren_groups [\"(\"], paren_string)\n    paren_groups [\")\"\
    ] = append(paren_groups [\")\"], paren_string)\n    paren_groups [\"{\"] = append(paren_groups\
    \ [\"{\"], paren_string)\n    paren_groups [\"}\"] = append(paren_groups [\"}\"\
    ], paren_string)\n    paren_groups [\"(\"] = append(paren_groups [\"(\"], paren_string)\n\
    \    paren_groups [\")\"] = append(paren_groups [\")\"], paren_string)\n    paren\n\
    func TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp9tt00bis_test.go:16:45: expected ''=='', found ''=''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074123
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_string += \")\"\n    paren_string += \"(\"\n \
    \   paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string += \")\"\
    \n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string += \"\
    )\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string +=\
    \ \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_\n\
    func TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpcvtu_s7s_test.go:80:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074002
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n\
    \    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"\
    {}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    \nfunc\
    \ TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8bpr93_n_test.go:89:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074002
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_groups := []string{}\n    paren_group := \"\"\n\
    \    paren_group_open := false\n    paren_group_closed := false\n    paren_group_count\
    \ := 0\n    for _, char := range paren_string {\n        if char == '(' {\n  \
    \          if paren_group_open {\n                fmt.Println(\"paren_group_open\"\
    , paren_group_open)\n                fmt.Println(\"paren_group_closed\", paren_group_closed)\n\
    \                fmt.Println(\"paren_group_count\", paren_group_count)\n     \
    \           fmt.Println(\"paren_group\", paren_group)\n                fmt.Println(\"\
    paren_groups\", paren_groups)\n                fmt.Println(\"paren_group\", char)\n\
    \                fmt.Println(\"paren_groups\", paren_groups)\n               \
    \ fmt.Println(\"paren_group\", char)\n                fmt.Println(\"paren_groups\"\
    , paren_groups)\n                fmt.Println(\"paren_group\", char)\n        \
    \        fmt.Println(\"paren_groups\", paren_groups)\n                fmt.Println(\"\
    paren_group\", char)\n                fmt.Println(\"paren_groups\", paren_groups)\n\
    \                fmt.Println(\"paren_group\", char)\n                fmt.Println(\"\
    paren_groups\", paren_groups)\n                fmt.Println(\"paren_group\", char)\n\
    \                fmt.Println(\"paren_groups\", paren_groups)\n               \
    \ fmt.Println(\"paren_group\", char)\n                fmt.Println(\"paren_groups\"\
    , paren_groups)\n                fmt.Println(\"paren_group\", char)\n        \
    \        fmt.Println(\"paren_groups\", paren_groups)\n                fmt.Println(\"\
    paren_group\", char)\n                fmt.Println(\"paren_groups\", paren_groups)\n\
    \                fmt.Println(\"paren_group\", char)\n                fmt.Println(\"\
    paren_groups\", paren_groups)\n                fmt.Println(\"paren_group\", char)\n\
    \                fmt.Println(\"paren_groups\", paren_groups)\n               \
    \ fmt.Println(\"paren_group\", char)\n                fmt.Println(\"paren_groups\"\
    , paren_groups)\n                fmt.Println(\"paren_group\", char)\n        \
    \        fmt.Println(\"paren_groups\", paren_groups)\n                fmt.Println(\"\
    paren_group\", char)\n                fmt.Println(\"paren_groups\", paren_groups)\n\
    \                fmt.Println(\"paren_group\", char)\n                fmt.Println(\"\
    paren_groups\", paren_groups)\n                fmt.Println(\"paren_group\", char)\n\
    \                fmt.Println(\"paren_groups\", paren_groups)\n               \
    \ fmt.Println(\"paren_group\", char)\n                fmt.\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp4zuz7jl0_test.go:62:1: expected selector or type assertion, found ''func''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074123
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_group_strings := []string{}\n    paren_group_string\
    \ := \"\"\n    paren_group_open := false\n    paren_group_closed := false\n  \
    \  for _, character := range paren_string {\n        if character == \"(\" {\n\
    \            if paren_group_open {\n                fmt.Printf(\"Error: unexpected\
    \ open paren group\\n\")\n                fmt.Printf(\"Input: %s\\n\", paren_string)\n\
    \                fmt.Printf(\"Output: %s\\n\", paren_group_strings)\n        \
    \        panic(\"unexpected open paren group\")\n            }\n            paren_group_open\
    \ = true\n            paren_group_string += character\n        } else if character\
    \ == \")\" {\n            if paren_group_closed {\n                fmt.Printf(\"\
    Error: unexpected close paren group\\n\")\n                fmt.Printf(\"Input:\
    \ %s\\n\", paren_string)\n                fmt.Printf(\"Output: %s\\n\", paren_group_strings)\n\
    \                panic(\"unexpected close paren group\")\n            }\n    \
    \        paren_group_closed = true\n            paren_group_string += character\n\
    \        } else if character == \" \" {\n            if paren_group_open {\n \
    \               paren_group_string += character\n            } else if paren_group_closed\
    \ {\n                paren_group_strings = append(paren_group_strings, paren_group_string)\n\
    \                paren_group_string = \"\"\n            }\n        } else {\n\
    \            paren_group_string += character\n        }\n    }\n    if paren_group_open\
    \ {\n        fmt.Printf(\"Error: unexpected open paren group\\n\")\n        fmt.Printf(\"\
    Input: %s\\n\", paren_string)\n        fmt.Printf(\"Output: %s\\n\", paren_group_strings)\n\
    \        panic(\"unexpected open paren group\")\n    }\n    if paren_group_closed\
    \ {\n        fmt.Printf(\"Error: unexpected close paren group\\n\")\n        fmt.Printf(\"\
    Input: %s\\n\", paren_string)\n        fmt.Printf(\"Output: %s\\n\", paren_group_strings)\n\
    \        panic(\"unexpected close paren group\")\n    }\n    return paren_group_strings\n\
    }\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpoo03rg83_test.go:20:25: invalid operation: character == "(" (mismatched
    types rune and untyped string)

    /tmp/tmpoo03rg83_test.go:28:13: invalid operation: paren_group_string += character
    (mismatched types string and rune)

    /tmp/tmpoo03rg83_test.go:29:32: invalid operation: character == ")" (mismatched
    types rune and untyped string)

    /tmp/tmpoo03rg83_test.go:37:13: invalid operation: paren_group_string += character
    (mismatched types string and rune)

    /tmp/tmpoo03rg83_test.go:38:32: invalid operation: character == " " (mismatched
    types rune and untyped string)

    /tmp/tmpoo03rg83_test.go:40:17: invalid operation: paren_group_string += character
    (mismatched types string and rune)

    /tmp/tmpoo03rg83_test.go:46:13: invalid operation: paren_group_string += character
    (mismatched types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074123
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    // Initialize a stack to keep track of open parens\n\
    \    stack := make([]string, 0)\n\n    // Initialize a result list to hold the\
    \ result\n    result := make([]string, 0)\n\n    // Iterate through the input\
    \ string\n    for _, char := range paren_string {\n        // If the character\
    \ is a left paren, push it to the stack\n        if char == '(' {\n          \
    \  stack = append(stack, char)\n        }\n\n        // If the character is a\
    \ right paren, pop from the stack\n        if char == ')' {\n            stack\
    \ := stack[:len(stack)-1]\n        }\n\n        // If the stack is empty, add\
    \ the character to the result list\n        if len(stack) == 0 {\n           \
    \ result = append(result, char)\n        }\n    }\n\n    return result\n}\n\n\
    func TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpw8jgfgu7_test.go:25:35: cannot use char (variable of type rune) as type
    string in argument to append

    /tmp/tmpw8jgfgu7_test.go:30:13: stack declared but not used

    /tmp/tmpw8jgfgu7_test.go:35:37: cannot use char (variable of type rune) as type
    string in argument to append

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074123
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_group_strings := make([]string, 0)\n    paren_group_strings\
    \ = append(paren_group_strings, paren_string)\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_group_strings = append(paren_group_strings, paren_string)\n    paren_group_strings\
    \ = append(paren_group_strings, paren_string)\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_group_strings = append(paren_group_strings, paren_string)\n    paren_group_strings\
    \ = append(paren_group_strings, paren_string)\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_group_strings = append(paren_group_strings, paren_string)\n    paren_group_strings\
    \ = append(paren_group_strings, paren_string)\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_group_strings = append(paren_group_strings, paren_string)\n    paren_group_strings\
    \ = append(paren_group_strings, paren_string)\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_group_strings = append(paren_group_strings, paren_string)\n    paren_group_strings\
    \ = append(paren_group_strings, paren_string)\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_group_strings = append(paren_group_strings, paren_string)\n    paren_group_strings\
    \ = append(paren_group_strings, paren_string)\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_group_strings = append(paren_group_strings, paren_string)\n    paren_group_strings\
    \ = append(paren_group_strings, paren_string)\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp705dn0ck_test.go:48:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074117
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_group_regex := regexp.MustCompile(`\\((?P<paren_group>.+)\\\
    )`)\n    paren_groups := paren_group_regex.FindAllStringSubmatch(paren_string,\
    \ -1)\n    result := make([]string, len(paren_groups))\n    for i, paren_group\
    \ := range paren_groups {\n        result[i] = paren_group[0]\n    }\n    return\
    \ result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate :=\
    \ separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\",\
    \ \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected:\
    \ []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"\
    ( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8iy4n45s_test.go:15:26: undefined: regexp

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074123
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_groups := []string{}\n    paren_group := \"\"\n\
    \    paren_group_open := false\n    paren_group_closed := false\n    paren_group_is_closed\
    \ := false\n    paren_group_is_open := false\n    paren_group_is_open_paren :=\
    \ false\n    paren_group_is_open_paren_or_closed := false\n    paren_group_is_open_paren_or_closed_paren\
    \ := false\n    paren_group_is_open_paren_or_closed_paren_or_closed := false\n\
    \    paren_group_is_open_paren_or_closed_paren_or_closed_paren := false\n    paren_group_is_open_paren_or_closed_paren_or_closed_paren_or_closed\
    \ := false\n    paren_group_is_open_paren_or_closed_paren_or_closed_paren_or_closed_paren\
    \ := false\n    paren_group_is_open_paren_or_closed_paren_or_closed_paren_or_closed_paren_or_closed\
    \ := false\n    paren_group_is_open_paren_or_closed_paren_or_closed_paren_or_closed_paren_or_closed_paren\
    \ := false\n    paren_group_is_open_paren_or_closed_paren_or_closed_paren_or_closed_paren_or_closed_paren_or_closed\
    \ := false\n    paren_group_is_open_paren_or_closed_paren_or_closed_paren_or_closed_paren_or_closed_paren_or_closed_paren\
    \ := false\n    paren_group_is_open_paren_or_closed_paren_or_closed_paren_or_closed_paren_or_closed_paren_or_closed_paren_or_closed\
    \ := false\n    paren_group_is_open_paren_or_closed_paren_or_closed_paren_or_closed_paren_or_closed_paren_or_closed_paren_or_closed_paren\
    \ := false\n    paren_group_is_open_paren_or_closed_paren_or_closed_paren_or_closed_paren_or_closed_paren_or_closed_paren_or_closed_paren_or_closed\
    \ := false\n    paren_group_is_open_paren_or_closed_paren_or_closed_paren_or_closed_paren_or_closed_paren_or_closed_paren_or_closed_paren_or_closed_paren\
    \ := false\n    paren_group_is_open_paren_or_closed_paren_or_closed_paren_or_closed_paren_or_closed_paren_or_closed_paren_or_closed_paren_\n\
    func TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpo6ju27fl_test.go:37:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074123
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_group_strings := []string{}\n    paren_group_string\
    \ := \"\"\n    paren_group_open := false\n    paren_group_closed := false\n  \
    \  for _, char := range paren_string {\n        if char == '(' {\n           \
    \ if paren_group_open {\n                fmt.Println(\"Error: unexpected open\
    \ paren group\")\n            }\n            paren_group_open = true\n       \
    \     paren_group_string += char\n        } else if char == ')' {\n          \
    \  if paren_group_closed {\n                fmt.Println(\"Error: unexpected close\
    \ paren group\")\n            }\n            paren_group_closed = true\n     \
    \       paren_group_string += char\n        } else if char == ' ' {\n        \
    \    if paren_group_open && paren_group_closed {\n                fmt.Println(\"\
    Error: unexpected space in paren group\")\n            }\n            paren_group_string\
    \ += char\n        } else {\n            paren_group_string += char\n        }\n\
    \    }\n    if paren_group_open {\n        fmt.Println(\"Error: unexpected open\
    \ paren group\")\n    }\n    if paren_group_closed {\n        fmt.Println(\"Error:\
    \ unexpected close paren group\")\n    }\n    return paren_group_strings\n}\n\n\
    func TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvp2xg_4w_test.go:25:13: invalid operation: paren_group_string += char
    (mismatched types string and rune)

    /tmp/tmpvp2xg_4w_test.go:31:13: invalid operation: paren_group_string += char
    (mismatched types string and rune)

    /tmp/tmpvp2xg_4w_test.go:36:13: invalid operation: paren_group_string += char
    (mismatched types string and rune)

    /tmp/tmpvp2xg_4w_test.go:38:13: invalid operation: paren_group_string += char
    (mismatched types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074123
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_group_strings := make([]string, 0)\n    paren_group_string\
    \ := \"\"\n    paren_group_open := false\n    paren_group_closed := false\n  \
    \  paren_group_count := 0\n    for _, character := range paren_string {\n    \
    \    if character == '(' {\n            if paren_group_open {\n              \
    \  fmt.Println(\"Found nested paren group\")\n                paren_group_closed--\n\
    \                paren_group_open = false\n                paren_group_count--\n\
    \            } else {\n                paren_group_open = true\n             \
    \   paren_group_count++\n            }\n        } else if character == ')' {\n\
    \            if paren_group_closed {\n                fmt.Println(\"Found nested\
    \ paren group\")\n                paren_group_open = false\n                paren_group_closed--\n\
    \                paren_group_count--\n            } else {\n                paren_group_closed\
    \ = true\n                paren_group_count++\n            }\n        } else if\
    \ character == ' ' {\n            if paren_group_open {\n                fmt.Println(\"\
    Found nested paren group\")\n                paren_group_closed--\n          \
    \      paren_group_open = false\n                paren_group_count--\n       \
    \     } else {\n                paren_group_open = true\n                paren_group_count++\n\
    \            }\n        } else {\n            paren_group_string += character\n\
    \        }\n        if paren_group_count == 0 {\n            paren_group_strings\
    \ = append(paren_group_strings, paren_group_string)\n            paren_group_string\
    \ = \"\"\n            paren_group_open = false\n            paren_group_closed\
    \ = false\n            paren_group_count = 0\n        }\n    }\n    return paren_group_strings\n\
    }\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpwit_fmxp_test.go:24:17: invalid operation: paren_group_closed-- (non-numeric
    type bool)

    /tmp/tmpwit_fmxp_test.go:35:17: invalid operation: paren_group_closed-- (non-numeric
    type bool)

    /tmp/tmpwit_fmxp_test.go:44:17: invalid operation: paren_group_closed-- (non-numeric
    type bool)

    /tmp/tmpwit_fmxp_test.go:52:13: invalid operation: paren_group_string += character
    (mismatched types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074123
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_string += \")\"\n    paren_string += \"(\"\n \
    \   paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string += \")\"\
    \n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string += \"\
    )\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string +=\
    \ \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_string\
    \ += \")\"\n    paren_string += \")\"\n    paren_string += \")\"\n    paren_\n\
    func TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpcvtu_s7s_test.go:80:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074002
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_group_strings := []string{}\n    paren_group_string\
    \ := \"\"\n    paren_group_open_braces := 0\n    paren_group_close_braces := 0\n\
    \    paren_group_string += \"(\"\n    paren_group_open_braces++\n    paren_group_string\
    \ += paren_string\n    paren_group_close_braces++\n    for i := len(paren_string)\
    \ - 1; i >= 0; i-- {\n        if paren_string[i] == '(' {\n            paren_group_string\
    \ += \")\"\n            paren_group_close_braces++\n            paren_group_string\
    \ += \"(\"\n            paren_group_open_braces++\n        } else if paren_string[i]\
    \ == ')' {\n            paren_group_string += \")\"\n            paren_group_open_braces--\n\
    \            paren_group_string += \"(\"\n            paren_group_close_braces--\n\
    \        } else if paren_string[i] == ' ' {\n            continue\n        } else\
    \ {\n            paren_group_string += paren_string[i]\n        }\n        if\
    \ paren_group_open_braces == paren_group_close_braces {\n            paren_group_strings\
    \ = append(paren_group_strings, paren_group_string)\n            paren_group_string\
    \ = \"\"\n            paren_group_open_braces = 0\n            paren_group_close_braces\
    \ = 0\n        }\n    }\n    return paren_group_strings\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdbi2rllu_test.go:37:13: invalid operation: paren_group_string += paren_string[i]
    (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074123
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_group_strings := []string{}\n    paren_group_strings\
    \ = append(paren_group_strings, paren_string)\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_group_strings = append(paren_group_strings, paren_string)\n    return\
    \ paren_group_strings\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n \
    \ candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmpp1q7mzsi_test.go:39: expected '[(()()) ((())) () ((())()())]',\
    \ got '[(()()) ((())) () ((())()()) (()()) ((())) () ((())()()) (()()) ((()))\
    \ () ((())()()) (()()) ((())) () ((())()())]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1\
    \ (0.00s)\n        tmpp1q7mzsi_test.go:39: expected '[() (()) ((())) (((())))]',\
    \ got '[() (()) ((())) (((()))) () (()) ((())) (((()))) () (()) ((())) (((())))\
    \ () (()) ((())) (((())))]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2\
    \ (0.00s)\n        tmpp1q7mzsi_test.go:39: expected '[(()(())((())))]', got '[(()(())((())))\
    \ (()(())((()))) (()(())((()))) (()(())((())))]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmpp1q7mzsi_test.go:39: expected '[() (()) (()())]', got '[(\
    \ ) (( )) (( )( )) ( ) (( )) (( )( )) ( ) (( )) (( )( )) ( ) (( )) (( )( ))]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074122
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_groups := []string{}\n    paren_group := \"\"\n\
    \    paren_group_open := false\n    for _, char := range paren_string {\n    \
    \    if char == '(' {\n            if paren_group_open {\n                fmt.Printf(\"\
    Found nested paren group: %v\\n\", paren_group)\n                paren_groups\
    \ = append(paren_groups, paren_group)\n                paren_group = \"\"\n  \
    \              paren_group_open = false\n            }\n            paren_group_open\
    \ = true\n        } else if char == ')' {\n            if paren_group_open {\n\
    \                paren_groups = append(paren_groups, paren_group)\n          \
    \      paren_group = \"\"\n                paren_group_open = false\n        \
    \    } else {\n                fmt.Printf(\"Found unclosed paren group: %v\\n\"\
    , paren_group)\n            }\n        } else if char == ' ' {\n            continue\n\
    \        } else {\n            paren_group += string(char)\n        }\n    }\n\
    \    if paren_group != \"\" {\n        paren_groups = append(paren_groups, paren_group)\n\
    \    }\n    return paren_groups\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "Found nested paren group: \nFound unclosed paren group: \nFound nested\
    \ paren group: \nFound nested paren group: \nFound unclosed paren group: \nFound\
    \ unclosed paren group: \nFound nested paren group: \nFound nested paren group:\
    \ \nFound unclosed paren group: \nFound unclosed paren group: \nFound nested paren\
    \ group: \nFound unclosed paren group: \nFound nested paren group: \nFound nested\
    \ paren group: \nFound unclosed paren group: \nFound unclosed paren group: \n\
    Found nested paren group: \nFound nested paren group: \nFound nested paren group:\
    \ \nFound unclosed paren group: \nFound unclosed paren group: \nFound unclosed\
    \ paren group: \nFound nested paren group: \nFound nested paren group: \nFound\
    \ unclosed paren group: \nFound nested paren group: \nFound nested paren group:\
    \ \nFound unclosed paren group: \nFound unclosed paren group: \nFound unclosed\
    \ paren group: \nFound nested paren group: \nFound unclosed paren group: \nFound\
    \ nested paren group: \nFound unclosed paren group: \n--- FAIL: TestSeparate_Paren_Groups\
    \ (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n     \
    \   tmp68sod3al_test.go:63: expected '[(()()) ((())) () ((())()())]', got '[ \
    \          ]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n \
    \       tmp68sod3al_test.go:63: expected '[() (()) ((())) (((())))]', got '[ \
    \        ]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n   \
    \     tmp68sod3al_test.go:63: expected '[(()(())((())))]', got '[      ]'\n  \
    \  --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmp68sod3al_test.go:63:\
    \ expected '[() (()) (()())]', got '[     ]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660074124
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_group_strings := []string{}\n    paren_group_count\
    \ := 0\n    paren_group_string := \"\"\n    paren_group_open_brace := false\n\
    \    for _, character := range paren_string {\n        if character == '(' {\n\
    \            if paren_group_open_brace {\n                fmt.Println(\"Error:\
    \ unexpected open brace in paren group\")\n            }\n            paren_group_open_brace\
    \ = true\n            paren_group_string += character\n        } else if character\
    \ == ')' {\n            if paren_group_open_brace {\n                paren_group_string\
    \ += character\n                paren_group_open_brace = false\n             \
    \   paren_group_strings = append(paren_group_strings, paren_group_string)\n  \
    \              paren_group_string = \"\"\n                paren_group_count =\
    \ 0\n            } else {\n                paren_group_count += 1\n          \
    \  }\n        } else {\n            paren_group_string += character\n        }\n\
    \    }\n    if paren_group_open_brace {\n        fmt.Println(\"Error: unexpected\
    \ close brace in paren group\")\n    }\n    return paren_group_strings\n}\n\n\
    func TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmplzsg0u8z_test.go:25:13: invalid operation: paren_group_string += character
    (mismatched types string and rune)

    /tmp/tmplzsg0u8z_test.go:28:17: invalid operation: paren_group_string += character
    (mismatched types string and rune)

    /tmp/tmplzsg0u8z_test.go:37:13: invalid operation: paren_group_string += character
    (mismatched types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074123
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_groups = make([]string, 0)\n    paren_stack =\
    \ make([]string, 0)\n    paren_stack = append(paren_stack, paren_string)\n   \
    \ paren_groups = append(paren_groups, paren_string)\n    for len(paren_stack)\
    \ > 0 {\n        paren_string = paren_stack[len(paren_stack)-1]\n        paren_stack\
    \ = paren_stack[:len(paren_stack)-1]\n        paren_groups = append(paren_groups,\
    \ paren_string)\n    }\n    return paren_groups\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpuwhcjddj_test.go:15:5: undefined: paren_groups

    /tmp/tmpuwhcjddj_test.go:16:5: undefined: paren_stack

    /tmp/tmpuwhcjddj_test.go:17:26: undefined: paren_stack

    /tmp/tmpuwhcjddj_test.go:18:27: undefined: paren_groups

    /tmp/tmpuwhcjddj_test.go:19:13: undefined: paren_stack

    /tmp/tmpuwhcjddj_test.go:20:24: undefined: paren_stack

    /tmp/tmpuwhcjddj_test.go:21:23: undefined: paren_stack

    /tmp/tmpuwhcjddj_test.go:22:31: undefined: paren_groups

    /tmp/tmpuwhcjddj_test.go:24:12: undefined: paren_groups

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074123
