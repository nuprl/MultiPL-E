language: go_test.go
name: HumanEval_96_count_up_to
results:
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime :=\
    \ append(prime, 3)\n    for i := 4; i <= n; i++ {\n        for j := 2; j < i;\
    \ j++ {\n            if i % j == 0 {\n                break\n            }\n \
    \       }\n        if j == i {\n            prime = append(prime, i)\n       \
    \ }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpcs4rn_5u_test.go:25:11: no new variables on left side of :=

    /tmp/tmpcs4rn_5u_test.go:26:11: no new variables on left side of :=

    /tmp/tmpcs4rn_5u_test.go:33:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075219
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime :=\
    \ append(prime, 3)\n    for i := 4; i <= n; i++ {\n        for j := 2; j < i;\
    \ j++ {\n            if i % j == 0 {\n                break\n            }\n \
    \       }\n        if j > i {\n            prime = append(prime, i)\n        }\n\
    \    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpf_4cdq0t_test.go:25:11: no new variables on left side of :=

    /tmp/tmpf_4cdq0t_test.go:26:11: no new variables on left side of :=

    /tmp/tmpf_4cdq0t_test.go:33:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075219
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0)\n    prime := append(prime, 2)\n    for i :=\
    \ 3; i < n; i++ {\n        for j := 2; j < i; j++ {\n            if i%j == 0 {\n\
    \                break\n            }\n        }\n        if i == j {\n      \
    \      prime = append(prime, i)\n        }\n    }\n    return prime\n}\n\nfunc\
    \ TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2,\
    \ 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n   \
    \  { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp18h8lo5x_test.go:25:11: no new variables on left side of :=

    /tmp/tmp18h8lo5x_test.go:32:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075219
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    primes := make([]int, n+1)\n    primes[0] = 1\n    primes[1] = 1\n  \
    \  for i := 2; i <= n; i++ {\n        for j := 2; j < i; j++ {\n            if\
    \ i*j > n {\n                break\n            }\n            if primes[i*j]\
    \ == 0 {\n                primes[i*j] = i\n            }\n        }\n    }\n \
    \   return primes[:n]\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [1] with length 1 [recovered]\n\tpanic: runtime error: index out of range [1]\
    \ with length 1\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmps7pyx1xu_test.go:26\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmps7pyx1xu_test.go:51\
    \ +0x173\ntesting.tRunner(0xc0001a0340, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075219
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0, n)\n    for i := 2; i <= n; i++ {\n        if\
    \ isPrime(i) {\n            prime = append(prime, i)\n        }\n    }\n    return\
    \ prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0gb6o504_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075219
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n        if\
    \ prime[prime[0]-1] != i {\n            prime = append(prime, i)\n        }\n\
    \    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 34 [running]:\ntesting.tRunner.func1.2({0x513920,\
    \ 0xc0001d6000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513920, 0xc0001d6000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmpuqiqaevc_test.go:26\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmpuqiqaevc_test.go:40\
    \ +0xdbb\ntesting.tRunner(0xc000198ea0, 0x529240)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075219
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime :=\
    \ append(prime, 3)\n    for i := 4; i <= n; i++ {\n        for j := 2; j < i;\
    \ j++ {\n            if i % j == 0 {\n                break\n            }\n \
    \       }\n        if j == i {\n            prime = append(prime, i)\n       \
    \ }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpcs4rn_5u_test.go:25:11: no new variables on left side of :=

    /tmp/tmpcs4rn_5u_test.go:26:11: no new variables on left side of :=

    /tmp/tmpcs4rn_5u_test.go:33:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075219
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime :=\
    \ append(prime, 3)\n    for i := 4; i <= n; i++ {\n        for j := 2; j < i;\
    \ j++ {\n            if i % j == 0 {\n                break\n            }\n \
    \       }\n        if j == i {\n            prime = append(prime, i)\n       \
    \ }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpcs4rn_5u_test.go:25:11: no new variables on left side of :=

    /tmp/tmpcs4rn_5u_test.go:26:11: no new variables on left side of :=

    /tmp/tmpcs4rn_5u_test.go:33:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075219
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0, n)\n    for i := 2; i <= n; i++ {\n        if\
    \ isPrime(i) {\n            prime = append(prime, i)\n        }\n    }\n    return\
    \ prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0gb6o504_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075219
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    primes := make([]int, n+1)\n    primes[0] = 2\n    primes[1] = 2\n  \
    \  for i := 2; i <= n; i++ {\n        for j := 2; j < i; j++ {\n            if\
    \ i % j == 0 {\n                break\n            }\n        }\n        if j\
    \ == i {\n            primes[i+1] = i\n        }\n    }\n    return primes\n}\n\
    \nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpok3p820e_test.go:33:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075219
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0)\n    prime := append(prime, 2)\n    for i :=\
    \ 3; i < n; i++ {\n        for _, j := range prime {\n            if j%i == 0\
    \ {\n                break\n            }\n            if i == j {\n         \
    \       prime = append(prime, i)\n                break\n            }\n     \
    \   }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpcl6b4aah_test.go:25:11: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075219
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime :=\
    \ append(prime, 3)\n    for i := 4; i <= n; i++ {\n        for j := 2; j < i;\
    \ j++ {\n            if i%j == 0 {\n                break\n            }\n   \
    \     }\n        if i == j {\n            prime = append(prime, i)\n        }\n\
    \    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6kz16l2x_test.go:25:11: no new variables on left side of :=

    /tmp/tmp6kz16l2x_test.go:26:11: no new variables on left side of :=

    /tmp/tmp6kz16l2x_test.go:33:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075219
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime :=\
    \ append(prime, 3)\n    for i := 4; i <= n; i++ {\n        for j := 2; j < i;\
    \ j++ {\n            if i % j == 0 {\n                break\n            }\n \
    \       }\n        if j == i {\n            prime = append(prime, i)\n       \
    \ }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpcs4rn_5u_test.go:25:11: no new variables on left side of :=

    /tmp/tmpcs4rn_5u_test.go:26:11: no new variables on left side of :=

    /tmp/tmpcs4rn_5u_test.go:33:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075219
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0, n)\n    prime := append(prime, 2)\n    prime\
    \ := append(prime, 3)\n    prime := append(prime, 5)\n    prime := append(prime,\
    \ 7)\n    prime := append(prime, 11)\n    prime := append(prime, 13)\n    prime\
    \ := append(prime, 17)\n    prime := append(prime, 19)\n    prime := append(prime,\
    \ 23)\n    prime := append(prime, 29)\n    prime := append(prime, 31)\n    prime\
    \ := append(prime, 37)\n    prime := append(prime, 43)\n    prime := append(prime,\
    \ 49)\n    prime := append(prime, 57)\n    prime := append(prime, 61)\n    prime\
    \ := append(prime, 67)\n    prime := append(prime, 73)\n    prime := append(prime,\
    \ 79)\n    prime := append(prime, 83)\n    prime := append(prime, 89)\n    prime\
    \ := append(prime, 97)\n    prime := append(prime, 101)\n    prime := append(prime,\
    \ 103)\n    prime := append(prime, 107)\n    prime := append(prime, 109)\n   \
    \ prime := append(prime, 113)\n    prime := append(prime, 127)\n    prime := append(prime,\
    \ 131)\n    prime := append(prime, 137)\n    prime := append(prime, 139)\n   \
    \ prime := append(prime, 149)\n    prime := append(prime, 151)\n    prime := append(prime,\
    \ 157)\n    prime := append(prime, 163)\n    prime := append(prime, 167)\n   \
    \ prime := append(prime, 173)\n    prime := append(prime, 179)\n    prime := append(prime,\
    \ 181)\n    prime := append(prime, 191)\n    prime := append(prime, 193)\n   \
    \ prime := append(prime, 197)\n    prime := append(prime, 199)\n    prime := append(prime,\
    \ 211)\n    prime := append(prime, 223)\n    prime := append(prime, 227)\n   \
    \ prime := append(prime, 229)\n    prime := append(prime, 233)\n    prime := append(prime,\
    \ 239)\n    prime := append(prime, 241)\n    prime := append(prime, 243)\n   \
    \ prime := append(prime, 247)\n    prime := append(prime, 251)\n    prime := append(prime,\
    \ 257)\n    prime := append(prime, 263)\n    prime := append(prime, 269)\n   \
    \ prime := append(prime, \nfunc TestCount_Up_To(t *testing.T) {\n  candidate :=\
    \ count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpbtkaogbp_test.go:82:6: expected ''('', found TestCount_Up_To

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075218
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0)\n    prime := append(prime, 2)\n    for i :=\
    \ 3; i < n; i++ {\n        for j := 2; j < i; j++ {\n            if i%j == 0 {\n\
    \                break\n            }\n        }\n        if i == j {\n      \
    \      prime = append(prime, i)\n        }\n    }\n    return prime\n}\n\nfunc\
    \ TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2,\
    \ 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n   \
    \  { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp18h8lo5x_test.go:25:11: no new variables on left side of :=

    /tmp/tmp18h8lo5x_test.go:32:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075219
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n        for\
    \ j := 2; j < i; j++ {\n            if i%j == 0 {\n                break\n   \
    \         }\n        }\n        if i == j {\n            prime = append(prime,\
    \ i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpt19r5qk1_test.go:31:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075219
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n        for\
    \ j := 2; j < i; j++ {\n            if i%j == 0 {\n                break\n   \
    \         }\n        }\n        if i == n {\n            prime = append(prime,\
    \ i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmpgsr31q6h_test.go:60: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__1 (0.00s)\n        tmpgsr31q6h_test.go:60:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__2\
    \ (0.00s)\n        tmpgsr31q6h_test.go:60: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__3 (0.00s)\n        tmpgsr31q6h_test.go:60:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]', got '[]'\n    ---\
    \ FAIL: TestCount_Up_To/test_num__5 (0.00s)\n        tmpgsr31q6h_test.go:60: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)\
    \ %!s(int=19)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n\
    \        tmpgsr31q6h_test.go:60: expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)\
    \ %!s(int=11) %!s(int=13) %!s(int=17)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__8\
    \ (0.00s)\n        tmpgsr31q6h_test.go:60: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29)\
    \ %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__9\
    \ (0.00s)\n        tmpgsr31q6h_test.go:60: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29)\
    \ %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43) %!s(int=47) %!s(int=53) %!s(int=59)\
    \ %!s(int=61) %!s(int=67) %!s(int=71) %!s(int=73) %!s(int=79) %!s(int=83) %!s(int=89)\
    \ %!s(int=97)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075219
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n        if\
    \ prime[len(prime)-1] != i {\n            prime = append(prime, i)\n        }\n\
    \    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine\
    \ 6 [running]:\ntesting.tRunner.func1.2({0x513920, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513920, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmpn66hzij1_test.go:26\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmpn66hzij1_test.go:40\
    \ +0xd1d\ntesting.tRunner(0xc0001a0340, 0x529240)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075219
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0, n)\n    prime := append(prime, 2)\n    prime\
    \ := append(prime, 3)\n    for i := 4; i <= n; i++ {\n        for j := 2; j <\
    \ i; j++ {\n            if i%j == 0 {\n                break\n            }\n\
    \        }\n        if j > i {\n            prime = append(prime, i)\n       \
    \ }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbc58cyfj_test.go:25:11: no new variables on left side of :=

    /tmp/tmpbc58cyfj_test.go:26:11: no new variables on left side of :=

    /tmp/tmpbc58cyfj_test.go:33:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075219
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    primes := make([]int, n+1)\n    primes[0] = 2\n    primes[1] = 2\n  \
    \  for i := 2; i <= n; i++ {\n        for j := 2; j < i; j++ {\n            if\
    \ i%j == 0 {\n                break\n            }\n        }\n        if j >\
    \ i {\n            primes[i] = j\n        }\n    }\n    return primes\n}\n\nfunc\
    \ TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2,\
    \ 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n   \
    \  { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfkvahsso_test.go:33:12: undefined: j

    /tmp/tmpfkvahsso_test.go:34:25: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075219
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n        if\
    \ prime[prime[0]-1] == 0 {\n            prime = append(prime, i)\n        }\n\
    \        for j := 0; j < i; j++ {\n            if prime[j] == 0 {\n          \
    \      prime = append(prime, j)\n                break\n            }\n      \
    \  }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513920,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513920, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmppgbc1akp_test.go:26\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmppgbc1akp_test.go:46\
    \ +0x12b6\ntesting.tRunner(0xc0001a0340, 0x529240)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075219
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n        if\
    \ prime[prime[0]] == 0 {\n            prime = append(prime, i)\n        }\n  \
    \      for j := 0; j < i; j++ {\n            if prime[j] == 0 {\n            \
    \    prime = append(prime, j)\n            }\n        }\n    }\n    return prime\n\
    }\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513920,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513920, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmpprvszh3k_test.go:26\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmpprvszh3k_test.go:45\
    \ +0x1234\ntesting.tRunner(0xc0001a0340, 0x529240)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075219
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime :=\
    \ append(prime, 3)\n    for i := 4; i <= n; i++ {\n        for j := 2; j < i;\
    \ j++ {\n            if i%j == 0 {\n                break\n            }\n   \
    \     }\n        if j == i {\n            prime = append(prime, i)\n        }\n\
    \    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4gzm8ir8_test.go:25:11: no new variables on left side of :=

    /tmp/tmp4gzm8ir8_test.go:26:11: no new variables on left side of :=

    /tmp/tmp4gzm8ir8_test.go:33:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075219
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime :=\
    \ append(prime, 3)\n    prime := append(prime, 5)\n    prime := append(prime,\
    \ 7)\n    prime := append(prime, 11)\n    prime := append(prime, 13)\n    prime\
    \ := append(prime, 17)\n    prime := append(prime, 19)\n    prime := append(prime,\
    \ 29)\n    prime := append(prime, 31)\n    prime := append(prime, 37)\n    prime\
    \ := append(prime, 43)\n    prime := append(prime, 59)\n    prime := append(prime,\
    \ 61)\n    prime := append(prime, 67)\n    prime := append(prime, 73)\n    prime\
    \ := append(prime, 79)\n    prime := append(prime, 83)\n    prime := append(prime,\
    \ 89)\n    prime := append(prime, 97)\n    prime := append(prime, 101)\n    prime\
    \ := append(prime, 103)\n    prime := append(prime, 107)\n    prime := append(prime,\
    \ 109)\n    prime := append(prime, 113)\n    prime := append(prime, 127)\n   \
    \ prime := append(prime, 131)\n    prime := append(prime, 137)\n    prime := append(prime,\
    \ 139)\n    prime := append(prime, 149)\n    prime := append(prime, 151)\n   \
    \ prime := append(prime, 157)\n    prime := append(prime, 163)\n    prime := append(prime,\
    \ 167)\n    prime := append(prime, 173)\n    prime := append(prime, 179)\n   \
    \ prime := append(prime, 181)\n    prime := append(prime, 191)\n    prime := append(prime,\
    \ 193)\n    prime := append(prime, 197)\n    prime := append(prime, 199)\n   \
    \ prime := append(prime, 211)\n    prime := append(prime, 223)\n    prime := append(prime,\
    \ 227)\n    prime := append(prime, 229)\n    prime := append(prime, 233)\n   \
    \ prime := append(prime, 239)\n    prime := append(prime, 241)\n    prime := append(prime,\
    \ 251)\n    prime := append(prime, 257)\n    prime := append(prime, 263)\n   \
    \ prime := append(prime, 269)\n    prime := append(prime, 271)\n    prime := append(prime,\
    \ 277)\n    prime := append(prime, 281)\n    prime := append(prime, 283)\n   \
    \ prime := append(prime, \nfunc TestCount_Up_To(t *testing.T) {\n  candidate :=\
    \ count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpuu4in1_l_test.go:82:6: expected ''('', found TestCount_Up_To

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075218
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0, n)\n    prime := append(prime, 2)\n    for i\
    \ := 3; i < n; i++ {\n        for _, j := range prime {\n            if i%j ==\
    \ 0 {\n                break\n            }\n            if j > i {\n        \
    \        prime = append(prime, j)\n            }\n        }\n    }\n    return\
    \ prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpcz557gqo_test.go:25:11: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075219
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime :=\
    \ append(prime, 3)\n    for i := 4; i < n; i++ {\n        for _, j := range prime\
    \ {\n            if i%j == 0 {\n                break\n            }\n       \
    \ }\n        if i == n {\n            prime = append(prime, i)\n        }\n  \
    \  }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpiiyhsvnq_test.go:25:11: no new variables on left side of :=

    /tmp/tmpiiyhsvnq_test.go:26:11: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075219
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n        for\
    \ j := 2; j < i; j++ {\n            if i%j == 0 {\n                break\n   \
    \         }\n        }\n        if i == n {\n            prime = append(prime,\
    \ i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmpgsr31q6h_test.go:60: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__1 (0.00s)\n        tmpgsr31q6h_test.go:60:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__2\
    \ (0.00s)\n        tmpgsr31q6h_test.go:60: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__3 (0.00s)\n        tmpgsr31q6h_test.go:60:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]', got '[]'\n    ---\
    \ FAIL: TestCount_Up_To/test_num__5 (0.00s)\n        tmpgsr31q6h_test.go:60: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)\
    \ %!s(int=19)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n\
    \        tmpgsr31q6h_test.go:60: expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)\
    \ %!s(int=11) %!s(int=13) %!s(int=17)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__8\
    \ (0.00s)\n        tmpgsr31q6h_test.go:60: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29)\
    \ %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__9\
    \ (0.00s)\n        tmpgsr31q6h_test.go:60: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29)\
    \ %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43) %!s(int=47) %!s(int=53) %!s(int=59)\
    \ %!s(int=61) %!s(int=67) %!s(int=71) %!s(int=73) %!s(int=79) %!s(int=83) %!s(int=89)\
    \ %!s(int=97)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075219
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0)\n    prime := append(prime, 2)\n    for i :=\
    \ 3; i < n; i++ {\n        for j := 2; j < i; j++ {\n            if i%j == 0 {\n\
    \                break\n            }\n        }\n        if i == j {\n      \
    \      prime = append(prime, i)\n        }\n    }\n    return prime\n}\n\nfunc\
    \ TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2,\
    \ 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n   \
    \  { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp18h8lo5x_test.go:25:11: no new variables on left side of :=

    /tmp/tmp18h8lo5x_test.go:32:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075219
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0, n)\n    prime := append(prime, 2)\n    prime\
    \ := append(prime, 3)\n    for i := 4; i <= n; i++ {\n        for j := 2; j <\
    \ i; j++ {\n            if i%j == 0 {\n                break\n            }\n\
    \        }\n        if i == j {\n            prime = append(prime, i)\n      \
    \  }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpftin8gjr_test.go:25:11: no new variables on left side of :=

    /tmp/tmpftin8gjr_test.go:26:11: no new variables on left side of :=

    /tmp/tmpftin8gjr_test.go:33:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075219
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    primes := make([]int, n+1)\n    primes[0] = 1\n    primes[1] = 1\n  \
    \  for i := 2; i <= n; i++ {\n        for j := 2; j < i; j++ {\n            if\
    \ i*j > n {\n                break\n            }\n            if primes[i*j]\
    \ == 0 {\n                primes[i*j] = i\n            }\n        }\n    }\n \
    \   return primes[:n]\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [1] with length 1 [recovered]\n\tpanic: runtime error: index out of range [1]\
    \ with length 1\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmps7pyx1xu_test.go:26\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmps7pyx1xu_test.go:51\
    \ +0x173\ntesting.tRunner(0xc0001a0340, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075219
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0, n)\n    prime := append(prime, 2)\n    prime\
    \ := append(prime, 3)\n    for i := 4; i <= n; i++ {\n        for j := 2; j <\
    \ i; j++ {\n            if i % j == 0 {\n                break\n            }\n\
    \        }\n        if j > i {\n            prime = append(prime, i)\n       \
    \ }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp45e9zqma_test.go:25:11: no new variables on left side of :=

    /tmp/tmp45e9zqma_test.go:26:11: no new variables on left side of :=

    /tmp/tmp45e9zqma_test.go:33:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075219
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n        if\
    \ prime[prime[0]-1] == 0 {\n            prime = append(prime, i)\n        }\n\
    \        for j := 0; j < i; j++ {\n            if prime[j] == 0 {\n          \
    \      prime = append(prime, j)\n            }\n        }\n    }\n    return prime\n\
    }\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513920,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513920, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmpaddpwe5v_test.go:26\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmpaddpwe5v_test.go:45\
    \ +0x1254\ntesting.tRunner(0xc0001924e0, 0x529240)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075221
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0)\n    prime := append(prime, 2)\n    for i :=\
    \ 3; i < n; i++ {\n        for j := 2; j < i; j++ {\n            if i%j == 0 {\n\
    \                break\n            }\n        }\n        if i == j {\n      \
    \      prime = append(prime, i)\n        }\n    }\n    return prime\n}\n\nfunc\
    \ TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2,\
    \ 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n   \
    \  { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp18h8lo5x_test.go:25:11: no new variables on left side of :=

    /tmp/tmp18h8lo5x_test.go:32:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075219
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime :=\
    \ append(prime, 3)\n    prime := append(prime, 5)\n    prime := append(prime,\
    \ 7)\n    prime := append(prime, 11)\n    prime := append(prime, 13)\n    prime\
    \ := append(prime, 17)\n    prime := append(prime, 19)\n    prime := append(prime,\
    \ 23)\n    prime := append(prime, 29)\n    prime := append(prime, 31)\n    prime\
    \ := append(prime, 37)\n    prime := append(prime, 43)\n    prime := append(prime,\
    \ 49)\n    prime := append(prime, 57)\n    prime := append(prime, 61)\n    prime\
    \ := append(prime, 67)\n    prime := append(prime, 73)\n    prime := append(prime,\
    \ 79)\n    prime := append(prime, 83)\n    prime := append(prime, 89)\n    prime\
    \ := append(prime, 97)\n    prime := append(prime, 101)\n    prime := append(prime,\
    \ 103)\n    prime := append(prime, 107)\n    prime := append(prime, 109)\n   \
    \ prime := append(prime, 113)\n    prime := append(prime, 127)\n    prime := append(prime,\
    \ 131)\n    prime := append(prime, 137)\n    prime := append(prime, 139)\n   \
    \ prime := append(prime, 149)\n    prime := append(prime, 151)\n    prime := append(prime,\
    \ 157)\n    prime := append(prime, 163)\n    prime := append(prime, 167)\n   \
    \ prime := append(prime, 173)\n    prime := append(prime, 179)\n    prime := append(prime,\
    \ 181)\n    prime := append(prime, 191)\n    prime := append(prime, 193)\n   \
    \ prime := append(prime, 197)\n    prime := append(prime, 199)\n    prime := append(prime,\
    \ 211)\n    prime := append(prime, 223)\n    prime := append(prime, 227)\n   \
    \ prime := append(prime, 229)\n    prime := append(prime, 233)\n    prime := append(prime,\
    \ 239)\n    prime := append(prime, 241)\n    prime := append(prime, 251)\n   \
    \ prime := append(prime, 257)\n    prime := append(prime, 263)\n    prime := append(prime,\
    \ 269)\n    prime := append(prime, 271)\n    prime := append(prime, 277)\n   \
    \ prime := append(prime, 28\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpa2cnz7tx_test.go:81:30: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075219
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime :=\
    \ append(prime, 3)\n    prime := append(prime, 5)\n    prime := append(prime,\
    \ 7)\n    prime := append(prime, 11)\n    prime := append(prime, 13)\n    prime\
    \ := append(prime, 17)\n    prime := append(prime, 19)\n    prime := append(prime,\
    \ 23)\n    prime := append(prime, 29)\n    prime := append(prime, 31)\n    prime\
    \ := append(prime, 37)\n    prime := append(prime, 43)\n    prime := append(prime,\
    \ 49)\n    prime := append(prime, 57)\n    prime := append(prime, 61)\n    prime\
    \ := append(prime, 67)\n    prime := append(prime, 73)\n    prime := append(prime,\
    \ 79)\n    prime := append(prime, 83)\n    prime := append(prime, 89)\n    prime\
    \ := append(prime, 97)\n    prime := append(prime, 101)\n    prime := append(prime,\
    \ 103)\n    prime := append(prime, 107)\n    prime := append(prime, 109)\n   \
    \ prime := append(prime, 113)\n    prime := append(prime, 127)\n    prime := append(prime,\
    \ 131)\n    prime := append(prime, 137)\n    prime := append(prime, 139)\n   \
    \ prime := append(prime, 149)\n    prime := append(prime, 151)\n    prime := append(prime,\
    \ 157)\n    prime := append(prime, 163)\n    prime := append(prime, 167)\n   \
    \ prime := append(prime, 173)\n    prime := append(prime, 179)\n    prime := append(prime,\
    \ 181)\n    prime := append(prime, 191)\n    prime := append(prime, 193)\n   \
    \ prime := append(prime, 197)\n    prime := append(prime, 199)\n    prime := append(prime,\
    \ 211)\n    prime := append(prime, 223)\n    prime := append(prime, 227)\n   \
    \ prime := append(prime, 229)\n    prime := append(prime, 233)\n    prime := append(prime,\
    \ 239)\n    prime := append(prime, 241)\n    prime := append(prime, 251)\n   \
    \ prime := append(prime, 257)\n    prime := append(prime, 263)\n    prime := append(prime,\
    \ 269)\n    prime := append(prime, 271)\n    prime := append(prime, 277)\n   \
    \ prime := append(prime, 28\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpa2cnz7tx_test.go:81:30: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075219
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n        for\
    \ j := 2; j < i; j++ {\n            if i%j == 0 {\n                break\n   \
    \         }\n        }\n        if i == j {\n            prime = append(prime,\
    \ i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpt19r5qk1_test.go:31:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075219
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0, n)\n    for i := 2; i <= n; i++ {\n        for\
    \ j := 2; j < i; j++ {\n            if i%j == 0 {\n                break\n   \
    \         }\n        }\n        if i == j {\n            prime = append(prime,\
    \ i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6d7706_v_test.go:31:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075221
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n        if\
    \ prime[i / 2] {\n            continue\n        }\n        for j := i * i; j <\
    \ n; j += i {\n            if j > n {\n                break\n            }\n\
    \            prime = append(prime, j)\n        }\n    }\n    return prime\n}\n\
    \nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpd78jtxff_test.go:26:12: non-boolean condition in if statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075221
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime :=\
    \ append(prime, 3)\n    for i := 4; i < n; i++ {\n        for j := 2; j < i; j++\
    \ {\n            if i%j == 0 {\n                break\n            }\n       \
    \ }\n        if j == i {\n            prime = append(prime, i)\n        }\n  \
    \  }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpgsfihhpx_test.go:25:11: no new variables on left side of :=

    /tmp/tmpgsfihhpx_test.go:26:11: no new variables on left side of :=

    /tmp/tmpgsfihhpx_test.go:33:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075221
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n        if\
    \ prime[prime[0]-1] == 0 {\n            prime = append(prime, i)\n        }\n\
    \        for j := 0; j < i; j++ {\n            if prime[j] == 0 {\n          \
    \      prime = append(prime, i+j)\n                break\n            }\n    \
    \    }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n \
    \ candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513920,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513920, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmp1kzr4ka__test.go:26\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmp1kzr4ka__test.go:46\
    \ +0x12d6\ntesting.tRunner(0xc00019a680, 0x529240)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075222
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0, n)\n    for i := 0; i < n; i++ {\n        if\
    \ isprime(i) {\n            prime = append(prime, i)\n        }\n    }\n    return\
    \ prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpl1uf0kwv_test.go:26:12: undefined: isprime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075221
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n        if\
    \ prime[prime[0]-1] == 0 {\n            prime = append(prime, i)\n        }\n\
    \        for j := 0; j < i; j++ {\n            if prime[j] == 0 {\n          \
    \      prime = append(prime, i+j)\n                break\n            }\n    \
    \    }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n \
    \ candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513920,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513920, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmp1kzr4ka__test.go:26\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmp1kzr4ka__test.go:46\
    \ +0x12d6\ntesting.tRunner(0xc00019a680, 0x529240)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075222
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n        if\
    \ prime[prime[len(prime)-1]-1] != i {\n            prime = append(prime, i)\n\
    \        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n\
    \  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine\
    \ 19 [running]:\ntesting.tRunner.func1.2({0x513920, 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513920, 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmpuec6jttv_test.go:26\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmpuec6jttv_test.go:40\
    \ +0xddd\ntesting.tRunner(0xc0001036c0, 0x529240)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075222
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    primes := make([]int, n+1)\n    primes[0] = 1\n    for i := 2; i <= n;\
    \ i++ {\n        for j := 2; j < i; j++ {\n            if i%j == 0 {\n       \
    \         break\n            }\n        }\n        if i == j {\n            primes[i]\
    \ = 1\n        }\n    }\n    return primes[:n]\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpcz8lnrud_test.go:32:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075221
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    primes := make([]int, n+1)\n    primes[0] = 1\n    primes[1] = 1\n  \
    \  for i := 2; i <= n; i++ {\n        for j := 2; j < i; j++ {\n            if\
    \ i*j > n {\n                break\n            }\n            if primes[i*j]\
    \ == 0 {\n                primes[i*j] = i\n            }\n        }\n    }\n \
    \   return primes[:n]\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [1] with length 1 [recovered]\n\tpanic: runtime error: index out of range [1]\
    \ with length 1\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmps7pyx1xu_test.go:26\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmps7pyx1xu_test.go:51\
    \ +0x173\ntesting.tRunner(0xc0001a0340, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075219
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0)\n    for i := 2; i <= n; i++ {\n        if isprime(i)\
    \ {\n            prime = append(prime, i)\n        }\n    }\n    return prime\n\
    }\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphdatrv6w_test.go:26:12: undefined: isprime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075221
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0, n)\n    prime := append(prime, 2)\n    prime\
    \ := append(prime, 3)\n    for i := 4; i <= n; i++ {\n        for j := 2; j <\
    \ i; j++ {\n            if i % j == 0 {\n                break\n            }\n\
    \        }\n        if j > i {\n            prime = append(prime, i)\n       \
    \ }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp45e9zqma_test.go:25:11: no new variables on left side of :=

    /tmp/tmp45e9zqma_test.go:26:11: no new variables on left side of :=

    /tmp/tmp45e9zqma_test.go:33:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075219
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    primes := make([]int, n+1)\n    primes[0] = 1\n    for i := 2; i <= n;\
    \ i++ {\n        if primes[i] != 0 {\n            continue\n        }\n      \
    \  for j := 2; i*j <= n; j++ {\n            if i*j == n {\n                primes[i*j]\
    \ = i\n                break\n            }\n            if primes[i*j] == 0 {\n\
    \                primes[i*j] = i\n                break\n            }\n     \
    \   }\n    }\n    return primes[:n]\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n\
    \  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmpz7j4bx26_test.go:66: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[%!s(int=1) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=2)]'\n    --- FAIL:\
    \ TestCount_Up_To/test_num__1 (0.00s)\n        tmpz7j4bx26_test.go:66: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[%!s(int=1) %!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=2) %!s(int=0)]'\n    --- FAIL: TestCount_Up_To/test_num__2\
    \ (0.00s)\n        tmpz7j4bx26_test.go:66: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]',\
    \ got '[%!s(int=1) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=2) %!s(int=0) %!s(int=3)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__3 (0.00s)\n        tmpz7j4bx26_test.go:66:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]', got '[%!s(int=1) %!s(int=0)\
    \ %!s(int=0) %!s(int=0) %!s(int=2) %!s(int=0) %!s(int=3) %!s(int=0) %!s(int=0)\
    \ %!s(int=0)]'\n    --- FAIL: TestCount_Up_To/test_num__5 (0.00s)\n        tmpz7j4bx26_test.go:66:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19)]', got '[%!s(int=1) %!s(int=0) %!s(int=0) %!s(int=0)\
    \ %!s(int=2) %!s(int=0) %!s(int=3) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=5)\
    \ %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=7) %!s(int=0) %!s(int=8) %!s(int=0)\
    \ %!s(int=9) %!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestCount_Up_To/test_num__6\
    \ (0.00s)\n        tmpz7j4bx26_test.go:66: expected '[]', got '[%!s(int=1)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n        tmpz7j4bx26_test.go:66:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17)]', got '[%!s(int=1) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=2)\
    \ %!s(int=0) %!s(int=3) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=5) %!s(int=0)\
    \ %!s(int=0) %!s(int=0) %!s(int=7) %!s(int=0) %!s(int=8) %!s(int=0)]'\n    ---\
    \ FAIL: TestCount_Up_To/test_num__8 (0.00s)\n        tmpz7j4bx26_test.go:66: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)\
    \ %!s(int=19) %!s(int=23) %!s(int=29) %!s(int=31) %"
  timestamp: 1660075222
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0, n)\n    prime := append(prime, 2)\n    for i\
    \ := 3; i < n; i++ {\n        for _, j := range prime {\n            if j%i ==\
    \ 0 {\n                break\n            }\n            if i%j == 0 {\n     \
    \           prime = append(prime, j)\n                break\n            }\n \
    \       }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n\
    \  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpp41p_6x9_test.go:25:11: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075221
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n        if\
    \ prime[i / 2] {\n            continue\n        }\n        for j := i * i; j <\
    \ n; j += i {\n            prime[j] = true\n        }\n    }\n    return prime\n\
    }\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdzu0fb5__test.go:26:12: non-boolean condition in if statement

    /tmp/tmpdzu0fb5__test.go:30:24: cannot use true (untyped bool constant) as int
    value in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075221
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0, n)\n    prime := append(prime, 2)\n    prime\
    \ := append(prime, 3)\n    for i := 4; i <= n; i++ {\n        for j := 2; j <\
    \ i; j++ {\n            if i % j == 0 {\n                break\n            }\n\
    \        }\n        if j == i {\n            prime = append(prime, i)\n      \
    \  }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpngz4c41y_test.go:25:11: no new variables on left side of :=

    /tmp/tmpngz4c41y_test.go:26:11: no new variables on left side of :=

    /tmp/tmpngz4c41y_test.go:33:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075221
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0, n)\n    prime := append(prime, 2)\n    prime\
    \ := append(prime, 3)\n    for i := 4; i <= n; i++ {\n        for j := 2; j <\
    \ i; j++ {\n            if i % j == 0 {\n                break\n            }\n\
    \        }\n        if j > i {\n            prime = append(prime, i)\n       \
    \ }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp45e9zqma_test.go:25:11: no new variables on left side of :=

    /tmp/tmp45e9zqma_test.go:26:11: no new variables on left side of :=

    /tmp/tmp45e9zqma_test.go:33:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075219
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n        if\
    \ prime[prime[len(prime)-1]-1] != i {\n            prime = append(prime, i)\n\
    \        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n\
    \  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine\
    \ 19 [running]:\ntesting.tRunner.func1.2({0x513920, 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513920, 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmpuec6jttv_test.go:26\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmpuec6jttv_test.go:40\
    \ +0xddd\ntesting.tRunner(0xc0001036c0, 0x529240)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075222
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0, n)\n    prime := append(prime, 2)\n    prime\
    \ := append(prime, 3)\n    prime := append(prime, 5)\n    prime := append(prime,\
    \ 7)\n    prime := append(prime, 11)\n    prime := append(prime, 13)\n    prime\
    \ := append(prime, 17)\n    prime := append(prime, 19)\n    prime := append(prime,\
    \ 29)\n    prime := append(prime, 31)\n    prime := append(prime, 37)\n    prime\
    \ := append(prime, 43)\n    prime := append(prime, 59)\n    prime := append(prime,\
    \ 61)\n    prime := append(prime, 67)\n    prime := append(prime, 73)\n    prime\
    \ := append(prime, 79)\n    prime := append(prime, 83)\n    prime := append(prime,\
    \ 89)\n    prime := append(prime, 97)\n    prime := append(prime, 101)\n    prime\
    \ := append(prime, 103)\n    prime := append(prime, 107)\n    prime := append(prime,\
    \ 109)\n    prime := append(prime, 113)\n    prime := append(prime, 127)\n   \
    \ prime := append(prime, 131)\n    prime := append(prime, 137)\n    prime := append(prime,\
    \ 139)\n    prime := append(prime, 149)\n    prime := append(prime, 151)\n   \
    \ prime := append(prime, 157)\n    prime := append(prime, 163)\n    prime := append(prime,\
    \ 167)\n    prime := append(prime, 173)\n    prime := append(prime, 179)\n   \
    \ prime := append(prime, 181)\n    prime := append(prime, 191)\n    prime := append(prime,\
    \ 193)\n    prime := append(prime, 197)\n    prime := append(prime, 199)\n   \
    \ prime := append(prime, 211)\n    prime := append(prime, 223)\n    prime := append(prime,\
    \ 227)\n    prime := append(prime, 229)\n    prime := append(prime, 233)\n   \
    \ prime := append(prime, 239)\n    prime := append(prime, 241)\n    prime := append(prime,\
    \ 251)\n    prime := append(prime, 257)\n    prime := append(prime, 263)\n   \
    \ prime := append(prime, 269)\n    prime := append(prime, 271)\n    prime := append(prime,\
    \ 277)\n    prime := append(prime, 281)\n    prime := append(prime, 283)\n   \
    \ prime := append(prime\nfunc TestCount_Up_To(t *testing.T) {\n  candidate :=\
    \ count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvccghpx6_test.go:81:26: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075221
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0, n)\n    prime := append(prime, 2)\n    prime\
    \ := append(prime, 3)\n    for i := 4; i <= n; i++ {\n        for j := 2; j <\
    \ i; j++ {\n            if i%j == 0 {\n                break\n            }\n\
    \        }\n        if i == j {\n            prime = append(prime, i)\n      \
    \  }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpftin8gjr_test.go:25:11: no new variables on left side of :=

    /tmp/tmpftin8gjr_test.go:26:11: no new variables on left side of :=

    /tmp/tmpftin8gjr_test.go:33:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075219
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime :=\
    \ append(prime, 3)\n    prime := append(prime, 5)\n    prime := append(prime,\
    \ 7)\n    prime := append(prime, 11)\n    prime := append(prime, 13)\n    prime\
    \ := append(prime, 17)\n    prime := append(prime, 19)\n    prime := append(prime,\
    \ 23)\n    prime := append(prime, 29)\n    prime := append(prime, 31)\n    prime\
    \ := append(prime, 37)\n    prime := append(prime, 43)\n    prime := append(prime,\
    \ 49)\n    prime := append(prime, 57)\n    prime := append(prime, 61)\n    prime\
    \ := append(prime, 67)\n    prime := append(prime, 73)\n    prime := append(prime,\
    \ 79)\n    prime := append(prime, 83)\n    prime := append(prime, 89)\n    prime\
    \ := append(prime, 97)\n    prime := append(prime, 101)\n    prime := append(prime,\
    \ 103)\n    prime := append(prime, 107)\n    prime := append(prime, 109)\n   \
    \ prime := append(prime, 113)\n    prime := append(prime, 127)\n    prime := append(prime,\
    \ 131)\n    prime := append(prime, 137)\n    prime := append(prime, 139)\n   \
    \ prime := append(prime, 149)\n    prime := append(prime, 151)\n    prime := append(prime,\
    \ 157)\n    prime := append(prime, 163)\n    prime := append(prime, 167)\n   \
    \ prime := append(prime, 173)\n    prime := append(prime, 179)\n    prime := append(prime,\
    \ 181)\n    prime := append(prime, 191)\n    prime := append(prime, 193)\n   \
    \ prime := append(prime, 197)\n    prime := append(prime, 199)\n    prime := append(prime,\
    \ 211)\n    prime := append(prime, 223)\n    prime := append(prime, 227)\n   \
    \ prime := append(prime, 229)\n    prime := append(prime, 233)\n    prime := append(prime,\
    \ 239)\n    prime := append(prime, 241)\n    prime := append(prime, 243)\n   \
    \ prime := append(prime, 247)\n    prime := append(prime, 251)\n    prime := append(prime,\
    \ 257)\n    prime := append(prime, 263)\n    prime := append(prime, 269)\n   \
    \ prime := append(prime, 27\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphqd44j9a_test.go:81:30: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075221
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0, n)\n    for i := 0; i < n; i++ {\n        if\
    \ isprime(i) {\n            prime = append(prime, i)\n        }\n    }\n    return\
    \ prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpl1uf0kwv_test.go:26:12: undefined: isprime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075221
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0, n)\n    prime := append(prime, 2)\n    prime\
    \ := append(prime, 3)\n    for i := 4; i <= n; i++ {\n        for j := 2; j <\
    \ i; j++ {\n            if i%j == 0 {\n                break\n            }\n\
    \        }\n        if i == j {\n            prime = append(prime, i)\n      \
    \  }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpftin8gjr_test.go:25:11: no new variables on left side of :=

    /tmp/tmpftin8gjr_test.go:26:11: no new variables on left side of :=

    /tmp/tmpftin8gjr_test.go:33:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075219
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime :=\
    \ append(prime, 3)\n    for i := 4; i <= n; i++ {\n        for j := 2; j < i;\
    \ j++ {\n            if i % j == 0 {\n                break\n            }\n \
    \       }\n        if j == i {\n            prime = append(prime, i)\n       \
    \ }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpcs4rn_5u_test.go:25:11: no new variables on left side of :=

    /tmp/tmpcs4rn_5u_test.go:26:11: no new variables on left side of :=

    /tmp/tmpcs4rn_5u_test.go:33:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075219
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    primes := make([]int, n)\n    primes[0] = 1\n    for i := 1; i < n; i++\
    \ {\n        for j := 2; j < i; j++ {\n            if primes[j] == 0 {\n     \
    \           break\n            }\n            if i%primes[j] == 0 {\n        \
    \        primes[j] = 1\n                break\n            }\n        }\n    \
    \    if primes[i] == 0 {\n            primes[i] = 1\n        }\n    }\n    return\
    \ primes[:n]\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmpmp5k425v_test.go:25\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmpmp5k425v_test.go:54\
    \ +0x1d8\ntesting.tRunner(0xc0001a0340, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075222
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    primes := make([]int, n+1)\n    primes[0] = 1\n    primes[1] = 1\n  \
    \  for i := 2; i <= n; i++ {\n        for j := 2; j < i; j++ {\n            if\
    \ i*j > n {\n                break\n            }\n            if primes[i*j]\
    \ == 0 {\n                primes[i*j] = i\n            }\n        }\n    }\n \
    \   return primes[:n]\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [1] with length 1 [recovered]\n\tpanic: runtime error: index out of range [1]\
    \ with length 1\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmps7pyx1xu_test.go:26\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmps7pyx1xu_test.go:51\
    \ +0x173\ntesting.tRunner(0xc0001a0340, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075219
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime :=\
    \ append(prime, 3)\n    for i := 4; i <= n; i++ {\n        for j := 2; j < i;\
    \ j++ {\n            if i % j == 0 {\n                break\n            }\n \
    \       }\n        if j > i {\n            prime = append(prime, i)\n        }\n\
    \    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpf_4cdq0t_test.go:25:11: no new variables on left side of :=

    /tmp/tmpf_4cdq0t_test.go:26:11: no new variables on left side of :=

    /tmp/tmpf_4cdq0t_test.go:33:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075219
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime :=\
    \ append(prime, 3)\n    for i := 4; i <= n; i++ {\n        for j := 2; j < i;\
    \ j++ {\n            if i % j == 0 {\n                break\n            }\n \
    \       }\n        if j == i {\n            prime = append(prime, i)\n       \
    \ }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpcs4rn_5u_test.go:25:11: no new variables on left side of :=

    /tmp/tmpcs4rn_5u_test.go:26:11: no new variables on left side of :=

    /tmp/tmpcs4rn_5u_test.go:33:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075219
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0)\n    prime := append(prime, 2)\n    for i :=\
    \ 3; i < n; i++ {\n        for j := 2; j < i; j++ {\n            if i % j == 0\
    \ {\n                break\n            }\n        }\n        if j > i {\n   \
    \         prime = append(prime, i)\n        }\n    }\n    return prime\n}\n\n\
    func TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpazhjvxpx_test.go:25:11: no new variables on left side of :=

    /tmp/tmpazhjvxpx_test.go:32:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075222
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime :=\
    \ append(prime, 3)\n    for i := 4; i <= n; i++ {\n        for j := 2; j < i;\
    \ j++ {\n            if i % j == 0 {\n                break\n            }\n \
    \       }\n        if j > i {\n            prime = append(prime, i)\n        }\n\
    \    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpf_4cdq0t_test.go:25:11: no new variables on left side of :=

    /tmp/tmpf_4cdq0t_test.go:26:11: no new variables on left side of :=

    /tmp/tmpf_4cdq0t_test.go:33:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075219
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n        if\
    \ prime[prime[0]-1] == 0 {\n            prime = append(prime, i)\n        }\n\
    \        for j := 1; j < i; j++ {\n            if prime[j-1] != 0 && prime[j-1]\
    \ != i {\n                prime = append(prime, j)\n            }\n        }\n\
    \    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513920,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513920, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmp5i1tzc8s_test.go:26\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmp5i1tzc8s_test.go:45\
    \ +0x1285\ntesting.tRunner(0xc0001a0340, 0x529240)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075222
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n        if\
    \ prime[prime[0]] == 0 {\n            prime = append(prime, i)\n        }\n  \
    \      for j := 0; j < prime[0]; j++ {\n            if i*prime[j] >= n {\n   \
    \             break\n            }\n            if prime[prime[j]] == 0 {\n  \
    \              prime = append(prime, prime[j])\n            }\n        }\n   \
    \ }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 34 [running]:\ntesting.tRunner.func1.2({0x513920,\
    \ 0xc0001d6000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513920, 0xc0001d6000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmpe2jq7yte_test.go:26\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmpe2jq7yte_test.go:48\
    \ +0x14ac\ntesting.tRunner(0xc000198ea0, 0x529240)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075222
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0)\n    prime := append(prime, 2)\n    for i :=\
    \ 3; i < n; i++ {\n        for _, j := range prime {\n            if i%j == 0\
    \ {\n                break\n            }\n            if j == i {\n         \
    \       prime = append(prime, i)\n                break\n            }\n     \
    \   }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpcz8ewy5a_test.go:25:11: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075222
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime :=\
    \ append(prime, 3)\n    prime := append(prime, 5)\n    prime := append(prime,\
    \ 7)\n    prime := append(prime, 11)\n    prime := append(prime, 13)\n    prime\
    \ := append(prime, 17)\n    prime := append(prime, 19)\n    prime := append(prime,\
    \ 23)\n    prime := append(prime, 29)\n    prime := append(prime, 31)\n    prime\
    \ := append(prime, 37)\n    prime := append(prime, 43)\n    prime := append(prime,\
    \ 49)\n    prime := append(prime, 57)\n    prime := append(prime, 61)\n    prime\
    \ := append(prime, 67)\n    prime := append(prime, 73)\n    prime := append(prime,\
    \ 79)\n    prime := append(prime, 83)\n    prime := append(prime, 89)\n    prime\
    \ := append(prime, 97)\n    prime := append(prime, 101)\n    prime := append(prime,\
    \ 103)\n    prime := append(prime, 107)\n    prime := append(prime, 109)\n   \
    \ prime := append(prime, 113)\n    prime := append(prime, 127)\n    prime := append(prime,\
    \ 131)\n    prime := append(prime, 137)\n    prime := append(prime, 139)\n   \
    \ prime := append(prime, 149)\n    prime := append(prime, 151)\n    prime := append(prime,\
    \ 157)\n    prime := append(prime, 163)\n    prime := append(prime, 167)\n   \
    \ prime := append(prime, 173)\n    prime := append(prime, 179)\n    prime := append(prime,\
    \ 181)\n    prime := append(prime, 191)\n    prime := append(prime, 193)\n   \
    \ prime := append(prime, 197)\n    prime := append(prime, 199)\n    prime := append(prime,\
    \ 211)\n    prime := append(prime, 223)\n    prime := append(prime, 227)\n   \
    \ prime := append(prime, 229)\n    prime := append(prime, 233)\n    prime := append(prime,\
    \ 239)\n    prime := append(prime, 241)\n    prime := append(prime, 251)\n   \
    \ prime := append(prime, 257)\n    prime := append(prime, 263)\n    prime := append(prime,\
    \ 269)\n    prime := append(prime, 271)\n    prime := append(prime, 277)\n   \
    \ prime := append(prime, 28\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpa2cnz7tx_test.go:81:30: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075219
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime :=\
    \ append(prime, 3)\n    for i := 4; i <= n; i++ {\n        for j := 2; j < i;\
    \ j++ {\n            if i % j == 0 {\n                break\n            }\n \
    \       }\n        if j > i {\n            prime = append(prime, i)\n        }\n\
    \    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpf_4cdq0t_test.go:25:11: no new variables on left side of :=

    /tmp/tmpf_4cdq0t_test.go:26:11: no new variables on left side of :=

    /tmp/tmpf_4cdq0t_test.go:33:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075219
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n        if\
    \ prime[prime[len(prime)-1]-1] == i {\n            prime = append(prime, i)\n\
    \        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n\
    \  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine\
    \ 6 [running]:\ntesting.tRunner.func1.2({0x513920, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513920, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmpnmiylgv5_test.go:26\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmpnmiylgv5_test.go:40\
    \ +0xddd\ntesting.tRunner(0xc0001a0340, 0x529240)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075222
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime :=\
    \ append(prime, 3)\n    for i := 4; i <= n; i++ {\n        for j := 2; j < i;\
    \ j++ {\n            if i%j == 0 {\n                break\n            }\n   \
    \     }\n        if i == j {\n            prime = append(prime, i)\n        }\n\
    \    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6kz16l2x_test.go:25:11: no new variables on left side of :=

    /tmp/tmp6kz16l2x_test.go:26:11: no new variables on left side of :=

    /tmp/tmp6kz16l2x_test.go:33:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075219
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0)\n    prime := append(prime, 2)\n    for i :=\
    \ 3; i < n; i++ {\n        if isPrime(i) {\n            prime = append(prime,\
    \ i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkv5cd45t_test.go:25:11: no new variables on left side of :=

    /tmp/tmpkv5cd45t_test.go:27:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075222
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime :=\
    \ append(prime, 3)\n    for i := 4; i <= n; i++ {\n        for j := 2; j < i;\
    \ j++ {\n            if i % j == 0 {\n                break\n            }\n \
    \       }\n        if j > i {\n            prime = append(prime, i)\n        }\n\
    \    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpf_4cdq0t_test.go:25:11: no new variables on left side of :=

    /tmp/tmpf_4cdq0t_test.go:26:11: no new variables on left side of :=

    /tmp/tmpf_4cdq0t_test.go:33:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075219
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n        if\
    \ prime[prime[0]-1] == 0 || prime[prime[0]-1] == i {\n            prime = append(prime,\
    \ i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513920,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513920, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmp8n71vgk3_test.go:26\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmp8n71vgk3_test.go:40\
    \ +0xdfb\ntesting.tRunner(0xc0001a0340, 0x529240)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075222
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0, n)\n    for i := 2; i <= n; i++ {\n        if\
    \ isPrime(i) {\n            prime = append(prime, i)\n        }\n    }\n    return\
    \ prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0gb6o504_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075219
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0)\n    for i := 2; i < n; i++ {\n        if isprime(i)\
    \ {\n            prime = append(prime, i)\n        }\n    }\n    return prime\n\
    }\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8dafzva8_test.go:26:12: undefined: isprime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075223
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime :=\
    \ append(prime, 3)\n    for i := 4; i <= n; i++ {\n        for j := 2; j < i;\
    \ j++ {\n            if i % j == 0 {\n                break\n            }\n \
    \       }\n        if j == i {\n            prime = append(prime, i)\n       \
    \ }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpcs4rn_5u_test.go:25:11: no new variables on left side of :=

    /tmp/tmpcs4rn_5u_test.go:26:11: no new variables on left side of :=

    /tmp/tmpcs4rn_5u_test.go:33:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075219
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime :=\
    \ append(prime, 3)\n    for i := 4; i <= n; i++ {\n        for j := 2; j < i;\
    \ j++ {\n            if i % j == 0 {\n                break\n            }\n \
    \       }\n        if j == i {\n            prime = append(prime, i)\n       \
    \ }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpcs4rn_5u_test.go:25:11: no new variables on left side of :=

    /tmp/tmpcs4rn_5u_test.go:26:11: no new variables on left side of :=

    /tmp/tmpcs4rn_5u_test.go:33:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075219
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n        for\
    \ j := 2; j < i; j++ {\n            if i%j == 0 {\n                break\n   \
    \         }\n        }\n        if i == n {\n            prime = append(prime,\
    \ i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmpgsr31q6h_test.go:60: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__1 (0.00s)\n        tmpgsr31q6h_test.go:60:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__2\
    \ (0.00s)\n        tmpgsr31q6h_test.go:60: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__3 (0.00s)\n        tmpgsr31q6h_test.go:60:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]', got '[]'\n    ---\
    \ FAIL: TestCount_Up_To/test_num__5 (0.00s)\n        tmpgsr31q6h_test.go:60: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)\
    \ %!s(int=19)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n\
    \        tmpgsr31q6h_test.go:60: expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)\
    \ %!s(int=11) %!s(int=13) %!s(int=17)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__8\
    \ (0.00s)\n        tmpgsr31q6h_test.go:60: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29)\
    \ %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__9\
    \ (0.00s)\n        tmpgsr31q6h_test.go:60: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29)\
    \ %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43) %!s(int=47) %!s(int=53) %!s(int=59)\
    \ %!s(int=61) %!s(int=67) %!s(int=71) %!s(int=73) %!s(int=79) %!s(int=83) %!s(int=89)\
    \ %!s(int=97)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075219
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime :=\
    \ append(prime, 3)\n    for i := 4; i <= n; i++ {\n        for j := 2; j < i;\
    \ j++ {\n            if i % j == 0 {\n                break\n            }\n \
    \       }\n        if j > i {\n            prime = append(prime, i)\n        }\n\
    \    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpf_4cdq0t_test.go:25:11: no new variables on left side of :=

    /tmp/tmpf_4cdq0t_test.go:26:11: no new variables on left side of :=

    /tmp/tmpf_4cdq0t_test.go:33:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075219
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n        if\
    \ prime[prime[len(prime)-1]-1] != i {\n            prime = append(prime, i)\n\
    \        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n\
    \  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine\
    \ 19 [running]:\ntesting.tRunner.func1.2({0x513920, 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513920, 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmpuec6jttv_test.go:26\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmpuec6jttv_test.go:40\
    \ +0xddd\ntesting.tRunner(0xc0001036c0, 0x529240)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075222
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime :=\
    \ append(prime, 3)\n    prime := append(prime, 5)\n    prime := append(prime,\
    \ 7)\n    prime := append(prime, 11)\n    prime := append(prime, 13)\n    prime\
    \ := append(prime, 17)\n    prime := append(prime, 19)\n    prime := append(prime,\
    \ 23)\n    prime := append(prime, 29)\n    prime := append(prime, 31)\n    prime\
    \ := append(prime, 37)\n    prime := append(prime, 43)\n    prime := append(prime,\
    \ 49)\n    prime := append(prime, 57)\n    prime := append(prime, 61)\n    prime\
    \ := append(prime, 67)\n    prime := append(prime, 73)\n    prime := append(prime,\
    \ 79)\n    prime := append(prime, 83)\n    prime := append(prime, 89)\n    prime\
    \ := append(prime, 97)\n    prime := append(prime, 101)\n    prime := append(prime,\
    \ 103)\n    prime := append(prime, 107)\n    prime := append(prime, 109)\n   \
    \ prime := append(prime, 113)\n    prime := append(prime, 127)\n    prime := append(prime,\
    \ 131)\n    prime := append(prime, 137)\n    prime := append(prime, 139)\n   \
    \ prime := append(prime, 149)\n    prime := append(prime, 151)\n    prime := append(prime,\
    \ 157)\n    prime := append(prime, 163)\n    prime := append(prime, 167)\n   \
    \ prime := append(prime, 173)\n    prime := append(prime, 179)\n    prime := append(prime,\
    \ 181)\n    prime := append(prime, 191)\n    prime := append(prime, 193)\n   \
    \ prime := append(prime, 197)\n    prime := append(prime, 199)\n    prime := append(prime,\
    \ 211)\n    prime := append(prime, 223)\n    prime := append(prime, 227)\n   \
    \ prime := append(prime, 229)\n    prime := append(prime, 233)\n    prime := append(prime,\
    \ 239)\n    prime := append(prime, 241)\n    prime := append(prime, 251)\n   \
    \ prime := append(prime, 257)\n    prime := append(prime, 263)\n    prime := append(prime,\
    \ 269)\n    prime := append(prime, 271)\n    prime := append(prime, 277)\n   \
    \ prime := append(prime, 28\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpa2cnz7tx_test.go:81:30: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075219
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime :=\
    \ append(prime, 3)\n    for i := 4; i < n; i++ {\n        for j := 2; j < i; j++\
    \ {\n            if i % j == 0 {\n                break\n            }\n     \
    \   }\n        if j > i {\n            prime = append(prime, i)\n        }\n \
    \   }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpsk7j88uq_test.go:25:11: no new variables on left side of :=

    /tmp/tmpsk7j88uq_test.go:26:11: no new variables on left side of :=

    /tmp/tmpsk7j88uq_test.go:33:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075223
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0, n)\n    prime := append(prime, 2)\n    for i\
    \ := 3; i < n; i++ {\n        for j := 2; j < i; j++ {\n            if i%j ==\
    \ 0 {\n                break\n            }\n        }\n        if i == j {\n\
    \            prime = append(prime, i)\n        }\n    }\n    return prime\n}\n\
    \nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpn1r8i3ww_test.go:25:11: no new variables on left side of :=

    /tmp/tmpn1r8i3ww_test.go:32:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075223
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    primes := make([]int, n+1)\n    primes[0] = 1\n    for i := 2; i <= n;\
    \ i++ {\n        for j := 2; j < i; j++ {\n            if i%j == 0 {\n       \
    \         break\n            }\n        }\n        if j > i {\n            primes[i]\
    \ = j\n        }\n    }\n    return primes\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpzvci1d5f_test.go:32:12: undefined: j

    /tmp/tmpzvci1d5f_test.go:33:25: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075223
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n        if\
    \ prime[i / 2] {\n            continue\n        }\n        for j := i * i; j <\
    \ n; j += i {\n            if j > n {\n                break\n            }\n\
    \            if prime[j] {\n                continue\n            }\n        \
    \    prime = append(prime, j)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9e5h73r7_test.go:26:12: non-boolean condition in if statement

    /tmp/tmp9e5h73r7_test.go:33:16: non-boolean condition in if statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075223
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime :=\
    \ append(prime, 3)\n    for i := 4; i <= n; i++ {\n        for j := 2; j < i;\
    \ j++ {\n            if i%j == 0 {\n                break\n            }\n   \
    \     }\n        if i == j {\n            prime = append(prime, i)\n        }\n\
    \    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6kz16l2x_test.go:25:11: no new variables on left side of :=

    /tmp/tmp6kz16l2x_test.go:26:11: no new variables on left side of :=

    /tmp/tmp6kz16l2x_test.go:33:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075219
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0, n)\n    for i := 2; i <= n; i++ {\n        if\
    \ prime[i / 2] {\n            continue\n        }\n        for j := i * i; j <\
    \ n; j += i {\n            prime[j] = true\n        }\n    }\n    return prime\n\
    }\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpg8ervz0m_test.go:26:12: non-boolean condition in if statement

    /tmp/tmpg8ervz0m_test.go:30:24: cannot use true (untyped bool constant) as int
    value in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075223
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime :=\
    \ append(prime, 3)\n    prime := append(prime, 5)\n    prime := append(prime,\
    \ 7)\n    prime := append(prime, 11)\n    prime := append(prime, 13)\n    prime\
    \ := append(prime, 17)\n    prime := append(prime, 19)\n    prime := append(prime,\
    \ 23)\n    prime := append(prime, 29)\n    prime := append(prime, 31)\n    prime\
    \ := append(prime, 37)\n    prime := append(prime, 43)\n    prime := append(prime,\
    \ 49)\n    prime := append(prime, 57)\n    prime := append(prime, 61)\n    prime\
    \ := append(prime, 67)\n    prime := append(prime, 73)\n    prime := append(prime,\
    \ 79)\n    prime := append(prime, 83)\n    prime := append(prime, 89)\n    prime\
    \ := append(prime, 97)\n    prime := append(prime, 101)\n    prime := append(prime,\
    \ 103)\n    prime := append(prime, 107)\n    prime := append(prime, 109)\n   \
    \ prime := append(prime, 113)\n    prime := append(prime, 127)\n    prime := append(prime,\
    \ 131)\n    prime := append(prime, 137)\n    prime := append(prime, 139)\n   \
    \ prime := append(prime, 149)\n    prime := append(prime, 151)\n    prime := append(prime,\
    \ 157)\n    prime := append(prime, 163)\n    prime := append(prime, 167)\n   \
    \ prime := append(prime, 173)\n    prime := append(prime, 179)\n    prime := append(prime,\
    \ 181)\n    prime := append(prime, 191)\n    prime := append(prime, 193)\n   \
    \ prime := append(prime, 197)\n    prime := append(prime, 199)\n    prime := append(prime,\
    \ 211)\n    prime := append(prime, 223)\n    prime := append(prime, 227)\n   \
    \ prime := append(prime, 229)\n    prime := append(prime, 233)\n    prime := append(prime,\
    \ 239)\n    prime := append(prime, 241)\n    prime := append(prime, 251)\n   \
    \ prime := append(prime, 257)\n    prime := append(prime, 263)\n    prime := append(prime,\
    \ 269)\n    prime := append(prime, 271)\n    prime := append(prime, 277)\n   \
    \ prime := append(prime, 28\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpa2cnz7tx_test.go:81:30: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075219
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime :=\
    \ append(prime, 3)\n    prime := append(prime, 5)\n    prime := append(prime,\
    \ 7)\n    prime := append(prime, 11)\n    prime := append(prime, 13)\n    prime\
    \ := append(prime, 17)\n    prime := append(prime, 19)\n    if n <= 0 {\n    \
    \    return prime\n    }\n    for i := 5; i <= n; i++ {\n        if isPrime(i)\
    \ {\n            prime = append(prime, i)\n        }\n    }\n    return prime\n\
    }\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1x33dg9__test.go:25:11: no new variables on left side of :=

    /tmp/tmp1x33dg9__test.go:26:11: no new variables on left side of :=

    /tmp/tmp1x33dg9__test.go:27:11: no new variables on left side of :=

    /tmp/tmp1x33dg9__test.go:28:11: no new variables on left side of :=

    /tmp/tmp1x33dg9__test.go:29:11: no new variables on left side of :=

    /tmp/tmp1x33dg9__test.go:30:11: no new variables on left side of :=

    /tmp/tmp1x33dg9__test.go:31:11: no new variables on left side of :=

    /tmp/tmp1x33dg9__test.go:32:11: no new variables on left side of :=

    /tmp/tmp1x33dg9__test.go:37:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075223
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0, n)\n    for i := 2; i <= n; i++ {\n        if\
    \ isPrime(i) {\n            prime = append(prime, i)\n        }\n    }\n    return\
    \ prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0gb6o504_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075219
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0, n)\n    for i := 0; i < n; i++ {\n        if\
    \ i%2 == 0 {\n            continue\n        }\n        for j := 3; j < i; j++\
    \ {\n            if i%j == 0 {\n                break\n            }\n       \
    \ }\n        if j > i {\n            prime = append(prime, i)\n        }\n   \
    \ }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmph4kbyezz_test.go:34:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075223
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n        if\
    \ prime[prime[0]-1] == 0 {\n            prime = append(prime, i)\n        }\n\
    \        for j := 0; j < i; j++ {\n            if prime[j] == 0 {\n          \
    \      prime = append(prime, j)\n            }\n        }\n    }\n    return prime\n\
    }\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513920,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513920, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmpaddpwe5v_test.go:26\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmpaddpwe5v_test.go:45\
    \ +0x1254\ntesting.tRunner(0xc0001924e0, 0x529240)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075221
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n        if\
    \ prime[len(prime)-1] < i {\n            prime = append(prime, i)\n        }\n\
    \    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine\
    \ 6 [running]:\ntesting.tRunner.func1.2({0x513920, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513920, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmp8kf_xox8_test.go:26\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmp8kf_xox8_test.go:40\
    \ +0xd1d\ntesting.tRunner(0xc0001a0340, 0x529240)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075224
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime :=\
    \ append(prime, 3)\n    prime := append(prime, 5)\n    prime := append(prime,\
    \ 7)\n    prime := append(prime, 11)\n    prime := append(prime, 13)\n    prime\
    \ := append(prime, 17)\n    prime := append(prime, 19)\n    if n < 0 {\n     \
    \   return nil\n    }\n    if n == 0 {\n        return prime\n    }\n    for i\
    \ := 3; i <= n; i++ {\n        if prime[n-1] == i {\n            prime = append(prime,\
    \ i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmppem7k7cj_test.go:25:11: no new variables on left side of :=

    /tmp/tmppem7k7cj_test.go:26:11: no new variables on left side of :=

    /tmp/tmppem7k7cj_test.go:27:11: no new variables on left side of :=

    /tmp/tmppem7k7cj_test.go:28:11: no new variables on left side of :=

    /tmp/tmppem7k7cj_test.go:29:11: no new variables on left side of :=

    /tmp/tmppem7k7cj_test.go:30:11: no new variables on left side of :=

    /tmp/tmppem7k7cj_test.go:31:11: no new variables on left side of :=

    /tmp/tmppem7k7cj_test.go:32:11: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075223
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0, n)\n    prime := append(prime, 2)\n    for i\
    \ := 3; i < n; i++ {\n        for j := 2; j < i; j++ {\n            if i%j ==\
    \ 0 {\n                break\n            }\n        }\n        if i == j {\n\
    \            prime = append(prime, i)\n        }\n    }\n    return prime\n}\n\
    \nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpn1r8i3ww_test.go:25:11: no new variables on left side of :=

    /tmp/tmpn1r8i3ww_test.go:32:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075223
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0, n)\n    prime := append(prime, 2)\n    prime\
    \ := append(prime, 3)\n    prime := append(prime, 5)\n    prime := append(prime,\
    \ 7)\n    prime := append(prime, 11)\n    prime := append(prime, 13)\n    prime\
    \ := append(prime, 17)\n    prime := append(prime, 19)\n    prime := append(prime,\
    \ 23)\n    prime := append(prime, 29)\n    prime := append(prime, 31)\n    prime\
    \ := append(prime, 37)\n    prime := append(prime, 43)\n    prime := append(prime,\
    \ 49)\n    prime := append(prime, 57)\n    prime := append(prime, 61)\n    prime\
    \ := append(prime, 67)\n    prime := append(prime, 73)\n    prime := append(prime,\
    \ 79)\n    prime := append(prime, 83)\n    prime := append(prime, 89)\n    prime\
    \ := append(prime, 97)\n    prime := append(prime, 101)\n    prime := append(prime,\
    \ 103)\n    prime := append(prime, 107)\n    prime := append(prime, 109)\n   \
    \ prime := append(prime, 113)\n    prime := append(prime, 127)\n    prime := append(prime,\
    \ 131)\n    prime := append(prime, 137)\n    prime := append(prime, 139)\n   \
    \ prime := append(prime, 149)\n    prime := append(prime, 151)\n    prime := append(prime,\
    \ 157)\n    prime := append(prime, 163)\n    prime := append(prime, 167)\n   \
    \ prime := append(prime, 173)\n    prime := append(prime, 179)\n    prime := append(prime,\
    \ 181)\n    prime := append(prime, 191)\n    prime := append(prime, 193)\n   \
    \ prime := append(prime, 197)\n    prime := append(prime, 199)\n    prime := append(prime,\
    \ 211)\n    prime := append(prime, 223)\n    prime := append(prime, 227)\n   \
    \ prime := append(prime, 229)\n    prime := append(prime, 233)\n    prime := append(prime,\
    \ 239)\n    prime := append(prime, 241)\n    prime := append(prime, 251)\n   \
    \ prime := append(prime, 257)\n    prime := append(prime, 263)\n    prime := append(prime,\
    \ 269)\n    prime := append(prime, 271)\n    prime := append(prime, 277)\n   \
    \ prime := append(prime, \nfunc TestCount_Up_To(t *testing.T) {\n  candidate :=\
    \ count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpo0fsmgp0_test.go:82:6: expected ''('', found TestCount_Up_To

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075223
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0)\n    prime := append(prime, 2)\n    for i :=\
    \ 3; i < n; i++ {\n        if isPrime(i) {\n            prime = append(prime,\
    \ i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkv5cd45t_test.go:25:11: no new variables on left side of :=

    /tmp/tmpkv5cd45t_test.go:27:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075222
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n        if\
    \ prime[prime[len(prime)-1]-1] != i {\n            prime = append(prime, i)\n\
    \        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n\
    \  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine\
    \ 19 [running]:\ntesting.tRunner.func1.2({0x513920, 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513920, 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmpuec6jttv_test.go:26\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmpuec6jttv_test.go:40\
    \ +0xddd\ntesting.tRunner(0xc0001036c0, 0x529240)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075222
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0)\n    for i := 2; i <= n; i++ {\n        for j\
    \ := 2; j < i; j++ {\n            if i % j == 0 {\n                break\n   \
    \         }\n        }\n        if i == j {\n            prime = append(prime,\
    \ i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1jghscu7_test.go:31:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075223
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0, n)\n    prime := append(prime, 2)\n    for i\
    \ := 3; i <= n; i++ {\n        for _, j := range prime {\n            if i%j ==\
    \ 0 {\n                break\n            }\n            if j > i {\n        \
    \        break\n            }\n            prime = append(prime, j)\n        }\n\
    \    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpp0vcgbih_test.go:25:11: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075224
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n        for\
    \ j := 2; j < i; j++ {\n            if i%j == 0 {\n                break\n   \
    \         }\n        }\n        if i == n {\n            prime = append(prime,\
    \ i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmpgsr31q6h_test.go:60: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__1 (0.00s)\n        tmpgsr31q6h_test.go:60:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__2\
    \ (0.00s)\n        tmpgsr31q6h_test.go:60: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__3 (0.00s)\n        tmpgsr31q6h_test.go:60:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]', got '[]'\n    ---\
    \ FAIL: TestCount_Up_To/test_num__5 (0.00s)\n        tmpgsr31q6h_test.go:60: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)\
    \ %!s(int=19)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n\
    \        tmpgsr31q6h_test.go:60: expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)\
    \ %!s(int=11) %!s(int=13) %!s(int=17)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__8\
    \ (0.00s)\n        tmpgsr31q6h_test.go:60: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29)\
    \ %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__9\
    \ (0.00s)\n        tmpgsr31q6h_test.go:60: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29)\
    \ %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43) %!s(int=47) %!s(int=53) %!s(int=59)\
    \ %!s(int=61) %!s(int=67) %!s(int=71) %!s(int=73) %!s(int=79) %!s(int=83) %!s(int=89)\
    \ %!s(int=97)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075219
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n        if\
    \ prime[prime[0]] == 0 {\n            prime = append(prime, i)\n        }\n  \
    \      for j := 0; j < i; j++ {\n            if prime[j] == 0 {\n            \
    \    prime = append(prime, j)\n            }\n        }\n    }\n    return prime\n\
    }\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513920,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513920, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmpprvszh3k_test.go:26\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmpprvszh3k_test.go:45\
    \ +0x1234\ntesting.tRunner(0xc0001a0340, 0x529240)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075219
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0)\n    prime := append(prime, 2)\n    for i :=\
    \ 3; i <= n; i++ {\n        for j := 2; j < i; j++ {\n            if i % j ==\
    \ 0 {\n                break\n            }\n        }\n        if j > i {\n \
    \           prime = append(prime, i)\n        }\n    }\n    return prime\n}\n\n\
    func TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmps7lxo5nq_test.go:25:11: no new variables on left side of :=

    /tmp/tmps7lxo5nq_test.go:32:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075224
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n        if\
    \ prime[prime[len(prime)-1]-1] != i {\n            prime = append(prime, i)\n\
    \        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n\
    \  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine\
    \ 19 [running]:\ntesting.tRunner.func1.2({0x513920, 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513920, 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmpuec6jttv_test.go:26\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmpuec6jttv_test.go:40\
    \ +0xddd\ntesting.tRunner(0xc0001036c0, 0x529240)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075222
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0)\n    for i := 2; i <= n; i++ {\n        for j\
    \ := 2; j < i; j++ {\n            if i%j == 0 {\n                break\n     \
    \       }\n        }\n        if j > i {\n            prime = append(prime, i)\n\
    \        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n\
    \  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprg_hpz0h_test.go:31:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075224
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime :=\
    \ append(prime, 3)\n    for i := 4; i <= n; i++ {\n        for j := 2; j < i;\
    \ j++ {\n            if i % j == 0 {\n                break\n            }\n \
    \       }\n        if j == i {\n            prime = append(prime, i)\n       \
    \ }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpcs4rn_5u_test.go:25:11: no new variables on left side of :=

    /tmp/tmpcs4rn_5u_test.go:26:11: no new variables on left side of :=

    /tmp/tmpcs4rn_5u_test.go:33:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075219
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime :=\
    \ append(prime, 3)\n    prime := append(prime, 5)\n    prime := append(prime,\
    \ 7)\n    prime := append(prime, 11)\n    prime := append(prime, 13)\n    prime\
    \ := append(prime, 17)\n    prime := append(prime, 19)\n    prime := append(prime,\
    \ 23)\n    prime := append(prime, 29)\n    prime := append(prime, 31)\n    prime\
    \ := append(prime, 37)\n    prime := append(prime, 43)\n    prime := append(prime,\
    \ 49)\n    prime := append(prime, 57)\n    prime := append(prime, 61)\n    prime\
    \ := append(prime, 67)\n    prime := append(prime, 73)\n    prime := append(prime,\
    \ 79)\n    prime := append(prime, 83)\n    prime := append(prime, 89)\n    prime\
    \ := append(prime, 97)\n    prime := append(prime, 101)\n    prime := append(prime,\
    \ 103)\n    prime := append(prime, 107)\n    prime := append(prime, 109)\n   \
    \ prime := append(prime, 113)\n    prime := append(prime, 127)\n    prime := append(prime,\
    \ 131)\n    prime := append(prime, 137)\n    prime := append(prime, 139)\n   \
    \ prime := append(prime, 149)\n    prime := append(prime, 151)\n    prime := append(prime,\
    \ 157)\n    prime := append(prime, 163)\n    prime := append(prime, 167)\n   \
    \ prime := append(prime, 173)\n    prime := append(prime, 179)\n    prime := append(prime,\
    \ 181)\n    prime := append(prime, 191)\n    prime := append(prime, 193)\n   \
    \ prime := append(prime, 197)\n    prime := append(prime, 199)\n    prime := append(prime,\
    \ 211)\n    prime := append(prime, 223)\n    prime := append(prime, 227)\n   \
    \ prime := append(prime, 229)\n    prime := append(prime, 233)\n    prime := append(prime,\
    \ 239)\n    prime := append(prime, 241)\n    prime := append(prime, 251)\n   \
    \ prime := append(prime, 257)\n    prime := append(prime, 263)\n    prime := append(prime,\
    \ 269)\n    prime := append(prime, 271)\n    prime := append(prime, 277)\n   \
    \ prime := append(prime, 28\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpa2cnz7tx_test.go:81:30: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075219
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n        if\
    \ prime[i / 2] {\n            continue\n        }\n        for j := i * i; j <\
    \ n; j += i {\n            if j > n {\n                break\n            }\n\
    \            prime = append(prime, j)\n        }\n    }\n    return prime\n}\n\
    \nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpd78jtxff_test.go:26:12: non-boolean condition in if statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075221
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0, n)\n    prime := append(prime, 2)\n    for i\
    \ := 3; i < n; i++ {\n        for j := 2; j < i; j++ {\n            if i%j ==\
    \ 0 {\n                break\n            }\n        }\n        if i == j {\n\
    \            prime = append(prime, i)\n        }\n    }\n    return prime\n}\n\
    \nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpn1r8i3ww_test.go:25:11: no new variables on left side of :=

    /tmp/tmpn1r8i3ww_test.go:32:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075223
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n        if\
    \ prime[prime[0]-1] == 0 {\n            prime = append(prime, i)\n        }\n\
    \        for j := 0; j < i; j++ {\n            if prime[j] == 0 {\n          \
    \      prime = append(prime, j)\n                break\n            }\n      \
    \  }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513920,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513920, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmppgbc1akp_test.go:26\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmppgbc1akp_test.go:46\
    \ +0x12b6\ntesting.tRunner(0xc0001a0340, 0x529240)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075219
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime :=\
    \ append(prime, 3)\n    for i := 4; i <= n; i++ {\n        for j := 2; j < i;\
    \ j++ {\n            if i % j == 0 {\n                break\n            }\n \
    \       }\n        if j > i {\n            prime = append(prime, i)\n        }\n\
    \    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpf_4cdq0t_test.go:25:11: no new variables on left side of :=

    /tmp/tmpf_4cdq0t_test.go:26:11: no new variables on left side of :=

    /tmp/tmpf_4cdq0t_test.go:33:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075219
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0, n)\n    for i := 2; i <= n; i++ {\n        for\
    \ j := 2; j < i; j++ {\n            if i%j == 0 {\n                break\n   \
    \         }\n        }\n        if i != j {\n            prime = append(prime,\
    \ i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmptqdu2ks__test.go:31:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075224
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime :=\
    \ append(prime, 3)\n    for i := 4; i <= n; i++ {\n        for j := 2; j < i;\
    \ j++ {\n            if i % j == 0 {\n                break\n            }\n \
    \       }\n        if j > i {\n            prime = append(prime, i)\n        }\n\
    \    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpf_4cdq0t_test.go:25:11: no new variables on left side of :=

    /tmp/tmpf_4cdq0t_test.go:26:11: no new variables on left side of :=

    /tmp/tmpf_4cdq0t_test.go:33:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075219
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime :=\
    \ append(prime, 3)\n    for i := 4; i <= n; i++ {\n        for j := 2; j < i;\
    \ j++ {\n            if i % j == 0 {\n                break\n            }\n \
    \       }\n        if j == i {\n            prime = append(prime, i)\n       \
    \ }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpcs4rn_5u_test.go:25:11: no new variables on left side of :=

    /tmp/tmpcs4rn_5u_test.go:26:11: no new variables on left side of :=

    /tmp/tmpcs4rn_5u_test.go:33:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075219
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    if n < 2 {\n        return []int{}\n    }\n    prime := make([]int, 0,\
    \ n)\n    prime := append(prime, 2)\n    for i := 3; i < n; i++ {\n        if\
    \ prime[prime[len(prime)-1]-1] == i {\n            prime = append(prime, i)\n\
    \        } else {\n            prime = append(prime, i+1)\n        }\n    }\n\
    \    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1b_srzsv_test.go:28:11: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075224
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime :=\
    \ append(prime, 3)\n    prime := append(prime, 5)\n    prime := append(prime,\
    \ 7)\n    prime := append(prime, 11)\n    prime := append(prime, 13)\n    prime\
    \ := append(prime, 17)\n    prime := append(prime, 19)\n    prime := append(prime,\
    \ 23)\n    prime := append(prime, 29)\n    prime := append(prime, 31)\n    prime\
    \ := append(prime, 37)\n    prime := append(prime, 43)\n    prime := append(prime,\
    \ 49)\n    prime := append(prime, 57)\n    prime := append(prime, 61)\n    prime\
    \ := append(prime, 67)\n    prime := append(prime, 73)\n    prime := append(prime,\
    \ 79)\n    prime := append(prime, 83)\n    prime := append(prime, 89)\n    prime\
    \ := append(prime, 97)\n    prime := append(prime, 101)\n    prime := append(prime,\
    \ 103)\n    prime := append(prime, 107)\n    prime := append(prime, 109)\n   \
    \ prime := append(prime, 113)\n    prime := append(prime, 127)\n    prime := append(prime,\
    \ 131)\n    prime := append(prime, 137)\n    prime := append(prime, 139)\n   \
    \ prime := append(prime, 149)\n    prime := append(prime, 151)\n    prime := append(prime,\
    \ 157)\n    prime := append(prime, 163)\n    prime := append(prime, 167)\n   \
    \ prime := append(prime, 173)\n    prime := append(prime, 179)\n    prime := append(prime,\
    \ 181)\n    prime := append(prime, 191)\n    prime := append(prime, 193)\n   \
    \ prime := append(prime, 197)\n    prime := append(prime, 199)\n    prime := append(prime,\
    \ 211)\n    prime := append(prime, 223)\n    prime := append(prime, 227)\n   \
    \ prime := append(prime, 229)\n    prime := append(prime, 233)\n    prime := append(prime,\
    \ 239)\n    prime := append(prime, 241)\n    prime := append(prime, 243)\n   \
    \ prime := append(prime, 247)\n    prime := append(prime, 251)\n    prime := append(prime,\
    \ 257)\n    prime := append(prime, 263)\n    prime := append(prime, 269)\n   \
    \ prime := append(prime, 27\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphqd44j9a_test.go:81:30: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075221
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n        for\
    \ j := 2; j < i; j++ {\n            if i%j == 0 {\n                break\n   \
    \         }\n        }\n        if i == j {\n            prime = append(prime,\
    \ i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpt19r5qk1_test.go:31:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075219
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n        if\
    \ prime[prime[len(prime)-1]-1] < i {\n            prime = append(prime, i)\n \
    \       }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n\
    \  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine\
    \ 6 [running]:\ntesting.tRunner.func1.2({0x513920, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513920, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmpzs5tloor_test.go:26\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmpzs5tloor_test.go:40\
    \ +0xddd\ntesting.tRunner(0xc0001924e0, 0x529240)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075224
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0, n)\n    prime := append(prime, 2)\n    prime\
    \ := append(prime, 3)\n    for i := 4; i < n; i++ {\n        for j := 2; j < i;\
    \ j++ {\n            if i%j == 0 {\n                break\n            }\n   \
    \     }\n        if i == j {\n            prime = append(prime, i)\n        }\n\
    \    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpo9y0f_os_test.go:25:11: no new variables on left side of :=

    /tmp/tmpo9y0f_os_test.go:26:11: no new variables on left side of :=

    /tmp/tmpo9y0f_os_test.go:33:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075224
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n        if\
    \ prime[prime[len(prime)-1]-1] != i {\n            prime = append(prime, i)\n\
    \        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n\
    \  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine\
    \ 19 [running]:\ntesting.tRunner.func1.2({0x513920, 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513920, 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmpuec6jttv_test.go:26\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmpuec6jttv_test.go:40\
    \ +0xddd\ntesting.tRunner(0xc0001036c0, 0x529240)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075222
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n        for\
    \ j := 2; j < i; j++ {\n            if i%j == 0 {\n                break\n   \
    \         }\n        }\n        if i == n {\n            prime = append(prime,\
    \ i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmpgsr31q6h_test.go:60: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__1 (0.00s)\n        tmpgsr31q6h_test.go:60:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__2\
    \ (0.00s)\n        tmpgsr31q6h_test.go:60: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__3 (0.00s)\n        tmpgsr31q6h_test.go:60:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]', got '[]'\n    ---\
    \ FAIL: TestCount_Up_To/test_num__5 (0.00s)\n        tmpgsr31q6h_test.go:60: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)\
    \ %!s(int=19)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n\
    \        tmpgsr31q6h_test.go:60: expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)\
    \ %!s(int=11) %!s(int=13) %!s(int=17)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__8\
    \ (0.00s)\n        tmpgsr31q6h_test.go:60: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29)\
    \ %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__9\
    \ (0.00s)\n        tmpgsr31q6h_test.go:60: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29)\
    \ %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43) %!s(int=47) %!s(int=53) %!s(int=59)\
    \ %!s(int=61) %!s(int=67) %!s(int=71) %!s(int=73) %!s(int=79) %!s(int=83) %!s(int=89)\
    \ %!s(int=97)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075219
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime :=\
    \ append(prime, 3)\n    for i := 4; i <= n; i++ {\n        for j := 2; j < i;\
    \ j++ {\n            if i % j == 0 {\n                break\n            }\n \
    \       }\n        if j > i {\n            prime = append(prime, i)\n        }\n\
    \    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpf_4cdq0t_test.go:25:11: no new variables on left side of :=

    /tmp/tmpf_4cdq0t_test.go:26:11: no new variables on left side of :=

    /tmp/tmpf_4cdq0t_test.go:33:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075219
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n        for\
    \ j := 2; j < i; j++ {\n            if i%j == 0 {\n                break\n   \
    \         }\n        }\n        if i == n {\n            prime = append(prime,\
    \ i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmpgsr31q6h_test.go:60: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__1 (0.00s)\n        tmpgsr31q6h_test.go:60:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__2\
    \ (0.00s)\n        tmpgsr31q6h_test.go:60: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__3 (0.00s)\n        tmpgsr31q6h_test.go:60:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]', got '[]'\n    ---\
    \ FAIL: TestCount_Up_To/test_num__5 (0.00s)\n        tmpgsr31q6h_test.go:60: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)\
    \ %!s(int=19)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n\
    \        tmpgsr31q6h_test.go:60: expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)\
    \ %!s(int=11) %!s(int=13) %!s(int=17)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__8\
    \ (0.00s)\n        tmpgsr31q6h_test.go:60: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29)\
    \ %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__9\
    \ (0.00s)\n        tmpgsr31q6h_test.go:60: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29)\
    \ %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43) %!s(int=47) %!s(int=53) %!s(int=59)\
    \ %!s(int=61) %!s(int=67) %!s(int=71) %!s(int=73) %!s(int=79) %!s(int=83) %!s(int=89)\
    \ %!s(int=97)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075219
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0, n)\n    for i := 0; i < n; i++ {\n        if\
    \ i%2 == 0 {\n            continue\n        }\n        prime := append(prime,\
    \ i)\n        for j := i + 1; j < n; j++ {\n            if j%2 == 0 {\n      \
    \          continue\n            }\n            if i%j == 0 {\n              \
    \  prime = append(prime, j)\n            }\n        }\n    }\n    return prime\n\
    }\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmphs0z92mo_test.go:64: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__1 (0.00s)\n        tmphs0z92mo_test.go:64:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__2\
    \ (0.00s)\n        tmphs0z92mo_test.go:64: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__3 (0.00s)\n        tmphs0z92mo_test.go:64:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]', got '[]'\n    ---\
    \ FAIL: TestCount_Up_To/test_num__5 (0.00s)\n        tmphs0z92mo_test.go:64: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)\
    \ %!s(int=19)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n\
    \        tmphs0z92mo_test.go:64: expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)\
    \ %!s(int=11) %!s(int=13) %!s(int=17)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__8\
    \ (0.00s)\n        tmphs0z92mo_test.go:64: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29)\
    \ %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__9\
    \ (0.00s)\n        tmphs0z92mo_test.go:64: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29)\
    \ %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43) %!s(int=47) %!s(int=53) %!s(int=59)\
    \ %!s(int=61) %!s(int=67) %!s(int=71) %!s(int=73) %!s(int=79) %!s(int=83) %!s(int=89)\
    \ %!s(int=97)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075225
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0, n)\n    for i := 0; i < n; i++ {\n        if\
    \ isprime(i) {\n            prime = append(prime, i)\n        }\n    }\n    return\
    \ prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpl1uf0kwv_test.go:26:12: undefined: isprime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075221
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n        for\
    \ j := 2; j < i; j++ {\n            if i%j == 0 {\n                break\n   \
    \         }\n        }\n        if i == j {\n            prime = append(prime,\
    \ i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpt19r5qk1_test.go:31:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075219
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n        if\
    \ prime[prime[0]-1] == 0 {\n            prime = append(prime, i)\n        }\n\
    \        for j := 0; j < i; j++ {\n            if prime[j] == 0 {\n          \
    \      prime = append(prime, j)\n            }\n        }\n    }\n    return prime\n\
    }\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513920,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513920, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmpaddpwe5v_test.go:26\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmpaddpwe5v_test.go:45\
    \ +0x1254\ntesting.tRunner(0xc0001924e0, 0x529240)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075221
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0, n)\n    prime := append(prime, 2)\n    for i\
    \ := 3; i < n; i++ {\n        for j := 2; j < i; j++ {\n            if i%j ==\
    \ 0 {\n                break\n            }\n        }\n        if i == j {\n\
    \            prime = append(prime, i)\n        }\n    }\n    return prime\n}\n\
    \nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpn1r8i3ww_test.go:25:11: no new variables on left side of :=

    /tmp/tmpn1r8i3ww_test.go:32:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075223
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n        for\
    \ j := 2; j < i; j++ {\n            if i%j == 0 {\n                break\n   \
    \         }\n        }\n        if i == j {\n            prime = append(prime,\
    \ i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpt19r5qk1_test.go:31:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075219
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime :=\
    \ append(prime, 3)\n    for i := 4; i <= n; i++ {\n        for j := 2; j < i;\
    \ j++ {\n            if i % j == 0 {\n                break\n            }\n \
    \       }\n        if j > i {\n            prime = append(prime, i)\n        }\n\
    \    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpf_4cdq0t_test.go:25:11: no new variables on left side of :=

    /tmp/tmpf_4cdq0t_test.go:26:11: no new variables on left side of :=

    /tmp/tmpf_4cdq0t_test.go:33:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075219
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime :=\
    \ append(prime, 3)\n    for i := 4; i <= n; i++ {\n        for j := 2; j < i;\
    \ j++ {\n            if i % j == 0 {\n                break\n            }\n \
    \       }\n        if j == i {\n            prime = append(prime, i)\n       \
    \ }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpcs4rn_5u_test.go:25:11: no new variables on left side of :=

    /tmp/tmpcs4rn_5u_test.go:26:11: no new variables on left side of :=

    /tmp/tmpcs4rn_5u_test.go:33:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075219
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime :=\
    \ append(prime, 3)\n    prime := append(prime, 5)\n    prime := append(prime,\
    \ 7)\n    prime := append(prime, 11)\n    prime := append(prime, 13)\n    prime\
    \ := append(prime, 17)\n    prime := append(prime, 19)\n    prime := append(prime,\
    \ 23)\n    prime := append(prime, 29)\n    prime := append(prime, 31)\n    prime\
    \ := append(prime, 37)\n    prime := append(prime, 43)\n    prime := append(prime,\
    \ 49)\n    prime := append(prime, 57)\n    prime := append(prime, 61)\n    prime\
    \ := append(prime, 67)\n    prime := append(prime, 73)\n    prime := append(prime,\
    \ 79)\n    prime := append(prime, 83)\n    prime := append(prime, 89)\n    prime\
    \ := append(prime, 97)\n    prime := append(prime, 101)\n    prime := append(prime,\
    \ 103)\n    prime := append(prime, 107)\n    prime := append(prime, 109)\n   \
    \ prime := append(prime, 113)\n    prime := append(prime, 127)\n    prime := append(prime,\
    \ 131)\n    prime := append(prime, 137)\n    prime := append(prime, 139)\n   \
    \ prime := append(prime, 149)\n    prime := append(prime, 151)\n    prime := append(prime,\
    \ 157)\n    prime := append(prime, 163)\n    prime := append(prime, 167)\n   \
    \ prime := append(prime, 173)\n    prime := append(prime, 179)\n    prime := append(prime,\
    \ 181)\n    prime := append(prime, 191)\n    prime := append(prime, 193)\n   \
    \ prime := append(prime, 197)\n    prime := append(prime, 199)\n    prime := append(prime,\
    \ 211)\n    prime := append(prime, 223)\n    prime := append(prime, 227)\n   \
    \ prime := append(prime, 229)\n    prime := append(prime, 233)\n    prime := append(prime,\
    \ 239)\n    prime := append(prime, 241)\n    prime := append(prime, 251)\n   \
    \ prime := append(prime, 257)\n    prime := append(prime, 263)\n    prime := append(prime,\
    \ 269)\n    prime := append(prime, 271)\n    prime := append(prime, 277)\n   \
    \ prime := append(prime, 28\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpa2cnz7tx_test.go:81:30: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075219
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0, n)\n    for i := 0; i < n; i++ {\n        prime\
    \ := append(prime, i)\n        for j := i + 1; j < n; j++ {\n            if isprime(j)\
    \ && j%i == 0 {\n                prime = append(prime, j)\n            }\n   \
    \     }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n\
    \  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpd9v_a4zv_test.go:28:16: undefined: isprime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075225
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n        for\
    \ j := 2; j < i; j++ {\n            if i%j == 0 {\n                break\n   \
    \         }\n        }\n        if i == n {\n            prime = append(prime,\
    \ i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmpgsr31q6h_test.go:60: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__1 (0.00s)\n        tmpgsr31q6h_test.go:60:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__2\
    \ (0.00s)\n        tmpgsr31q6h_test.go:60: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__3 (0.00s)\n        tmpgsr31q6h_test.go:60:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]', got '[]'\n    ---\
    \ FAIL: TestCount_Up_To/test_num__5 (0.00s)\n        tmpgsr31q6h_test.go:60: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)\
    \ %!s(int=19)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n\
    \        tmpgsr31q6h_test.go:60: expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)\
    \ %!s(int=11) %!s(int=13) %!s(int=17)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__8\
    \ (0.00s)\n        tmpgsr31q6h_test.go:60: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29)\
    \ %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__9\
    \ (0.00s)\n        tmpgsr31q6h_test.go:60: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29)\
    \ %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43) %!s(int=47) %!s(int=53) %!s(int=59)\
    \ %!s(int=61) %!s(int=67) %!s(int=71) %!s(int=73) %!s(int=79) %!s(int=83) %!s(int=89)\
    \ %!s(int=97)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075219
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime :=\
    \ append(prime, 3)\n    for i := 4; i <= n; i++ {\n        for j := 2; j < i;\
    \ j++ {\n            if i % j == 0 {\n                break\n            }\n \
    \       }\n        if j > i {\n            prime = append(prime, i)\n        }\n\
    \    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpf_4cdq0t_test.go:25:11: no new variables on left side of :=

    /tmp/tmpf_4cdq0t_test.go:26:11: no new variables on left side of :=

    /tmp/tmpf_4cdq0t_test.go:33:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075219
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime :=\
    \ append(prime, 3)\n    prime := append(prime, 5)\n    prime := append(prime,\
    \ 7)\n    prime := append(prime, 11)\n    prime := append(prime, 13)\n    prime\
    \ := append(prime, 17)\n    prime := append(prime, 19)\n    prime := append(prime,\
    \ 23)\n    prime := append(prime, 29)\n    prime := append(prime, 31)\n    prime\
    \ := append(prime, 37)\n    prime := append(prime, 43)\n    prime := append(prime,\
    \ 49)\n    prime := append(prime, 57)\n    prime := append(prime, 61)\n    prime\
    \ := append(prime, 67)\n    prime := append(prime, 73)\n    prime := append(prime,\
    \ 79)\n    prime := append(prime, 83)\n    prime := append(prime, 89)\n    prime\
    \ := append(prime, 97)\n    prime := append(prime, 101)\n    prime := append(prime,\
    \ 103)\n    prime := append(prime, 107)\n    prime := append(prime, 109)\n   \
    \ prime := append(prime, 113)\n    prime := append(prime, 127)\n    prime := append(prime,\
    \ 131)\n    prime := append(prime, 137)\n    prime := append(prime, 139)\n   \
    \ prime := append(prime, 149)\n    prime := append(prime, 151)\n    prime := append(prime,\
    \ 157)\n    prime := append(prime, 163)\n    prime := append(prime, 167)\n   \
    \ prime := append(prime, 173)\n    prime := append(prime, 179)\n    prime := append(prime,\
    \ 181)\n    prime := append(prime, 191)\n    prime := append(prime, 193)\n   \
    \ prime := append(prime, 197)\n    prime := append(prime, 199)\n    prime := append(prime,\
    \ 211)\n    prime := append(prime, 223)\n    prime := append(prime, 227)\n   \
    \ prime := append(prime, 229)\n    prime := append(prime, 233)\n    prime := append(prime,\
    \ 239)\n    prime := append(prime, 241)\n    prime := append(prime, 251)\n   \
    \ prime := append(prime, 257)\n    prime := append(prime, 263)\n    prime := append(prime,\
    \ 269)\n    prime := append(prime, 271)\n    prime := append(prime, 277)\n   \
    \ prime := append(prime, 28\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpa2cnz7tx_test.go:81:30: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075219
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime :=\
    \ append(prime, 3)\n    prime := append(prime, 5)\n    prime := append(prime,\
    \ 7)\n    prime := append(prime, 11)\n    prime := append(prime, 13)\n    prime\
    \ := append(prime, 17)\n    prime := append(prime, 19)\n\n    for i := 6; i <\
    \ n; i++ {\n        if prime[n - i] == true {\n            prime[n - i] = false\n\
    \            prime = append(prime, n - i)\n        }\n    }\n    return prime\n\
    }\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1tfc4afa_test.go:25:11: no new variables on left side of :=

    /tmp/tmp1tfc4afa_test.go:26:11: no new variables on left side of :=

    /tmp/tmp1tfc4afa_test.go:27:11: no new variables on left side of :=

    /tmp/tmp1tfc4afa_test.go:28:11: no new variables on left side of :=

    /tmp/tmp1tfc4afa_test.go:29:11: no new variables on left side of :=

    /tmp/tmp1tfc4afa_test.go:30:11: no new variables on left side of :=

    /tmp/tmp1tfc4afa_test.go:31:11: no new variables on left side of :=

    /tmp/tmp1tfc4afa_test.go:32:11: no new variables on left side of :=

    /tmp/tmp1tfc4afa_test.go:35:28: invalid operation: prime[n - i] == true (mismatched
    types int and untyped bool)

    /tmp/tmp1tfc4afa_test.go:36:28: cannot use false (untyped bool constant) as int
    value in assignment

    /tmp/tmp1tfc4afa_test.go:36:28: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075224
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime :=\
    \ append(prime, 3)\n    for i := 4; i < n; i++ {\n        for j := 2; j < i; j++\
    \ {\n            if i%j == 0 {\n                break\n            }\n       \
    \ }\n        if j > i {\n            prime = append(prime, i)\n        }\n   \
    \ }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpnmr8g85q_test.go:25:11: no new variables on left side of :=

    /tmp/tmpnmr8g85q_test.go:26:11: no new variables on left side of :=

    /tmp/tmpnmr8g85q_test.go:33:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075225
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n        if\
    \ prime[prime[0]-1] == 0 {\n            prime = append(prime, i)\n        }\n\
    \        for j := 0; j < i; j++ {\n            if prime[j] == 0 {\n          \
    \      prime = append(prime, j)\n            }\n        }\n    }\n    return prime\n\
    }\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513920,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513920, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmpaddpwe5v_test.go:26\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmpaddpwe5v_test.go:45\
    \ +0x1254\ntesting.tRunner(0xc0001924e0, 0x529240)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075221
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime :=\
    \ append(prime, 3)\n    for i := 4; i <= n; i++ {\n        for j := 2; j < i;\
    \ j++ {\n            if i % j == 0 {\n                break\n            }\n \
    \       }\n        if j == i {\n            prime = append(prime, i)\n       \
    \ }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpcs4rn_5u_test.go:25:11: no new variables on left side of :=

    /tmp/tmpcs4rn_5u_test.go:26:11: no new variables on left side of :=

    /tmp/tmpcs4rn_5u_test.go:33:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075219
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0)\n    prime := append(prime, 2)\n    for i :=\
    \ 3; i < n; i++ {\n        for j := 2; j < i; j++ {\n            if i%j == 0 {\n\
    \                break\n            }\n        }\n        if i == j {\n      \
    \      prime = append(prime, i)\n        }\n    }\n    return prime\n}\n\nfunc\
    \ TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2,\
    \ 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n   \
    \  { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp18h8lo5x_test.go:25:11: no new variables on left side of :=

    /tmp/tmp18h8lo5x_test.go:32:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075219
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0, n)\n    prime := append(prime, 2)\n    for i\
    \ := 3; i < n; i++ {\n        for j := 2; j < i; j++ {\n            if i%j ==\
    \ 0 {\n                break\n            }\n        }\n        if i == j {\n\
    \            prime = append(prime, i)\n        }\n    }\n    return prime\n}\n\
    \nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpn1r8i3ww_test.go:25:11: no new variables on left side of :=

    /tmp/tmpn1r8i3ww_test.go:32:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075223
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime :=\
    \ append(prime, 3)\n    for i := 4; i <= n; i++ {\n        for j := 2; j < i;\
    \ j++ {\n            if i % j == 0 {\n                break\n            }\n \
    \       }\n        if j > i {\n            prime = append(prime, i)\n        }\n\
    \    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpf_4cdq0t_test.go:25:11: no new variables on left side of :=

    /tmp/tmpf_4cdq0t_test.go:26:11: no new variables on left side of :=

    /tmp/tmpf_4cdq0t_test.go:33:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075219
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    if n < 2 {\n        return []int{}\n    }\n    result := make([]int,\
    \ 0, n)\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n      \
    \  if prime[i] {\n            continue\n        }\n        prime = append(prime,\
    \ i)\n        for j := i + i; j < n; j += i {\n            if j%i == 0 {\n   \
    \             prime = append(prime, j)\n            }\n        }\n    }\n    for\
    \ _, v := range prime {\n        result = append(result, v)\n    }\n    return\
    \ result\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxgis1nqb_test.go:30:12: non-boolean condition in if statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075225
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n        if\
    \ prime[i - 2] == 0 {\n            prime[i - 2] = 1\n            for j := i -\
    \ 3; j > 0; j-- {\n                if prime[j] == 0 {\n                    prime[j]\
    \ = 1\n                    break\n                }\n            }\n        }\n\
    \    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmpukicv_fg_test.go:26\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmpukicv_fg_test.go:46\
    \ +0x31\ntesting.tRunner(0xc0001a0340, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075225
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0, n)\n    for i := 2; i <= n; i++ {\n        if\
    \ isPrime(i) {\n            prime = append(prime, i)\n        }\n    }\n    return\
    \ prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0gb6o504_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075219
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime :=\
    \ append(prime, 3)\n    for i := 4; i <= n; i++ {\n        for j := 2; j < i;\
    \ j++ {\n            if i % j == 0 {\n                break\n            }\n \
    \       }\n        if j > i {\n            prime = append(prime, i)\n        }\n\
    \    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpf_4cdq0t_test.go:25:11: no new variables on left side of :=

    /tmp/tmpf_4cdq0t_test.go:26:11: no new variables on left side of :=

    /tmp/tmpf_4cdq0t_test.go:33:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075219
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    if n < 2 {\n        return []int{}\n    }\n    prime := make([]int, 0,\
    \ n)\n    for i := 2; i < n; i++ {\n        if prime[prime[0]] == 0 {\n      \
    \      prime = append(prime, i)\n        }\n        for j := 0; j < i; j++ {\n\
    \            if prime[j] == 0 {\n                prime = append(prime, j)\n  \
    \          }\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513920,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513920, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmp2f04mevq_test.go:29\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmp2f04mevq_test.go:48\
    \ +0x11f4\ntesting.tRunner(0xc0001a0340, 0x529240)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075225
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime :=\
    \ append(prime, 3)\n    for i := 4; i <= n; i++ {\n        for j := 2; j < i;\
    \ j++ {\n            if i % j == 0 {\n                break\n            }\n \
    \       }\n        if j > i {\n            prime = append(prime, i)\n        }\n\
    \    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpf_4cdq0t_test.go:25:11: no new variables on left side of :=

    /tmp/tmpf_4cdq0t_test.go:26:11: no new variables on left side of :=

    /tmp/tmpf_4cdq0t_test.go:33:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075219
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    primes := make([]int, n+1)\n    primes[0] = 2\n    primes[1] = 3\n  \
    \  for i := 2; i <= n; i++ {\n        for j := 2; j < i; j++ {\n            if\
    \ i % j == 0 {\n                break\n            }\n        }\n        if j\
    \ > i {\n            primes[i+1] = i\n        }\n    }\n    return primes[:n]\n\
    }\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpy8fg4cm1_test.go:33:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075225
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0, n)\n    for i := 0; i < n; i++ {\n        if\
    \ isprime(i) {\n            prime = append(prime, i)\n        }\n    }\n    return\
    \ prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpl1uf0kwv_test.go:26:12: undefined: isprime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075221
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0, n)\n    prime := append(prime, 2)\n    prime\
    \ := append(prime, 3)\n    prime := append(prime, 5)\n    prime := append(prime,\
    \ 7)\n    prime := append(prime, 11)\n    prime := append(prime, 13)\n    prime\
    \ := append(prime, 17)\n    prime := append(prime, 19)\n    prime := append(prime,\
    \ 23)\n    prime := append(prime, 29)\n    prime := append(prime, 31)\n    prime\
    \ := append(prime, 37)\n    prime := append(prime, 43)\n    prime := append(prime,\
    \ 49)\n    prime := append(prime, 57)\n    prime := append(prime, 61)\n    prime\
    \ := append(prime, 67)\n    prime := append(prime, 73)\n    prime := append(prime,\
    \ 79)\n    prime := append(prime, 83)\n    prime := append(prime, 89)\n    prime\
    \ := append(prime, 97)\n    prime := append(prime, 101)\n    prime := append(prime,\
    \ 103)\n    prime := append(prime, 107)\n    prime := append(prime, 109)\n   \
    \ prime := append(prime, 113)\n    prime := append(prime, 127)\n    prime := append(prime,\
    \ 131)\n    prime := append(prime, 137)\n    prime := append(prime, 139)\n   \
    \ prime := append(prime, 149)\n    prime := append(prime, 151)\n    prime := append(prime,\
    \ 157)\n    prime := append(prime, 163)\n    prime := append(prime, 167)\n   \
    \ prime := append(prime, 173)\n    prime := append(prime, 179)\n    prime := append(prime,\
    \ 181)\n    prime := append(prime, 191)\n    prime := append(prime, 193)\n   \
    \ prime := append(prime, 197)\n    prime := append(prime, 199)\n    prime := append(prime,\
    \ 211)\n    prime := append(prime, 223)\n    prime := append(prime, 227)\n   \
    \ prime := append(prime, 229)\n    prime := append(prime, 233)\n    prime := append(prime,\
    \ 239)\n    prime := append(prime, 241)\n    prime := append(prime, 243)\n   \
    \ prime := append(prime, 247)\n    prime := append(prime, 251)\n    prime := append(prime,\
    \ 257)\n    prime := append(prime, 263)\n    prime := append(prime, 269)\n   \
    \ prime := append(prime, \nfunc TestCount_Up_To(t *testing.T) {\n  candidate :=\
    \ count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpbtkaogbp_test.go:82:6: expected ''('', found TestCount_Up_To

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075218
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n        for\
    \ j := 2; j < i; j++ {\n            if i%j == 0 {\n                break\n   \
    \         }\n        }\n        if i == n {\n            prime = append(prime,\
    \ i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmpgsr31q6h_test.go:60: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__1 (0.00s)\n        tmpgsr31q6h_test.go:60:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__2\
    \ (0.00s)\n        tmpgsr31q6h_test.go:60: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__3 (0.00s)\n        tmpgsr31q6h_test.go:60:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]', got '[]'\n    ---\
    \ FAIL: TestCount_Up_To/test_num__5 (0.00s)\n        tmpgsr31q6h_test.go:60: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)\
    \ %!s(int=19)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n\
    \        tmpgsr31q6h_test.go:60: expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)\
    \ %!s(int=11) %!s(int=13) %!s(int=17)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__8\
    \ (0.00s)\n        tmpgsr31q6h_test.go:60: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29)\
    \ %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__9\
    \ (0.00s)\n        tmpgsr31q6h_test.go:60: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29)\
    \ %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43) %!s(int=47) %!s(int=53) %!s(int=59)\
    \ %!s(int=61) %!s(int=67) %!s(int=71) %!s(int=73) %!s(int=79) %!s(int=83) %!s(int=89)\
    \ %!s(int=97)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075219
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime :=\
    \ append(prime, 3)\n    for i := 4; i <= n; i++ {\n        for j := 2; j < i;\
    \ j++ {\n            if i % j == 0 {\n                break\n            }\n \
    \       }\n        if j == i {\n            prime = append(prime, i)\n       \
    \ }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpcs4rn_5u_test.go:25:11: no new variables on left side of :=

    /tmp/tmpcs4rn_5u_test.go:26:11: no new variables on left side of :=

    /tmp/tmpcs4rn_5u_test.go:33:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075219
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    primes := make([]int, n+1)\n    primes[0] = 1\n    primes[1] = 1\n  \
    \  for i := 2; i <= n; i++ {\n        if primes[i] != 0 {\n            for j :=\
    \ 2; i*j <= n; j++ {\n                if i*j > n {\n                    break\n\
    \                }\n                if primes[i*j] == 0 {\n                  \
    \  primes[i*j] = i\n                }\n            }\n        }\n    }\n    return\
    \ primes[:n]\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [1] with length 1 [recovered]\n\tpanic: runtime error: index out of range [1]\
    \ with length 1\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmptq_iy9n0_test.go:26\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmptq_iy9n0_test.go:53\
    \ +0x192\ntesting.tRunner(0xc0001a01a0, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075226
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0)\n    prime := append(prime, 2)\n    for i :=\
    \ 3; i <= n; i++ {\n        for _, j := range prime {\n            if i%j == 0\
    \ {\n                break\n            }\n            if j == i {\n         \
    \       prime = append(prime, i)\n                break\n            }\n     \
    \   }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp81ul7586_test.go:25:11: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075225
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime :=\
    \ append(prime, 3)\n    for i := 4; i <= n; i++ {\n        for j := 2; j < i;\
    \ j++ {\n            if i%j == 0 {\n                break\n            }\n   \
    \     }\n        if i == j {\n            prime = append(prime, i)\n        }\n\
    \    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6kz16l2x_test.go:25:11: no new variables on left side of :=

    /tmp/tmp6kz16l2x_test.go:26:11: no new variables on left side of :=

    /tmp/tmp6kz16l2x_test.go:33:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075219
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime :=\
    \ append(prime, 3)\n    for i := 4; i <= n; i++ {\n        for j := 2; j < i;\
    \ j++ {\n            if i % j == 0 {\n                break\n            }\n \
    \       }\n        if j == i {\n            prime = append(prime, i)\n       \
    \ }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpcs4rn_5u_test.go:25:11: no new variables on left side of :=

    /tmp/tmpcs4rn_5u_test.go:26:11: no new variables on left side of :=

    /tmp/tmpcs4rn_5u_test.go:33:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075219
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n        if\
    \ prime[i / 2] {\n            continue\n        }\n        for j := i * i; j <\
    \ n; j += i {\n            prime[j] = true\n        }\n    }\n    return prime\n\
    }\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdzu0fb5__test.go:26:12: non-boolean condition in if statement

    /tmp/tmpdzu0fb5__test.go:30:24: cannot use true (untyped bool constant) as int
    value in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075221
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0, n)\n    for i := 2; i <= n; i++ {\n        if\
    \ isPrime(i) {\n            prime = append(prime, i)\n        }\n    }\n    return\
    \ prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0gb6o504_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075219
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0, n)\n    prime := append(prime, 2)\n    for i\
    \ := 3; i <= n; i++ {\n        for j := 2; j < i; j++ {\n            if i % j\
    \ == 0 {\n                break\n            }\n        }\n        if j > i {\n\
    \            prime = append(prime, i)\n        }\n    }\n    return prime\n}\n\
    \nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbgtmvn4m_test.go:25:11: no new variables on left side of :=

    /tmp/tmpbgtmvn4m_test.go:32:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075225
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime :=\
    \ append(prime, 3)\n    prime := append(prime, 5)\n    prime := append(prime,\
    \ 7)\n    prime := append(prime, 11)\n    prime := append(prime, 13)\n    prime\
    \ := append(prime, 17)\n    prime := append(prime, 19)\n    if n < 0 {\n     \
    \   return nil\n    }\n    if n == 0 {\n        return prime\n    }\n    if n\
    \ == 1 {\n        return nil\n    }\n    if n == 2 {\n        return prime\n \
    \   }\n    if n == 3 {\n        return append(prime, 5)\n    }\n    if n == 4\
    \ {\n        return append(prime, 7)\n    }\n    if n == 5 {\n        return append(prime,\
    \ 11)\n    }\n    if n == 6 {\n        return append(prime, 13)\n    }\n    if\
    \ n == 7 {\n        return append(prime, 17)\n    }\n    if n == 8 {\n       \
    \ return append(prime, 19)\n    }\n    if n == 9 {\n        return append(prime,\
    \ 23)\n    }\n    if n == 10 {\n        return append(prime, 29)\n    }\n    if\
    \ n == 11 {\n        return append(prime, 31)\n    }\n    if n == 12 {\n     \
    \   return append(prime, 37)\n    }\n    if n == 13 {\n        return append(prime,\
    \ 41)\n    }\n    if n == 14 {\n        return append(prime, 43)\n    }\n    if\
    \ n == 15 {\n        return append(prime, 47)\n    }\n    if n == 16 {\n     \
    \   return append(prime, 53)\n    }\n    if n == 17 {\n        return append(prime,\
    \ 59)\n    }\n    if n == 18 {\n        return append(prime, 61)\n    }\n    if\
    \ n == 19 {\n        return append(prime, 67)\n    }\n    if n == 20 {\n     \
    \   return append(prime, 71)\n    }\n    if n == 21 {\n        return append(prime,\
    \ 73)\n    }\n    if n == 22 {\n        return append(prime, 79)\n    }\n    if\
    \ n == 23 {\n        return append(prime, 83)\n    }\n    if n == 24 {\n     \
    \   return append(prime, 89)\n    }\n    if n == 25 {\n        return append(prime,\
    \ 97)\n    }\n    if n == 26 {\n        return append(prime, 101)\n    }\n   \
    \ if n == 27 {\n        return append(prime, 103)\n    }\n    if n == 28 {\n \
    \       return append(prime, 107)\n    }\n    if n == 29 {\n        return append(prime,\
    \ 113)\n    }\n    if n == 30 {\n        return append(prime, 127)\n    }\n  \
    \  if n == 31 {\n        return append(prime, 131)\n    }\n    if n == 32 {\n\
    func TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp2go24j98_test.go:133:6: expected ''('', found TestCount_Up_To

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075225
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime :=\
    \ append(prime, 3)\n    prime := append(prime, 5)\n    prime := append(prime,\
    \ 7)\n    prime := append(prime, 11)\n    prime := append(prime, 13)\n    prime\
    \ := append(prime, 17)\n    prime := append(prime, 19)\n    prime := append(prime,\
    \ 23)\n    prime := append(prime, 29)\n    prime := append(prime, 31)\n    prime\
    \ := append(prime, 37)\n    prime := append(prime, 43)\n    prime := append(prime,\
    \ 49)\n    prime := append(prime, 57)\n    prime := append(prime, 61)\n    prime\
    \ := append(prime, 67)\n    prime := append(prime, 73)\n    prime := append(prime,\
    \ 79)\n    prime := append(prime, 83)\n    prime := append(prime, 89)\n    prime\
    \ := append(prime, 97)\n    prime := append(prime, 101)\n    prime := append(prime,\
    \ 103)\n    prime := append(prime, 107)\n    prime := append(prime, 109)\n   \
    \ prime := append(prime, 113)\n    prime := append(prime, 127)\n    prime := append(prime,\
    \ 131)\n    prime := append(prime, 137)\n    prime := append(prime, 139)\n   \
    \ prime := append(prime, 149)\n    prime := append(prime, 151)\n    prime := append(prime,\
    \ 157)\n    prime := append(prime, 163)\n    prime := append(prime, 167)\n   \
    \ prime := append(prime, 173)\n    prime := append(prime, 179)\n    prime := append(prime,\
    \ 181)\n    prime := append(prime, 191)\n    prime := append(prime, 193)\n   \
    \ prime := append(prime, 197)\n    prime := append(prime, 199)\n    prime := append(prime,\
    \ 211)\n    prime := append(prime, 223)\n    prime := append(prime, 227)\n   \
    \ prime := append(prime, 229)\n    prime := append(prime, 233)\n    prime := append(prime,\
    \ 239)\n    prime := append(prime, 241)\n    prime := append(prime, 243)\n   \
    \ prime := append(prime, 247)\n    prime := append(prime, 251)\n    prime := append(prime,\
    \ 257)\n    prime := append(prime, 263)\n    prime := append(prime, 269)\n   \
    \ prime := append(prime, 27\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphqd44j9a_test.go:81:30: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075221
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n        if\
    \ isPrime(i) {\n            prime = append(prime, i)\n        }\n    }\n    return\
    \ prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpq4icf6yd_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075225
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime :=\
    \ append(prime, 3)\n    for i := 4; i <= n; i++ {\n        for j := 2; j < i;\
    \ j++ {\n            if i%j == 0 {\n                break\n            }\n   \
    \     }\n        if i == j {\n            prime = append(prime, i)\n        }\n\
    \    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6kz16l2x_test.go:25:11: no new variables on left side of :=

    /tmp/tmp6kz16l2x_test.go:26:11: no new variables on left side of :=

    /tmp/tmp6kz16l2x_test.go:33:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075219
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0)\n    for i := 2; i < n; i++ {\n        for j\
    \ := 2; j < i; j++ {\n            if i%j == 0 {\n                break\n     \
    \       }\n        }\n        if i == n {\n            prime = append(prime, i)\n\
    \        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n\
    \  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmp7wdzr5y4_test.go:60: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__1 (0.00s)\n        tmp7wdzr5y4_test.go:60:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__2\
    \ (0.00s)\n        tmp7wdzr5y4_test.go:60: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__3 (0.00s)\n        tmp7wdzr5y4_test.go:60:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]', got '[]'\n    ---\
    \ FAIL: TestCount_Up_To/test_num__5 (0.00s)\n        tmp7wdzr5y4_test.go:60: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)\
    \ %!s(int=19)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n\
    \        tmp7wdzr5y4_test.go:60: expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)\
    \ %!s(int=11) %!s(int=13) %!s(int=17)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__8\
    \ (0.00s)\n        tmp7wdzr5y4_test.go:60: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29)\
    \ %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__9\
    \ (0.00s)\n        tmp7wdzr5y4_test.go:60: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29)\
    \ %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43) %!s(int=47) %!s(int=53) %!s(int=59)\
    \ %!s(int=61) %!s(int=67) %!s(int=71) %!s(int=73) %!s(int=79) %!s(int=83) %!s(int=89)\
    \ %!s(int=97)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660075226
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0)\n    prime := append(prime, 2)\n    for i :=\
    \ 3; i < n; i++ {\n        for j := 2; j < i; j++ {\n            if i%j == 0 {\n\
    \                break\n            }\n        }\n        if i == j {\n      \
    \      prime = append(prime, i)\n        }\n    }\n    return prime\n}\n\nfunc\
    \ TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2,\
    \ 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n   \
    \  { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp18h8lo5x_test.go:25:11: no new variables on left side of :=

    /tmp/tmp18h8lo5x_test.go:32:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075219
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n        if\
    \ prime[prime[0]-1] == 0 {\n            prime = append(prime, i)\n        }\n\
    \        for j := 1; j < i; j++ {\n            if prime[j-1] == 0 {\n        \
    \        prime = append(prime, j)\n            }\n        }\n    }\n    return\
    \ prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513920,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513920, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmpsa_tsnm2_test.go:26\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmpsa_tsnm2_test.go:45\
    \ +0x1274\ntesting.tRunner(0xc0001a0340, 0x529240)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075226
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n        for\
    \ j := 2; j < i; j++ {\n            if i%j == 0 {\n                break\n   \
    \         }\n        }\n        if i == j {\n            prime = append(prime,\
    \ i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpt19r5qk1_test.go:31:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075219
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0)\n    prime := append(prime, 2)\n    for i :=\
    \ 3; i <= n; i++ {\n        for j := 2; j < i; j++ {\n            if i%j == 0\
    \ {\n                break\n            }\n        }\n        if i == j {\n  \
    \          prime = append(prime, i)\n        }\n    }\n    return prime\n}\n\n\
    func TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp72he_1si_test.go:25:11: no new variables on left side of :=

    /tmp/tmp72he_1si_test.go:32:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075226
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0)\n    prime := append(prime, 2)\n    for i :=\
    \ 3; i <= n; i++ {\n        for j := 2; j < i; j++ {\n            if i % j ==\
    \ 0 {\n                break\n            }\n        }\n        if j == i {\n\
    \            prime = append(prime, i)\n        }\n    }\n    return prime\n}\n\
    \nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7qs02ade_test.go:25:11: no new variables on left side of :=

    /tmp/tmp7qs02ade_test.go:32:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075226
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n        if\
    \ prime[i / 2] {\n            continue\n        }\n        for j := i * i; j <\
    \ n; j += i {\n            if !prime[j] {\n                prime = append(prime,\
    \ j)\n            }\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3wfz5175_test.go:26:12: non-boolean condition in if statement

    /tmp/tmp3wfz5175_test.go:30:17: invalid operation: operator ! not defined on prime[j]
    (variable of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075226
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime :=\
    \ append(prime, 3)\n    for i := 4; i <= n; i++ {\n        for j := 2; j < i;\
    \ j++ {\n            if i%j == 0 {\n                break\n            }\n   \
    \     }\n        if i != j {\n            prime = append(prime, i)\n        }\n\
    \    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdphwl6co_test.go:25:11: no new variables on left side of :=

    /tmp/tmpdphwl6co_test.go:26:11: no new variables on left side of :=

    /tmp/tmpdphwl6co_test.go:33:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075226
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime :=\
    \ append(prime, 3)\n    prime := append(prime, 5)\n    prime := append(prime,\
    \ 7)\n    prime := append(prime, 11)\n    prime := append(prime, 13)\n    prime\
    \ := append(prime, 17)\n    prime := append(prime, 19)\n    prime := append(prime,\
    \ 23)\n    prime := append(prime, 29)\n    prime := append(prime, 31)\n    prime\
    \ := append(prime, 37)\n    prime := append(prime, 43)\n    prime := append(prime,\
    \ 49)\n    prime := append(prime, 57)\n    prime := append(prime, 61)\n    prime\
    \ := append(prime, 67)\n    prime := append(prime, 73)\n    prime := append(prime,\
    \ 79)\n    prime := append(prime, 83)\n    prime := append(prime, 89)\n    prime\
    \ := append(prime, 97)\n    prime := append(prime, 101)\n    prime := append(prime,\
    \ 103)\n    prime := append(prime, 107)\n    prime := append(prime, 109)\n   \
    \ prime := append(prime, 113)\n    prime := append(prime, 127)\n    prime := append(prime,\
    \ 131)\n    prime := append(prime, 137)\n    prime := append(prime, 139)\n   \
    \ prime := append(prime, 149)\n    prime := append(prime, 151)\n    prime := append(prime,\
    \ 157)\n    prime := append(prime, 163)\n    prime := append(prime, 167)\n   \
    \ prime := append(prime, 173)\n    prime := append(prime, 179)\n    prime := append(prime,\
    \ 181)\n    prime := append(prime, 191)\n    prime := append(prime, 193)\n   \
    \ prime := append(prime, 197)\n    prime := append(prime, 199)\n    prime := append(prime,\
    \ 211)\n    prime := append(prime, 223)\n    prime := append(prime, 227)\n   \
    \ prime := append(prime, 229)\n    prime := append(prime, 233)\n    prime := append(prime,\
    \ 239)\n    prime := append(prime, 241)\n    prime := append(prime, 251)\n   \
    \ prime := append(prime, 257)\n    prime := append(prime, 263)\n    prime := append(prime,\
    \ 269)\n    prime := append(prime, 271)\n    prime := append(prime, 277)\n   \
    \ prime := append(prime, 28\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpa2cnz7tx_test.go:81:30: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075219
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n        if\
    \ prime[prime[len(prime)-1]-1] < i {\n            prime = append(prime, i)\n \
    \       }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n\
    \  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine\
    \ 6 [running]:\ntesting.tRunner.func1.2({0x513920, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513920, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmpzs5tloor_test.go:26\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmpzs5tloor_test.go:40\
    \ +0xddd\ntesting.tRunner(0xc0001924e0, 0x529240)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075224
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime :=\
    \ append(prime, 3)\n    for i := 4; i < n; i++ {\n        for _, j := range prime\
    \ {\n            if i%j == 0 {\n                break\n            }\n       \
    \ }\n        if i == n {\n            prime = append(prime, i)\n        }\n  \
    \  }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpiiyhsvnq_test.go:25:11: no new variables on left side of :=

    /tmp/tmpiiyhsvnq_test.go:26:11: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075219
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0, n)\n    prime := append(prime, 2)\n    for i\
    \ := 3; i < n; i++ {\n        for _, j := range prime {\n            if j%i ==\
    \ 0 {\n                break\n            }\n            if i == j {\n       \
    \         prime = append(prime, i)\n                break\n            }\n   \
    \     }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n\
    \  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpz60_zlfr_test.go:25:11: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075226
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime :=\
    \ append(prime, 3)\n    prime := append(prime, 5)\n    prime := append(prime,\
    \ 7)\n    prime := append(prime, 11)\n    prime := append(prime, 13)\n    prime\
    \ := append(prime, 17)\n    prime := append(prime, 19)\n    prime := append(prime,\
    \ 23)\n    prime := append(prime, 29)\n    prime := append(prime, 31)\n    prime\
    \ := append(prime, 37)\n    prime := append(prime, 43)\n    prime := append(prime,\
    \ 49)\n    prime := append(prime, 57)\n    prime := append(prime, 61)\n    prime\
    \ := append(prime, 67)\n    prime := append(prime, 73)\n    prime := append(prime,\
    \ 79)\n    prime := append(prime, 83)\n    prime := append(prime, 89)\n    prime\
    \ := append(prime, 97)\n    prime := append(prime, 101)\n    prime := append(prime,\
    \ 103)\n    prime := append(prime, 107)\n    prime := append(prime, 109)\n   \
    \ prime := append(prime, 113)\n    prime := append(prime, 127)\n    prime := append(prime,\
    \ 131)\n    prime := append(prime, 137)\n    prime := append(prime, 139)\n   \
    \ prime := append(prime, 149)\n    prime := append(prime, 151)\n    prime := append(prime,\
    \ 157)\n    prime := append(prime, 163)\n    prime := append(prime, 167)\n   \
    \ prime := append(prime, 173)\n    prime := append(prime, 179)\n    prime := append(prime,\
    \ 181)\n    prime := append(prime, 191)\n    prime := append(prime, 193)\n   \
    \ prime := append(prime, 197)\n    prime := append(prime, 199)\n    prime := append(prime,\
    \ 211)\n    prime := append(prime, 223)\n    prime := append(prime, 227)\n   \
    \ prime := append(prime, 229)\n    prime := append(prime, 233)\n    prime := append(prime,\
    \ 239)\n    prime := append(prime, 241)\n    prime := append(prime, 251)\n   \
    \ prime := append(prime, 257)\n    prime := append(prime, 263)\n    prime := append(prime,\
    \ 269)\n    prime := append(prime, 271)\n    prime := append(prime, 277)\n   \
    \ prime := append(prime, 28\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpa2cnz7tx_test.go:81:30: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075219
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n        if\
    \ prime[prime[0]-1] == 0 {\n            prime = append(prime, i)\n        }\n\
    \        for j := 0; j < i; j++ {\n            if prime[j] == 0 {\n          \
    \      prime = append(prime, j)\n            }\n        }\n    }\n    return prime\n\
    }\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513920,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513920, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmpaddpwe5v_test.go:26\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmpaddpwe5v_test.go:45\
    \ +0x1254\ntesting.tRunner(0xc0001924e0, 0x529240)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075221
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n        for\
    \ j := 2; j < i; j++ {\n            if i%j == 0 {\n                break\n   \
    \         }\n        }\n        if i == j {\n            prime = append(prime,\
    \ i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpt19r5qk1_test.go:31:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075219
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime :=\
    \ append(prime, 3)\n    for i := 4; i <= n; i++ {\n        for j := 2; j < i;\
    \ j++ {\n            if i % j == 0 {\n                break\n            }\n \
    \       }\n        if j == i {\n            prime = append(prime, i)\n       \
    \ }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpcs4rn_5u_test.go:25:11: no new variables on left side of :=

    /tmp/tmpcs4rn_5u_test.go:26:11: no new variables on left side of :=

    /tmp/tmpcs4rn_5u_test.go:33:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075219
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime :=\
    \ append(prime, 3)\n    for i := 4; i <= n; i++ {\n        for j := 2; j < i;\
    \ j++ {\n            if i % j == 0 {\n                break\n            }\n \
    \       }\n        if j == i {\n            prime = append(prime, i)\n       \
    \ }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpcs4rn_5u_test.go:25:11: no new variables on left side of :=

    /tmp/tmpcs4rn_5u_test.go:26:11: no new variables on left side of :=

    /tmp/tmpcs4rn_5u_test.go:33:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075219
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0)\n    prime := append(prime, 2)\n    for i :=\
    \ 3; i < n; i++ {\n        for j := 2; j < i; j++ {\n            if i%j == 0 {\n\
    \                break\n            }\n        }\n        if i == j {\n      \
    \      prime = append(prime, i)\n        }\n    }\n    return prime\n}\n\nfunc\
    \ TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2,\
    \ 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n   \
    \  { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp18h8lo5x_test.go:25:11: no new variables on left side of :=

    /tmp/tmp18h8lo5x_test.go:32:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075219
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime :=\
    \ append(prime, 3)\n    prime := append(prime, 5)\n    prime := append(prime,\
    \ 7)\n    prime := append(prime, 11)\n    prime := append(prime, 13)\n    prime\
    \ := append(prime, 17)\n    prime := append(prime, 19)\n    prime := append(prime,\
    \ 23)\n    prime := append(prime, 29)\n    prime := append(prime, 31)\n    prime\
    \ := append(prime, 37)\n    prime := append(prime, 43)\n    prime := append(prime,\
    \ 49)\n    prime := append(prime, 57)\n    prime := append(prime, 61)\n    prime\
    \ := append(prime, 67)\n    prime := append(prime, 73)\n    prime := append(prime,\
    \ 79)\n    prime := append(prime, 83)\n    prime := append(prime, 89)\n    prime\
    \ := append(prime, 97)\n    prime := append(prime, 101)\n    prime := append(prime,\
    \ 103)\n    prime := append(prime, 107)\n    prime := append(prime, 109)\n   \
    \ prime := append(prime, 113)\n    prime := append(prime, 127)\n    prime := append(prime,\
    \ 131)\n    prime := append(prime, 137)\n    prime := append(prime, 139)\n   \
    \ prime := append(prime, 149)\n    prime := append(prime, 151)\n    prime := append(prime,\
    \ 157)\n    prime := append(prime, 163)\n    prime := append(prime, 167)\n   \
    \ prime := append(prime, 173)\n    prime := append(prime, 179)\n    prime := append(prime,\
    \ 181)\n    prime := append(prime, 191)\n    prime := append(prime, 193)\n   \
    \ prime := append(prime, 197)\n    prime := append(prime, 199)\n    prime := append(prime,\
    \ 211)\n    prime := append(prime, 223)\n    prime := append(prime, 227)\n   \
    \ prime := append(prime, 229)\n    prime := append(prime, 233)\n    prime := append(prime,\
    \ 239)\n    prime := append(prime, 241)\n    prime := append(prime, 251)\n   \
    \ prime := append(prime, 257)\n    prime := append(prime, 263)\n    prime := append(prime,\
    \ 269)\n    prime := append(prime, 271)\n    prime := append(prime, 277)\n   \
    \ prime := append(prime, 28\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpa2cnz7tx_test.go:81:30: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075219
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0, n)\n    prime := append(prime, 2)\n    for i\
    \ := 3; i < n; i++ {\n        for j := 2; j < i; j++ {\n            if i%j ==\
    \ 0 {\n                break\n            }\n        }\n        if i == j {\n\
    \            prime = append(prime, i)\n        }\n    }\n    return prime\n}\n\
    \nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpn1r8i3ww_test.go:25:11: no new variables on left side of :=

    /tmp/tmpn1r8i3ww_test.go:32:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075223
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    primes := make([]int, n+1)\n    primes[0] = 1\n    primes[1] = 1\n  \
    \  for i := 2; i <= n; i++ {\n        for j := 2; j < i; j++ {\n            if\
    \ i*j > n {\n                break\n            }\n            if primes[i*j]\
    \ == 0 {\n                primes[i*j] = i\n            }\n        }\n    }\n \
    \   return primes[:n]\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [1] with length 1 [recovered]\n\tpanic: runtime error: index out of range [1]\
    \ with length 1\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmps7pyx1xu_test.go:26\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmps7pyx1xu_test.go:51\
    \ +0x173\ntesting.tRunner(0xc0001a0340, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075219
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n        if\
    \ prime[prime[len(prime)-1]-1] != i {\n            prime = append(prime, i)\n\
    \        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n\
    \  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine\
    \ 19 [running]:\ntesting.tRunner.func1.2({0x513920, 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513920, 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmpuec6jttv_test.go:26\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmpuec6jttv_test.go:40\
    \ +0xddd\ntesting.tRunner(0xc0001036c0, 0x529240)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075222
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime :=\
    \ append(prime, 3)\n    for i := 4; i < n; i++ {\n        for j := 2; j < i; j++\
    \ {\n            if i % j == 0 {\n                break\n            }\n     \
    \   }\n        if j > i {\n            prime = append(prime, i)\n        }\n \
    \   }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpsk7j88uq_test.go:25:11: no new variables on left side of :=

    /tmp/tmpsk7j88uq_test.go:26:11: no new variables on left side of :=

    /tmp/tmpsk7j88uq_test.go:33:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075223
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0, n)\n    prime := append(prime, 2)\n    for i\
    \ := 3; i < n; i++ {\n        if prime[len(prime)-1] == i {\n            prime\
    \ = append(prime, i)\n        } else {\n            prime = append(prime, i+1)\n\
    \        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n\
    \  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4i03r44l_test.go:25:11: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075226
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime :=\
    \ append(prime, 3)\n    prime := append(prime, 5)\n    prime := append(prime,\
    \ 7)\n    prime := append(prime, 11)\n    prime := append(prime, 13)\n    prime\
    \ := append(prime, 17)\n    prime := append(prime, 19)\n    if n < 0 {\n     \
    \   return nil\n    }\n    if n == 0 {\n        return prime\n    }\n    if n\
    \ == 1 {\n        return nil\n    }\n    if n == 2 {\n        return prime\n \
    \   }\n    if n == 3 {\n        return append(prime, 3)\n    }\n    if n == 4\
    \ {\n        return append(prime, 5)\n    }\n    if n == 5 {\n        return append(prime,\
    \ 7)\n    }\n    if n == 6 {\n        return append(prime, 11)\n    }\n    if\
    \ n == 7 {\n        return append(prime, 13)\n    }\n    if n == 8 {\n       \
    \ return append(prime, 17)\n    }\n    if n == 9 {\n        return append(prime,\
    \ 19)\n    }\n    if n == 10 {\n        return append(prime, 23)\n    }\n    if\
    \ n == 11 {\n        return append(prime, 29)\n    }\n    if n == 12 {\n     \
    \   return append(prime, 31)\n    }\n    if n == 13 {\n        return append(prime,\
    \ 37)\n    }\n    if n == 14 {\n        return append(prime, 43)\n    }\n    if\
    \ n == 15 {\n        return append(prime, 49)\n    }\n    if n == 16 {\n     \
    \   return append(prime, 57)\n    }\n    if n == 17 {\n        return append(prime,\
    \ 61)\n    }\n    if n == 18 {\n        return append(prime, 67)\n    }\n    if\
    \ n == 19 {\n        return append(prime, 73)\n    }\n    if n == 20 {\n     \
    \   return append(prime, 79)\n    }\n    if n == 21 {\n        return append(prime,\
    \ 83)\n    }\n    if n == 22 {\n        return append(prime, 89)\n    }\n    if\
    \ n == 23 {\n        return append(prime, 97)\n    }\n    if n == 24 {\n     \
    \   return append(prime, 101)\n    }\n    if n == 25 {\n        return append(prime,\
    \ 105)\n    }\n    if n == 26 {\n        return append(prime, 109)\n    }\n  \
    \  if n == 27 {\n        return append(prime, 113)\n    }\n    if n == 28 {\n\
    \        return append(prime, 127)\n    }\n    if n == 29 {\n        return append(prime,\
    \ 131)\n    }\n    if n == 30 {\n        return append(prime, 135)\n    }\n  \
    \  if n == 31 {\n        return append(prime, 139)\n    }\n    if n == 32 {\n\n\
    func TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_2jtbesz_test.go:134:6: expected ''('', found TestCount_Up_To

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075225
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0, n)\n    for i := 2; i <= n; i++ {\n        for\
    \ j := 2; j < i; j++ {\n            if i % j == 0 {\n                break\n \
    \           }\n        }\n        if i == j {\n            prime = append(prime,\
    \ i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2iju3lpw_test.go:31:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075226
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0)\n    prime := append(prime, 2)\n    for i :=\
    \ 3; i < n; i++ {\n        for j := 2; j < i; j++ {\n            if i % j == 0\
    \ {\n                break\n            }\n        }\n        if j > i {\n   \
    \         prime = append(prime, i)\n        }\n    }\n    return prime\n}\n\n\
    func TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpazhjvxpx_test.go:25:11: no new variables on left side of :=

    /tmp/tmpazhjvxpx_test.go:32:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075222
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0, n)\n    prime := append(prime, 2)\n    prime\
    \ := append(prime, 3)\n    prime := append(prime, 5)\n    prime := append(prime,\
    \ 7)\n    prime := append(prime, 11)\n    prime := append(prime, 13)\n    prime\
    \ := append(prime, 17)\n    prime := append(prime, 19)\n    prime := append(prime,\
    \ 23)\n    prime := append(prime, 29)\n    prime := append(prime, 31)\n    prime\
    \ := append(prime, 37)\n    prime := append(prime, 43)\n    prime := append(prime,\
    \ 49)\n    prime := append(prime, 57)\n    prime := append(prime, 61)\n    prime\
    \ := append(prime, 67)\n    prime := append(prime, 73)\n    prime := append(prime,\
    \ 79)\n    prime := append(prime, 83)\n    prime := append(prime, 89)\n    prime\
    \ := append(prime, 97)\n    prime := append(prime, 101)\n    prime := append(prime,\
    \ 103)\n    prime := append(prime, 107)\n    prime := append(prime, 109)\n   \
    \ prime := append(prime, 113)\n    prime := append(prime, 127)\n    prime := append(prime,\
    \ 131)\n    prime := append(prime, 137)\n    prime := append(prime, 139)\n   \
    \ prime := append(prime, 149)\n    prime := append(prime, 151)\n    prime := append(prime,\
    \ 157)\n    prime := append(prime, 163)\n    prime := append(prime, 167)\n   \
    \ prime := append(prime, 173)\n    prime := append(prime, 179)\n    prime := append(prime,\
    \ 181)\n    prime := append(prime, 191)\n    prime := append(prime, 193)\n   \
    \ prime := append(prime, 197)\n    prime := append(prime, 199)\n    prime := append(prime,\
    \ 211)\n    prime := append(prime, 223)\n    prime := append(prime, 227)\n   \
    \ prime := append(prime, 229)\n    prime := append(prime, 233)\n    prime := append(prime,\
    \ 239)\n    prime := append(prime, 241)\n    prime := append(prime, 243)\n   \
    \ prime := append(prime, 247)\n    prime := append(prime, 251)\n    prime := append(prime,\
    \ 257)\n    prime := append(prime, 263)\n    prime := append(prime, 269)\n   \
    \ prime := append(prime, \nfunc TestCount_Up_To(t *testing.T) {\n  candidate :=\
    \ count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpbtkaogbp_test.go:82:6: expected ''('', found TestCount_Up_To

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075218
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n        if\
    \ prime[prime[0]-1] == 0 {\n            prime = append(prime, i)\n        }\n\
    \        for j := 0; j < i; j++ {\n            if prime[j] == 0 {\n          \
    \      prime = append(prime, j)\n                break\n            }\n      \
    \  }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513920,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513920, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmppgbc1akp_test.go:26\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmppgbc1akp_test.go:46\
    \ +0x12b6\ntesting.tRunner(0xc0001a0340, 0x529240)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075219
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0)\n    prime := append(prime, 2)\n    for i :=\
    \ 3; i < n; i++ {\n        for j := 2; j < i; j++ {\n            if i%j == 0 {\n\
    \                break\n            }\n        }\n        if i == j {\n      \
    \      prime = append(prime, i)\n        }\n    }\n    return prime\n}\n\nfunc\
    \ TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2,\
    \ 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n   \
    \  { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp18h8lo5x_test.go:25:11: no new variables on left side of :=

    /tmp/tmp18h8lo5x_test.go:32:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075219
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0, n)\n    for i := 2; i <= n; i++ {\n        if\
    \ prime[prime[0]-1] == 0 {\n            prime = append(prime, i)\n        }\n\
    \        for j := 1; j < i; j++ {\n            if i%prime[j] == 0 {\n        \
    \        break\n            }\n            if j == len(prime) {\n            \
    \    prime = append(prime, i)\n            }\n        }\n    }\n    return prime\n\
    }\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2({0x513920,\
    \ 0xc00014e000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513920, 0xc00014e000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmpn18mesvd_test.go:26\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmpn18mesvd_test.go:48\
    \ +0x10ce\ntesting.tRunner(0xc00011b1e0, 0x529240)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n"
  timestamp: 1660075226
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n        if\
    \ prime[prime[len(prime)-1]-1] != i {\n            prime = append(prime, i)\n\
    \        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n\
    \  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine\
    \ 19 [running]:\ntesting.tRunner.func1.2({0x513920, 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513920, 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmpuec6jttv_test.go:26\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmpuec6jttv_test.go:40\
    \ +0xddd\ntesting.tRunner(0xc0001036c0, 0x529240)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075222
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// []int{}\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// []int{}\n// >>>\
    \ count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int\
    \ {\n    prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime :=\
    \ append(prime, 3)\n    for i := 4; i <= n; i++ {\n        for j := 2; j < i;\
    \ j++ {\n            if i % j == 0 {\n                break\n            }\n \
    \       }\n        if j > i {\n            prime = append(prime, i)\n        }\n\
    \    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpf_4cdq0t_test.go:25:11: no new variables on left side of :=

    /tmp/tmpf_4cdq0t_test.go:26:11: no new variables on left side of :=

    /tmp/tmpf_4cdq0t_test.go:33:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075219
