language: go_test.go
name: HumanEval_79_decimal_to_binary
results:
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n     \
    \   result += binary_to_decimal(decimal)\n    }\n    decimal /= 2\n    if decimal\
    \ > 0 {\n        result += binary_to_decimal(decimal)\n    }\n    return result\n\
    }\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyphcuo4j_test.go:22:19: undefined: binary_to_decimal

    /tmp/tmpyphcuo4j_test.go:26:19: undefined: binary_to_decimal

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074382
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n     \
    \   result += \"1\"\n    }\n    for i := 0; i < decimal; i++ {\n        result\
    \ += \"0\"\n    }\n    return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpopc6z5a3_test.go:46: expected 'db0db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpopc6z5a3_test.go:46: expected\
    \ 'db100000db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n\
    \        tmpopc6z5a3_test.go:46: expected 'db1100111db', got '10'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpopc6z5a3_test.go:46: expected\
    \ 'db1111db', got '10'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074383
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    binaryString := \"\"\n    binaryString += \"db\"\n    for i :=\
    \ 0; i < decimal; i++ {\n        if decimal % 2 == 0 {\n            binaryString\
    \ += \"1\"\n        } else {\n            binaryString += \"0\"\n        }\n \
    \       decimal = decimal / 2\n    }\n    return binaryString\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpuhhngrth_test.go:48: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpuhhngrth_test.go:48:\
    \ expected 'db100000db', got 'db1111'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpuhhngrth_test.go:48: expected 'db1100111db', got 'db00011'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpuhhngrth_test.go:48:\
    \ expected 'db1111db', got 'db000'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074382
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n     \
    \   result += binary_to_decimal(decimal)\n    }\n    decimal /= 2\n    if decimal\
    \ > 0 {\n        result += binary_to_decimal(decimal)\n    }\n    decimal /= 2\n\
    \    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n    }\n \
    \   decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= \nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpnkc5b_ds_test.go:117:6: expected ''('', found TestDecimal_To_Binary

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074381
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n     \
    \   result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 0 {\n    \
    \    result += \"1\"\n    }\n    return result\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpeocrmak2_test.go:46: expected 'db0db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpeocrmak2_test.go:46: expected\
    \ 'db100000db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n\
    \        tmpeocrmak2_test.go:46: expected 'db1100111db', got '1'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpeocrmak2_test.go:46: expected\
    \ 'db1111db', got '1'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074382
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    for i := 0; i < len(decimal);\
    \ i++ {\n        if decimal > 0 {\n            result += fmt.Sprintf(\"%c\", decimal%2)\n\
    \            decimal /= 2\n        } else {\n            result += fmt.Sprintf(\"\
    %c\", decimal%2)\n            decimal *= 2\n        }\n    }\n    return \"db\"\
    \ + result + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqkhu5g09_test.go:21:25: invalid argument: decimal (variable of type int)
    for len

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074388
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    for i := 0; i < decimal;\
    \ i++ {\n        result += \"0\"\n    }\n    result += \"1\"\n    return result\n\
    }\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp82rsg2ko_test.go:44: expected 'db0db', got '1'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp82rsg2ko_test.go:44:\
    \ expected 'db100000db', got '1'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmp82rsg2ko_test.go:44: expected 'db1100111db', got '01'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp82rsg2ko_test.go:44:\
    \ expected 'db1111db', got '01'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074382
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n     \
    \   result += decimal_to_binary(decimal/2)\n    }\n    decimal %= 2\n    if decimal\
    \ > 0 {\n        result += decimal_to_binary(decimal/2)\n    }\n    decimal %=\
    \ 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n  \
    \  }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= \nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpem5vjt3e_test.go:117:6: expected ''('', found TestDecimal_To_Binary

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074381
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    // Your code here\n    result := \"\"\n    i := 0\n    for i <\
    \ decimal {\n        if decimal % 2 == 0 {\n            result += fmt.Sprintf(\"\
    0\", decimal%2)\n        } else {\n            result += fmt.Sprintf(\"1\", decimal%2)\n\
    \        }\n        decimal /= 2\n        i++\n    }\n    return \"db\" + result\
    \ + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test

    /tmp/tmp9y45bxae_test.go:24:34: fmt.Sprintf call has arguments but no formatting
    directives

    /tmp/tmp9y45bxae_test.go:26:34: fmt.Sprintf call has arguments but no formatting
    directives

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074491
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    for i := 0; i < decimal;\
    \ i++ {\n        result += \"1\"\n    }\n    for i := decimal - 1; i >= 0; i--\
    \ {\n        result += \"0\"\n    }\n    return \"db\" + result\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp5xzz5bs6_test.go:46: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp5xzz5bs6_test.go:46:\
    \ expected 'db100000db', got 'db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmp5xzz5bs6_test.go:46: expected 'db1100111db', got 'db10'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp5xzz5bs6_test.go:46:\
    \ expected 'db1111db', got 'db10'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074491
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n     \
    \   result += binary_to_decimal(decimal)\n    }\n    decimal /= 2\n    if decimal\
    \ > 0 {\n        result += binary_to_decimal(decimal)\n    }\n    return result\n\
    }\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyphcuo4j_test.go:22:19: undefined: binary_to_decimal

    /tmp/tmpyphcuo4j_test.go:26:19: undefined: binary_to_decimal

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074382
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    binary := make([]byte, 32)\n    i := 0\n    for decimal%2 == 0\
    \ {\n        binary[i] = '1'\n        decimal = decimal / 2\n        i++\n   \
    \ }\n    for decimal%2 == 1 {\n        binary[i] = '0'\n        decimal = decimal\
    \ / 2\n        i++\n    }\n    binary[i] = 'b'\n    return string(binary)\n}\n\
    \nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\npanic: runtime error: index out\
    \ of range [32] with length 32 [recovered]\n\tpanic: runtime error: index out\
    \ of range [32] with length 32\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513640,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513640, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.decimal_to_binary(...)\n\t/tmp/tmplh69y52t_test.go:22\n\
    command-line-arguments_test.TestDecimal_To_Binary(0x0?)\n\t/tmp/tmplh69y52t_test.go:42\
    \ +0x5ec\ntesting.tRunner(0xc0000da340, 0x528f88)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074386
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    binary := make([]byte, 32)\n    i := 0\n    for ; i < 32; i++\
    \ {\n        binary[i] = byte(decimal % 2)\n        decimal /= 2\n    }\n    binary[31]\
    \ = 'b'\n    return string(binary)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpw5m2my1b_test.go:45: expected 'db0db', got '\0\0\0\0\0\0\
    \0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0b'\n    --- FAIL: TestDecimal_To_Binary/test_num__1\
    \ (0.00s)\n        tmpw5m2my1b_test.go:45: expected 'db100000db', got '\0\0\0\0\
    \0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0b'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpw5m2my1b_test.go:45: expected 'db1100111db', got '\x01\x01\
    \x01\0\0\x01\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0b'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpw5m2my1b_test.go:45: expected\
    \ 'db1111db', got '\x01\x01\x01\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\
    \0\0\0\0\0b'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074491
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n     \
    \   result += decimal_to_binary(decimal/2)\n    }\n    decimal %= 2\n    if decimal\
    \ > 0 {\n        result += decimal_to_binary(decimal/2)\n    }\n    decimal %=\
    \ 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n  \
    \  }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= \nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpem5vjt3e_test.go:117:6: expected ''('', found TestDecimal_To_Binary

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074381
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    binary := make([]byte, 32)\n    i := 0\n    for ; decimal > 0;\
    \ decimal = decimal/2 {\n        binary[i] = byte(decimal % 2)\n        i++\n\
    \    }\n    binary[i] = byte(decimal)\n    return string(binary)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp4og_zxjs_test.go:45: expected 'db0db', got '\0\0\0\0\0\0\
    \0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0'\n    --- FAIL: TestDecimal_To_Binary/test_num__1\
    \ (0.00s)\n        tmp4og_zxjs_test.go:45: expected 'db100000db', got '\0\0\0\0\
    \0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmp4og_zxjs_test.go:45: expected 'db1100111db', got '\x01\x01\
    \x01\0\0\x01\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp4og_zxjs_test.go:45: expected\
    \ 'db1111db', got '\x01\x01\x01\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\
    \0\0\0\0\0\0'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074491
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n     \
    \   result += \"1\"\n    }\n    for i := 0; i < decimal; i++ {\n        result\
    \ += \"0\"\n    }\n    return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpopc6z5a3_test.go:46: expected 'db0db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpopc6z5a3_test.go:46: expected\
    \ 'db100000db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n\
    \        tmpopc6z5a3_test.go:46: expected 'db1100111db', got '10'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpopc6z5a3_test.go:46: expected\
    \ 'db1111db', got '10'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074383
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    binaryString := \"\"\n    switch decimal {\n    case 0:\n    \
    \    binaryString = \"0\"\n    case 1:\n        binaryString = \"1\"\n    }\n\
    \    return binaryString + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp_9s2knmp_test.go:45: expected 'db0db', got '0db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp_9s2knmp_test.go:45:\
    \ expected 'db100000db', got 'db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmp_9s2knmp_test.go:45: expected 'db1100111db', got 'db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp_9s2knmp_test.go:45:\
    \ expected 'db1111db', got 'db'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\n\
    FAIL\n"
  timestamp: 1660074391
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    binary := make([]byte, 32)\n    for i := 0; i < len(binary); i++\
    \ {\n        binary[i] = byte(decimal % 2)\n        decimal /= 2\n    }\n    binary[0]\
    \ = 'b'\n    binary[len(binary)-1] = 'b'\n    return string(binary)\n}\n\nfunc\
    \ TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpsoo0cqvr_test.go:45: expected 'db0db', got 'b\0\0\0\0\0\0\
    \0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0b'\n    --- FAIL: TestDecimal_To_Binary/test_num__1\
    \ (0.00s)\n        tmpsoo0cqvr_test.go:45: expected 'db100000db', got 'b\0\0\0\
    \0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0b'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpsoo0cqvr_test.go:45: expected 'db1100111db', got 'b\x01\x01\
    \0\0\x01\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0b'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpsoo0cqvr_test.go:45: expected\
    \ 'db1111db', got 'b\x01\x01\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\
    \0\0\0\0b'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074391
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    binary := make([]byte, 32)\n    i := 0\n    for ; i < 32; i++\
    \ {\n        if decimal >= 2 {\n            binary[i] = byte(decimal % 2)\n  \
    \          decimal /= 2\n        } else {\n            binary[i] = byte(decimal)\n\
    \            break\n        }\n    }\n    return string(binary)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpzr8yi_l5_test.go:49: expected 'db0db', got '\0\0\0\0\0\0\
    \0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0'\n    --- FAIL: TestDecimal_To_Binary/test_num__1\
    \ (0.00s)\n        tmpzr8yi_l5_test.go:49: expected 'db100000db', got '\0\0\0\0\
    \0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpzr8yi_l5_test.go:49: expected 'db1100111db', got '\x01\x01\
    \x01\0\0\x01\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpzr8yi_l5_test.go:49: expected\
    \ 'db1111db', got '\x01\x01\x01\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\
    \0\0\0\0\0\0'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074491
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n     \
    \   result += binary_to_decimal(decimal)\n    }\n    if decimal > 1 {\n      \
    \  result += binary_to_decimal(decimal - 1)\n    }\n    return result\n}\n\nfunc\
    \ TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9vla42xs_test.go:22:19: undefined: binary_to_decimal

    /tmp/tmp9vla42xs_test.go:25:19: undefined: binary_to_decimal

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074491
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n     \
    \   result += fmt.Sprintf(\"%c\", decimal)\n        decimal /= 2\n    }\n    if\
    \ decimal > 0 {\n        result += fmt.Sprintf(\"%c\", decimal)\n        decimal\
    \ /= 2\n    }\n    if decimal > 0 {\n        result += fmt.Sprintf(\"%c\", decimal)\n\
    \        decimal /= 2\n    }\n    if decimal > 0 {\n        result += fmt.Sprintf(\"\
    %c\", decimal)\n        decimal /= 2\n    }\n    if decimal > 0 {\n        result\
    \ += fmt.Sprintf(\"%c\", decimal)\n        decimal /= 2\n    }\n    if decimal\
    \ > 0 {\n        result += fmt.Sprintf(\"%c\", decimal)\n        decimal /= 2\n\
    \    }\n    if decimal > 0 {\n        result += fmt.Sprintf(\"%c\", decimal)\n\
    \        decimal /= 2\n    }\n    if decimal > 0 {\n        result += fmt.Sprintf(\"\
    %c\", decimal)\n        decimal /= 2\n    }\n    if decimal > 0 {\n        result\
    \ += fmt.Sprintf(\"%c\", decimal)\n        decimal /= 2\n    }\n    if decimal\
    \ > 0 {\n        result += fmt.Sprintf(\"%c\", decimal)\n        decimal /= 2\n\
    \    }\n    if decimal > 0 {\n        result += fmt.Sprintf(\"%c\", decimal)\n\
    \        decimal /= 2\n    }\n    if decimal > 0 {\n        result += fmt.Sprintf(\"\
    %c\", decimal)\n        decimal /= 2\n    }\n    if decimal > 0 {\n        result\
    \ += fmt.Sprintf(\"%c\", decimal)\n        decimal /= 2\n    }\n    if decimal\
    \ > 0 {\n        result += fmt.Sprintf(\"%c\", decimal)\n        decimal /= 2\n\
    \    }\n    if decimal > 0 {\n        result += fmt.Sprintf(\"%c\", decimal)\n\
    \        decimal /= 2\n    }\n    if decimal > 0 {\n        result += fmt.Sprintf(\"\
    %c\", decimal)\n        decimal /= 2\n    }\n    if decimal > 0 {\n        result\
    \ += fmt.Sprintf(\"%c\", decimal)\n        decimal /= 2\n    }\n    if decimal\
    \ > 0 {\n        result += fmt.Sprintf(\"%c\", decimal)\n        decimal /= 2\n\
    \    }\n    if decimal > 0 {\n        result += fmt.Sprintf(\"%c\", decimal)\n\
    \        decimal /= 2\n    }\n    if decimal > 0 {\n        result += fmt.Sprintf(\"\
    %c\", decimal)\n        decimal /= 2\n    }\n    if decimal > 0 {\n        result\
    \ += fmt.Sprintf(\"%c\", decimal)\n        decimal /= 2\n    }\n    if decimal\
    \ > 0 {\n        result += fmt.Sprintf(\"%c\", decimal)\n        decimal /= \n\
    func TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmplt95_fz5_test.go:108:6: expected ''('', found TestDecimal_To_Binary

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074490
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n     \
    \   result += fmt.Sprintf(\"%c\", decimal)\n    }\n    for i := 0; i < len(result);\
    \ i++ {\n        decimal /= 2\n        if decimal > 0 {\n            result +=\
    \ fmt.Sprintf(\"%c\", decimal)\n        }\n    }\n    return \"db\" + result +\
    \ \"db\"\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpodyrhed9_test.go:49: expected 'db0db', got 'dbdb'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpodyrhed9_test.go:49:\
    \ expected 'db100000db', got 'dbdb'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpodyrhed9_test.go:49: expected 'db1100111db', got 'db\x01\
    db'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpodyrhed9_test.go:49:\
    \ expected 'db1111db', got 'db\x01db'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074390
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    for i := 0; i < decimal;\
    \ i++ {\n        result += \"0\"\n    }\n    result += \"1\"\n    result += \"\
    db\"\n    return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpnbbo4poz_test.go:45: expected 'db0db', got '1db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpnbbo4poz_test.go:45:\
    \ expected 'db100000db', got '1db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpnbbo4poz_test.go:45: expected 'db1100111db', got '01db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpnbbo4poz_test.go:45:\
    \ expected 'db1111db', got '01db'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074382
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    binaryString := \"\"\n    decimalString := fmt.Sprintf(\"%d\"\
    , decimal)\n    for i := 0; i < len(decimalString); i++ {\n        if decimalString[i]\
    \ == '1' {\n            binaryString += \"1\"\n        } else {\n            binaryString\
    \ += \"0\"\n        }\n    }\n    return \"db\" + binaryString\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmppuyl_ai2_test.go:47: expected 'db0db', got 'db0'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmppuyl_ai2_test.go:47:\
    \ expected 'db100000db', got 'db00'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmppuyl_ai2_test.go:47: expected 'db1100111db', got 'db100'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmppuyl_ai2_test.go:47:\
    \ expected 'db1111db', got 'db10'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074491
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    binary := make([]byte, 32)\n    i := 0\n    for decimal%2 == 0\
    \ {\n        binary[i] = '0'\n        decimal = decimal / 2\n        i++\n   \
    \ }\n    for decimal%2 == 1 {\n        binary[i] = '1'\n        decimal = decimal\
    \ / 2\n        i++\n    }\n    binary[i] = 'b'\n    return string(binary)\n}\n\
    \nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\npanic: runtime error: index out\
    \ of range [32] with length 32 [recovered]\n\tpanic: runtime error: index out\
    \ of range [32] with length 32\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2({0x513640,\
    \ 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513640, 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.decimal_to_binary(...)\n\t/tmp/tmpp9udcie4_test.go:22\n\
    command-line-arguments_test.TestDecimal_To_Binary(0x0?)\n\t/tmp/tmpp9udcie4_test.go:42\
    \ +0x5ec\ntesting.tRunner(0xc000103520, 0x528f88)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074389
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    binary := make([]byte, 32)\n    i := 0\n    for decimal%2 == 0\
    \ {\n        binary[i] = '1'\n        decimal = decimal / 2\n        i++\n   \
    \ }\n    for decimal%2 == 1 {\n        binary[i] = '0'\n        decimal = decimal\
    \ / 2\n        i++\n    }\n    binary[i] = 'db'\n    return string(binary)\n}\n\
    \nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpkkaehvb5_test.go:31:17: illegal rune literal

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074490
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n     \
    \   result += binary_to_decimal(decimal)\n    }\n    decimal /= 2\n    if decimal\
    \ > 0 {\n        result += binary_to_decimal(decimal)\n    }\n    decimal /= 2\n\
    \    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n    }\n \
    \   decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= \nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpnkc5b_ds_test.go:117:6: expected ''('', found TestDecimal_To_Binary

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074381
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n     \
    \   for i := 0; i < decimal; i++ {\n            result += \"1\"\n        }\n \
    \   } else {\n        for i := 0; i < decimal; i++ {\n            result += \"\
    0\"\n        }\n    }\n    return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpu9tpp7wo_test.go:49: expected 'db0db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpu9tpp7wo_test.go:49: expected\
    \ 'db100000db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n\
    \        tmpu9tpp7wo_test.go:49: expected 'db1100111db', got '1'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpu9tpp7wo_test.go:49: expected\
    \ 'db1111db', got '1'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074382
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n     \
    \   result += \"1\"\n    }\n    for i := 0; i < decimal; i++ {\n        result\
    \ += \"0\"\n    }\n    return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpopc6z5a3_test.go:46: expected 'db0db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpopc6z5a3_test.go:46: expected\
    \ 'db100000db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n\
    \        tmpopc6z5a3_test.go:46: expected 'db1100111db', got '10'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpopc6z5a3_test.go:46: expected\
    \ 'db1111db', got '10'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074383
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n     \
    \   result += binary_to_decimal(decimal)\n    }\n    decimal /= 2\n    if decimal\
    \ > 0 {\n        result += binary_to_decimal(decimal)\n    }\n    decimal /= 2\n\
    \    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n    }\n \
    \   decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= \nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpnkc5b_ds_test.go:117:6: expected ''('', found TestDecimal_To_Binary

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074381
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    temp := decimal\n    for i := 0; i < len(fmt.Sprintf(\"\
    %d\", temp)); i++ {\n        if temp%2 == 0 {\n            result += \"1\"\n \
    \       } else {\n            result += \"0\"\n        }\n        temp /= 2\n\
    \    }\n    return \"db\" + result + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp5d21jbo6_test.go:48: expected 'db0db', got 'db1db'\n   \
    \ --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp5d21jbo6_test.go:48:\
    \ expected 'db100000db', got 'db11db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmp5d21jbo6_test.go:48: expected 'db1100111db', got 'db00db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp5d21jbo6_test.go:48:\
    \ expected 'db1111db', got 'db0db'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\n\
    FAIL\n"
  timestamp: 1660074491
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    binary := make([]byte, 32)\n    i := 0\n    for decimal%2 == 0\
    \ {\n        binary[i] = '1'\n        i++\n        decimal = decimal / 2\n   \
    \ }\n    for decimal%2 == 1 {\n        binary[i] = '0'\n        i++\n        decimal\
    \ = decimal / 2\n    }\n    return string(binary)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\npanic: runtime error: index out\
    \ of range [32] with length 32 [recovered]\n\tpanic: runtime error: index out\
    \ of range [32] with length 32\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513640,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513640, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.decimal_to_binary(...)\n\t/tmp/tmp06czmos6_test.go:22\n\
    command-line-arguments_test.TestDecimal_To_Binary(0x0?)\n\t/tmp/tmp06czmos6_test.go:41\
    \ +0x573\ntesting.tRunner(0xc0000da1a0, 0x528f88)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074491
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n     \
    \   result += \"1\"\n    }\n    for i := 0; i < decimal; i++ {\n        result\
    \ += \"0\"\n    }\n    return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpopc6z5a3_test.go:46: expected 'db0db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpopc6z5a3_test.go:46: expected\
    \ 'db100000db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n\
    \        tmpopc6z5a3_test.go:46: expected 'db1100111db', got '10'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpopc6z5a3_test.go:46: expected\
    \ 'db1111db', got '10'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074383
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n     \
    \   result += binary_to_decimal(decimal)\n    }\n    decimal /= 2\n    if decimal\
    \ > 0 {\n        result += binary_to_decimal(decimal)\n    }\n    return result\n\
    }\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyphcuo4j_test.go:22:19: undefined: binary_to_decimal

    /tmp/tmpyphcuo4j_test.go:26:19: undefined: binary_to_decimal

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074382
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    binary := \"\"\n    decimal %= 2\n    for i := 0; i < decimal;\
    \ i++ {\n        binary += \"0\"\n    }\n    binary += \"1\"\n    return binary\n\
    }\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpfk4lm6ct_test.go:44: expected 'db0db', got '1'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpfk4lm6ct_test.go:44:\
    \ expected 'db100000db', got '1'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpfk4lm6ct_test.go:44: expected 'db1100111db', got '01'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpfk4lm6ct_test.go:44:\
    \ expected 'db1111db', got '01'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\n\
    FAIL\n"
  timestamp: 1660074491
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    binary := \"\"\n    decimal %= 2\n    for i := 0; i < len(decimal);\
    \ i++ {\n        if decimal > 0 {\n            binary += \"1\"\n            decimal--\n\
    \        } else {\n            binary += \"0\"\n        }\n    }\n    return binary\
    \ + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpv6b9engz_test.go:21:25: invalid argument: decimal (variable of type int)
    for len

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074491
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n     \
    \   result += binary_to_decimal(decimal)\n    }\n    decimal /= 2\n    if decimal\
    \ > 0 {\n        result += binary_to_decimal(decimal)\n    }\n    return result\n\
    }\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyphcuo4j_test.go:22:19: undefined: binary_to_decimal

    /tmp/tmpyphcuo4j_test.go:26:19: undefined: binary_to_decimal

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074382
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    for i := 0; i < decimal;\
    \ i++ {\n        result += \"0\"\n    }\n    result += \"1\"\n    result += \"\
    db\"\n    return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpnbbo4poz_test.go:45: expected 'db0db', got '1db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpnbbo4poz_test.go:45:\
    \ expected 'db100000db', got '1db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpnbbo4poz_test.go:45: expected 'db1100111db', got '01db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpnbbo4poz_test.go:45:\
    \ expected 'db1111db', got '01db'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074382
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n     \
    \   result += binary_to_decimal(decimal)\n    }\n    decimal /= 2\n    if decimal\
    \ > 0 {\n        result += binary_to_decimal(decimal)\n    }\n    return result\n\
    }\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyphcuo4j_test.go:22:19: undefined: binary_to_decimal

    /tmp/tmpyphcuo4j_test.go:26:19: undefined: binary_to_decimal

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074382
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    binaryString := \"\"\n    binaryString += \"db\"\n    binaryString\
    \ += fmt.Sprintf(\"%0*d\", decimal, decimal)\n    binaryString += \"db\"\n   \
    \ return binaryString\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__1\
    \ (0.00s)\n        tmp5o89a_9q_test.go:42: expected 'db100000db', got 'db00000000000000000000000000000032db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmp5o89a_9q_test.go:42:\
    \ expected 'db1100111db', got 'db0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000103db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp5o89a_9q_test.go:42:\
    \ expected 'db1111db', got 'db000000000000015db'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074384
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    result += \"db\"\n    for i := 0; i < decimal;\
    \ i++ {\n        if decimal % 2 == 0 {\n            result += fmt.Sprintf(\"%c\"\
    , 0)\n        } else {\n            result += fmt.Sprintf(\"%c\", 1)\n       \
    \ }\n        decimal /= 2\n    }\n    return result\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp4027198v_test.go:48: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp4027198v_test.go:48:\
    \ expected 'db100000db', got 'db\0\0\0\0'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmp4027198v_test.go:48: expected 'db1100111db', got 'db\x01\
    \x01\x01\0\0'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n     \
    \   tmp4027198v_test.go:48: expected 'db1111db', got 'db\x01\x01\x01'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074491
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    binary := make([]byte, 32)\n    i := 0\n    for decimal%2 == 0\
    \ {\n        binary[i] = '1'\n        decimal = decimal / 2\n        i++\n   \
    \ }\n    for decimal%2 == 1 {\n        binary[i] = '0'\n        decimal = decimal\
    \ / 2\n        i++\n    }\n    binary[i] = 'b'\n    return string(binary)\n}\n\
    \nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\npanic: runtime error: index out\
    \ of range [32] with length 32 [recovered]\n\tpanic: runtime error: index out\
    \ of range [32] with length 32\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513640,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513640, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.decimal_to_binary(...)\n\t/tmp/tmplh69y52t_test.go:22\n\
    command-line-arguments_test.TestDecimal_To_Binary(0x0?)\n\t/tmp/tmplh69y52t_test.go:42\
    \ +0x5ec\ntesting.tRunner(0xc0000da340, 0x528f88)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074386
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n     \
    \   result += binary_to_decimal(decimal)\n    }\n    decimal /= 2\n    if decimal\
    \ > 0 {\n        result += binary_to_decimal(decimal)\n    }\n    return result\n\
    }\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyphcuo4j_test.go:22:19: undefined: binary_to_decimal

    /tmp/tmpyphcuo4j_test.go:26:19: undefined: binary_to_decimal

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074382
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    binaryString := \"\"\n    binaryString += \"db\"\n    for i :=\
    \ 0; i < decimal; i++ {\n        if decimal % 2 == 0 {\n            binaryString\
    \ += \"1\"\n        } else {\n            binaryString += \"0\"\n        }\n \
    \       decimal = decimal / 2\n    }\n    return binaryString\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpuhhngrth_test.go:48: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpuhhngrth_test.go:48:\
    \ expected 'db100000db', got 'db1111'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpuhhngrth_test.go:48: expected 'db1100111db', got 'db00011'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpuhhngrth_test.go:48:\
    \ expected 'db1111db', got 'db000'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074382
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    binary := make([]byte, 32)\n    for i := 0; i < len(binary); i++\
    \ {\n        binary[i] = byte(decimal % 2)\n        decimal /= 2\n    }\n    binary[0]\
    \ = 'b'\n    binary[len(binary)-1] = 'b'\n    return string(binary)\n}\n\nfunc\
    \ TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpsoo0cqvr_test.go:45: expected 'db0db', got 'b\0\0\0\0\0\0\
    \0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0b'\n    --- FAIL: TestDecimal_To_Binary/test_num__1\
    \ (0.00s)\n        tmpsoo0cqvr_test.go:45: expected 'db100000db', got 'b\0\0\0\
    \0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0b'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpsoo0cqvr_test.go:45: expected 'db1100111db', got 'b\x01\x01\
    \0\0\x01\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0b'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpsoo0cqvr_test.go:45: expected\
    \ 'db1111db', got 'b\x01\x01\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\
    \0\0\0\0b'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074391
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    for i := 0; i < len(decimal);\
    \ i++ {\n        if decimal > 0 {\n            result += strconv.Itoa(decimal%2)\n\
    \            decimal /= 2\n        } else {\n            result += strconv.Itoa((decimal%2)*2)\n\
    \            decimal /= 2\n        }\n    }\n    return \"db\" + result + \"db\"\
    \n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmppw_fu3eu_test.go:21:25: invalid argument: decimal (variable of type int)
    for len

    /tmp/tmppw_fu3eu_test.go:23:23: undefined: strconv

    /tmp/tmppw_fu3eu_test.go:26:23: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074491
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    binary := make([]byte, 32)\n    i := 0\n    for decimal%2 == 0\
    \ {\n        binary[i] = '1'\n        decimal = decimal / 2\n        i++\n   \
    \ }\n    for decimal%2 == 1 {\n        binary[i] = '0'\n        decimal = decimal\
    \ / 2\n        i++\n    }\n    binary[i] = 'db'\n    return string(binary)\n}\n\
    \nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpkkaehvb5_test.go:31:17: illegal rune literal

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074490
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    for i := 0; i < decimal;\
    \ i++ {\n        result += \"1\"\n    }\n    for i := decimal; i < 32; i++ {\n\
    \        result += \"0\"\n    }\n    result += \"db\"\n    return result\n}\n\n\
    func TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpal3yvzpz_test.go:47: expected 'db0db', got '00000000000000000000000000000000db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpal3yvzpz_test.go:47:\
    \ expected 'db100000db', got '00000000000000000000000000000000db'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpal3yvzpz_test.go:47: expected\
    \ 'db1100111db', got '10000000000000000000000000000000db'\n    --- FAIL: TestDecimal_To_Binary/test_num__3\
    \ (0.00s)\n        tmpal3yvzpz_test.go:47: expected 'db1111db', got '10000000000000000000000000000000db'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074491
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n     \
    \   result += \"1\"\n    }\n    for i := 0; i < decimal; i++ {\n        result\
    \ += \"0\"\n    }\n    result += \"db\"\n    return result\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp4y534hoc_test.go:47: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp4y534hoc_test.go:47:\
    \ expected 'db100000db', got 'db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmp4y534hoc_test.go:47: expected 'db1100111db', got '10db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp4y534hoc_test.go:47:\
    \ expected 'db1111db', got '10db'\nFAIL\nFAIL\tcommand-line-arguments\t0.011s\n\
    FAIL\n"
  timestamp: 1660074491
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n     \
    \   result += binary_to_decimal(decimal)\n    }\n    decimal /= 2\n    if decimal\
    \ > 0 {\n        result += binary_to_decimal(decimal)\n    }\n    decimal /= 2\n\
    \    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n    }\n \
    \   decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= \nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpnkc5b_ds_test.go:117:6: expected ''('', found TestDecimal_To_Binary

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074381
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    for i := 0; i < decimal;\
    \ i++ {\n        result += \"1\"\n    }\n    for i := decimal; i > 0; i-- {\n\
    \        result += \"0\"\n    }\n    return \"db\" + result + \"db\"\n}\n\nfunc\
    \ TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpj6kk67ci_test.go:46: expected 'db0db', got 'dbdb'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpj6kk67ci_test.go:46:\
    \ expected 'db100000db', got 'dbdb'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpj6kk67ci_test.go:46: expected 'db1100111db', got 'db10db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpj6kk67ci_test.go:46:\
    \ expected 'db1111db', got 'db10db'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074491
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n     \
    \   result += decimal_to_binary(decimal/2)\n    }\n    result += \"1\"\n    return\
    \ result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpsr91us8y_test.go:44: expected 'db0db', got '1'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpsr91us8y_test.go:44:\
    \ expected 'db100000db', got '1'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpsr91us8y_test.go:44: expected 'db1100111db', got '11'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpsr91us8y_test.go:44:\
    \ expected 'db1111db', got '11'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\n\
    FAIL\n"
  timestamp: 1660074491
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n     \
    \   result += binary_to_decimal(decimal)\n    }\n    decimal /= 2\n    if decimal\
    \ > 0 {\n        result += binary_to_decimal(decimal)\n    }\n    return result\n\
    }\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyphcuo4j_test.go:22:19: undefined: binary_to_decimal

    /tmp/tmpyphcuo4j_test.go:26:19: undefined: binary_to_decimal

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074382
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    binary := \"\"\n    decimal %= 2\n    if decimal > 0 {\n     \
    \   binary += \"1\"\n    }\n    for i := 0; i < decimal; i++ {\n        binary\
    \ += \"0\"\n    }\n    return binary + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmps8xqk7w5_test.go:46: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmps8xqk7w5_test.go:46:\
    \ expected 'db100000db', got 'db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmps8xqk7w5_test.go:46: expected 'db1100111db', got '10db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmps8xqk7w5_test.go:46:\
    \ expected 'db1111db', got '10db'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074382
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n     \
    \   result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 1 {\n    \
    \    result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 2 {\n   \
    \     result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 3 {\n  \
    \      result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 4 {\n \
    \       result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 5 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 6 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 7 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 8 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 9 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 10 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 11 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 12 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 13 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 14 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 15 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 16 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 17 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 18 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 19 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 20 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 21 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 22 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 23 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 24 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 25 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 26 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 27 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 28 {\n\
    \        result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 29 {\n\
    \        result += decimal_to_binary(decimal/2)\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpuvrce25e_test.go:110:6: expected ''('', found TestDecimal_To_Binary

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074490
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    for i := 0; i < len(decimal);\
    \ i++ {\n        if decimal > 0 {\n            result += fmt.Sprintf(\"%c\", decimal%2)\n\
    \            decimal /= 2\n        } else {\n            result += fmt.Sprintf(\"\
    %c\", decimal%2)\n            decimal *= 2\n        }\n    }\n    return \"db\"\
    \ + result + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqkhu5g09_test.go:21:25: invalid argument: decimal (variable of type int)
    for len

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074388
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    i := 0\n    for ; i < decimal; i++ {\n   \
    \     result += \"0\"\n    }\n    for ; i < decimal; i++ {\n        result +=\
    \ \"1\"\n    }\n    return \"db\" + result + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp5fx633e8_test.go:46: expected 'db0db', got 'dbdb'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp5fx633e8_test.go:46:\
    \ expected 'db100000db', got 'db00000000000000000000000000000000db'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmp5fx633e8_test.go:46: expected\
    \ 'db1100111db', got 'db0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp5fx633e8_test.go:46:\
    \ expected 'db1111db', got 'db000000000000000db'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074491
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n     \
    \   result += \"1\"\n    }\n    for i := 0; i < decimal; i++ {\n        result\
    \ += \"0\"\n    }\n    return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpopc6z5a3_test.go:46: expected 'db0db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpopc6z5a3_test.go:46: expected\
    \ 'db100000db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n\
    \        tmpopc6z5a3_test.go:46: expected 'db1100111db', got '10'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpopc6z5a3_test.go:46: expected\
    \ 'db1111db', got '10'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074383
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n     \
    \   result += fmt.Sprintf(\"%d\", decimal)\n        decimal /= 2\n    }\n    for\
    \ i := 0; i < decimal; i++ {\n        result += \"1\"\n    }\n    return result\n\
    }\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmphx766qwu_test.go:47: expected 'db0db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmphx766qwu_test.go:47: expected\
    \ 'db100000db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n\
    \        tmphx766qwu_test.go:47: expected 'db1100111db', got '1'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmphx766qwu_test.go:47: expected\
    \ 'db1111db', got '1'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074491
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    // Write your code here\n    result := \"\"\n    decimal %= 2\n\
    \    decimal /= 2\n    for i := 0; i < decimal; i++ {\n        result += \"1\"\
    \n    }\n    for i := decimal; i > 0; i-- {\n        result += \"0\"\n    }\n\
    \    return \"db\" + result + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpjgvakoda_test.go:48: expected 'db0db', got 'dbdb'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpjgvakoda_test.go:48:\
    \ expected 'db100000db', got 'dbdb'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpjgvakoda_test.go:48: expected 'db1100111db', got 'dbdb'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpjgvakoda_test.go:48:\
    \ expected 'db1111db', got 'dbdb'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\n\
    FAIL\n"
  timestamp: 1660074491
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n     \
    \   result += decimal_to_binary(decimal/2)\n    }\n    if decimal % 2 == 0 {\n\
    \        result += \"1\"\n    } else {\n        result += \"0\"\n    }\n    return\
    \ result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpxhi37q0u_test.go:48: expected 'db0db', got '1'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpxhi37q0u_test.go:48:\
    \ expected 'db100000db', got '1'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpxhi37q0u_test.go:48: expected 'db1100111db', got '10'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpxhi37q0u_test.go:48:\
    \ expected 'db1111db', got '10'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074391
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    // Your code here\n    result := \"\"\n    temp := decimal\n \
    \   for i := 0; i < 32; i++ {\n        if temp%2 == 0 {\n            result +=\
    \ \"1\"\n        } else {\n            result += \"0\"\n        }\n        temp\
    \ /= 2\n    }\n    return \"db\" + result + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmprqt0kd7v_test.go:49: expected 'db0db', got 'db11111111111111111111111111111111db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmprqt0kd7v_test.go:49:\
    \ expected 'db100000db', got 'db11111011111111111111111111111111db'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmprqt0kd7v_test.go:49: expected\
    \ 'db1100111db', got 'db00011001111111111111111111111111db'\n    --- FAIL: TestDecimal_To_Binary/test_num__3\
    \ (0.00s)\n        tmprqt0kd7v_test.go:49: expected 'db1111db', got 'db00001111111111111111111111111111db'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074493
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n     \
    \   result += binary_to_decimal(decimal)\n    }\n    decimal /= 2\n    if decimal\
    \ > 0 {\n        result += binary_to_decimal(decimal)\n    }\n    return result\n\
    }\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyphcuo4j_test.go:22:19: undefined: binary_to_decimal

    /tmp/tmpyphcuo4j_test.go:26:19: undefined: binary_to_decimal

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074382
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    temp := decimal % 2\n    decimal /= 2\n  \
    \  for i := 0; i < decimal; i++ {\n        if temp == 0 {\n            result\
    \ += \"0\"\n        } else {\n            result += \"1\"\n        }\n       \
    \ temp = temp / 2\n    }\n    if decimal > 0 {\n        result += \"1\"\n    }\n\
    \    return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpnpivv9x8_test.go:52: expected 'db0db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpnpivv9x8_test.go:52: expected\
    \ 'db100000db', got '00000000000000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpnpivv9x8_test.go:52: expected 'db1100111db', got '1000000000000000000000000000000000000000000000000001'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpnpivv9x8_test.go:52:\
    \ expected 'db1111db', got '10000001'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074493
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n     \
    \   result += binary_to_decimal(decimal)\n    }\n    decimal /= 2\n    if decimal\
    \ > 0 {\n        result += binary_to_decimal(decimal)\n    }\n    return result\n\
    }\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyphcuo4j_test.go:22:19: undefined: binary_to_decimal

    /tmp/tmpyphcuo4j_test.go:26:19: undefined: binary_to_decimal

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074382
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n     \
    \   result += binary_to_decimal(decimal)\n    }\n    decimal /= 2\n    if decimal\
    \ > 0 {\n        result += binary_to_decimal(decimal)\n    }\n    return result\n\
    }\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyphcuo4j_test.go:22:19: undefined: binary_to_decimal

    /tmp/tmpyphcuo4j_test.go:26:19: undefined: binary_to_decimal

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074382
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n     \
    \   result += \"1\"\n    }\n    for i := 0; i < decimal; i++ {\n        result\
    \ += \"0\"\n    }\n    return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpopc6z5a3_test.go:46: expected 'db0db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpopc6z5a3_test.go:46: expected\
    \ 'db100000db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n\
    \        tmpopc6z5a3_test.go:46: expected 'db1100111db', got '10'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpopc6z5a3_test.go:46: expected\
    \ 'db1111db', got '10'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074383
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n     \
    \   result += binary_to_decimal(decimal)\n    }\n    decimal /= 2\n    if decimal\
    \ > 0 {\n        result += binary_to_decimal(decimal)\n    }\n    decimal /= 2\n\
    \    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n    }\n \
    \   decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= \nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpnkc5b_ds_test.go:117:6: expected ''('', found TestDecimal_To_Binary

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074381
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n     \
    \   result += binary_to_decimal(decimal)\n    }\n    decimal /= 2\n    if decimal\
    \ > 0 {\n        result += binary_to_decimal(decimal)\n    }\n    decimal %= 2\n\
    \    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n    }\n \
    \   decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal %= \nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp3qmzun0i_test.go:117:6: expected ''('', found TestDecimal_To_Binary

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074491
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    binaryString := \"\"\n    for i := 0; i < decimal; i++ {\n   \
    \     if i%2 == 0 {\n            binaryString += \"1\"\n        } else {\n   \
    \         binaryString += \"0\"\n        }\n    }\n    return \"db\" + binaryString\n\
    }\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp9bptvtz5_test.go:46: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp9bptvtz5_test.go:46:\
    \ expected 'db100000db', got 'db10101010101010101010101010101010'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmp9bptvtz5_test.go:46: expected\
    \ 'db1100111db', got 'db1010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp9bptvtz5_test.go:46:\
    \ expected 'db1111db', got 'db101010101010101'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660074493
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    for i := 0; i < len(decimal);\
    \ i++ {\n        if decimal > 0 {\n            result += fmt.Sprintf(\"%c\", decimal%2)\n\
    \            decimal /= 2\n        } else {\n            result += fmt.Sprintf(\"\
    %c\", decimal%2)\n            decimal *= 2\n        }\n    }\n    return \"db\"\
    \ + result + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqkhu5g09_test.go:21:25: invalid argument: decimal (variable of type int)
    for len

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074388
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    // Your code here\n    result := \"\"\n    decimal %= 2\n    for\
    \ i := 0; i < decimal; i++ {\n        result += \"1\"\n    }\n    for i := decimal\
    \ - 1; i >= 0; i-- {\n        result += \"0\"\n    }\n    return \"db\" + result\
    \ + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpg_f2xf3h_test.go:47: expected 'db0db', got 'dbdb'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpg_f2xf3h_test.go:47:\
    \ expected 'db100000db', got 'dbdb'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpg_f2xf3h_test.go:47: expected 'db1100111db', got 'db10db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpg_f2xf3h_test.go:47:\
    \ expected 'db1111db', got 'db10db'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074493
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    for i := 0; i < decimal;\
    \ i++ {\n        result += \"0\"\n    }\n    result += \"1\"\n    return result\n\
    }\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp82rsg2ko_test.go:44: expected 'db0db', got '1'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp82rsg2ko_test.go:44:\
    \ expected 'db100000db', got '1'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmp82rsg2ko_test.go:44: expected 'db1100111db', got '01'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp82rsg2ko_test.go:44:\
    \ expected 'db1111db', got '01'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074382
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n     \
    \   result += fmt.Sprintf(\"%d\", decimal)\n    }\n    decimal /= 2\n    if decimal\
    \ > 0 {\n        result += fmt.Sprintf(\"%d\", decimal)\n    }\n    decimal /=\
    \ 2\n    if decimal > 0 {\n        result += fmt.Sprintf(\"%d\", decimal)\n  \
    \  }\n    decimal /= 2\n    if decimal > 0 {\n        result += fmt.Sprintf(\"\
    %d\", decimal)\n    }\n    decimal /= 2\n    if decimal > 0 {\n        result\
    \ += fmt.Sprintf(\"%d\", decimal)\n    }\n    decimal /= 2\n    if decimal > 0\
    \ {\n        result += fmt.Sprintf(\"%d\", decimal)\n    }\n    decimal /= 2\n\
    \    if decimal > 0 {\n        result += fmt.Sprintf(\"%d\", decimal)\n    }\n\
    \    decimal /= 2\n    if decimal > 0 {\n        result += fmt.Sprintf(\"%d\"\
    , decimal)\n    }\n    decimal /= 2\n    if decimal > 0 {\n        result += fmt.Sprintf(\"\
    %d\", decimal)\n    }\n    decimal /= 2\n    if decimal > 0 {\n        result\
    \ += fmt.Sprintf(\"%d\", decimal)\n    }\n    decimal /= 2\n    if decimal > 0\
    \ {\n        result += fmt.Sprintf(\"%d\", decimal)\n    }\n    decimal /= 2\n\
    \    if decimal > 0 {\n        result += fmt.Sprintf(\"%d\", decimal)\n    }\n\
    \    decimal /= 2\n    if decimal > 0 {\n        result += fmt.Sprintf(\"%d\"\
    , decimal)\n    }\n    decimal /= 2\n    if decimal > 0 {\n        result += fmt.Sprintf(\"\
    %d\", decimal)\n    }\n    decimal /= 2\n    if decimal > 0 {\n        result\
    \ += fmt.Sprintf(\"%d\", decimal)\n    }\n    decimal /= 2\n    if decimal > 0\
    \ {\n        result += fmt.Sprintf(\"%d\", decimal)\n    }\n    decimal /= 2\n\
    \    if decimal > 0 {\n        result += fmt.Sprintf(\"%d\", decimal)\n    }\n\
    \    decimal /= 2\n    if decimal > 0 {\n        result += fmt.Sprintf(\"%d\"\
    , decimal)\n    }\n    decimal /= 2\n    if decimal > 0 {\n        result += fmt.Sprintf(\"\
    %d\", decimal)\n    }\n    decimal /= 2\n    if decimal > 0 {\n        result\
    \ += fmt.Sprintf(\"%d\", decimal)\n    }\n    decimal /= 2\n    if decimal > 0\
    \ {\n        result += fmt.Sprintf(\"%d\", decimal)\n    }\n    decimal /= 2\n\
    \    if decimal > 0 {\n        result += fmt.Sprintf(\"%d\", decimal)\n    }\n\
    \    decimal /= 2\n    if decimal > 0 {\n        result += fmt.Sprintf(\"%d\"\
    , decimal)\n    }\n    decimal /= 2\n    if decimal > 0 {\n        result += fmt.Sprintf(\"\
    %d\", decimal)\n    }\n    decimal /= \nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp7aemokmx_test.go:117:6: expected ''('', found TestDecimal_To_Binary

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074381
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    // Your code here\n    result := \"\"\n    decimal %= 2\n    if\
    \ decimal > 0 {\n        result += \"1\"\n    }\n    for i := 0; i < decimal;\
    \ i++ {\n        result += \"0\"\n    }\n    result += \"db\"\n    return result\n\
    }\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpkhiej8j1_test.go:48: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpkhiej8j1_test.go:48:\
    \ expected 'db100000db', got 'db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpkhiej8j1_test.go:48: expected 'db1100111db', got '10db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpkhiej8j1_test.go:48:\
    \ expected 'db1111db', got '10db'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074386
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    binaryString := \"\"\n    binaryString += \"db\"\n    for i :=\
    \ 0; i < decimal; i++ {\n        if i%2 == 0 {\n            binaryString += \"\
    1\"\n        } else {\n            binaryString += \"0\"\n        }\n    }\n \
    \   return binaryString\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpgfd1q_zy_test.go:47: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpgfd1q_zy_test.go:47:\
    \ expected 'db100000db', got 'db10101010101010101010101010101010'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpgfd1q_zy_test.go:47: expected\
    \ 'db1100111db', got 'db1010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpgfd1q_zy_test.go:47:\
    \ expected 'db1111db', got 'db101010101010101'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074384
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n     \
    \   result += binary_to_decimal(decimal)\n    }\n    decimal /= 2\n    if decimal\
    \ > 0 {\n        result += binary_to_decimal(decimal)\n    }\n    decimal %= 2\n\
    \    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n    }\n \
    \   decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal %= \nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp3qmzun0i_test.go:117:6: expected ''('', found TestDecimal_To_Binary

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074491
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    for i := 0; i < decimal;\
    \ i++ {\n        result += \"0\"\n    }\n    result += \"1\"\n    return result\n\
    }\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp82rsg2ko_test.go:44: expected 'db0db', got '1'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp82rsg2ko_test.go:44:\
    \ expected 'db100000db', got '1'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmp82rsg2ko_test.go:44: expected 'db1100111db', got '01'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp82rsg2ko_test.go:44:\
    \ expected 'db1111db', got '01'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074382
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n     \
    \   result += binary_to_decimal(decimal)\n    }\n    decimal /= 2\n    if decimal\
    \ > 0 {\n        result += binary_to_decimal(decimal)\n    }\n    return result\n\
    }\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyphcuo4j_test.go:22:19: undefined: binary_to_decimal

    /tmp/tmpyphcuo4j_test.go:26:19: undefined: binary_to_decimal

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074382
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    for i := 0; i < decimal;\
    \ i++ {\n        result += \"0\"\n    }\n    result += \"1\"\n    return result\n\
    }\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp82rsg2ko_test.go:44: expected 'db0db', got '1'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp82rsg2ko_test.go:44:\
    \ expected 'db100000db', got '1'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmp82rsg2ko_test.go:44: expected 'db1100111db', got '01'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp82rsg2ko_test.go:44:\
    \ expected 'db1111db', got '01'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074382
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n     \
    \   result += fmt.Sprintf(\"%c\", decimal)\n        decimal /= 2\n    }\n    for\
    \ i := 0; i < decimal; i++ {\n        result += fmt.Sprintf(\"%c\", '0')\n   \
    \ }\n    return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpg_dnpe3__test.go:47: expected 'db0db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpg_dnpe3__test.go:47: expected\
    \ 'db100000db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n\
    \        tmpg_dnpe3__test.go:47: expected 'db1100111db', got '\x01'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpg_dnpe3__test.go:47: expected\
    \ 'db1111db', got '\x01'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074493
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    temp := decimal\n    for i := 0; i < 32; i++\
    \ {\n        if temp > 0 {\n            result += \"1\"\n            temp -= 10\n\
    \        } else {\n            result += \"0\"\n            temp += 10\n     \
    \   }\n    }\n    return \"db\" + result + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpnyqfp4ci_test.go:49: expected 'db0db', got 'db01010101010101010101010101010101db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpnyqfp4ci_test.go:49:\
    \ expected 'db100000db', got 'db11110101010101010101010101010101db'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpnyqfp4ci_test.go:49: expected\
    \ 'db1100111db', got 'db11111111111010101010101010101010db'\n    --- FAIL: TestDecimal_To_Binary/test_num__3\
    \ (0.00s)\n        tmpnyqfp4ci_test.go:49: expected 'db1111db', got 'db11010101010101010101010101010101db'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074494
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n     \
    \   result += binary_to_decimal(decimal)\n    }\n    decimal /= 2\n    if decimal\
    \ > 0 {\n        result += binary_to_decimal(decimal)\n    }\n    return result\n\
    }\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyphcuo4j_test.go:22:19: undefined: binary_to_decimal

    /tmp/tmpyphcuo4j_test.go:26:19: undefined: binary_to_decimal

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074382
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    binary := make([]byte, 32)\n    i := 0\n    for decimal%2 == 0\
    \ {\n        binary[i] = '1'\n        decimal = decimal / 2\n        i++\n   \
    \ }\n    for decimal%2 == 1 {\n        binary[i] = '0'\n        decimal = decimal\
    \ / 2\n        i++\n    }\n    binary[i] = 'b'\n    return string(binary)\n}\n\
    \nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\npanic: runtime error: index out\
    \ of range [32] with length 32 [recovered]\n\tpanic: runtime error: index out\
    \ of range [32] with length 32\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513640,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513640, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.decimal_to_binary(...)\n\t/tmp/tmplh69y52t_test.go:22\n\
    command-line-arguments_test.TestDecimal_To_Binary(0x0?)\n\t/tmp/tmplh69y52t_test.go:42\
    \ +0x5ec\ntesting.tRunner(0xc0000da340, 0x528f88)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074386
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    binary := \"\"\n    decimal %= 2\n    if decimal > 0 {\n     \
    \   binary += \"1\"\n    }\n    for i := 0; i < decimal; i++ {\n        binary\
    \ += \"0\"\n    }\n    return binary + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmps8xqk7w5_test.go:46: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmps8xqk7w5_test.go:46:\
    \ expected 'db100000db', got 'db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmps8xqk7w5_test.go:46: expected 'db1100111db', got '10db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmps8xqk7w5_test.go:46:\
    \ expected 'db1111db', got '10db'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074382
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    for i := 0; i < decimal;\
    \ i++ {\n        result += \"0\"\n    }\n    result += \"1\"\n    result += \"\
    db\"\n    return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpnbbo4poz_test.go:45: expected 'db0db', got '1db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpnbbo4poz_test.go:45:\
    \ expected 'db100000db', got '1db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpnbbo4poz_test.go:45: expected 'db1100111db', got '01db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpnbbo4poz_test.go:45:\
    \ expected 'db1111db', got '01db'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074382
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    for i := 0; i < decimal;\
    \ i++ {\n        result += \"0\"\n    }\n    result += \"1\"\n    return result\n\
    }\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp82rsg2ko_test.go:44: expected 'db0db', got '1'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp82rsg2ko_test.go:44:\
    \ expected 'db100000db', got '1'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmp82rsg2ko_test.go:44: expected 'db1100111db', got '01'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp82rsg2ko_test.go:44:\
    \ expected 'db1111db', got '01'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074382
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    i := 0\n    for ; decimal > 0; decimal = decimal\
    \ / 2 {\n        result += fmt.Sprintf(\"%c\", decimal%2)\n        i++\n    }\n\
    \    for ; decimal > 0; decimal = decimal / 2 {\n        result += fmt.Sprintf(\"\
    %c\", decimal%2)\n    }\n    result += \"db\"\n    return result\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpl94117wj_test.go:48: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpl94117wj_test.go:48:\
    \ expected 'db100000db', got '\0\0\0\0\0\x01db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpl94117wj_test.go:48: expected 'db1100111db', got '\x01\x01\
    \x01\0\0\x01\x01db'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n\
    \        tmpl94117wj_test.go:48: expected 'db1111db', got '\x01\x01\x01\x01db'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074494
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    binary := make([]byte, 32)\n    i := 0\n    for decimal%2 == 0\
    \ {\n        binary[i] = '0'\n        decimal = decimal / 2\n        i++\n   \
    \ }\n    for decimal%2 == 1 {\n        binary[i] = '1'\n        decimal = decimal\
    \ / 2\n        i++\n    }\n    binary[i] = 'd'\n    binary[i+4] = 'b'\n    binary[i+8]\
    \ = 'b'\n    binary[i+12] = 'b'\n    return string(binary)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\npanic: runtime error: index out\
    \ of range [32] with length 32 [recovered]\n\tpanic: runtime error: index out\
    \ of range [32] with length 32\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513640,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513640, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.decimal_to_binary(...)\n\t/tmp/tmp1mgu8mqr_test.go:22\n\
    command-line-arguments_test.TestDecimal_To_Binary(0x0?)\n\t/tmp/tmp1mgu8mqr_test.go:45\
    \ +0x7b3\ntesting.tRunner(0xc0000da1a0, 0x528f88)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074494
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n     \
    \   for i := 0; i < decimal; i++ {\n            result += \"1\"\n        }\n \
    \   } else {\n        for i := 0; i < decimal; i++ {\n            result += \"\
    0\"\n        }\n    }\n    return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpu9tpp7wo_test.go:49: expected 'db0db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpu9tpp7wo_test.go:49: expected\
    \ 'db100000db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n\
    \        tmpu9tpp7wo_test.go:49: expected 'db1100111db', got '1'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpu9tpp7wo_test.go:49: expected\
    \ 'db1111db', got '1'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074382
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n     \
    \   result += binary_to_decimal(decimal)\n    }\n    decimal /= 2\n    if decimal\
    \ > 0 {\n        result += binary_to_decimal(decimal)\n    }\n    return result\n\
    }\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyphcuo4j_test.go:22:19: undefined: binary_to_decimal

    /tmp/tmpyphcuo4j_test.go:26:19: undefined: binary_to_decimal

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074382
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    for i := 0; i < len(strconv.Itoa(decimal));\
    \ i++ {\n        result += \"0\"\n    }\n    result += \"1\"\n    return result\n\
    }\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7s5bx8_9_test.go:21:25: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074383
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    temp := decimal\n    for temp > 0 {\n    \
    \    result += \"0\"\n        temp--\n    }\n    for temp > 0 {\n        result\
    \ += \"1\"\n        temp--\n    }\n    return \"db\" + result\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp8if39vh__test.go:48: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp8if39vh__test.go:48:\
    \ expected 'db100000db', got 'db00000000000000000000000000000000'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmp8if39vh__test.go:48: expected\
    \ 'db1100111db', got 'db0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp8if39vh__test.go:48:\
    \ expected 'db1111db', got 'db000000000000000'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660074389
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    // Your code here\n    result := \"\"\n    decimal %= 2\n    for\
    \ i := 0; i < decimal; i++ {\n        result += \"0\"\n    }\n    decimal /= 2\n\
    \    for i := 0; i < decimal; i++ {\n        result += \"1\"\n    }\n    result\
    \ += \"db\"\n    return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp5krg5kvo_test.go:49: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp5krg5kvo_test.go:49:\
    \ expected 'db100000db', got 'db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmp5krg5kvo_test.go:49: expected 'db1100111db', got '0db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp5krg5kvo_test.go:49:\
    \ expected 'db1111db', got '0db'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\n\
    FAIL\n"
  timestamp: 1660074388
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    binary := \"\"\n    for i := 0; i < decimal; i++ {\n        if\
    \ decimal % 2 == 0 {\n            binary += \"1\"\n        } else {\n        \
    \    binary += \"0\"\n        }\n        decimal /= 2\n    }\n    return binary\
    \ + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpx7cgvww2_test.go:47: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpx7cgvww2_test.go:47:\
    \ expected 'db100000db', got '1111db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpx7cgvww2_test.go:47: expected 'db1100111db', got '00011db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpx7cgvww2_test.go:47:\
    \ expected 'db1111db', got '000db'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074494
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n     \
    \   for i := 0; i < decimal; i++ {\n            result += \"1\"\n        }\n \
    \   } else {\n        for i := 0; i < decimal; i++ {\n            result += \"\
    0\"\n        }\n    }\n    return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpu9tpp7wo_test.go:49: expected 'db0db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpu9tpp7wo_test.go:49: expected\
    \ 'db100000db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n\
    \        tmpu9tpp7wo_test.go:49: expected 'db1100111db', got '1'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpu9tpp7wo_test.go:49: expected\
    \ 'db1111db', got '1'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074382
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n     \
    \   result += \"1\"\n    }\n    for i := 0; i < decimal; i++ {\n        result\
    \ += \"0\"\n    }\n    return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpopc6z5a3_test.go:46: expected 'db0db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpopc6z5a3_test.go:46: expected\
    \ 'db100000db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n\
    \        tmpopc6z5a3_test.go:46: expected 'db1100111db', got '10'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpopc6z5a3_test.go:46: expected\
    \ 'db1111db', got '10'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074383
- exit_code: null
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n     \
    \   result += fmt.Sprintf(\"%c\", decimal)\n    }\n    for i := 0; i < len(result);\
    \ i++ {\n        if decimal > 0 {\n            result += fmt.Sprintf(\"%c\", decimal%2)\n\
    \            decimal /= 2\n        } else {\n            result += fmt.Sprintf(\"\
    %c\", 1)\n        }\n    }\n    return \"db\" + result\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660074506
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n     \
    \   result += fmt.Sprintf(\"%d\", decimal)\n    }\n    for i := 0; i < len(result);\
    \ i++ {\n        decimal /= 2\n        if decimal > 0 {\n            result +=\
    \ fmt.Sprintf(\"%d\", decimal)\n        }\n    }\n    return \"db\" + result +\
    \ \"db\"\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp9x9l2f8q_test.go:49: expected 'db0db', got 'dbdb'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp9x9l2f8q_test.go:49:\
    \ expected 'db100000db', got 'dbdb'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmp9x9l2f8q_test.go:49: expected 'db1100111db', got 'db1db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp9x9l2f8q_test.go:49:\
    \ expected 'db1111db', got 'db1db'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\n\
    FAIL\n"
  timestamp: 1660074494
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    binaryString := \"\"\n    binaryString += \"db\"\n    for i :=\
    \ 0; i < decimal; i++ {\n        binaryString += \"0\"\n    }\n    return binaryString\n\
    }\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpcugnncu__test.go:43: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpcugnncu__test.go:43:\
    \ expected 'db100000db', got 'db00000000000000000000000000000000'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpcugnncu__test.go:43: expected\
    \ 'db1100111db', got 'db0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpcugnncu__test.go:43:\
    \ expected 'db1111db', got 'db000000000000000'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074494
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    // Your code here\n    result := \"\"\n    i := 0\n    for i <\
    \ decimal {\n        if decimal % 2 == 0 {\n            result += fmt.Sprintf(\"\
    0\", decimal%2)\n        } else {\n            result += fmt.Sprintf(\"1\", decimal%2)\n\
    \        }\n        i++\n        decimal /= 2\n    }\n    result += \"db\"\n \
    \   return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test

    /tmp/tmpejxh0fjs_test.go:24:34: fmt.Sprintf call has arguments but no formatting
    directives

    /tmp/tmpejxh0fjs_test.go:26:34: fmt.Sprintf call has arguments but no formatting
    directives

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074494
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    binaryString := \"\"\n    decimal %= 2\n    for i := 0; i < len(binaryString);\
    \ i++ {\n        if decimal > 0 {\n            binaryString += \"1\"\n       \
    \     decimal--\n        } else {\n            binaryString += \"0\"\n       \
    \ }\n    }\n    return \"db\" + binaryString\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmphowo6fas_test.go:48: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmphowo6fas_test.go:48:\
    \ expected 'db100000db', got 'db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmphowo6fas_test.go:48: expected 'db1100111db', got 'db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmphowo6fas_test.go:48:\
    \ expected 'db1111db', got 'db'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074494
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    for i := 0; i < decimal;\
    \ i++ {\n        result += \"0\"\n    }\n    result += \"1\"\n    result += \"\
    db\"\n    return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpnbbo4poz_test.go:45: expected 'db0db', got '1db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpnbbo4poz_test.go:45:\
    \ expected 'db100000db', got '1db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpnbbo4poz_test.go:45: expected 'db1100111db', got '01db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpnbbo4poz_test.go:45:\
    \ expected 'db1111db', got '01db'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074382
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n     \
    \   result += \"1\"\n    }\n    for i := 0; i < decimal; i++ {\n        result\
    \ += \"0\"\n    }\n    return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpopc6z5a3_test.go:46: expected 'db0db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpopc6z5a3_test.go:46: expected\
    \ 'db100000db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n\
    \        tmpopc6z5a3_test.go:46: expected 'db1100111db', got '10'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpopc6z5a3_test.go:46: expected\
    \ 'db1111db', got '10'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074383
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n     \
    \   result += binary_to_decimal(decimal)\n    }\n    decimal /= 2\n    if decimal\
    \ > 0 {\n        result += binary_to_decimal(decimal)\n    }\n    return result\n\
    }\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyphcuo4j_test.go:22:19: undefined: binary_to_decimal

    /tmp/tmpyphcuo4j_test.go:26:19: undefined: binary_to_decimal

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074382
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    binary := make([]byte, 32)\n    i := 0\n    for decimal>0 {\n\
    \        binary[i] = byte(decimal%2)\n        decimal /= 2\n        i++\n    }\n\
    \    binary[i] = 'b'\n    return string(binary)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpt042t12h_test.go:46: expected 'db0db', got 'b\0\0\0\0\0\0\
    \0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0'\n    --- FAIL: TestDecimal_To_Binary/test_num__1\
    \ (0.00s)\n        tmpt042t12h_test.go:46: expected 'db100000db', got '\0\0\0\0\
    \0\x01b\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpt042t12h_test.go:46: expected 'db1100111db', got '\x01\x01\
    \x01\0\0\x01\x01b\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpt042t12h_test.go:46: expected\
    \ 'db1111db', got '\x01\x01\x01\x01b\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\
    \0\0\0\0\0\0'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074494
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    for i := 0; i < decimal;\
    \ i++ {\n        result += \"0\"\n    }\n    decimal /= 2\n    for i := decimal;\
    \ i > 0; i-- {\n        result += \"1\"\n    }\n    return \"db\" + result + \"\
    db\"\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpqb1_tf3u_test.go:47: expected 'db0db', got 'dbdb'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpqb1_tf3u_test.go:47:\
    \ expected 'db100000db', got 'dbdb'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpqb1_tf3u_test.go:47: expected 'db1100111db', got 'db0db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpqb1_tf3u_test.go:47:\
    \ expected 'db1111db', got 'db0db'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074494
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n     \
    \   result += binary_to_decimal(decimal)\n    }\n    if decimal > 1 {\n      \
    \  result += binary_to_decimal(decimal - 1)\n    }\n    return result\n}\n\nfunc\
    \ TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9vla42xs_test.go:22:19: undefined: binary_to_decimal

    /tmp/tmp9vla42xs_test.go:25:19: undefined: binary_to_decimal

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074491
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    temp := decimal\n    for temp > 0 {\n    \
    \    result += \"0\"\n        temp--\n    }\n    result += \"1\"\n    return result\n\
    }\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpj4ezv6kf_test.go:45: expected 'db0db', got '1'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpj4ezv6kf_test.go:45:\
    \ expected 'db100000db', got '000000000000000000000000000000001'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpj4ezv6kf_test.go:45: expected\
    \ 'db1100111db', got '00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpj4ezv6kf_test.go:45:\
    \ expected 'db1111db', got '0000000000000001'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074494
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n     \
    \   result += \"1\"\n    }\n    for i := 0; i < decimal; i++ {\n        result\
    \ += \"0\"\n    }\n    result += \"db\"\n    return result\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp4y534hoc_test.go:47: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp4y534hoc_test.go:47:\
    \ expected 'db100000db', got 'db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmp4y534hoc_test.go:47: expected 'db1100111db', got '10db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp4y534hoc_test.go:47:\
    \ expected 'db1111db', got '10db'\nFAIL\nFAIL\tcommand-line-arguments\t0.011s\n\
    FAIL\n"
  timestamp: 1660074491
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    binary := \"\"\n    for i := 0; i < decimal; i++ {\n        binary\
    \ += \"0\"\n    }\n    for i := decimal - 1; i >= 0; i-- {\n        binary +=\
    \ \"1\"\n    }\n    return \"db\" + binary + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpaqywyly__test.go:45: expected 'db0db', got 'dbdb'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpaqywyly__test.go:45:\
    \ expected 'db100000db', got 'db0000000000000000000000000000000011111111111111111111111111111111db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpaqywyly__test.go:45:\
    \ expected 'db1100111db', got 'db00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpaqywyly__test.go:45:\
    \ expected 'db1111db', got 'db000000000000000111111111111111db'\nFAIL\nFAIL\t\
    command-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074494
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n     \
    \   result += fmt.Sprintf(\"%c\", decimal)\n    }\n    decimal /= 2\n    if decimal\
    \ > 0 {\n        result += fmt.Sprintf(\"%c\", decimal)\n    }\n    return result\n\
    }\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpa6a4k6f6_test.go:47: expected 'db0db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpa6a4k6f6_test.go:47: expected\
    \ 'db100000db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n\
    \        tmpa6a4k6f6_test.go:47: expected 'db1100111db', got '\x01'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpa6a4k6f6_test.go:47: expected\
    \ 'db1111db', got '\x01'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074494
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    binaryString := \"\"\n    binaryString += \"db\"\n    binaryString\
    \ += fmt.Sprintf(\"%0*d\", decimal, decimal)\n    binaryString += \"db\"\n   \
    \ return binaryString\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__1\
    \ (0.00s)\n        tmp5o89a_9q_test.go:42: expected 'db100000db', got 'db00000000000000000000000000000032db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmp5o89a_9q_test.go:42:\
    \ expected 'db1100111db', got 'db0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000103db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp5o89a_9q_test.go:42:\
    \ expected 'db1111db', got 'db000000000000015db'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074384
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n     \
    \   result += binary_to_decimal(decimal)\n    }\n    decimal /= 2\n    if decimal\
    \ > 0 {\n        result += binary_to_decimal(decimal)\n    }\n    decimal /= 2\n\
    \    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n    }\n \
    \   decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= \nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpnkc5b_ds_test.go:117:6: expected ''('', found TestDecimal_To_Binary

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074381
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    binary := make([]byte, 32)\n    i := 0\n    for ; decimal != 0;\
    \ decimal = decimal/2 {\n        binary[i] = byte(decimal % 2)\n        i++\n\
    \    }\n    binary[i] = '0'\n    binary[len(binary)-1] = '1'\n    return string(binary)\n\
    }\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpnrylti58_test.go:46: expected 'db0db', got '0\0\0\0\0\0\0\
    \0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\01'\n    --- FAIL: TestDecimal_To_Binary/test_num__1\
    \ (0.00s)\n        tmpnrylti58_test.go:46: expected 'db100000db', got '\0\0\0\0\
    \0\x010\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\01'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpnrylti58_test.go:46: expected 'db1100111db', got '\x01\x01\
    \x01\0\0\x01\x010\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\01'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpnrylti58_test.go:46: expected\
    \ 'db1111db', got '\x01\x01\x01\x010\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\
    \0\0\0\0\01'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074494
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    temp := decimal\n    i := 0\n    for temp\
    \ > 0 {\n        if temp%2 == 1 {\n            result += \"1\"\n        } else\
    \ {\n            result += \"0\"\n        }\n        temp /= 2\n        i++\n\
    \    }\n    return \"db\" + result + fmt.Sprintf(\"db%vd\", i)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp8qt_7hpc_test.go:50: expected 'db0db', got 'dbdb0d'\n  \
    \  --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp8qt_7hpc_test.go:50:\
    \ expected 'db100000db', got 'db000001db6d'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmp8qt_7hpc_test.go:50: expected 'db1100111db', got 'db1110011db7d'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp8qt_7hpc_test.go:50:\
    \ expected 'db1111db', got 'db1111db4d'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074494
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n     \
    \   result += decimal_to_binary(decimal/2)\n    }\n    decimal %= 2\n    if decimal\
    \ > 0 {\n        result += decimal_to_binary(decimal/2)\n    }\n    decimal %=\
    \ 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n  \
    \  }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= \nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpem5vjt3e_test.go:117:6: expected ''('', found TestDecimal_To_Binary

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074381
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    binaryString := \"\"\n    binaryString += \"db\"\n    for i :=\
    \ 0; i < decimal; i++ {\n        binaryString += \"0\"\n    }\n    for i := decimal;\
    \ i > 0; i-- {\n        binaryString += \"1\"\n    }\n    return binaryString\n\
    }\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpszdmco2p_test.go:46: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpszdmco2p_test.go:46:\
    \ expected 'db100000db', got 'db0000000000000000000000000000000011111111111111111111111111111111'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpszdmco2p_test.go:46:\
    \ expected 'db1100111db', got 'db00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpszdmco2p_test.go:46:\
    \ expected 'db1111db', got 'db000000000000000111111111111111'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074386
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    // Your code here\n    result := \"\"\n    decimal %= 2\n    for\
    \ i := 0; i < decimal; i++ {\n        result += \"0\"\n    }\n    result += \"\
    1\"\n    result += \"db\"\n    return result\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp3xexb5l7_test.go:46: expected 'db0db', got '1db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp3xexb5l7_test.go:46:\
    \ expected 'db100000db', got '1db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmp3xexb5l7_test.go:46: expected 'db1100111db', got '01db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp3xexb5l7_test.go:46:\
    \ expected 'db1111db', got '01db'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074391
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    // Your code here\n    result := \"\"\n    result += \"db\"\n\
    \    result += fmt.Sprintf(\"%0*d\", len(strconv.Itoa(decimal)), decimal)\n  \
    \  return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_1k_pwv7_test.go:22:39: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074494
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    for i := 0; i < len(decimal);\
    \ i++ {\n        if decimal > 0 {\n            result += fmt.Sprintf(\"%c\", decimal%2)\n\
    \            decimal /= 2\n        } else {\n            result += fmt.Sprintf(\"\
    %c\", decimal%2)\n            decimal *= 2\n        }\n    }\n    return \"db\"\
    \ + result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6t6m9l2d_test.go:21:25: invalid argument: decimal (variable of type int)
    for len

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074387
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n     \
    \   result += binary_to_decimal(decimal)\n    }\n    decimal /= 2\n    if decimal\
    \ > 0 {\n        result += binary_to_decimal(decimal)\n    }\n    decimal %= 2\n\
    \    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n    }\n \
    \   decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal %= \nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp3qmzun0i_test.go:117:6: expected ''('', found TestDecimal_To_Binary

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074491
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n     \
    \   result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 0 {\n    \
    \    result += \"1\"\n    }\n    return result\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpeocrmak2_test.go:46: expected 'db0db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpeocrmak2_test.go:46: expected\
    \ 'db100000db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n\
    \        tmpeocrmak2_test.go:46: expected 'db1100111db', got '1'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpeocrmak2_test.go:46: expected\
    \ 'db1111db', got '1'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074382
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    binary := make([]byte, 32)\n    binary.PutUint32(decimal, binary.Size())\n\
    \    binary := append(binary, 'b')\n    return string(binary)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpi01ati9h_test.go:20:12: binary.PutUint32 undefined (type []byte has no
    field or method PutUint32)

    /tmp/tmpi01ati9h_test.go:20:38: binary.Size undefined (type []byte has no field
    or method Size)

    /tmp/tmpi01ati9h_test.go:21:12: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074494
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    temp := decimal\n    for temp > 0 {\n    \
    \    result += \"0\"\n        temp--\n    }\n    for temp > 0 {\n        result\
    \ += \"1\"\n        temp--\n    }\n    return \"db\" + result\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp8if39vh__test.go:48: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp8if39vh__test.go:48:\
    \ expected 'db100000db', got 'db00000000000000000000000000000000'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmp8if39vh__test.go:48: expected\
    \ 'db1100111db', got 'db0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp8if39vh__test.go:48:\
    \ expected 'db1111db', got 'db000000000000000'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660074389
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    binaryString := \"\"\n    decimalString := fmt.Sprintf(\"%d\"\
    , decimal)\n    decimalLen := len(decimalString)\n    binaryLen := decimalLen\
    \ / 2\n    for i := 0; i < decimalLen; i++ {\n        binaryString += decimalString[i]\n\
    \    }\n    for i := decimalLen - binaryLen; i < decimalLen; i++ {\n        binaryString\
    \ += \"0\"\n    }\n    return binaryString\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfaayplrh_test.go:24:9: invalid operation: binaryString += decimalString[i]
    (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074495
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n     \
    \   result += binary_to_decimal(decimal)\n    }\n    decimal /= 2\n    if decimal\
    \ > 0 {\n        result += binary_to_decimal(decimal)\n    }\n    return result\n\
    }\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyphcuo4j_test.go:22:19: undefined: binary_to_decimal

    /tmp/tmpyphcuo4j_test.go:26:19: undefined: binary_to_decimal

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074382
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    binaryString := \"\"\n    binaryString += \"db\"\n    for i :=\
    \ 0; i < decimal; i++ {\n        binaryString += \"0\"\n    }\n    for i := decimal;\
    \ i < 32; i++ {\n        binaryString += \"1\"\n    }\n    return binaryString\n\
    }\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmppqm8m3s4_test.go:46: expected 'db0db', got 'db11111111111111111111111111111111'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmppqm8m3s4_test.go:46:\
    \ expected 'db100000db', got 'db00000000000000000000000000000000'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmppqm8m3s4_test.go:46: expected\
    \ 'db1100111db', got 'db0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmppqm8m3s4_test.go:46:\
    \ expected 'db1111db', got 'db00000000000000011111111111111111'\nFAIL\nFAIL\t\
    command-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074495
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    // Your code here\n    result := \"\"\n    i := 0\n    for {\n\
    \        if decimal > 0 {\n            result += fmt.Sprintf(\"%c\", decimal%2)\n\
    \            decimal /= 2\n        } else {\n            result += fmt.Sprintf(\"\
    %c\", decimal%2)\n            break\n        }\n        i++\n    }\n    return\
    \ result + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp7w8c2x73_test.go:51: expected 'db0db', got '\0db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp7w8c2x73_test.go:51:\
    \ expected 'db100000db', got '\0\0\0\0\0\x01\0db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmp7w8c2x73_test.go:51: expected 'db1100111db', got '\x01\x01\
    \x01\0\0\x01\x01\0db'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n\
    \        tmp7w8c2x73_test.go:51: expected 'db1111db', got '\x01\x01\x01\x01\0\
    db'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074496
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n     \
    \   result += binary_to_decimal(decimal)\n    }\n    decimal /= 2\n    if decimal\
    \ > 0 {\n        result += binary_to_decimal(decimal)\n    }\n    decimal /= 2\n\
    \    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n    }\n \
    \   decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= \nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpnkc5b_ds_test.go:117:6: expected ''('', found TestDecimal_To_Binary

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074381
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n     \
    \   result += binary_to_decimal(decimal)\n    }\n    decimal /= 2\n    if decimal\
    \ > 0 {\n        result += binary_to_decimal(decimal)\n    }\n    return result\n\
    }\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyphcuo4j_test.go:22:19: undefined: binary_to_decimal

    /tmp/tmpyphcuo4j_test.go:26:19: undefined: binary_to_decimal

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074382
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    binaryString := \"\"\n    decimal %= 2\n    for i := 0; i < decimal;\
    \ i++ {\n        binaryString += \"0\"\n    }\n    binaryString += \"1\"\n   \
    \ return binaryString\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpap7wi9m0_test.go:44: expected 'db0db', got '1'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpap7wi9m0_test.go:44:\
    \ expected 'db100000db', got '1'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpap7wi9m0_test.go:44: expected 'db1100111db', got '01'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpap7wi9m0_test.go:44:\
    \ expected 'db1111db', got '01'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074389
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    for i := 0; i < decimal;\
    \ i++ {\n        result += \"0\"\n    }\n    result += \"1\"\n    return result\n\
    }\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp82rsg2ko_test.go:44: expected 'db0db', got '1'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp82rsg2ko_test.go:44:\
    \ expected 'db100000db', got '1'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmp82rsg2ko_test.go:44: expected 'db1100111db', got '01'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp82rsg2ko_test.go:44:\
    \ expected 'db1111db', got '01'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074382
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    binary := \"\"\n    decimal %= 2\n    if decimal\
    \ > 0 {\n        decimal--\n        binary = \"1\"\n    }\n    for i := 0; i <\
    \ decimal; i++ {\n        binary += \"0\"\n    }\n    result += binary\n    return\
    \ result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpojljyaew_test.go:49: expected 'db0db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpojljyaew_test.go:49: expected\
    \ 'db100000db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n\
    \        tmpojljyaew_test.go:49: expected 'db1100111db', got '1'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpojljyaew_test.go:49: expected\
    \ 'db1111db', got '1'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074391
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    switch decimal {\n    case 0:\n        result\
    \ = \"0\"\n    case 1:\n        result = \"1\"\n    case 2:\n        result =\
    \ \"10\"\n    case 3:\n        result = \"11\"\n    case 4:\n        result =\
    \ \"100\"\n    case 5:\n        result = \"101\"\n    case 6:\n        result\
    \ = \"110\"\n    case 7:\n        result = \"111\"\n    case 8:\n        result\
    \ = \"1000\"\n    case 9:\n        result = \"1001\"\n    case 10:\n        result\
    \ = \"1010\"\n    case 11:\n        result = \"1011\"\n    case 12:\n        result\
    \ = \"1100\"\n    case 13:\n        result = \"1101\"\n    case 14:\n        result\
    \ = \"1110\"\n    case 15:\n        result = \"1111\"\n    case 16:\n        result\
    \ = \"10000\"\n    case 17:\n        result = \"10001\"\n    case 18:\n      \
    \  result = \"10010\"\n    case 19:\n        result = \"10011\"\n    case 20:\n\
    \        result = \"10100\"\n    case 21:\n        result = \"10101\"\n    case\
    \ 22:\n        result = \"10110\"\n    case 23:\n        result = \"10111\"\n\
    \    case 24:\n        result = \"11000\"\n    case 25:\n        result = \"11001\"\
    \n    case 26:\n        result = \"11010\"\n    case 27:\n        result = \"\
    11011\"\n    case 28:\n        result = \"11100\"\n    case 29:\n        result\
    \ = \"11101\"\n    case 30:\n        result = \"11110\"\n    case 31:\n      \
    \  result = \"11111\"\n    case 32:\n        result = \"100001\"\n    case 33:\n\
    \        result = \"1000010\"\n    case 34:\n        result = \"1000011\"\n  \
    \  case 35:\n        result = \"1000100\"\n    case 36:\n        result = \"1000101\"\
    \n    case 37:\n        result = \"1000111\"\n    case 38:\n        result = \"\
    1001000\"\n    case 39:\n        result = \"1001001\"\n    case 40:\n        result\
    \ = \"1001010\"\n    case 41:\n        result = \"1001011\"\n    case 42:\n  \
    \      result = \"1001100\"\n    case 43:\n        result = \"1001101\"\n    case\
    \ 44:\n        result = \"1001110\"\n    case 45:\n        result = \"1001111\"\
    \n    case 46:\n        result = \"1010000\"\n    case 47:\n        result = \"\
    1010100\"\n    case 48:\n        result = \"1010001\"\n    case 49:\n        result\
    \ = \"1010010\"\n    case 50:\n        result = \"1010011\"\n    case 51:\n  \
    \      result = \"1010101\"\n    case 52:\n        result = \"1010111\"\n    case\
    \ 53:\n        result = \"1011000\"\n    case 54:\n        result = \"101100\n\
    func TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpx3z9_1f9_test.go:130:18: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074494
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    binary := make([]byte, 32)\n    i := 0\n    for decimal>0 {\n\
    \        binary[i] = byte(decimal%2)\n        decimal /= 2\n        i++\n    }\n\
    \    binary[i] = byte(decimal)\n    return string(binary)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmppbgxpagv_test.go:46: expected 'db0db', got '\0\0\0\0\0\0\
    \0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0'\n    --- FAIL: TestDecimal_To_Binary/test_num__1\
    \ (0.00s)\n        tmppbgxpagv_test.go:46: expected 'db100000db', got '\0\0\0\0\
    \0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmppbgxpagv_test.go:46: expected 'db1100111db', got '\x01\x01\
    \x01\0\0\x01\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmppbgxpagv_test.go:46: expected\
    \ 'db1111db', got '\x01\x01\x01\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\
    \0\0\0\0\0\0'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074496
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n     \
    \   result += binary_to_decimal(decimal)\n    }\n    decimal /= 2\n    if decimal\
    \ > 0 {\n        result += binary_to_decimal(decimal)\n    }\n    decimal /= 2\n\
    \    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n    }\n \
    \   decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= \nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpnkc5b_ds_test.go:117:6: expected ''('', found TestDecimal_To_Binary

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074381
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n     \
    \   result += decimal_to_binary(decimal/2)\n    }\n    decimal %= 2\n    if decimal\
    \ > 0 {\n        result += decimal_to_binary(decimal/2)\n    }\n    decimal %=\
    \ 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n  \
    \  }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= \nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpem5vjt3e_test.go:117:6: expected ''('', found TestDecimal_To_Binary

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074381
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    for i := 0; i < decimal;\
    \ i++ {\n        result += \"0\"\n    }\n    result += \"1\"\n    result += \"\
    db\"\n    return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpnbbo4poz_test.go:45: expected 'db0db', got '1db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpnbbo4poz_test.go:45:\
    \ expected 'db100000db', got '1db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpnbbo4poz_test.go:45: expected 'db1100111db', got '01db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpnbbo4poz_test.go:45:\
    \ expected 'db1111db', got '01db'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074382
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    binary := make([]byte, 32)\n    i := 0\n    for decimal%2 == 0\
    \ {\n        binary[i] = '1'\n        decimal = decimal / 2\n        i++\n   \
    \ }\n    for decimal%2 == 1 {\n        binary[i] = '0'\n        decimal = decimal\
    \ / 2\n        i++\n    }\n    binary[i] = 'b'\n    return string(binary)\n}\n\
    \nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\npanic: runtime error: index out\
    \ of range [32] with length 32 [recovered]\n\tpanic: runtime error: index out\
    \ of range [32] with length 32\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513640,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513640, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.decimal_to_binary(...)\n\t/tmp/tmplh69y52t_test.go:22\n\
    command-line-arguments_test.TestDecimal_To_Binary(0x0?)\n\t/tmp/tmplh69y52t_test.go:42\
    \ +0x5ec\ntesting.tRunner(0xc0000da340, 0x528f88)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074386
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    for i := 0; i < len(decimal);\
    \ i++ {\n        if decimal > 0 {\n            result += string(decimal%2 + 1)\n\
    \        }\n        decimal = decimal/2\n    }\n    return \"db\" + result + \"\
    db\"\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqn21zxe0_test.go:21:25: invalid argument: decimal (variable of type int)
    for len

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074496
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n     \
    \   result += \"1\"\n    }\n    for i := 0; i < decimal; i++ {\n        result\
    \ += \"0\"\n    }\n    return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpopc6z5a3_test.go:46: expected 'db0db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpopc6z5a3_test.go:46: expected\
    \ 'db100000db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n\
    \        tmpopc6z5a3_test.go:46: expected 'db1100111db', got '10'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpopc6z5a3_test.go:46: expected\
    \ 'db1111db', got '10'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074383
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n     \
    \   result += binary_to_decimal(decimal)\n    }\n    decimal /= 2\n    if decimal\
    \ > 0 {\n        result += binary_to_decimal(decimal)\n    }\n    decimal /= 2\n\
    \    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n    }\n \
    \   decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= \nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpnkc5b_ds_test.go:117:6: expected ''('', found TestDecimal_To_Binary

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074381
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n     \
    \   result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 0 {\n    \
    \    result += \"1\"\n    }\n    return result\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpeocrmak2_test.go:46: expected 'db0db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpeocrmak2_test.go:46: expected\
    \ 'db100000db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n\
    \        tmpeocrmak2_test.go:46: expected 'db1100111db', got '1'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpeocrmak2_test.go:46: expected\
    \ 'db1111db', got '1'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074382
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n     \
    \   result += binary_to_decimal(decimal)\n    }\n    decimal /= 2\n    if decimal\
    \ > 0 {\n        result += binary_to_decimal(decimal)\n    }\n    return result\n\
    }\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyphcuo4j_test.go:22:19: undefined: binary_to_decimal

    /tmp/tmpyphcuo4j_test.go:26:19: undefined: binary_to_decimal

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074382
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    binary := \"\"\n    decimal %= 2\n    if decimal > 0 {\n     \
    \   binary += \"1\"\n    }\n    for i := 0; i < decimal; i++ {\n        binary\
    \ += \"0\"\n    }\n    return binary + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmps8xqk7w5_test.go:46: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmps8xqk7w5_test.go:46:\
    \ expected 'db100000db', got 'db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmps8xqk7w5_test.go:46: expected 'db1100111db', got '10db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmps8xqk7w5_test.go:46:\
    \ expected 'db1111db', got '10db'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074382
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n     \
    \   result += fmt.Sprintf(\"%c\", decimal)\n        decimal /= 2\n    }\n    for\
    \ i := 0; i < decimal; i++ {\n        result += fmt.Sprintf(\"%c\", '0')\n   \
    \ }\n    return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpg_dnpe3__test.go:47: expected 'db0db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpg_dnpe3__test.go:47: expected\
    \ 'db100000db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n\
    \        tmpg_dnpe3__test.go:47: expected 'db1100111db', got '\x01'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpg_dnpe3__test.go:47: expected\
    \ 'db1111db', got '\x01'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074493
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n     \
    \   result += binary_to_decimal(decimal)\n    }\n    decimal /= 2\n    if decimal\
    \ > 0 {\n        result += binary_to_decimal(decimal)\n    }\n    return result\n\
    }\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyphcuo4j_test.go:22:19: undefined: binary_to_decimal

    /tmp/tmpyphcuo4j_test.go:26:19: undefined: binary_to_decimal

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074382
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    binary := make([]byte, 32)\n    i := 0\n    for ; decimal > 0;\
    \ decimal = decimal / 2 {\n        binary[i] = byte(decimal % 2)\n        i++\n\
    \    }\n    binary[i] = byte(decimal)\n    return string(binary)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp10ick9ol_test.go:45: expected 'db0db', got '\0\0\0\0\0\0\
    \0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0'\n    --- FAIL: TestDecimal_To_Binary/test_num__1\
    \ (0.00s)\n        tmp10ick9ol_test.go:45: expected 'db100000db', got '\0\0\0\0\
    \0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmp10ick9ol_test.go:45: expected 'db1100111db', got '\x01\x01\
    \x01\0\0\x01\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp10ick9ol_test.go:45: expected\
    \ 'db1111db', got '\x01\x01\x01\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\
    \0\0\0\0\0\0'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074496
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n     \
    \   result += decimal_to_binary(decimal/2)\n    }\n    decimal %= 2\n    if decimal\
    \ > 0 {\n        result += decimal_to_binary(decimal/2)\n    }\n    decimal %=\
    \ 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n  \
    \  }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= \nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpem5vjt3e_test.go:117:6: expected ''('', found TestDecimal_To_Binary

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074381
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n     \
    \   result += decimal_to_binary(decimal/2)\n    }\n    if decimal > 0 {\n    \
    \    result += \"1\"\n    }\n    return result\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpeocrmak2_test.go:46: expected 'db0db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpeocrmak2_test.go:46: expected\
    \ 'db100000db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n\
    \        tmpeocrmak2_test.go:46: expected 'db1100111db', got '1'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpeocrmak2_test.go:46: expected\
    \ 'db1111db', got '1'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074382
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    for i := 0; i < len(fmt.Sprintf(\"\
    %d\", decimal)); i++ {\n        if decimal > 0 {\n            result += fmt.Sprintf(\"\
    %d\", decimal%2)\n            decimal /= 2\n        } else {\n            result\
    \ += fmt.Sprintf(\"%d\", decimal%2)\n            decimal *= 2\n        }\n   \
    \ }\n    return \"db\" + result + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__1\
    \ (0.00s)\n        tmpdmtj6bh0_test.go:49: expected 'db100000db', got 'db0db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpdmtj6bh0_test.go:49:\
    \ expected 'db1100111db', got 'db1db'\n    --- FAIL: TestDecimal_To_Binary/test_num__3\
    \ (0.00s)\n        tmpdmtj6bh0_test.go:49: expected 'db1111db', got 'db1db'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074384
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    binary := \"\"\n    decimal %= 2\n    if decimal > 0 {\n     \
    \   binary += \"1\"\n    }\n    for i := 0; i < decimal; i++ {\n        binary\
    \ += \"0\"\n    }\n    return binary + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmps8xqk7w5_test.go:46: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmps8xqk7w5_test.go:46:\
    \ expected 'db100000db', got 'db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmps8xqk7w5_test.go:46: expected 'db1100111db', got '10db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmps8xqk7w5_test.go:46:\
    \ expected 'db1111db', got '10db'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074382
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    binary := make([]byte, 32)\n    i := 0\n    for decimal == 0 {\n\
    \        binary[i] = '0'\n        i++\n        decimal = decimal * 2\n    }\n\
    \    for decimal == 1 {\n        binary[i] = '1'\n        i++\n        decimal\
    \ = decimal * 2\n    }\n    binary[i] = 'b'\n    i++\n    return string(binary)\n\
    }\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\npanic: runtime error: index out\
    \ of range [32] with length 32 [recovered]\n\tpanic: runtime error: index out\
    \ of range [32] with length 32\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513640,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513640, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.decimal_to_binary(...)\n\t/tmp/tmpetdsk723_test.go:22\n\
    command-line-arguments_test.TestDecimal_To_Binary(0x0?)\n\t/tmp/tmpetdsk723_test.go:43\
    \ +0x56c\ntesting.tRunner(0xc0000da340, 0x528f88)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074496
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    // Your code here\n    result := \"\"\n    decimal %= 2\n    if\
    \ decimal > 0 {\n        result += fmt.Sprintf(\"%c\", decimal)\n    }\n    if\
    \ decimal > 1 {\n        result += fmt.Sprintf(\"%c\", decimal)\n    }\n    if\
    \ decimal > 2 {\n        result += fmt.Sprintf(\"%c\", decimal)\n    }\n    if\
    \ decimal > 3 {\n        result += fmt.Sprintf(\"%c\", decimal)\n    }\n    if\
    \ decimal > 4 {\n        result += fmt.Sprintf(\"%c\", decimal)\n    }\n    if\
    \ decimal > 5 {\n        result += fmt.Sprintf(\"%c\", decimal)\n    }\n    if\
    \ decimal > 6 {\n        result += fmt.Sprintf(\"%c\", decimal)\n    }\n    if\
    \ decimal > 7 {\n        result += fmt.Sprintf(\"%c\", decimal)\n    }\n    if\
    \ decimal > 8 {\n        result += fmt.Sprintf(\"%c\", decimal)\n    }\n    if\
    \ decimal > 9 {\n        result += fmt.Sprintf(\"%c\", decimal)\n    }\n    if\
    \ decimal > 10 {\n        result += fmt.Sprintf(\"%c\", decimal)\n    }\n    if\
    \ decimal > 11 {\n        result += fmt.Sprintf(\"%c\", decimal)\n    }\n    if\
    \ decimal > 12 {\n        result += fmt.Sprintf(\"%c\", decimal)\n    }\n    if\
    \ decimal > 13 {\n        result += fmt.Sprintf(\"%c\", decimal)\n    }\n    if\
    \ decimal > 14 {\n        result += fmt.Sprintf(\"%c\", decimal)\n    }\n    if\
    \ decimal > 15 {\n        result += fmt.Sprintf(\"%c\", decimal)\n    }\n    if\
    \ decimal > 16 {\n        result += fmt.Sprintf(\"%c\", decimal)\n    }\n    if\
    \ decimal > 17 {\n        result += fmt.Sprintf(\"%c\", decimal)\n    }\n    if\
    \ decimal > 18 {\n        result += fmt.Sprintf(\"%c\", decimal)\n    }\n    if\
    \ decimal > 19 {\n        result += fmt.Sprintf(\"%c\", decimal)\n    }\n    if\
    \ decimal > 20 {\n        result += fmt.Sprintf(\"%c\", decimal)\n    }\n    if\
    \ decimal > 21 {\n        result += fmt.Sprintf(\"%c\", decimal)\n    }\n    if\
    \ decimal > 22 {\n        result += fmt.Sprintf(\"%c\", decimal)\n    }\n    if\
    \ decimal > 23 {\n        result += fmt.Sprintf(\"%c\", decimal)\n    }\n    if\
    \ decimal > 24 {\n        result += fmt.Sprintf(\"%c\", decimal)\n    }\n    if\
    \ decimal > 25 {\n        result += fmt.Sprintf(\"%c\", decimal)\n    }\n    if\
    \ decimal > 26 {\n        result += \nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpdeip0az7_test.go:102:6: expected ''('', found TestDecimal_To_Binary

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074496
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    // Your code here\n    result := \"\"\n    decimal %= 2\n    if\
    \ decimal > 0 {\n        result += fmt.Sprintf(\"%c\", decimal)\n    }\n    decimal\
    \ /= 2\n    if decimal > 0 {\n        result += fmt.Sprintf(\"%c\", decimal)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += fmt.Sprintf(\"\
    %c\", decimal)\n    }\n    decimal /= 2\n    if decimal > 0 {\n        result\
    \ += fmt.Sprintf(\"%c\", decimal)\n    }\n    decimal %= 2\n    if decimal > 0\
    \ {\n        result += fmt.Sprintf(\"%c\", decimal)\n    }\n    decimal /= 2\n\
    \    if decimal > 0 {\n        result += fmt.Sprintf(\"%c\", decimal)\n    }\n\
    \    decimal %= 2\n    if decimal > 0 {\n        result += fmt.Sprintf(\"%c\"\
    , decimal)\n    }\n    decimal /= 2\n    if decimal > 0 {\n        result += fmt.Sprintf(\"\
    %c\", decimal)\n    }\n    decimal %= 2\n    if decimal > 0 {\n        result\
    \ += fmt.Sprintf(\"%c\", decimal)\n    }\n    decimal /= 2\n    if decimal > 0\
    \ {\n        result += fmt.Sprintf(\"%c\", decimal)\n    }\n    decimal %= 2\n\
    \    if decimal > 0 {\n        result += fmt.Sprintf(\"%c\", decimal)\n    }\n\
    \    decimal /= 2\n    if decimal > 0 {\n        result += fmt.Sprintf(\"%c\"\
    , decimal)\n    }\n    decimal %= 2\n    if decimal > 0 {\n        result += fmt.Sprintf(\"\
    %c\", decimal)\n    }\n    decimal /= 2\n    if decimal > 0 {\n        result\
    \ += fmt.Sprintf(\"%c\", decimal)\n    }\n    decimal %= 2\n    if decimal > 0\
    \ {\n        result += fmt.Sprintf(\"%c\", decimal)\n    }\n    decimal /= 2\n\
    \    if decimal > 0 {\n        result += fmt.Sprintf(\"%c\", decimal)\n    }\n\
    \    decimal %= 2\n    if decimal > 0 {\n        result += fmt.Sprintf(\"%c\"\
    , decimal)\n    }\n    decimal /= 2\n    if decimal > 0 {\n        result += fmt.Sprintf(\"\
    %c\", decimal)\n    }\n    decimal %= 2\n    if decimal > 0 {\n        result\
    \ += fmt.Sprintf(\"%c\", decimal)\n    }\n    decimal /= 2\n    if decimal > 0\
    \ {\n        result += fmt.Sprintf(\"%c\", decimal)\n    }\n    decimal %= 2\n\
    \    if decimal > 0 {\n        result += fmt.Sprintf(\"%c\", decimal)\n    }\n\
    \    decimal /= 2\n    if decimal > 0 {\n        result += fmt.Sprintf(\"%c\"\
    , decimal\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphlv_rwe4_test.go:107:44: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074496
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n     \
    \   result += binary_to_decimal(decimal)\n    }\n    decimal /= 2\n    if decimal\
    \ > 0 {\n        result += binary_to_decimal(decimal)\n    }\n    return result\n\
    }\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyphcuo4j_test.go:22:19: undefined: binary_to_decimal

    /tmp/tmpyphcuo4j_test.go:26:19: undefined: binary_to_decimal

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074382
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    temp := decimal % 2\n    decimal /= 2\n  \
    \  for i := 0; i < decimal; i++ {\n        if temp == 0 {\n            result\
    \ += \"0\"\n        } else {\n            result += \"1\"\n        }\n       \
    \ temp = temp * 2\n    }\n    return \"db\" + result + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpg2grszfp_test.go:49: expected 'db0db', got 'dbdb'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpg2grszfp_test.go:49:\
    \ expected 'db100000db', got 'db0000000000000000db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpg2grszfp_test.go:49: expected 'db1100111db', got 'db111111111111111111111111111111111111111111111111111db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpg2grszfp_test.go:49:\
    \ expected 'db1111db', got 'db1111111db'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074496
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n     \
    \   result += binary_to_decimal(decimal)\n    }\n    if decimal > 1 {\n      \
    \  result += binary_to_decimal(decimal - 1)\n    }\n    return result\n}\n\nfunc\
    \ TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9vla42xs_test.go:22:19: undefined: binary_to_decimal

    /tmp/tmp9vla42xs_test.go:25:19: undefined: binary_to_decimal

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074491
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n     \
    \   result += decimal_to_binary(decimal/2)\n    }\n    if decimal % 2 == 0 {\n\
    \        result += \"1\"\n    } else {\n        result += \"0\"\n    }\n    return\
    \ result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpxhi37q0u_test.go:48: expected 'db0db', got '1'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpxhi37q0u_test.go:48:\
    \ expected 'db100000db', got '1'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpxhi37q0u_test.go:48: expected 'db1100111db', got '10'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpxhi37q0u_test.go:48:\
    \ expected 'db1111db', got '10'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074391
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n     \
    \   result += decimal_to_binary(decimal/2)\n    }\n    if decimal < 2 {\n    \
    \    result += \"0\"\n    }\n    return result\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpnjeimy72_test.go:46: expected 'db0db', got '0'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpnjeimy72_test.go:46:\
    \ expected 'db100000db', got '0'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpnjeimy72_test.go:46: expected 'db1100111db', got '00'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpnjeimy72_test.go:46:\
    \ expected 'db1111db', got '00'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074496
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n     \
    \   result += binary_to_decimal(decimal)\n    }\n    decimal /= 2\n    if decimal\
    \ > 0 {\n        result += binary_to_decimal(decimal)\n    }\n    return result\n\
    }\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyphcuo4j_test.go:22:19: undefined: binary_to_decimal

    /tmp/tmpyphcuo4j_test.go:26:19: undefined: binary_to_decimal

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074382
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n     \
    \   result += binary_to_decimal(decimal)\n    }\n    if decimal > 1 {\n      \
    \  result += binary_to_decimal(decimal - 1)\n    }\n    return result\n}\n\nfunc\
    \ TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9vla42xs_test.go:22:19: undefined: binary_to_decimal

    /tmp/tmp9vla42xs_test.go:25:19: undefined: binary_to_decimal

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074491
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    binaryString := \"\"\n    binaryString += \"db\"\n    for i :=\
    \ 0; i < decimal; i++ {\n        if decimal % 2 == 0 {\n            binaryString\
    \ += \"1\"\n        } else {\n            binaryString += \"0\"\n        }\n \
    \       decimal = decimal / 2\n    }\n    return binaryString\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpuhhngrth_test.go:48: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpuhhngrth_test.go:48:\
    \ expected 'db100000db', got 'db1111'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpuhhngrth_test.go:48: expected 'db1100111db', got 'db00011'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpuhhngrth_test.go:48:\
    \ expected 'db1111db', got 'db000'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074382
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n     \
    \   for i := 0; i < decimal; i++ {\n            result += \"1\"\n        }\n \
    \   } else {\n        for i := 0; i < decimal; i++ {\n            result += \"\
    0\"\n        }\n    }\n    return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpu9tpp7wo_test.go:49: expected 'db0db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpu9tpp7wo_test.go:49: expected\
    \ 'db100000db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n\
    \        tmpu9tpp7wo_test.go:49: expected 'db1100111db', got '1'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpu9tpp7wo_test.go:49: expected\
    \ 'db1111db', got '1'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074382
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    // Your code here\n    result := \"\"\n    temp := decimal\n \
    \   for temp > 0 {\n        result += \"0\"\n        temp--\n    }\n    for temp\
    \ > 0 {\n        result += \"1\"\n        temp--\n    }\n    result += \"db\"\n\
    \    return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpn9gtly_z_test.go:50: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpn9gtly_z_test.go:50:\
    \ expected 'db100000db', got '00000000000000000000000000000000db'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpn9gtly_z_test.go:50: expected\
    \ 'db1100111db', got '0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpn9gtly_z_test.go:50:\
    \ expected 'db1111db', got '000000000000000db'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074389
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n     \
    \   result += binary_to_decimal(decimal)\n    }\n    decimal /= 2\n    if decimal\
    \ > 0 {\n        result += binary_to_decimal(decimal)\n    }\n    return result\n\
    }\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyphcuo4j_test.go:22:19: undefined: binary_to_decimal

    /tmp/tmpyphcuo4j_test.go:26:19: undefined: binary_to_decimal

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074382
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    binary := make([]byte, 32)\n    i := 0\n    j := len(binary) -\
    \ 1\n    for ; i < j; i, j = i+1, j-1 {\n        binary[i] = byte(decimal % 2)\n\
    \        decimal /= 2\n    }\n    binary[i] = byte(decimal)\n    return string(binary)\n\
    }\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpm_3mrrkg_test.go:46: expected 'db0db', got '\0\0\0\0\0\0\
    \0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0'\n    --- FAIL: TestDecimal_To_Binary/test_num__1\
    \ (0.00s)\n        tmpm_3mrrkg_test.go:46: expected 'db100000db', got '\0\0\0\0\
    \0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpm_3mrrkg_test.go:46: expected 'db1100111db', got '\x01\x01\
    \x01\0\0\x01\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpm_3mrrkg_test.go:46: expected\
    \ 'db1111db', got '\x01\x01\x01\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\
    \0\0\0\0\0\0'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074496
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    binary := make([]byte, 32)\n    i := 0\n    for decimal>0 {\n\
    \        binary[i] = byte(decimal%2)\n        decimal = decimal/2\n        i++\n\
    \    }\n    binary[i] = 'b'\n    binary[i+32] = 'b'\n    return string(binary)\n\
    }\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\npanic: runtime error: index out\
    \ of range [32] with length 32 [recovered]\n\tpanic: runtime error: index out\
    \ of range [32] with length 32\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513640,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513640, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.decimal_to_binary(...)\n\t/tmp/tmplawk_z6z_test.go:27\n\
    command-line-arguments_test.TestDecimal_To_Binary(0x0?)\n\t/tmp/tmplawk_z6z_test.go:38\
    \ +0x592\ntesting.tRunner(0xc0000cc4e0, 0x528f88)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074496
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n     \
    \   result += binary_to_decimal(decimal)\n    }\n    decimal /= 2\n    if decimal\
    \ > 0 {\n        result += binary_to_decimal(decimal)\n    }\n    decimal /= 2\n\
    \    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n    }\n \
    \   decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= \nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpnkc5b_ds_test.go:117:6: expected ''('', found TestDecimal_To_Binary

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074381
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    binary := \"\"\n    decimal %= 2\n    if decimal > 0 {\n     \
    \   binary += \"1\"\n        decimal -= 1\n    }\n    for i := 0; i < decimal;\
    \ i++ {\n        binary += \"0\"\n    }\n    return binary + \"db\"\n}\n\nfunc\
    \ TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpamope0jo_test.go:47: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpamope0jo_test.go:47:\
    \ expected 'db100000db', got 'db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpamope0jo_test.go:47: expected 'db1100111db', got '1db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpamope0jo_test.go:47:\
    \ expected 'db1111db', got '1db'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\n\
    FAIL\n"
  timestamp: 1660074496
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    binary := make([]byte, 32)\n    for i := 0; i < len(binary); i++\
    \ {\n        binary[i] = byte(decimal % 2)\n        decimal /= 2\n    }\n    return\
    \ fmt.Sprintf(\"db%vdb\", binary)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpv716vkcq_test.go:43: expected 'db0db', got 'db[0 0 0 0 0\
    \ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]db'\n    --- FAIL: TestDecimal_To_Binary/test_num__1\
    \ (0.00s)\n        tmpv716vkcq_test.go:43: expected 'db100000db', got 'db[0 0\
    \ 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]db'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpv716vkcq_test.go:43: expected\
    \ 'db1100111db', got 'db[1 1 1 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\
    \ 0 0 0 0 0]db'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n   \
    \     tmpv716vkcq_test.go:43: expected 'db1111db', got 'db[1 1 1 1 0 0 0 0 0 0\
    \ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]db'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660074496
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    binaryString := \"\"\n    binaryString += \"db\"\n    binaryString\
    \ += fmt.Sprintf(\"%0*d\", decimal, decimal)\n    return binaryString\n}\n\nfunc\
    \ TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpv6rh2lsr_test.go:41: expected 'db0db', got 'db0'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpv6rh2lsr_test.go:41:\
    \ expected 'db100000db', got 'db00000000000000000000000000000032'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpv6rh2lsr_test.go:41: expected\
    \ 'db1100111db', got 'db0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000103'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpv6rh2lsr_test.go:41:\
    \ expected 'db1111db', got 'db000000000000015'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074389
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    // Your code here\n    result := \"\"\n    decimal %= 2\n    if\
    \ decimal > 0 {\n        result += \"1\"\n    }\n    for i := 0; i < decimal;\
    \ i++ {\n        result += \"0\"\n    }\n    return result\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpjd1c9syu_test.go:47: expected 'db0db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpjd1c9syu_test.go:47: expected\
    \ 'db100000db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n\
    \        tmpjd1c9syu_test.go:47: expected 'db1100111db', got '10'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpjd1c9syu_test.go:47: expected\
    \ 'db1111db', got '10'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074386
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    binary := \"\"\n    decimal %= 2\n    if decimal > 0 {\n     \
    \   binary += \"1\"\n    }\n    for i := 0; i < decimal; i++ {\n        binary\
    \ += \"0\"\n    }\n    return binary + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmps8xqk7w5_test.go:46: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmps8xqk7w5_test.go:46:\
    \ expected 'db100000db', got 'db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmps8xqk7w5_test.go:46: expected 'db1100111db', got '10db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmps8xqk7w5_test.go:46:\
    \ expected 'db1111db', got '10db'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074382
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    for i := 0; i < len(decimal);\
    \ i++ {\n        if decimal >= 2 {\n            result += fmt.Sprintf(\"%c\",\
    \ decimal%2)\n            decimal /= 2\n        } else {\n            result +=\
    \ fmt.Sprintf(\"%c\", 1)\n        }\n    }\n    result += \"db\"\n    return result\n\
    }\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvy0v76sf_test.go:21:25: invalid argument: decimal (variable of type int)
    for len

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074496
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    binary := make([]byte, 32)\n    i := 0\n    for decimal%2 == 0\
    \ {\n        binary[i] = '1'\n        decimal = decimal / 2\n        i++\n   \
    \ }\n    for decimal%2 == 1 {\n        binary[i] = '0'\n        decimal = decimal\
    \ / 2\n        i++\n    }\n    binary[i] = 'd'\n    binary[i+4] = 'b'\n    return\
    \ string(binary)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\npanic: runtime error: index out\
    \ of range [32] with length 32 [recovered]\n\tpanic: runtime error: index out\
    \ of range [32] with length 32\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513640,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513640, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.decimal_to_binary(...)\n\t/tmp/tmp678nunwc_test.go:22\n\
    command-line-arguments_test.TestDecimal_To_Binary(0x0?)\n\t/tmp/tmp678nunwc_test.go:43\
    \ +0x685\ntesting.tRunner(0xc0000da340, 0x528f88)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074496
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    binaryString := \"\"\n    binaryString += \"db\"\n    binaryString\
    \ += fmt.Sprintf(\"%0*d\", decimal, decimal)\n    binaryString += \"db\"\n   \
    \ return binaryString\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__1\
    \ (0.00s)\n        tmp5o89a_9q_test.go:42: expected 'db100000db', got 'db00000000000000000000000000000032db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmp5o89a_9q_test.go:42:\
    \ expected 'db1100111db', got 'db0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000103db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp5o89a_9q_test.go:42:\
    \ expected 'db1111db', got 'db000000000000015db'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074384
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n     \
    \   result += decimal_to_binary(decimal/2)\n    }\n    if decimal % 2 == 0 {\n\
    \        result += \"1\"\n    } else {\n        result += \"0\"\n    }\n    return\
    \ result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpxhi37q0u_test.go:48: expected 'db0db', got '1'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpxhi37q0u_test.go:48:\
    \ expected 'db100000db', got '1'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpxhi37q0u_test.go:48: expected 'db1100111db', got '10'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpxhi37q0u_test.go:48:\
    \ expected 'db1111db', got '10'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074391
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n     \
    \   result += \"1\"\n    }\n    for i := 0; i < decimal; i++ {\n        result\
    \ += \"0\"\n    }\n    return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpopc6z5a3_test.go:46: expected 'db0db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpopc6z5a3_test.go:46: expected\
    \ 'db100000db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n\
    \        tmpopc6z5a3_test.go:46: expected 'db1100111db', got '10'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpopc6z5a3_test.go:46: expected\
    \ 'db1111db', got '10'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074383
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    binary := \"\"\n    decimalToBinary := make([]string, decimal)\n\
    \    for i := 0; i < decimal; i++ {\n        decimalToBinary[i] = fmt.Sprintf(\"\
    %d\", decimalToBinary[i])\n    }\n    for i := 0; i < decimal; i++ {\n       \
    \ binary += decimalToBinary[i]\n    }\n    binary += \"db\"\n    return binary\n\
    }\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test

    /tmp/tmpv0di4rfv_test.go:22:30: fmt.Sprintf format %d has arg decimalToBinary[i]
    of wrong type string

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074496
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    i := 0\n    for ; decimal > 0; decimal = decimal\
    \ / 2 {\n        result = fmt.Sprintf(\"%c%c\", result, '0')\n        i++\n  \
    \  }\n    for ; decimal > 0; decimal = decimal / 2 {\n        result = fmt.Sprintf(\"\
    %c%c\", result, '1')\n        i++\n    }\n    return result + \"db\"\n}\n\nfunc\
    \ TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test

    /tmp/tmpv4g6gtic_test.go:22:18: fmt.Sprintf format %c has arg result of wrong
    type string

    /tmp/tmpv4g6gtic_test.go:26:18: fmt.Sprintf format %c has arg result of wrong
    type string

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074496
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    binaryString := \"\"\n    binaryString += \"db\"\n    for i :=\
    \ 0; i < 8; i++ {\n        if decimal >= 2 {\n            binaryString += \"1\"\
    \n            decimal -= 2\n        } else {\n            binaryString += \"0\"\
    \n        }\n    }\n    return binaryString\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp9yg4lvrm_test.go:48: expected 'db0db', got 'db00000000'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp9yg4lvrm_test.go:48:\
    \ expected 'db100000db', got 'db11111111'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmp9yg4lvrm_test.go:48: expected 'db1100111db', got 'db11111111'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp9yg4lvrm_test.go:48:\
    \ expected 'db1111db', got 'db11111110'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074390
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    result += \"db\"\n    for i := 0; i < decimal;\
    \ i++ {\n        if decimal % 2 == 0 {\n            result += fmt.Sprintf(\"%c\"\
    , 1)\n        } else {\n            result += fmt.Sprintf(\"%c\", 0)\n       \
    \ }\n        decimal /= 2\n    }\n    return result\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp77lqczbg_test.go:48: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp77lqczbg_test.go:48:\
    \ expected 'db100000db', got 'db\x01\x01\x01\x01'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmp77lqczbg_test.go:48: expected 'db1100111db', got 'db\0\0\
    \0\x01\x01'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n       \
    \ tmp77lqczbg_test.go:48: expected 'db1111db', got 'db\0\0\0'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660074496
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n     \
    \   result += fmt.Sprintf(\"%c\", decimal)\n        decimal /= 2\n    }\n    if\
    \ decimal > 0 {\n        result += fmt.Sprintf(\"%c\", decimal)\n        decimal\
    \ /= 2\n    }\n    if decimal > 0 {\n        result += fmt.Sprintf(\"%c\", decimal)\n\
    \        decimal /= 2\n    }\n    if decimal > 0 {\n        result += fmt.Sprintf(\"\
    %c\", decimal)\n        decimal /= 2\n    }\n    if decimal > 0 {\n        result\
    \ += fmt.Sprintf(\"%c\", decimal)\n        decimal /= 2\n    }\n    if decimal\
    \ > 0 {\n        result += fmt.Sprintf(\"%c\", decimal)\n        decimal /= 2\n\
    \    }\n    if decimal > 0 {\n        result += fmt.Sprintf(\"%c\", decimal)\n\
    \        decimal /= 2\n    }\n    if decimal > 0 {\n        result += fmt.Sprintf(\"\
    %c\", decimal)\n        decimal /= 2\n    }\n    if decimal > 0 {\n        result\
    \ += fmt.Sprintf(\"%c\", decimal)\n        decimal /= 2\n    }\n    if decimal\
    \ > 0 {\n        result += fmt.Sprintf(\"%c\", decimal)\n        decimal /= 2\n\
    \    }\n    if decimal > 0 {\n        result += fmt.Sprintf(\"%c\", decimal)\n\
    \        decimal /= 2\n    }\n    if decimal > 0 {\n        result += fmt.Sprintf(\"\
    %c\", decimal)\n        decimal /= 2\n    }\n    if decimal > 0 {\n        result\
    \ += fmt.Sprintf(\"%c\", decimal)\n        decimal /= 2\n    }\n    if decimal\
    \ > 0 {\n        result += fmt.Sprintf(\"%c\", decimal)\n        decimal /= 2\n\
    \    }\n    if decimal > 0 {\n        result += fmt.Sprintf(\"%c\", decimal)\n\
    \        decimal /= 2\n    }\n    if decimal > 0 {\n        result += fmt.Sprintf(\"\
    %c\", decimal)\n        decimal /= 2\n    }\n    if decimal > 0 {\n        result\
    \ += fmt.Sprintf(\"%c\", decimal)\n        decimal /= 2\n    }\n    if decimal\
    \ > 0 {\n        result += fmt.Sprintf(\"%c\", decimal)\n        decimal /= 2\n\
    \    }\n    if decimal > 0 {\n        result += fmt.Sprintf(\"%c\", decimal)\n\
    \        decimal /= 2\n    }\n    if decimal > 0 {\n        result += fmt.Sprintf(\"\
    %c\", decimal)\n        decimal /= 2\n    }\n    if decimal > 0 {\n        result\
    \ += fmt.Sprintf(\"%c\", decimal)\n        decimal /= 2\n    }\n    if decimal\
    \ > 0 {\n        result += fmt.Sprintf(\"%c\", decimal)\n        decimal /= \n\
    func TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmplt95_fz5_test.go:108:6: expected ''('', found TestDecimal_To_Binary

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074490
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    for i := 0; i < len(strconv.Itoa(decimal));\
    \ i++ {\n        if decimal > 0 {\n            result += strconv.Itoa(decimal%2)\n\
    \            decimal /= 2\n        } else {\n            result += strconv.Itoa((decimal%2)+1)\n\
    \            decimal /= 2\n        }\n    }\n    return \"db\" + result + \"db\"\
    \n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpgkrb7rnd_test.go:21:25: undefined: strconv

    /tmp/tmpgkrb7rnd_test.go:23:23: undefined: strconv

    /tmp/tmpgkrb7rnd_test.go:26:23: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074383
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n     \
    \   result += \"1\"\n    }\n    for i := 0; i < decimal; i++ {\n        result\
    \ += \"0\"\n    }\n    return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpopc6z5a3_test.go:46: expected 'db0db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpopc6z5a3_test.go:46: expected\
    \ 'db100000db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n\
    \        tmpopc6z5a3_test.go:46: expected 'db1100111db', got '10'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpopc6z5a3_test.go:46: expected\
    \ 'db1111db', got '10'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074383
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n     \
    \   result += binary_to_decimal(decimal)\n    }\n    decimal /= 2\n    if decimal\
    \ > 0 {\n        result += binary_to_decimal(decimal)\n    }\n    decimal /= 2\n\
    \    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n    }\n \
    \   decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += binary_to_decimal(decimal)\n\
    \    }\n    decimal /= \nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpnkc5b_ds_test.go:117:6: expected ''('', found TestDecimal_To_Binary

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074381
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    for i := 0; i < decimal;\
    \ i++ {\n        result += \"0\"\n    }\n    result += \"1\"\n    return result\n\
    }\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp82rsg2ko_test.go:44: expected 'db0db', got '1'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp82rsg2ko_test.go:44:\
    \ expected 'db100000db', got '1'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmp82rsg2ko_test.go:44: expected 'db1100111db', got '01'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp82rsg2ko_test.go:44:\
    \ expected 'db1111db', got '01'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074382
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n     \
    \   result += decimal_to_binary(decimal/2)\n    }\n    decimal %= 2\n    if decimal\
    \ > 0 {\n        result += decimal_to_binary(decimal/2)\n    }\n    decimal %=\
    \ 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n  \
    \  }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= \nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpem5vjt3e_test.go:117:6: expected ''('', found TestDecimal_To_Binary

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074381
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    binaryString := \"\"\n    decimalToBinary := decimal / 2\n   \
    \ decimalToBinaryToString := fmt.Sprintf(\"%d\", decimalToBinary)\n    binaryString\
    \ = binaryString + decimalToBinaryToString\n    decimal = decimal - decimalToBinary\n\
    \    decimalToBinaryToString := fmt.Sprintf(\"%d\", decimal)\n    binaryString\
    \ = binaryString + decimalToBinaryToString\n    return binaryString\n}\n\nfunc\
    \ TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfxdx8pp4_test.go:24:29: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074496
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    binary := make([]byte, 32)\n    for i := 0; i < len(binary); i++\
    \ {\n        binary[i] = byte(decimal % 2)\n        decimal /= 2\n    }\n    binary[0]\
    \ = 'b'\n    binary[len(binary)-1] = 'b'\n    return string(binary)\n}\n\nfunc\
    \ TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpsoo0cqvr_test.go:45: expected 'db0db', got 'b\0\0\0\0\0\0\
    \0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0b'\n    --- FAIL: TestDecimal_To_Binary/test_num__1\
    \ (0.00s)\n        tmpsoo0cqvr_test.go:45: expected 'db100000db', got 'b\0\0\0\
    \0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0b'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpsoo0cqvr_test.go:45: expected 'db1100111db', got 'b\x01\x01\
    \0\0\x01\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0b'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpsoo0cqvr_test.go:45: expected\
    \ 'db1111db', got 'b\x01\x01\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\
    \0\0\0\0b'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074391
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    for i := 0; i < len(decimal);\
    \ i++ {\n        if decimal > 0 {\n            result += fmt.Sprintf(\"%d\", decimal%2)\n\
    \        }\n        decimal = decimal/2\n    }\n    return \"db\" + result + \"\
    db\"\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4uhcuj10_test.go:21:25: invalid argument: decimal (variable of type int)
    for len

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074496
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n     \
    \   result += \"1\"\n    }\n    for i := 0; i < decimal; i++ {\n        result\
    \ += \"0\"\n    }\n    return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpopc6z5a3_test.go:46: expected 'db0db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpopc6z5a3_test.go:46: expected\
    \ 'db100000db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n\
    \        tmpopc6z5a3_test.go:46: expected 'db1100111db', got '10'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpopc6z5a3_test.go:46: expected\
    \ 'db1111db', got '10'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074383
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    for i := 0; i < len(fmt.Sprintf(\"\
    %d\", decimal)); i++ {\n        if decimal >= 2 {\n            result += fmt.Sprintf(\"\
    %d\", decimal)\n            decimal = decimal - 2\n        } else {\n        \
    \    result += fmt.Sprintf(\"0\", decimal)\n            decimal = 0\n        }\n\
    \    }\n    return \"db\" + result + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test

    /tmp/tmppnoslcki_test.go:26:34: fmt.Sprintf call has arguments but no formatting
    directives

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074496
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n     \
    \   result += binary_to_decimal(decimal)\n    }\n    decimal /= 2\n    if decimal\
    \ > 0 {\n        result += binary_to_decimal(decimal)\n    }\n    return result\n\
    }\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyphcuo4j_test.go:22:19: undefined: binary_to_decimal

    /tmp/tmpyphcuo4j_test.go:26:19: undefined: binary_to_decimal

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074382
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n     \
    \   result += \"1\"\n    }\n    for i := 0; i < decimal; i++ {\n        result\
    \ += \"0\"\n    }\n    return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpopc6z5a3_test.go:46: expected 'db0db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpopc6z5a3_test.go:46: expected\
    \ 'db100000db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n\
    \        tmpopc6z5a3_test.go:46: expected 'db1100111db', got '10'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpopc6z5a3_test.go:46: expected\
    \ 'db1111db', got '10'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074383
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n     \
    \   result += decimal_to_binary(decimal/2)\n    }\n    decimal %= 2\n    if decimal\
    \ > 0 {\n        result += decimal_to_binary(decimal/2)\n    }\n    decimal %=\
    \ 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n  \
    \  }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= \nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpem5vjt3e_test.go:117:6: expected ''('', found TestDecimal_To_Binary

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074381
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n     \
    \   result += \"1\"\n    }\n    for i := 0; i < decimal; i++ {\n        result\
    \ += \"0\"\n    }\n    return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpopc6z5a3_test.go:46: expected 'db0db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpopc6z5a3_test.go:46: expected\
    \ 'db100000db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n\
    \        tmpopc6z5a3_test.go:46: expected 'db1100111db', got '10'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpopc6z5a3_test.go:46: expected\
    \ 'db1111db', got '10'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074383
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    binary := make([]byte, 32)\n    i := 0\n    for decimal == 0 {\n\
    \        binary[i] = '0'\n        i++\n        decimal = decimal / 2\n    }\n\
    \    for decimal == 1 {\n        binary[i] = '1'\n        i++\n        decimal\
    \ = decimal / 2\n    }\n    binary[i] = 'd'\n    i++\n    binary[i] = 'b'\n  \
    \  i++\n    return string(binary)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\npanic: runtime error: index out\
    \ of range [32] with length 32 [recovered]\n\tpanic: runtime error: index out\
    \ of range [32] with length 32\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2({0x513640,\
    \ 0xc0001c4000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513640, 0xc0001c4000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.decimal_to_binary(...)\n\t/tmp/tmp420nze5k_test.go:22\n\
    command-line-arguments_test.TestDecimal_To_Binary(0x0?)\n\t/tmp/tmp420nze5k_test.go:45\
    \ +0x645\ntesting.tRunner(0xc000184ea0, 0x528f88)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n"
  timestamp: 1660074497
