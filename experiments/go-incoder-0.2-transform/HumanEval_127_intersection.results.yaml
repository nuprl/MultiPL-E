language: go_test.go
name: HumanEval_127_intersection
results:
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpfypebohj_test.go:285:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075396
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    \n    // Write your code here\n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpbz11ina1_test.go:283:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075396
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    if interval1Start > interval2End {\n  \
    \      return \"NO\"\n    }\n    if interval1End < interval2Start {\n        return\
    \ \"NO\"\n    }\n    \n    intersection := interval1Start + interval2End - interval1End\
    \ - interval2Start\n    \n    if intersection <= 0 {\n        return \"NO\"\n\
    \    }\n    \n    if isPrime(intersection) {\n        return \"YES\"\n    }\n\
    \    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate\
    \ := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6bbvm2id_test.go:50:8: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075546
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(int)\n    interval1End := interval1[1].(int)\n\
    \    interval2Start := interval2[0].(int)\n    interval2End := interval2[1].(int)\n\
    \    \n    if interval1Start > interval2End {\n        return \"NO\"\n    }\n\
    \    if interval1End < interval2Start {\n        return \"NO\"\n    }\n    \n\
    \    intersectionStart := interval1Start\n    intersectionEnd := interval1End\n\
    \    \n    for intersectionStart < interval2End {\n        if interval1Start <=\
    \ intersectionEnd && intersectionEnd <= interval2Start {\n            intersectionEnd\
    \ = intersectionEnd + 1\n        } else {\n            return \"NO\"\n       \
    \ }\n    }\n    \n    if interval1Start <= intersectionEnd && intersectionEnd\
    \ <= interval2Start {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n\
    }\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2\
    \ (0.00s)\n        tmpv9swzjjw_test.go:82: expected 'YES', got 'NO'\n    --- FAIL:\
    \ TestIntersection/test_num__3 (0.00s)\n        tmpv9swzjjw_test.go:82: expected\
    \ 'YES', got 'NO'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075546
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    \n    // Write your code here\n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpbz11ina1_test.go:283:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075396
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    if interval1Start > interval2End {\n  \
    \      return \"NO\"\n    }\n    if interval1End < interval2Start {\n        return\
    \ \"NO\"\n    }\n    \n    intersectionStart := interval1Start\n    intersectionEnd\
    \ := interval1End\n    \n    for i := 1; i < len(interval1); i++ {\n        interval1Start\
    \ := interval1[i].(float64)\n        interval1End := interval1[i+1].(float64)\n\
    \        \n        if interval1Start > interval1End {\n            return \"NO\"\
    \n        }\n        if interval1End < interval1Start {\n            return \"\
    NO\"\n        }\n        \n        if interval1Start <= intersectionEnd && interval1End\
    \ >= intersectionStart {\n            intersectionStart = interval1Start\n   \
    \         intersectionEnd = interval1End\n            continue\n        }\n  \
    \      \n        if interval1Start <= intersectionEnd && interval1End >= intersectionStart\
    \ {\n            intersectionStart = interval1End\n            intersectionEnd\
    \ = interval1Start\n            continue\n        }\n        \n        if interval1Start\
    \ <= intersectionEnd && interval1End <= intersectionStart {\n            intersectionStart\
    \ = interval1Start\n            intersectionEnd = interval1End\n            continue\n\
    \        }\n        \n        if interval1Start <= intersectionEnd && interval1End\
    \ >= intersectionStart {\n            intersectionStart = interval1End\n     \
    \       intersectionEnd = interval1Start\n            continue\n        }\n  \
    \      \n        if interval1Start <= intersectionEnd && interval1End <= intersectionStart\
    \ {\n            intersectionStart = interval1Start\n            intersectionEnd\
    \ = interval1End\n            continue\n        }\n        \n        if interval1Start\
    \ <= intersectionEnd && interval1End >= intersectionStart {\n            intersectionStart\
    \ = interval1End\n            intersectionEnd = interval1Start\n            continue\n\
    \        }\n        \n        if interval1Start <= intersectionEnd && interval1End\
    \ <= intersectionStart {\n            intersectionStart = interval1Start\n   \
    \         intersectionEnd = interval1End\n            continue\n        }\n  \
    \      \n        if interval1Start <= intersectionEnd && interval1End >= intersectionStart\
    \ {\n            intersectionStart = interval1End\n            intersectionEnd\
    \ = interval1Start\n            continue\n        }\n        \n        if interval1Start\
    \ <= intersectionEnd && interval1End <= intersectionStart {\n            intersectionStart\
    \ = interval1Start\n            intersectionEnd = interval1End\n            continue\n\
    \        }\n        \n        if interval1\nfunc TestIntersection(t *testing.T)\
    \ {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpem78lk9f_test.go:113:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075545
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    intersectionStart := interval1Start\n \
    \   intersectionEnd := interval1End\n    \n    for i := 1; i < len(interval1);\
    \ i++ {\n        interval1Start := interval1[i].(float64)\n        interval1End\
    \ := interval1[i+1].(float64)\n        \n        if interval1Start <= interval1End\
    \ {\n            intersectionStart = min(intersectionStart, interval1Start)\n\
    \            intersectionEnd = max(intersectionEnd, interval1End)\n        } else\
    \ {\n            intersectionStart = min(intersectionStart, interval1End)\n  \
    \          intersectionEnd = max(intersectionEnd, interval1Start)\n        }\n\
    \    }\n    \n    for i := 1; i < len(interval2); i++ {\n        interval2Start\
    \ := interval2[i].(float64)\n        interval2End := interval2[i+1].(float64)\n\
    \        \n        if interval2Start <= interval2End {\n            intersectionStart\
    \ = min(intersectionStart, interval2Start)\n            intersectionEnd = max(intersectionEnd,\
    \ interval2End)\n        } else {\n            intersectionStart = min(intersectionStart,\
    \ interval2End)\n            intersectionEnd = max(intersectionEnd, interval2Start)\n\
    \        }\n    }\n    \n    if intersectionStart <= intersectionEnd {\n     \
    \   if intersectionStart <= interval1End {\n            if intersectionEnd <=\
    \ interval2End {\n                if intersectionStart <= interval2Start {\n \
    \                   if intersectionEnd <= interval1Start {\n                 \
    \       if intersectionEnd <= interval1End {\n                            if intersectionEnd\
    \ <= interval2Start {\n                                if intersectionEnd <= interval2End\
    \ {\n                                    if intersectionEnd <= interval1Start\
    \ {\n                                        if intersectionEnd <= interval1End\
    \ {\n                                            if intersectionEnd <= interval2Start\
    \ {\n                                                if intersectionEnd <= interval2End\
    \ {\n                                                    if intersectionEnd <=\
    \ interval1Start {\n                                                        if\
    \ intersectionEnd <= interval1End {\n                                        \
    \                    if intersectionEnd <= interval2Start {\n                \
    \                                                if intersectionEnd <= interval2End\
    \ {\n                                                    if intersectionEnd <=\
    \ interval1Start {\n                                                        if\
    \ intersectionEnd <= interval1End {\n                                        \
    \                    if intersectionEnd <= interval2Start {\n                \
    \                                                if intersectionEnd <= interval2End\
    \ {\n                                                    if intersectionEnd <=\
    \ interval1Start {\n                                                        if\
    \ intersectionEnd <= interval1End {\n                                        \
    \                    if intersectionEnd <= interval2Start {\n                \
    \                                                if intersectionEnd <= interval2End\
    \ {\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpex6tlriy_test.go:90:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075545
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    \n    if len(interval1) != len(interval2) {\n        return \"\
    NO\"\n    }\n    \n    interval1 := make([]int, len(interval1))\n    interval2\
    \ := make([]int, len(interval2))\n    \n    for i := 0; i < len(interval1); i++\
    \ {\n        interval1[i] = int(interval1[i])\n    }\n    for i := 0; i < len(interval2);\
    \ i++ {\n        interval2[i] = int(interval2[i])\n    }\n    \n    result :=\
    \ make([]int, len(interval1))\n    \n    for i := 0; i < len(interval1); i++ {\n\
    \        for j := 0; j < len(interval2); j++ {\n            if interval1[i] <\
    \ interval2[j] {\n                result[i] = interval1[i]\n                break\n\
    \            }\n        }\n    }\n    \n    if result == interval1 {\n       \
    \ return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpe1rgmzam_test.go:33:15:\
    \ no new variables on left side of :=\n/tmp/tmpe1rgmzam_test.go:33:18: cannot\
    \ use make([]int, len(interval1)) (value of type []int) as type []interface{}\
    \ in assignment\n/tmp/tmpe1rgmzam_test.go:34:15: no new variables on left side\
    \ of :=\n/tmp/tmpe1rgmzam_test.go:34:18: cannot use make([]int, len(interval2))\
    \ (value of type []int) as type []interface{} in assignment\n/tmp/tmpe1rgmzam_test.go:37:28:\
    \ cannot convert interval1[i] (variable of type interface{}) to type int:\n\t\
    need type assertion\n/tmp/tmpe1rgmzam_test.go:40:28: cannot convert interval2[i]\
    \ (variable of type interface{}) to type int:\n\tneed type assertion\n/tmp/tmpe1rgmzam_test.go:47:16:\
    \ invalid operation: interval1[i] < interval2[j] (operator < not defined on interface)\n\
    /tmp/tmpe1rgmzam_test.go:48:29: cannot use interval1[i] (variable of type interface{})\
    \ as type int in assignment:\n\tneed type assertion\n/tmp/tmpe1rgmzam_test.go:54:18:\
    \ invalid operation: result == interval1 (mismatched types []int and []interface{})\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075546
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    var result string\n    \n    if len(interval1) != len(interval2)\
    \ {\n        return \"NO\"\n    }\n    \n    for i := 0; i < len(interval1); i++\
    \ {\n        if interval1[i].(float64) <= interval2[i].(float64) {\n         \
    \   result += fmt.Sprintf(\"%d\", interval1[i].(float64))\n        } else {\n\
    \            result += fmt.Sprintf(\"%d\", interval2[i].(float64))\n        }\n\
    \    }\n    \n    if result == \"0\" || result == \"1\" {\n        return \"NO\"\
    \n    }\n    \n    if isPrime(int(result)) {\n        return \"YES\"\n    }\n\
    \    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate\
    \ := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdvh_v3u0_test.go:46:8: undefined: isPrime

    /tmp/tmpdvh_v3u0_test.go:46:20: cannot convert result (variable of type string)
    to type int

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075546
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpfypebohj_test.go:285:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075396
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return\
    \ \"NO\"\n    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End\
    \ := interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n  \
    \  interval2End := interval2[1].(float64)\n    \n    if interval1Start > interval2End\
    \ {\n        return \"NO\"\n    }\n    if interval1End < interval2Start {\n  \
    \      return \"NO\"\n    }\n    \n    if interval1Start <= interval2Start {\n\
    \        interval1Start += interval1Start\n        interval1End += interval1End\n\
    \        interval2Start += interval2Start\n        interval2End += interval2End\n\
    \    }\n    \n    if interval1Start <= interval2End {\n        interval1Start\
    \ += interval1Start\n        interval1End += interval1End\n        interval2Start\
    \ += interval2Start\n        interval2End += interval2End\n    }\n    \n    if\
    \ interval1Start > interval2End {\n        return \"NO\"\n    }\n    if interval1End\
    \ < interval2Start {\n        return \"NO\"\n    }\n    \n    if interval1Start\
    \ <= interval2Start {\n        interval1Start += interval1Start\n        interval1End\
    \ += interval1End\n        interval2Start += interval2Start\n        interval2End\
    \ += interval2End\n    }\n    \n    if interval1Start <= interval2End {\n    \
    \    interval1Start += interval1Start\n        interval1End += interval1End\n\
    \        interval2Start += interval2Start\n        interval2End += interval2End\n\
    \    }\n    \n    if interval1Start > interval2End {\n        return \"NO\"\n\
    \    }\n    if interval1End < interval2Start {\n        return \"NO\"\n    }\n\
    \    \n    if interval1Start <= interval2Start {\n        interval1Start += interval1Start\n\
    \        interval1End += interval1End\n        interval2Start += interval2Start\n\
    \        interval2End += interval2End\n    }\n    \n    if interval1Start <= interval2End\
    \ {\n        interval1Start += interval1Start\n        interval1End += interval1End\n\
    \        interval2Start += interval2Start\n        interval2End += interval2End\n\
    \    }\n    \n    if interval1Start > interval2End {\n        return \"NO\"\n\
    \    }\n    if interval1End < interval2Start {\n        return \"NO\"\n    }\n\
    \    \n    if interval1Start <= interval2Start {\n        interval\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmptb_7gowz_test.go:109:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075545
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(int)\n    interval1End := interval1[1].(int)\n\
    \    interval2Start := interval2[0].(int)\n    interval2End := interval2[1].(int)\n\
    \    \n    result := 0\n    \n    if interval1Start <= interval2Start {\n    \
    \    result = interval1Start <= interval2End ? interval1End : interval2End\n \
    \   } else {\n        result = interval1Start <= interval2End ? interval2Start\
    \ : interval1Start\n    }\n    \n    if result % 2 == 0 {\n        return \"NO\"\
    \n    }\n    \n    for i := 3; i <= result/2; i++ {\n        if result % i ==\
    \ 0 {\n            return \"NO\"\n        }\n    }\n    \n    return \"YES\"\n\
    }\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmps3rrmvj5_test.go:40:49: illegal character U+003F ''?''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075545
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(int)\n    interval1End := interval1[1].(int)\n\
    \    interval2Start := interval2[0].(int)\n    interval2End := interval2[1].(int)\n\
    \    \n    if interval1Start > interval2End {\n        return \"NO\"\n    }\n\
    \    if interval1End < interval2Start {\n        return \"NO\"\n    }\n    \n\
    \    result := 0\n    \n    for i := 0; i < interval1Start; i++ {\n        result\
    \ ^= interval2[i]\n    }\n    \n    for i := interval1End; i < interval2End; i++\
    \ {\n        result ^= interval2[i]\n    }\n    \n    if result != 0 {\n     \
    \   return \"YES\"\n    }\n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T)\
    \ {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5s3d08et_test.go:47:9: invalid operation: result ^= interval2[i] (mismatched
    types int and interface{})

    /tmp/tmp5s3d08et_test.go:51:9: invalid operation: result ^= interval2[i] (mismatched
    types int and interface{})

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075546
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    if interval1Start > interval1End || interval2Start\
    \ > interval2End {\n        return \"NO\"\n    }\n    \n    interval1Length :=\
    \ interval1End - interval1Start\n    interval2Length := interval2End - interval2Start\n\
    \    \n    if interval1Length == 0 || interval2Length == 0 {\n        return \"\
    NO\"\n    }\n    \n    if interval1Length == interval2Length {\n        if interval1Start\
    \ <= interval2Start {\n            return \"NO\"\n        }\n        if interval1End\
    \ >= interval2End {\n            return \"NO\"\n        }\n        return \"YES\"\
    \n    }\n    \n    if interval1Length > interval2Length {\n        interval1Length\
    \ -= interval2Length\n        interval2Length = 0\n    }\n    \n    if interval1Length\
    \ < interval2Length {\n        interval2Length -= interval1Length\n        interval1Length\
    \ = 0\n    }\n    \n    if interval1Length == 0 {\n        return \"NO\"\n   \
    \ }\n    \n    if interval2Length == 0 {\n        return \"NO\"\n    }\n    \n\
    \    if interval1Start <= interval2Start {\n        if interval1Start < interval2Start\
    \ {\n            return \"NO\"\n        }\n        return \"YES\"\n    }\n   \
    \ \n    if interval1End >= interval2End {\n        if interval1End > interval2End\
    \ {\n            return \"NO\"\n        }\n        return \"YES\"\n    }\n   \
    \ \n    if interval1Start <= interval2End {\n        if interval1Start < interval2End\
    \ {\n            return \"NO\"\n        }\n        return \"YES\"\n    }\n   \
    \ \n    if interval1End >= interval2Start {\n        if interval1End > interval2Start\
    \ {\n            return \"NO\"\n        }\n        return \"YES\"\n    }\n   \
    \ \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate\
    \ := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface\
    \ {} is int, not float64\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x503ea0,\
    \ 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503ea0, 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection({0xc0000f5cc0?, 0x2?, 0x2?},\
    \ {0xc0000f5ca0?, 0x2?, 0x2?})\n\t/tmp/tmpw3p7v38x_test.go:32 +0x2eb\ncommand-line-arguments_test.TestIntersection(0x0?)\n\
    \t/tmp/tmpw3p7v38x_test.go:114 +0xe7\ntesting.tRunner(0xc0001a01a0, 0x528f48)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075546
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(int)\n    interval1End := interval1[1].(int)\n\
    \    interval2Start := interval2[0].(int)\n    interval2End := interval2[1].(int)\n\
    \    \n    if interval1Start > interval2End {\n        return \"NO\"\n    }\n\
    \    if interval1End < interval2Start {\n        return \"NO\"\n    }\n    \n\
    \    intersectionLength := interval1End - interval1Start\n    if interval1Start\
    \ <= interval2Start && interval1End >= interval2End {\n        return \"YES\"\n\
    \    }\n    if interval1Start <= interval2End && interval1End >= interval2Start\
    \ {\n        return \"YES\"\n    }\n    if interval1Start >= interval2Start &&\
    \ interval1End <= interval2End {\n        return \"YES\"\n    }\n    \n    if\
    \ interval1Start <= interval2Start && interval1End >= interval2End {\n       \
    \ return \"YES\"\n    }\n    if interval1Start >= interval2Start && interval1End\
    \ <= interval2End {\n        return \"YES\"\n    }\n    \n    if interval1Start\
    \ <= interval2Start && interval1End >= interval2End {\n        return \"YES\"\n\
    \    }\n    if interval1Start >= interval2Start && interval1End <= interval2End\
    \ {\n        return \"YES\"\n    }\n    \n    if interval1Start <= interval2Start\
    \ && interval1End >= interval2End {\n        return \"YES\"\n    }\n    if interval1Start\
    \ >= interval2Start && interval1End <= interval2End {\n        return \"YES\"\n\
    \    }\n    \n    if interval1Start <= interval2Start && interval1End >= interval2End\
    \ {\n        return \"YES\"\n    }\n    if interval1Start >= interval2Start &&\
    \ interval1End <= interval2End {\n        return \"YES\"\n    }\n    \n    if\
    \ interval1Start <= interval2Start && interval1End >= interval2End {\n       \
    \ return \"YES\"\n    }\n    if interval1Start >= interval2Start && interval1End\
    \ <= interval2End {\n        return \"YES\"\n    }\n    \n    if interval1Start\
    \ <= interval2Start && interval1End >= interval2End {\n        return \"YES\"\n\
    \    }\n    if interval1Start >= interval2Start && interval1End <= interval2End\
    \ {\n        return \"YES\"\n    }\n    \n    if interval1Start <= interval2Start\
    \ && interval1End >= interval2End {\n        return \"YES\"\n    }\n    if interval1Start\
    \ >= interval2Start && \nfunc TestIntersection(t *testing.T) {\n  candidate :=\
    \ intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpx15pd99g_test.go:101:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075545
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    \n    var interval1Start, interval1End int\n    var interval2Start,\
    \ interval2End int\n    \n    interval1Start, interval1End = interval1[0].(int),\
    \ interval1[1].(int)\n    interval2Start, interval2End = interval2[0].(int), interval2[1].(int)\n\
    \    \n    if interval1Start > interval2End {\n        return fmt.Sprintf(\"NO\"\
    )\n    }\n    if interval1End < interval2Start {\n        return fmt.Sprintf(\"\
    NO\")\n    }\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpqul8899g_test.go:250:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075545
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    \n    // Your code here\n    \n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpejg7v3l3_test.go:54: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmpejg7v3l3_test.go:54: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmpejg7v3l3_test.go:54:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmpejg7v3l3_test.go:54: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmpejg7v3l3_test.go:54: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmpejg7v3l3_test.go:54: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmpejg7v3l3_test.go:54:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmpejg7v3l3_test.go:54: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660075546
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    interval1Start, interval1End := interval1[0], interval1[1]\n \
    \   interval2Start, interval2End := interval2[0], interval2[1]\n\n    if interval1Start\
    \ > interval1End {\n        fmt.Println(\"interval1Start > interval1End\")\n \
    \       return \"NO\"\n    }\n    if interval2Start > interval2End {\n       \
    \ fmt.Println(\"interval2Start > interval2End\")\n        return \"NO\"\n    }\n\
    \n    if interval1Start <= interval2Start && interval1End >= interval2End {\n\
    \        fmt.Println(\"interval1Start <= interval2Start && interval1End >= interval2End\"\
    )\n        return \"NO\"\n    }\n\n    if interval1Start <= interval2End && interval1End\
    \ >= interval2Start {\n        fmt.Println(\"interval1Start <= interval2End &&\
    \ interval1End >= interval2Start\")\n        return \"NO\"\n    }\n\n    if interval1Start\
    \ <= interval2Start && interval1End >= interval2End {\n        fmt.Println(\"\
    interval1Start <= interval2Start && interval1End >= interval2End\")\n        return\
    \ \"NO\"\n    }\n\n    if interval1Start <= interval2End && interval1End >= interval2Start\
    \ {\n        fmt.Println(\"interval1Start <= interval2End && interval1End >= interval2Start\"\
    )\n        return \"NO\"\n    }\n\n    if interval1Start <= interval2Start &&\
    \ interval1End >= interval2End {\n        fmt.Println(\"interval1Start <= interval2Start\
    \ && interval1End >= interval2End\")\n        return \"NO\"\n    }\n\n    if interval1Start\
    \ <= interval2End && interval1End >= interval2Start {\n        fmt.Println(\"\
    interval1Start <= interval2End && interval1End >= interval2Start\")\n        return\
    \ \"NO\"\n    }\n\n    if interval1Start <= interval2Start && interval1End >=\
    \ interval2End {\n        fmt.Println(\"interval1Start <= interval2Start && interval1End\
    \ >= interval2End\")\n        return \"NO\"\n    }\n\n    if interval1Start <=\
    \ interval2End && interval1End >= interval2Start {\n        fmt.Println(\"interval1Start\
    \ <= interval2End && interval1End >= interval2Start\")\n        return \"NO\"\n\
    \    }\n\n    if interval1Start <= interval2Start && interval1End >= interval2End\
    \ {\n        fmt.Println(\"interval1Start <= interval2Start && interval1End >=\
    \ interval2End\")\n        return \"NO\"\n    }\n\n    if interval1Start <= interval2End\
    \ && interval1End >= interval2Start {\n        f\nfunc TestIntersection(t *testing.T)\
    \ {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpg9bq9cov_test.go:87:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075545
- exit_code: null
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(int)\n    interval1End := interval1[1].(int)\n\
    \    interval2Start := interval2[0].(int)\n    interval2End := interval2[1].(int)\n\
    \    \n    if interval1Start > interval1End {\n        return \"NO\"\n    }\n\
    \    if interval2Start > interval2End {\n        return \"NO\"\n    }\n    \n\
    \    intersectionStart := interval1Start\n    intersectionEnd := interval1End\n\
    \    \n    for intersectionStart <= interval2End {\n        if interval1Start\
    \ <= intersectionEnd && intersectionEnd <= interval2End {\n            if interval1Start\
    \ <= intersectionStart && intersectionStart <= interval2Start {\n            \
    \    intersectionEnd = interval2End\n            } else {\n                intersectionStart\
    \ = interval2Start\n            }\n        } else {\n            break\n     \
    \   }\n    }\n    \n    if intersectionStart <= interval2End {\n        return\
    \ \"YES\"\n    } else {\n        return \"NO\"\n    }\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660075557
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    \n    interval1Start := interval1[0].(float64)\n    interval1End\
    \ := interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n  \
    \  interval2End := interval2[1].(float64)\n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n\nfunc TestIntersection(t *testing.T) {\n\
    \  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpjbvn0uj2_test.go:267:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075402
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    if interval1Start > interval2End {\n  \
    \      return \"NO\"\n    }\n    if interval1End < interval2Start {\n        return\
    \ \"NO\"\n    }\n    \n    intersectionStart := interval1Start\n    intersectionEnd\
    \ := interval1End\n    \n    for i := 1; i < len(interval1); i++ {\n        interval1Start\
    \ := interval1[i].(float64)\n        interval1End := interval1[i+1].(float64)\n\
    \        \n        if interval1Start > interval2End {\n            return \"NO\"\
    \n        }\n        if interval1End < interval2Start {\n            return \"\
    NO\"\n        }\n        \n        if interval1Start <= intersectionEnd && interval1End\
    \ >= intersectionStart {\n            intersectionEnd = interval1End\n       \
    \ }\n        if interval1Start >= intersectionEnd && interval1End <= intersectionStart\
    \ {\n            intersectionStart = interval1Start\n        }\n    }\n    \n\
    \    if intersectionStart <= intersectionEnd {\n        return \"YES\"\n    }\n\
    \    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate :=\
    \ intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface\
    \ {} is int, not float64\n\ngoroutine 34 [running]:\ntesting.tRunner.func1.2({0x503ea0,\
    \ 0xc00018e3c0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503ea0, 0xc00018e3c0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection({0xc000187cc0?, 0x2?, 0x2?},\
    \ {0xc000187ca0?, 0x2?, 0x2?})\n\t/tmp/tmpb5uh4q8p_test.go:32 +0x26c\ncommand-line-arguments_test.TestIntersection(0x0?)\n\
    \t/tmp/tmpb5uh4q8p_test.go:79 +0xe7\ntesting.tRunner(0xc000199040, 0x528f48)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n"
  timestamp: 1660075546
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    \n    // Write your code here\n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpbz11ina1_test.go:283:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075396
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpfypebohj_test.go:285:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075396
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    if interval1Start > interval2End {\n  \
    \      return \"NO\"\n    }\n    if interval1End < interval2Start {\n        return\
    \ \"NO\"\n    }\n    \n    intersectionStart := interval1Start\n    intersectionEnd\
    \ := interval1End\n    \n    for i := 1; i < len(interval1); i++ {\n        interval1Start\
    \ := interval1[i].(float64)\n        interval1End := interval1[i+1].(float64)\n\
    \        \n        if interval1Start > interval2End {\n            return \"NO\"\
    \n        }\n        if interval1End < interval2Start {\n            return \"\
    NO\"\n        }\n        \n        if interval1Start <= intersectionEnd {\n  \
    \          if interval1End >= intersectionStart {\n                intersectionEnd\
    \ = interval1End\n            }\n        } else {\n            if interval1Start\
    \ >= intersectionStart {\n                intersectionStart = interval1Start\n\
    \            }\n        }\n    }\n    \n    if intersectionEnd <= intersectionStart\
    \ {\n        return \"NO\"\n    }\n    \n    if isPrime(intersectionEnd - intersectionStart)\
    \ {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpnwlokyhv_test.go:73:8: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075546
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return\
    \ \"NO\"\n    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End\
    \ := interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n  \
    \  interval2End := interval2[1].(float64)\n    \n    if interval1Start > interval2End\
    \ {\n        return \"NO\"\n    }\n    if interval1End < interval2Start {\n  \
    \      return \"NO\"\n    }\n    \n    intersectionStart := interval1Start\n \
    \   intersectionEnd := interval1End\n    \n    for interval1Start <= interval1End\
    \ && interval2Start <= interval2End {\n        if interval1Start <= interval2Start\
    \ {\n            intersectionStart = interval1Start\n            intersectionEnd\
    \ = interval1End\n        }\n        if interval1End <= interval2End {\n     \
    \       intersectionEnd = interval1End\n        }\n        if intersectionStart\
    \ > intersectionEnd {\n            return \"NO\"\n        }\n        \n      \
    \  interval1Start = interval1Start + 1\n        interval1End = interval1End +\
    \ 1\n        interval2Start = interval2Start + 1\n        interval2End = interval2End\
    \ + 1\n    }\n    \n    if intersectionStart > intersectionEnd {\n        return\
    \ \"NO\"\n    }\n    \n    if isPrime(intersectionStart) && isPrime(intersectionEnd)\
    \ {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpgc9fb206_test.go:69:8: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075546
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return\
    \ \"NO\"\n    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End\
    \ := interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n  \
    \  interval2End := interval2[1].(float64)\n    \n    if interval1Start > interval1End\
    \ {\n        interval1Start, interval1End = interval1End, interval1Start\n   \
    \ }\n    if interval2Start > interval2End {\n        interval2Start, interval2End\
    \ = interval2End, interval2Start\n    }\n    \n    if interval1Start <= interval2Start\
    \ && interval1End >= interval2End {\n        return \"YES\"\n    }\n    if interval1Start\
    \ <= interval2End && interval1End >= interval2Start {\n        return \"NO\"\n\
    \    }\n    if interval1Start >= interval2Start && interval1End <= interval2End\
    \ {\n        return \"NO\"\n    }\n    if interval1Start >= interval2End && interval1End\
    \ <= interval2Start {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n\
    }\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface\
    \ {} is int, not float64\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x503ea0,\
    \ 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503ea0, 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection({0xc0000f5cc0?, 0x2?, 0x2?},\
    \ {0xc0000f5ca0?, 0x2?, 0x2?})\n\t/tmp/tmpl4y3q2of_test.go:32 +0x1cc\ncommand-line-arguments_test.TestIntersection(0x0?)\n\
    \t/tmp/tmpl4y3q2of_test.go:67 +0xe7\ntesting.tRunner(0xc0001a01a0, 0x528f48)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075401
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    if interval1Start > interval2End {\n  \
    \      return \"NO\"\n    }\n    if interval1End < interval2Start {\n        return\
    \ \"NO\"\n    }\n    \n    intersectionStart := interval1Start\n    intersectionEnd\
    \ := interval1End\n    \n    for i := 1; i < len(interval1); i++ {\n        interval1Start\
    \ := interval1[i].(float64)\n        interval1End := interval1[i+1].(float64)\n\
    \        \n        if interval1Start > interval2End {\n            return \"NO\"\
    \n        }\n        if interval1End < interval2Start {\n            return \"\
    NO\"\n        }\n        \n        if interval1Start <= intersectionEnd {\n  \
    \          if interval1End >= intersectionStart {\n                intersectionEnd\
    \ = interval1End\n            }\n        } else {\n            if interval1Start\
    \ >= intersectionStart {\n                intersectionStart = interval1Start\n\
    \            }\n        }\n    }\n    \n    if intersectionEnd <= intersectionStart\
    \ {\n        return \"NO\"\n    }\n    \n    if isPrime(intersectionEnd - intersectionStart)\
    \ {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpnwlokyhv_test.go:73:8: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075546
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    if interval1Start > interval1End {\n  \
    \      interval1Start, interval1End = interval1End, interval1Start\n    }\n  \
    \  if interval2Start > interval2End {\n        interval2Start, interval2End =\
    \ interval2End, interval2Start\n    }\n    \n    if interval1Start <= interval2Start\
    \ && interval1End >= interval2End {\n        return fmt.Sprintf(\"YES\")\n   \
    \ }\n    \n    if interval1Start <= interval2End && interval1End >= interval2Start\
    \ {\n        return fmt.Sprintf(\"NO\")\n    }\n    \n    if interval1Start <=\
    \ interval2Start && interval1End <= interval2End {\n        return fmt.Sprintf(\"\
    NO\")\n    }\n    \n    if interval1Start >= interval2Start && interval1End <=\
    \ interval2End {\n        return fmt.Sprintf(\"NO\")\n    }\n    \n    if interval1Start\
    \ >= interval2Start && interval1End >= interval2End {\n        return fmt.Sprintf(\"\
    YES\")\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T)\
    \ {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface\
    \ {} is int, not float64\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x503ea0,\
    \ 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503ea0, 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection({0xc0000f5cc0?, 0x2?, 0x2?},\
    \ {0xc0000f5ca0?, 0x2?, 0x2?})\n\t/tmp/tmpuwtrjfh9_test.go:32 +0x22c\ncommand-line-arguments_test.TestIntersection(0x0?)\n\
    \t/tmp/tmpuwtrjfh9_test.go:74 +0xe7\ntesting.tRunner(0xc0001924e0, 0x528f48)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075546
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    var result string\n    \n    if len(interval1) != len(interval2)\
    \ {\n        return \"NO\"\n    }\n    \n    for i := 0; i < len(interval1); i++\
    \ {\n        if interval1[i].(float64) <= interval2[i].(float64) {\n         \
    \   result = \"NO\"\n            break\n        }\n    }\n    \n    if result\
    \ == \"NO\" {\n        return \"NO\"\n    }\n    \n    for i := 0; i < len(interval1);\
    \ i++ {\n        if interval1[i].(float64) >= interval2[i].(float64) {\n     \
    \       result = \"NO\"\n            break\n        }\n    }\n    \n    if result\
    \ == \"NO\" {\n        return \"NO\"\n    }\n    \n    if result == \"\" {\n \
    \       return \"YES\"\n    }\n    \n    return result\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface\
    \ {} is int, not float64\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x503ea0,\
    \ 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503ea0, 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection({0xc0000f5cc0?, 0x2?, 0x2?},\
    \ {0xc0000f5ca0?, 0x2?, 0x2?})\n\t/tmp/tmp1iod45mq_test.go:35 +0x1bb\ncommand-line-arguments_test.TestIntersection(0x0?)\n\
    \t/tmp/tmp1iod45mq_test.go:70 +0xe7\ntesting.tRunner(0xc0001a01a0, 0x528f48)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075546
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    interval1Start, interval1End := interval1[0], interval1[1]\n \
    \   interval2Start, interval2End := interval2[0], interval2[1]\n\n    if interval1Start\
    \ > interval2End {\n        return fmt.Sprintf(\"NO\")\n    }\n\n    if interval1End\
    \ < interval2Start {\n        return fmt.Sprintf(\"NO\")\n    }\n\n    if interval1Start\
    \ > interval2Start {\n        return fmt.Sprintf(\"NO\")\n    }\n\n    if interval1Start\
    \ <= interval2Start && interval1End >= interval2End {\n        return fmt.Sprintf(\"\
    YES\")\n    }\n\n    if interval1Start <= interval2End && interval1End >= interval2Start\
    \ {\n        return fmt.Sprintf(\"YES\")\n    }\n\n    if interval1Start <= interval2Start\
    \ && interval1End < interval2End {\n        return fmt.Sprintf(\"YES\")\n    }\n\
    \n    if interval1Start > interval2Start && interval1End <= interval2End {\n \
    \       return fmt.Sprintf(\"YES\")\n    }\n\n    if interval1Start > interval2Start\
    \ && interval1End > interval2End {\n        return fmt.Sprintf(\"NO\")\n    }\n\
    \n    return fmt.Sprintf(\"NO\")\n}\n\nfunc TestIntersection(t *testing.T) {\n\
    \  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp73bs1r5m_test.go:31:8: invalid operation: interval1Start > interval2End
    (operator > not defined on interface)

    /tmp/tmp73bs1r5m_test.go:35:8: invalid operation: interval1End < interval2Start
    (operator < not defined on interface)

    /tmp/tmp73bs1r5m_test.go:39:8: invalid operation: interval1Start > interval2Start
    (operator > not defined on interface)

    /tmp/tmp73bs1r5m_test.go:43:8: invalid operation: interval1Start <= interval2Start
    (operator <= not defined on interface)

    /tmp/tmp73bs1r5m_test.go:43:44: invalid operation: interval1End >= interval2End
    (operator >= not defined on interface)

    /tmp/tmp73bs1r5m_test.go:47:8: invalid operation: interval1Start <= interval2End
    (operator <= not defined on interface)

    /tmp/tmp73bs1r5m_test.go:47:42: invalid operation: interval1End >= interval2Start
    (operator >= not defined on interface)

    /tmp/tmp73bs1r5m_test.go:51:8: invalid operation: interval1Start <= interval2Start
    (operator <= not defined on interface)

    /tmp/tmp73bs1r5m_test.go:51:44: invalid operation: interval1End < interval2End
    (operator < not defined on interface)

    /tmp/tmp73bs1r5m_test.go:55:8: invalid operation: interval1Start > interval2Start
    (operator > not defined on interface)

    /tmp/tmp73bs1r5m_test.go:55:8: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075546
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    if interval1Start > interval1End {\n  \
    \      interval1Start, interval1End = interval1End, interval1Start\n    }\n  \
    \  if interval2Start > interval2End {\n        interval2Start, interval2End =\
    \ interval2End, interval2Start\n    }\n    \n    intersectionLength := interval1End\
    \ - interval1Start\n    \n    if interval2Start > interval2End {\n        intersectionLength\
    \ += interval2End - interval2Start\n    }\n    \n    if intersectionLength ==\
    \ 0 {\n        return \"NO\"\n    }\n    \n    if intersectionLength == 1 {\n\
    \        return \"YES\"\n    }\n    \n    if isPrime(intersectionLength) {\n \
    \       return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpanersta5_test.go:58:8: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075546
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpfypebohj_test.go:285:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075396
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    if interval1Start > interval2End {\n  \
    \      return \"NO\"\n    }\n    if interval1End < interval2Start {\n        return\
    \ \"NO\"\n    }\n    \n    interval1Length := interval1End - interval1Start\n\
    \    interval2Length := interval2End - interval2Start\n    \n    if interval1Length\
    \ == 0 || interval2Length == 0 {\n        return \"NO\"\n    }\n    \n    intersectionLength\
    \ := interval1Length * interval2Length\n    if intersectionLength == 0 {\n   \
    \     return \"NO\"\n    }\n    \n    if interval1Length == interval2Length {\n\
    \        if interval1Start <= interval2Start {\n            return \"YES\"\n \
    \       }\n        return \"NO\"\n    }\n    \n    if interval1Start <= interval2Start\
    \ {\n        if interval1Length == 1 {\n            return \"YES\"\n        }\n\
    \        return \"NO\"\n    }\n    \n    if interval1End >= interval2End {\n \
    \       if interval2Length == 1 {\n            return \"YES\"\n        }\n   \
    \     return \"NO\"\n    }\n    \n    if interval1Start <= interval2Start {\n\
    \        if interval1Length == 1 {\n            return \"YES\"\n        }\n  \
    \      return \"NO\"\n    }\n    \n    if interval1End >= interval2End {\n   \
    \     if interval2Length == 1 {\n            return \"YES\"\n        }\n     \
    \   return \"NO\"\n    }\n    \n    if interval1Start <= interval2Start {\n  \
    \      if interval1Length == 1 {\n            return \"YES\"\n        }\n    \
    \    return \"NO\"\n    }\n    \n    if interval1End >= interval2End {\n     \
    \   if interval2Length == 1 {\n            return \"YES\"\n        }\n       \
    \ return \"NO\"\n    }\n    \n    if interval1Start <= interval2Start {\n    \
    \    if interval1Length == 1 {\n            return \"YES\"\n        }\n      \
    \  return \"NO\"\n    }\n    \n    if interval1End >= interval2End {\n       \
    \ if interval2Length == 1 {\n            return \"YES\"\n        }\n        return\
    \ \"NO\"\n    }\n    \n    if interval1Start <= interval2Start {\n        if interval1Length\
    \ == 1 {\n            return \"YES\"\n        }\n        return \"NO\"\n    }\n\
    \    \n    if interval1End >= interval2End {\n        if interval2Length == 1\
    \ {\n            return \"YES\"\n        }\n        return \"NO\"\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpdof6o1az_test.go:131:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075545
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(int)\n    interval1End := interval1[1].(int)\n\
    \    interval2Start := interval2[0].(int)\n    interval2End := interval2[1].(int)\n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n\nfunc TestIntersection(t *testing.T)\
    \ {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp7xauvqf3_test.go:265:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075546
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    var interval1_start, interval1_end int\n    var interval2_start,\
    \ interval2_end int\n    var interval1_length, interval2_length int\n\n    for\
    \ _, interval := range interval1 {\n        interval1_start = interval.(float64)\n\
    \    }\n    for _, interval := range interval2 {\n        interval2_start = interval.(float64)\n\
    \    }\n    interval1_length = interval1_end - interval1_start\n    interval2_length\
    \ = interval2_end - interval2_start\n\n    if interval1_length == 0 || interval2_length\
    \ == 0 {\n        return \"NO\"\n    }\n\n    if interval1_start <= interval2_start\
    \ {\n        if interval1_end >= interval2_end {\n            return \"NO\"\n\
    \        }\n        if interval1_start <= interval2_end {\n            return\
    \ \"YES\"\n        }\n    }\n    if interval1_end >= interval2_start {\n     \
    \   if interval1_start <= interval2_end {\n            return \"YES\"\n      \
    \  }\n        if interval1_end >= interval2_end {\n            return \"NO\"\n\
    \        }\n    }\n    if interval1_start <= interval2_start {\n        if interval1_end\
    \ >= interval2_end {\n            return \"YES\"\n        }\n        if interval1_start\
    \ <= interval2_end {\n            return \"NO\"\n        }\n    }\n    if interval1_end\
    \ >= interval2_start {\n        if interval1_start <= interval2_end {\n      \
    \      return \"NO\"\n        }\n        if interval1_end >= interval2_end {\n\
    \            return \"YES\"\n        }\n    }\n    return \"NO\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpg4omfjj8_test.go:33:27: cannot use interval.(float64) (comma, ok expression
    of type float64) as type int in assignment

    /tmp/tmpg4omfjj8_test.go:36:27: cannot use interval.(float64) (comma, ok expression
    of type float64) as type int in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075547
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(int)\n    interval1End := interval1[1].(int)\n\
    \    interval2Start := interval2[0].(int)\n    interval2End := interval2[1].(int)\n\
    \    \n    if interval1Start > interval1End {\n        return \"NO\"\n    }\n\
    \    if interval2Start > interval2End {\n        return \"NO\"\n    }\n    \n\
    \    interval1Interval := interval1End - interval1Start\n    interval2Interval\
    \ := interval2End - interval2Start\n    \n    if interval1Interval == 0 || interval2Interval\
    \ == 0 {\n        return \"NO\"\n    }\n    \n    intersection := interval1Interval\
    \ * interval2Interval\n    \n    if intersection <= 1 {\n        return \"NO\"\
    \n    }\n    \n    if isPrime(intersection) {\n        return \"YES\"\n    }\n\
    \    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate\
    \ := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpzm2orkcb_test.go:57:8: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075547
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    var interval1_start, interval1_end int\n    var interval2_start,\
    \ interval2_end int\n    \n    interval1_start = interval1[0].(int)\n    interval1_end\
    \ = interval1[1].(int)\n    interval2_start = interval2[0].(int)\n    interval2_end\
    \ = interval2[1].(int)\n    \n    if interval1_start > interval1_end {\n     \
    \   interval1_start, interval1_end = interval1_end, interval1_start\n    }\n \
    \   if interval2_start > interval2_end {\n        interval2_start, interval2_end\
    \ = interval2_end, interval2_start\n    }\n    \n    if interval1_start > interval2_end\
    \ {\n        return \"NO\"\n    }\n    if interval2_start > interval1_end {\n\
    \        return \"NO\"\n    }\n    \n    if interval1_start == interval1_end {\n\
    \        if interval2_start == interval2_end {\n            if interval1_start\
    \ == interval1_end {\n                return \"YES\"\n            }\n        \
    \    return \"NO\"\n        }\n        return \"NO\"\n    }\n    \n    if interval2_start\
    \ == interval2_end {\n        return \"NO\"\n    }\n    \n    if interval1_start\
    \ < interval1_end {\n        if interval2_start < interval2_end {\n          \
    \  if interval1_start < interval2_start {\n                return \"NO\"\n   \
    \         }\n            if interval1_end < interval2_end {\n                return\
    \ \"NO\"\n            }\n        }\n        if interval2_start < interval1_end\
    \ {\n            return \"NO\"\n        }\n        if interval1_start < interval2_end\
    \ {\n            return \"NO\"\n        }\n    }\n    \n    return \"YES\"\n}\n\
    \nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2\
    \ (0.00s)\n        tmpgo0fssh2_test.go:104: expected 'YES', got 'NO'\n    ---\
    \ FAIL: TestIntersection/test_num__3 (0.00s)\n        tmpgo0fssh2_test.go:104:\
    \ expected 'YES', got 'NO'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075548
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(int)\n    interval1End := interval1[1].(int)\n\
    \    interval2Start := interval2[0].(int)\n    interval2End := interval2[1].(int)\n\
    \    \n    if interval1Start > interval1End {\n        return \"NO\"\n    }\n\
    \    if interval2Start > interval2End {\n        return \"NO\"\n    }\n    \n\
    \    intersection := interval1Start <= interval2End && interval2Start <= interval1End\n\
    \    \n    if intersection {\n        intersectionLength := interval1End - interval1Start\n\
    \        if intersectionLength == 2 {\n            return \"YES\"\n        }\n\
    \        if intersectionLength == 3 {\n            return \"YES\"\n        }\n\
    \        if intersectionLength == 5 {\n            return \"YES\"\n        }\n\
    \        if intersectionLength == 7 {\n            return \"YES\"\n        }\n\
    \        if intersectionLength == 9 {\n            return \"YES\"\n        }\n\
    \        if intersectionLength == 11 {\n            return \"YES\"\n        }\n\
    \        if intersectionLength == 13 {\n            return \"YES\"\n        }\n\
    \        if intersectionLength == 17 {\n            return \"YES\"\n        }\n\
    \        if intersectionLength == 19 {\n            return \"YES\"\n        }\n\
    \        if intersectionLength == 31 {\n            return \"YES\"\n        }\n\
    \        if intersectionLength == 37 {\n            return \"YES\"\n        }\n\
    \        if intersectionLength == 47 {\n            return \"YES\"\n        }\n\
    \        if intersectionLength == 71 {\n            return \"YES\"\n        }\n\
    \        if intersectionLength == 97 {\n            return \"YES\"\n        }\n\
    \        if intersectionLength == 109 {\n            return \"YES\"\n        }\n\
    \        if intersectionLength == 127 {\n            return \"YES\"\n        }\n\
    \        if intersectionLength == 131 {\n            return \"YES\"\n        }\n\
    \        if intersectionLength == 137 {\n            return \"YES\"\n        }\n\
    \        if intersectionLength == 143 {\n            return \"YES\"\n        }\n\
    \        if intersectionLength == 151 {\n            return \"YES\"\n        }\n\
    \        if intersectionLength == 157 {\n            return \"YES\"\n        }\n\
    \        if intersectionLength == 163 {\n            return \"YES\"\n        }\n\
    \        if intersectionLength == 169 {\n            return \"YES\"\n        }\n\
    \        if intersectionLength == 173 {\n            return \"YES\"\n        }\n\
    \        if intersectionLength == 179 {\n            return \"YES\"\n        }\n\
    \        if intersectionLength == 183 {\n            return \"YES\"\n        }\n\
    \        if intersectionLength == 191 {\n            return \"YES\"\n        }\n\
    \        if intersectionLength == 197 {\n            return \"YES\"\n        }\n\
    \        if intersectionLength == 203 {\n            return \"YES\"\n        }\n\
    \        if intersectionLength == 209 {\n            return \"YES\"\n        }\n\
    func TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp5zswdn7c_test.go:138:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075546
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    if interval1Start > interval2End {\n  \
    \      return \"NO\"\n    }\n    if interval1End < interval2Start {\n        return\
    \ \"NO\"\n    }\n    \n    interval1Length := interval1End - interval1Start\n\
    \    interval2Length := interval2End - interval2Start\n    \n    if interval1Length\
    \ == 0 || interval2Length == 0 {\n        return \"NO\"\n    }\n    \n    if interval1Length\
    \ == interval2Length {\n        if interval1Start <= interval2Start {\n      \
    \      return \"YES\"\n        }\n        return \"NO\"\n    }\n    \n    if interval1Length\
    \ < interval2Length {\n        interval1Start += interval1Length\n        interval1End\
    \ -= interval1Length\n    } else {\n        interval2Start += interval2Length\n\
    \        interval2End -= interval2Length\n    }\n    \n    if interval1Start <=\
    \ interval2Start {\n        return \"YES\"\n    }\n    return \"NO\"\n}\n\nfunc\
    \ TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface\
    \ {} is int, not float64\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x503ea0,\
    \ 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503ea0, 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection({0xc0000f5cc0?, 0x2?, 0x2?},\
    \ {0xc0000f5ca0?, 0x2?, 0x2?})\n\t/tmp/tmptqjad8bw_test.go:32 +0x1f0\ncommand-line-arguments_test.TestIntersection(0x0?)\n\
    \t/tmp/tmptqjad8bw_test.go:79 +0xe7\ntesting.tRunner(0xc0001a01a0, 0x528f48)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075548
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return\
    \ \"NO\"\n    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End\
    \ := interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n  \
    \  interval2End := interval2[1].(float64)\n    \n    if interval1Start > interval2End\
    \ {\n        return \"NO\"\n    }\n    if interval1End < interval2Start {\n  \
    \      return \"NO\"\n    }\n    \n    intersection := interval1Start + interval1End\
    \ + interval2Start + interval2End\n    \n    if intersection <= 1 {\n        return\
    \ \"NO\"\n    }\n    \n    if isPrime(intersection) {\n        return \"YES\"\n\
    \    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n\
    \  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpf7wsb0b5_test.go:50:8: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075547
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    intersectionStart := interval1Start\n \
    \   intersectionEnd := interval1End\n    \n    for i := 1; i < len(interval1);\
    \ i++ {\n        interval1Start := interval1[i].(float64)\n        interval1End\
    \ := interval1[i+1].(float64)\n        \n        if interval1Start <= interval1End\
    \ {\n            intersectionStart = interval1Start\n            intersectionEnd\
    \ = interval1End\n        } else {\n            intersectionStart = interval1End\n\
    \            intersectionEnd = interval1Start\n        }\n    }\n    \n    for\
    \ i := 1; i < len(interval2); i++ {\n        interval2Start := interval2[i].(float64)\n\
    \        interval2End := interval2[i+1].(float64)\n        \n        if interval2Start\
    \ <= interval2End {\n            intersectionStart = interval2Start\n        \
    \    intersectionEnd = interval2End\n        } else {\n            intersectionStart\
    \ = interval2End\n            intersectionEnd = interval2Start\n        }\n  \
    \  }\n    \n    if intersectionStart <= intersectionEnd {\n        if intersectionStart\
    \ <= interval1Start && intersectionEnd <= interval1End {\n            return \"\
    YES\"\n        }\n        if intersectionStart <= interval2Start && intersectionEnd\
    \ <= interval2End {\n            return \"YES\"\n        }\n        if intersectionStart\
    \ <= interval1Start && intersectionEnd <= interval2End {\n            return \"\
    YES\"\n        }\n        if intersectionStart <= interval2Start && intersectionEnd\
    \ <= interval1End {\n            return \"YES\"\n        }\n    }\n    \n    return\
    \ \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface\
    \ {} is int, not float64\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x503ea0,\
    \ 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503ea0, 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection({0xc0000f5cc0?, 0x2?, 0x2?},\
    \ {0xc0000f5ca0?, 0x2?, 0x2?})\n\t/tmp/tmplemom6q1_test.go:32 +0x2ee\ncommand-line-arguments_test.TestIntersection(0x0?)\n\
    \t/tmp/tmplemom6q1_test.go:91 +0xe7\ntesting.tRunner(0xc0001a0340, 0x528f48)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075548
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) < len(interval2) {\n        interval1, interval2\
    \ = interval2, interval1\n    }\n    \n    interval1Start := interval1[0].(float64)\n\
    \    interval1End := interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n\
    \    interval2End := interval2[1].(float64)\n    \n    intersectionStart := interval1Start\n\
    \    intersectionEnd := interval1End\n    \n    for i := 1; i < len(interval1);\
    \ i++ {\n        interval1Start := interval1[i].(float64)\n        interval1End\
    \ := interval1[i+1].(float64)\n        \n        if interval1Start > interval1End\
    \ {\n            interval1Start, interval1End = interval1End, interval1Start\n\
    \        }\n        \n        if interval2Start > interval2End {\n           \
    \ interval2Start, interval2End = interval2End, interval2Start\n        }\n   \
    \     \n        if interval1Start <= interval2Start && interval1End >= interval2End\
    \ {\n            intersectionStart = interval1Start\n            intersectionEnd\
    \ = interval1End\n        }\n        \n        if interval2Start <= interval1Start\
    \ && interval2End >= interval1End {\n            intersectionStart = interval2Start\n\
    \            intersectionEnd = interval2End\n        }\n    }\n    \n    if intersectionStart\
    \ > intersectionEnd {\n        return \"NO\"\n    }\n    \n    if intersectionStart\
    \ <= intersectionEnd {\n        intersectionStart += 0.5\n        intersectionEnd\
    \ -= 0.5\n    }\n    \n    if intersectionStart > interval1End {\n        return\
    \ \"NO\"\n    }\n    \n    if intersectionStart <= interval1Start {\n        return\
    \ \"NO\"\n    }\n    \n    if intersectionEnd >= interval1End {\n        return\
    \ \"NO\"\n    }\n    \n    if intersectionEnd >= interval2End {\n        return\
    \ \"NO\"\n    }\n    \n    if intersectionStart <= interval2Start {\n        return\
    \ \"NO\"\n    }\n    \n    if intersectionEnd >= interval2End {\n        return\
    \ \"NO\"\n    }\n    \n    if intersectionStart <= interval1Start {\n        return\
    \ \"NO\"\n    }\n    \n    if intersectionEnd >= interval1End {\n        return\
    \ \"NO\"\n    }\n    \n    if intersectionStart <= interval2Start {\n        return\
    \ \"NO\"\n    }\n    \n    if intersectionEnd >= interval2End {\n        return\
    \ \"NO\"\n    }\n    \n    if intersectionStart <= interval1Start {\n        return\
    \ \"NO\"\n    }\n    \n    if intersectionEnd >= interval1End {\n        return\
    \ \"NO\"\n    }\n    \n    if intersectionStart <= interval2Start {\n        return\
    \ \"NO\"\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpbbpnrsbm_test.go:123:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075547
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    intersection := interval1Start <= interval2End\
    \ && interval2Start <= interval1End\n    \n    if intersection {\n        intersectionLength\
    \ := interval1End - interval1Start\n        \n        if isPrime(intersectionLength)\
    \ {\n            return \"YES\"\n        }\n    }\n    \n    return \"NO\"\n}\n\
    \nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4sco3gx9_test.go:42:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075548
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    var result string\n    \n    if len(interval1) != len(interval2)\
    \ {\n        return \"NO\"\n    }\n    \n    for i := 0; i < len(interval1); i++\
    \ {\n        if interval1[i].(float64) >= interval2[i].(float64) {\n         \
    \   result = \"NO\"\n            break\n        }\n    }\n    \n    if result\
    \ == \"NO\" {\n        return \"NO\"\n    }\n    \n    for i := 0; i < len(interval1);\
    \ i++ {\n        if interval1[i].(float64) < interval2[i].(float64) {\n      \
    \      result = \"NO\"\n            break\n        }\n    }\n    \n    if result\
    \ == \"NO\" {\n        return \"NO\"\n    }\n    \n    if interval1[0].(float64)\
    \ <= interval2[0].(float64) {\n        result = \"NO\"\n    }\n    \n    if result\
    \ == \"NO\" {\n        return \"NO\"\n    }\n    \n    if interval1[1].(float64)\
    \ >= interval2[1].(float64) {\n        result = \"NO\"\n    }\n    \n    if result\
    \ == \"NO\" {\n        return \"NO\"\n    }\n    \n    if interval1[1].(float64)\
    \ < interval2[1].(float64) {\n        result = \"NO\"\n    }\n    \n    if result\
    \ == \"NO\" {\n        return \"NO\"\n    }\n    \n    if interval1[0].(float64)\
    \ <= interval2[0].(float64) && interval1[1].(float64) >= interval2[1].(float64)\
    \ {\n        result = \"YES\"\n    }\n    \n    if result == \"YES\" {\n     \
    \   return \"YES\"\n    }\n    \n    if interval1[0].(float64) >= interval2[0].(float64)\
    \ && interval1[1].(float64) <= interval2[1].(float64) {\n        result = \"YES\"\
    \n    }\n    \n    if result == \"YES\" {\n        return \"YES\"\n    }\n   \
    \ \n    if interval1[0].(float64) <= interval2[0].(float64) && interval1[1].(float64)\
    \ < interval2[1].(float64) {\n        result = \"YES\"\n    }\n    \n    if result\
    \ == \"YES\" {\n        return \"YES\"\n    }\n    \n    if interval1[0].(float64)\
    \ >= interval2[0].(float64) && interval1[1].(float64) > interval2[1].(float64)\
    \ {\n        result = \"YES\"\n    }\n    \n    if result == \"YES\" {\n     \
    \   return \"YES\"\n    }\n    \n    if interval1[0].(float64) < interval2[0].(float64)\
    \ && interval1[1].(float64) > interval2[1].(float64) {\n        result = \"YES\"\
    \n    }\n    \n    if result == \"YES\" {\n        return \"YES\"\n    }\n   \
    \ \n    if interval1[0].(float64) > interval2[0].(float64) && interval1[1].(float64\n\
    func TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp39xnuzf8_test.go:120:80: expected '')'', found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075547
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    var result string\n    var start1 int\n    var end1 int\n    var\
    \ start2 int\n    var end2 int\n    var length1 int\n    var length2 int\n   \
    \ var isPrime bool\n    \n    start1 = interval1[0].(int)\n    end1 = interval1[1].(int)\n\
    \    start2 = interval2[0].(int)\n    end2 = interval2[1].(int)\n    \n    length1\
    \ = end1 - start1\n    length2 = end2 - start2\n    \n    if length1 == 0 || length2\
    \ == 0 {\n        result = \"NO\"\n    } else {\n        isPrime = true\n    \
    \    for i := 2; i < length1; i++ {\n            if start1 + i == end1 || start2\
    \ + i == end2 {\n                isPrime = false\n                break\n    \
    \        }\n            if start1 + i == start2 || start2 + i == start1 {\n  \
    \              isPrime = false\n                break\n            }\n       \
    \ }\n    }\n    \n    if isPrime {\n        result = \"YES\"\n    }\n    \n  \
    \  return result\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpen0y9ajk_test.go:88: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmpen0y9ajk_test.go:88: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n      \
    \  tmpen0y9ajk_test.go:88: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__5\
    \ (0.00s)\n        tmpen0y9ajk_test.go:88: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__6 (0.00s)\n        tmpen0y9ajk_test.go:88: expected\
    \ 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075548
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    if interval1Start > interval2End {\n  \
    \      return \"NO\"\n    }\n    if interval1End < interval2Start {\n        return\
    \ \"NO\"\n    }\n    \n    intersectionStart := interval1Start\n    intersectionEnd\
    \ := interval1End\n    \n    for i := 1; i < len(interval1); i++ {\n        interval1Start\
    \ := interval1[i].(float64)\n        interval1End := interval1[i+1].(float64)\n\
    \        \n        if interval1Start > interval1End {\n            return \"NO\"\
    \n        }\n        if interval1End < interval1Start {\n            return \"\
    NO\"\n        }\n        \n        if intersectionStart > interval1End {\n   \
    \         return \"NO\"\n        }\n        if intersectionEnd < interval1Start\
    \ {\n            return \"NO\"\n        }\n        \n        intersectionStart\
    \ = intersectionEnd\n        intersectionEnd = interval1End\n    }\n    \n   \
    \ if intersectionStart > intersectionEnd {\n        return \"NO\"\n    }\n   \
    \ if intersectionEnd < intersectionStart {\n        return \"NO\"\n    }\n   \
    \ \n    if interval1Start <= intersectionStart && intersectionStart <= interval1End\
    \ {\n        return \"YES\"\n    }\n    if interval1Start <= intersectionEnd &&\
    \ intersectionEnd <= interval1End {\n        return \"YES\"\n    }\n    if intersectionStart\
    \ <= interval1Start && intersectionStart <= intersectionEnd {\n        return\
    \ \"YES\"\n    }\n    if intersectionStart <= interval1End && intersectionEnd\
    \ <= interval1End {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n\
    }\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface\
    \ {} is int, not float64\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x503ea0,\
    \ 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503ea0, 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection({0xc0000f5cc0?, 0x2?, 0x2?},\
    \ {0xc0000f5ca0?, 0x2?, 0x2?})\n\t/tmp/tmp1jk45dz7_test.go:32 +0x2f7\ncommand-line-arguments_test.TestIntersection(0x0?)\n\
    \t/tmp/tmp1jk45dz7_test.go:99 +0xe7\ntesting.tRunner(0xc0001924e0, 0x528f48)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075548
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    intersectionStart := interval1Start < interval2Start\
    \ ? interval1Start : interval2Start\n    intersectionEnd := interval1End < interval2End\
    \ ? interval1End : interval2End\n    \n    intersectionLength := intersectionEnd\
    \ - intersectionStart\n    \n    if intersectionLength == 0 {\n        return\
    \ \"NO\"\n    }\n    \n    if intersectionLength == 1 {\n        return \"YES\"\
    \n    }\n    \n    if isPrime(intersectionLength) {\n        return \"YES\"\n\
    \    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n\
    \  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpdpzb2r7p_test.go:37:58: illegal character U+003F ''?''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075547
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    var result string\n    \n    if len(interval1) != len(interval2)\
    \ {\n        return \"NO\"\n    }\n    \n    for i := 0; i < len(interval1); i++\
    \ {\n        if interval1[i].(float64) >= interval2[i].(float64) {\n         \
    \   result = \"NO\"\n            break\n        }\n    }\n    \n    if result\
    \ == \"NO\" {\n        return \"NO\"\n    }\n    \n    if result == \"YES\" {\n\
    \        for i := 0; i < len(interval1); i++ {\n            if interval1[i].(float64)\
    \ <= interval2[i].(float64) {\n                result = \"NO\"\n             \
    \   break\n            }\n        }\n    }\n    \n    if result == \"YES\" {\n\
    \        for i := 0; i < len(interval1); i++ {\n            if interval1[i].(float64)\
    \ == interval2[i].(float64) {\n                result = \"YES\"\n            \
    \    break\n            }\n        }\n    }\n    \n    if result == \"YES\" {\n\
    \        for i := 0; i < len(interval1); i++ {\n            if interval1[i].(float64)\
    \ == interval2[i].(float64) {\n                result = \"YES\"\n            \
    \    break\n            }\n        }\n    }\n    \n    if result == \"YES\" {\n\
    \        for i := 0; i < len(interval1); i++ {\n            if interval1[i].(float64)\
    \ == interval2[i].(float64) {\n                result = \"YES\"\n            \
    \    break\n            }\n        }\n    }\n    \n    if result == \"YES\" {\n\
    \        for i := 0; i < len(interval1); i++ {\n            if interval1[i].(float64)\
    \ == interval2[i].(float64) {\n                result = \"YES\"\n            \
    \    break\n            }\n        }\n    }\n    \n    if result == \"YES\" {\n\
    \        for i := 0; i < len(interval1); i++ {\n            if interval1[i].(float64)\
    \ == interval2[i].(float64) {\n                result = \"YES\"\n            \
    \    break\n            }\n        }\n    }\n    \n    if result == \"YES\" {\n\
    \        for i := 0; i < len(interval1); i++ {\n            if interval1[i].(float64)\
    \ == interval2[i].(float64) {\n                result = \"YES\"\n            \
    \    break\n            }\n        }\n    }\n    \n    if result == \"YES\" {\n\
    \        for i := 0; i < len(interval1); i++ {\n            if interval1[i].(float64)\
    \ == interval2[i].(float64) {\n                result = \"YES\"\n            \
    \    break\n            }\n        }\n    }\n    \n    if result == \"YES\" {\n\
    \        for i := 0; i < len(interval1); i++ {\n            if interval1[i].(float64)\
    \ == interval2[i].(float64) {\n                result = \"YES\"\n            \
    \    break\n            }\n        }\n    }\n    \n    if result == \"YES\nfunc\
    \ TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpn08uj_b__test.go:126:18: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075547
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpfypebohj_test.go:285:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075396
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    if interval1Start > interval1End {\n  \
    \      interval1Start, interval1End = interval1End, interval1Start\n    }\n  \
    \  if interval2Start > interval2End {\n        interval2Start, interval2End =\
    \ interval2End, interval2Start\n    }\n    \n    if interval1Start <= interval2Start\
    \ && interval1End >= interval2End {\n        return \"YES\"\n    }\n    if interval1Start\
    \ <= interval2End && interval1End >= interval2Start {\n        return \"NO\"\n\
    \    }\n    \n    if interval1Start <= interval2Start {\n        return \"NO\"\
    \n    }\n    if interval1End >= interval2End {\n        return \"NO\"\n    }\n\
    \    \n    if interval1Start <= interval2End {\n        return \"YES\"\n    }\n\
    \    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate\
    \ := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface\
    \ {} is int, not float64\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x503ea0,\
    \ 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503ea0, 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection({0xc0000f5cc0?, 0x2?, 0x2?},\
    \ {0xc0000f5ca0?, 0x2?, 0x2?})\n\t/tmp/tmproz_4kus_test.go:32 +0x1d0\ncommand-line-arguments_test.TestIntersection(0x0?)\n\
    \t/tmp/tmproz_4kus_test.go:72 +0xe7\ntesting.tRunner(0xc0001a01a0, 0x528f48)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075548
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(int)\n    interval1End := interval1[1].(int)\n\
    \    interval2Start := interval2[0].(int)\n    interval2End := interval2[1].(int)\n\
    \    \n    if interval1Start > interval1End {\n        return \"NO\"\n    }\n\
    \    if interval2Start > interval2End {\n        return \"NO\"\n    }\n    \n\
    \    interval1Start += interval2Start\n    interval1End += interval2Start\n  \
    \  \n    if interval1Start > interval1End {\n        return \"NO\"\n    }\n  \
    \  if interval2Start > interval2End {\n        return \"NO\"\n    }\n    \n  \
    \  interval1Start += interval2End\n    interval1End += interval2End\n    \n  \
    \  if interval1Start > interval1End {\n        return \"NO\"\n    }\n    if interval2Start\
    \ > interval2End {\n        return \"NO\"\n    }\n    \n    result := false\n\
    \    \n    if interval1Start <= interval2Start && interval1End >= interval2End\
    \ {\n        result = true\n    }\n    \n    if interval1Start <= interval2End\
    \ && interval1End >= interval2Start {\n        result = true\n    }\n    \n  \
    \  if interval1Start >= interval2Start && interval1End <= interval2End {\n   \
    \     result = true\n    }\n    \n    if interval1Start >= interval2End && interval1End\
    \ <= interval2Start {\n        result = true\n    }\n    \n    if result {\n \
    \       return \"YES\"\n    }\n    return \"NO\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__1\
    \ (0.00s)\n        tmppw3lzc4k_test.go:108: expected 'NO', got 'YES'\n    ---\
    \ FAIL: TestIntersection/test_num__4 (0.00s)\n        tmppw3lzc4k_test.go:108:\
    \ expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075549
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpfypebohj_test.go:285:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075396
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpfypebohj_test.go:285:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075396
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(int)\n    interval1End := interval1[1].(int)\n\
    \    interval2Start := interval2[0].(int)\n    interval2End := interval2[1].(int)\n\
    \    \n    if interval1Start > interval1End || interval2Start > interval2End {\n\
    \        return \"NO\"\n    }\n    \n    interval1Length := interval1End - interval1Start\n\
    \    interval2Length := interval2End - interval2Start\n    \n    if interval1Length\
    \ == 0 || interval2Length == 0 {\n        return \"NO\"\n    }\n    \n    intersection\
    \ := interval1Start + interval2Start\n    \n    if interval1Length == interval2Length\
    \ {\n        return fmt.Sprintf(\"YES\")\n    }\n    \n    if interval1Length\
    \ > interval2Length {\n        intersection := interval1Start + interval2Length\n\
    \    }\n    \n    if interval1Length < interval2Length {\n        intersection\
    \ := interval2Start + interval1Length\n    }\n    \n    if isPrime(intersection)\
    \ {\n        return fmt.Sprintf(\"YES\")\n    }\n    \n    return \"NO\"\n}\n\n\
    func TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2nv20ivu_test.go:55:9: intersection declared but not used

    /tmp/tmp2nv20ivu_test.go:59:9: intersection declared but not used

    /tmp/tmp2nv20ivu_test.go:62:8: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075548
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    intersectionStart := interval1Start\n \
    \   intersectionEnd := interval1End\n    \n    for interval1Start <= interval1End\
    \ && interval2Start <= interval2End {\n        if interval1Start <= interval2Start\
    \ && interval1End >= interval2End {\n            intersectionStart = interval1Start\n\
    \            intersectionEnd = interval1End\n        }\n        if interval1Start\
    \ <= interval2End && interval1End >= interval2Start {\n            intersectionStart\
    \ = interval1End\n            intersectionEnd = interval1Start\n        }\n  \
    \      if interval1Start <= interval2Start && interval1End <= interval2End {\n\
    \            intersectionStart = interval1Start\n            intersectionEnd =\
    \ interval1End\n        }\n        if interval1Start >= interval2Start && interval1End\
    \ >= interval2End {\n            intersectionStart = interval1End\n          \
    \  intersectionEnd = interval1Start\n        }\n        if interval1Start >= interval2Start\
    \ && interval1End <= interval2End {\n            intersectionStart = interval1Start\n\
    \            intersectionEnd = interval1End\n        }\n        if interval1Start\
    \ <= interval2Start && interval1End >= interval2End {\n            intersectionStart\
    \ = interval1Start\n            intersectionEnd = interval1End\n        }\n  \
    \      if interval1Start <= interval2Start && interval1End <= interval2End {\n\
    \            intersectionStart = interval1Start\n            intersectionEnd =\
    \ interval1End\n        }\n    }\n    \n    if intersectionStart > intersectionEnd\
    \ {\n        return \"NO\"\n    }\n    \n    if intersectionStart < intersectionEnd\
    \ {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface\
    \ {} is int, not float64\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x503ea0,\
    \ 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503ea0, 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection({0xc0000f5cc0?, 0x2?, 0x2?},\
    \ {0xc0000f5ca0?, 0x2?, 0x2?})\n\t/tmp/tmp1osbth27_test.go:32 +0x219\ncommand-line-arguments_test.TestIntersection(0x0?)\n\
    \t/tmp/tmp1osbth27_test.go:89 +0xe7\ntesting.tRunner(0xc0001a0340, 0x528f48)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075549
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpfypebohj_test.go:285:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075396
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    if interval1Start > interval2End {\n  \
    \      return \"NO\"\n    }\n    if interval1End < interval2Start {\n        return\
    \ \"NO\"\n    }\n    \n    intersectionStart := interval1Start\n    intersectionEnd\
    \ := interval1End\n    \n    for i := 1; i < len(interval1); i++ {\n        interval1Start\
    \ := interval1[i].(float64)\n        interval1End := interval1[i+1].(float64)\n\
    \        \n        if interval1Start > interval2End {\n            return \"NO\"\
    \n        }\n        if interval1End < interval2Start {\n            return \"\
    NO\"\n        }\n        \n        if interval1Start < intersectionStart {\n \
    \           intersectionStart = interval1Start\n        }\n        if interval1End\
    \ > intersectionEnd {\n            intersectionEnd = interval1End\n        }\n\
    \    }\n    \n    if intersectionStart <= intersectionEnd && intersectionStart\
    \ % 2 == 0 {\n        return \"YES\"\n    }\n    if intersectionStart <= intersectionEnd\
    \ && intersectionStart % 2 != 0 {\n        return \"NO\"\n    }\n    \n    return\
    \ \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpg4_42izh_test.go:66:48: invalid operation: operator % not defined on intersectionStart
    (variable of type float64)

    /tmp/tmpg4_42izh_test.go:69:48: invalid operation: operator % not defined on intersectionStart
    (variable of type float64)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075548
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    if interval1Start > interval2End {\n  \
    \      return \"NO\"\n    }\n    \n    if interval1End < interval2Start {\n  \
    \      return \"NO\"\n    }\n    \n    intersection := interval1Start + interval1End\
    \ - interval2Start - interval2End\n    if intersection <= 0 {\n        return\
    \ \"NO\"\n    }\n    \n    if isPrime(intersection) {\n        return \"YES\"\n\
    \    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n\
    \  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1pyh4el5_test.go:50:8: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075548
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    \n    // Write your code here\n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpbz11ina1_test.go:283:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075396
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    var result string\n    \n    if len(interval1) != len(interval2)\
    \ {\n        return \"NO\"\n    }\n    \n    for i := 0; i < len(interval1); i++\
    \ {\n        if interval1[i].(float64) <= interval2[i].(float64) {\n         \
    \   result = \"NO\"\n            break\n        }\n    }\n    \n    if result\
    \ == \"NO\" {\n        for i := 0; i < len(interval1); i++ {\n            if interval1[i].(float64)\
    \ >= interval2[i].(float64) {\n                result = \"NO\"\n             \
    \   break\n            }\n        }\n    }\n    \n    if result == \"NO\" {\n\
    \        return \"NO\"\n    }\n    \n    if result == \"YES\" {\n        return\
    \ \"YES\"\n    }\n    \n    return result\n}\n\nfunc TestIntersection(t *testing.T)\
    \ {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface\
    \ {} is int, not float64\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x503ea0,\
    \ 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503ea0, 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection({0xc0000f5cc0?, 0x2?, 0x2?},\
    \ {0xc0000f5ca0?, 0x2?, 0x2?})\n\t/tmp/tmpmxqwqdgq_test.go:35 +0x1b0\ncommand-line-arguments_test.TestIntersection(0x0?)\n\
    \t/tmp/tmpmxqwqdgq_test.go:68 +0xe7\ntesting.tRunner(0xc000192680, 0x528f48)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075549
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return\
    \ \"NO\"\n    }\n    \n    interval1Start, interval1End := interval1[0].([]interface{})[0],\
    \ interval1[0].([]interface{})[1]\n    interval2Start, interval2End := interval2[0].([]interface{})[0],\
    \ interval2[0].([]interface{})[1]\n    \n    if interval1Start > interval2End\
    \ {\n        return \"NO\"\n    }\n    if interval1End < interval2Start {\n  \
    \      return \"NO\"\n    }\n    \n    intersection := make([]interface{}, 0)\n\
    \    \n    for i := 0; i < len(interval1); i++ {\n        if interval1Start <=\
    \ interval1[i].([]interface{})[1] && interval1[i].([]interface{})[1] < interval1End\
    \ {\n            intersection = append(intersection, interval1[i])\n        }\n\
    \    }\n    \n    for i := 0; i < len(interval2); i++ {\n        if interval2Start\
    \ <= interval2[i].([]interface{})[1] && interval2[i].([]interface{})[1] < interval2End\
    \ {\n            intersection = append(intersection, interval2[i])\n        }\n\
    \    }\n    \n    if len(intersection) == 0 {\n        return \"NO\"\n    }\n\
    \    \n    length := len(intersection)\n    \n    if length == 1 {\n        return\
    \ \"NO\"\n    }\n    \n    if length == 2 && interval1Start <= interval2Start\
    \ && interval1End >= interval2End {\n        return \"YES\"\n    }\n    \n   \
    \ if length == 2 && interval1Start <= interval2End && interval1End >= interval2Start\
    \ {\n        return \"YES\"\n    }\n    \n    if length == 3 && interval1Start\
    \ <= interval2Start && interval1End >= interval2End {\n        return \"YES\"\n\
    \    }\n    \n    if length == 3 && interval1Start <= interval2End && interval1End\
    \ >= interval2Start {\n        return \"YES\"\n    }\n    \n    if length == 4\
    \ && interval1Start <= interval2Start && interval1End >= interval2End {\n    \
    \    return \"YES\"\n    }\n    \n    if length == 4 && interval1Start <= interval2End\
    \ && interval1End >= interval2Start {\n        return \"YES\"\n    }\n    \n \
    \   if length == 5 && interval1Start <= interval2Start && interval1End >= interval2End\
    \ {\n        return \"YES\"\n    }\n    \n    if length == 5 && interval1Start\
    \ <= interval2End && interval1End >= interval2Start {\n        return \"YES\"\n\
    \    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n\
    \  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5f6nfcic_test.go:35:8: invalid operation: interval1Start > interval2End
    (operator > not defined on interface)

    /tmp/tmp5f6nfcic_test.go:38:8: invalid operation: interval1End < interval2Start
    (operator < not defined on interface)

    /tmp/tmp5f6nfcic_test.go:45:12: invalid operation: interval1Start <= interval1[i].([]interface{})[1]
    (operator <= not defined on interface)

    /tmp/tmp5f6nfcic_test.go:45:65: invalid operation: interval1[i].([]interface{})[1]
    < interval1End (operator < not defined on interface)

    /tmp/tmp5f6nfcic_test.go:51:12: invalid operation: interval2Start <= interval2[i].([]interface{})[1]
    (operator <= not defined on interface)

    /tmp/tmp5f6nfcic_test.go:51:65: invalid operation: interval2[i].([]interface{})[1]
    < interval2End (operator < not defined on interface)

    /tmp/tmp5f6nfcic_test.go:66:23: invalid operation: interval1Start <= interval2Start
    (operator <= not defined on interface)

    /tmp/tmp5f6nfcic_test.go:66:59: invalid operation: interval1End >= interval2End
    (operator >= not defined on interface)

    /tmp/tmp5f6nfcic_test.go:70:23: invalid operation: interval1Start <= interval2End
    (operator <= not defined on interface)

    /tmp/tmp5f6nfcic_test.go:70:57: invalid operation: interval1End >= interval2Start
    (operator >= not defined on interface)

    /tmp/tmp5f6nfcic_test.go:70:57: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075548
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n\n    if interval1Start <= interval2End && interval1End\
    \ <= interval2Start {\n        if interval1Start <= interval2Start {\n       \
    \     interval1Start = interval1Start\n            interval1End = interval1End\n\
    \        } else {\n            interval1End = interval1End\n            interval1Start\
    \ = interval1Start\n        }\n    }\n\n    if interval1Start <= interval2End\
    \ {\n        if interval1End <= interval2End {\n            interval1End = interval1End\n\
    \            interval1Start = interval1Start\n        } else {\n            interval1End\
    \ = interval1End\n            interval1Start = interval1Start\n        }\n   \
    \ }\n\n    if interval1Start <= interval2Start {\n        if interval1End <= interval2End\
    \ {\n            interval1End = interval1End\n            interval1Start = interval1Start\n\
    \        } else {\n            interval1End = interval1End\n            interval1Start\
    \ = interval1Start\n        }\n    }\n\n    if interval1Start <= interval2End\
    \ {\n        if interval1Start <= interval2End {\n            interval1Start =\
    \ interval1Start\n            interval1End = interval1End\n        } else {\n\
    \            interval1End = interval1End\n            interval1Start = interval1Start\n\
    \        }\n    }\n\n    if interval1Start <= interval2Start {\n        if interval1End\
    \ <= interval2End {\n            interval1End = interval1End\n            interval1Start\
    \ = interval1Start\n        } else {\n            interval1End = interval1End\n\
    \            interval1Start = interval1Start\n        }\n    }\n\n    if interval1Start\
    \ <= interval2End {\n        if interval1Start <= interval2End {\n           \
    \ interval1Start = interval1Start\n            interval1End = interval1End\n \
    \       } else {\n            interval1End = interval1End\n            interval1Start\
    \ = interval1Start\n        }\n    }\n\n    if interval1Start <= interval2Start\
    \ {\n        if interval1End <= interval2End {\n            interval1End = interval1End\n\
    \            interval1Start = interval1Start\n        } else {\n            interval1End\
    \ = interval1End\n            interval1Start = interval1Start\n        }\n   \
    \ }\n\n    if interval1Start <= interval2End {\n        if interval1Start <= interval2End\
    \ {\n            interval1Start = interval1Start\n            interval1End = interval1End\n\
    \        } else {\n            interval1End = interval1End\n            interval1Start\
    \ = interval1Start\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp5aq_k4gn_test.go:111:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075548
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start, interval1End := interval1[0], interval1[1]\n\
    \    interval2Start, interval2End := interval2[0], interval2[1]\n    \n    if\
    \ interval1Start > interval2End {\n        return \"NO\"\n    }\n    \n    if\
    \ interval1End < interval2Start {\n        return \"NO\"\n    }\n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n\nfunc TestIntersection(t *testing.T) {\n  candidate\
    \ := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp2xwz0w0p_test.go:258:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075548
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    if interval1Start > interval1End {\n  \
    \      interval1Start, interval1End = interval1End, interval1Start\n    }\n  \
    \  if interval2Start > interval2End {\n        interval2Start, interval2End =\
    \ interval2End, interval2Start\n    }\n    \n    intersectionStart := interval1Start\n\
    \    intersectionEnd := interval1End\n    \n    for interval2Start < interval2End\
    \ {\n        if interval2Start <= intersectionEnd {\n            intersectionEnd\
    \ = interval2End\n        } else {\n            intersectionStart = intersectionEnd\n\
    \            intersectionEnd = interval2Start\n        }\n    }\n    \n    if\
    \ intersectionStart <= intersectionEnd {\n        return \"NO\"\n    }\n    \n\
    \    if interval1Start <= interval2Start && interval1End >= interval2End {\n \
    \       return \"YES\"\n    }\n    \n    if interval1Start <= interval2End &&\
    \ interval1End >= interval2Start {\n        return \"YES\"\n    }\n    \n    return\
    \ \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface\
    \ {} is int, not float64\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x503ea0,\
    \ 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503ea0, 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection({0xc0000f5cc0?, 0x2?, 0x2?},\
    \ {0xc0000f5ca0?, 0x2?, 0x2?})\n\t/tmp/tmpma2so1ia_test.go:32 +0x1be\ncommand-line-arguments_test.TestIntersection(0x0?)\n\
    \t/tmp/tmpma2so1ia_test.go:78 +0xe7\ntesting.tRunner(0xc0001a0340, 0x528f48)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075550
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(int)\n    interval1End := interval1[1].(int)\n\
    \    interval2Start := interval2[0].(int)\n    interval2End := interval2[1].(int)\n\
    \    \n    if interval1Start > interval2End {\n        return \"NO\"\n    }\n\
    \    if interval1End < interval2Start {\n        return \"NO\"\n    }\n    \n\
    \    intersectionStart := interval1Start\n    intersectionEnd := interval1End\n\
    \    \n    for intersectionEnd < interval2End {\n        if interval1[intersectionEnd].(int)\
    \ == interval2[intersectionEnd].(int) {\n            intersectionEnd += 1\n  \
    \      } else {\n            break\n        }\n    }\n    \n    if intersectionEnd\
    \ > interval2End {\n        return \"NO\"\n    }\n    \n    if interval1Start\
    \ < intersectionStart {\n        return \"NO\"\n    }\n    \n    if interval1End\
    \ > intersectionEnd {\n        return \"NO\"\n    }\n    \n    if intersectionStart\
    \ < interval2Start {\n        return \"NO\"\n    }\n    \n    if intersectionEnd\
    \ > interval2End {\n        return \"NO\"\n    }\n    \n    if interval1[intersectionStart].(int)\
    \ == interval2[intersectionStart].(int) {\n        return \"YES\"\n    }\n   \
    \ \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate\
    \ := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: runtime error: index out of\
    \ range [2] with length 2 [recovered]\n\tpanic: runtime error: index out of range\
    \ [2] with length 2\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection({0xc0000f5cc0?, 0x2?, 0x2?},\
    \ {0xc0000f5ca0?, 0x2?, 0x2?})\n\t/tmp/tmpmyzw0lb2_test.go:48 +0x248\ncommand-line-arguments_test.TestIntersection(0x0?)\n\
    \t/tmp/tmpmyzw0lb2_test.go:89 +0xe7\ntesting.tRunner(0xc0001964e0, 0x528f48)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075550
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    if interval1Start > interval2End {\n  \
    \      return \"NO\"\n    }\n    if interval1End < interval2Start {\n        return\
    \ \"NO\"\n    }\n    \n    intersection := interval1Start + interval1End - interval2Start\
    \ - interval2End\n    \n    if intersection <= 0 {\n        return \"NO\"\n  \
    \  }\n    \n    if isPrime(intersection) {\n        return \"YES\"\n    }\n  \
    \  \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate\
    \ := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2wl81vbj_test.go:50:8: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075397
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpfypebohj_test.go:285:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075396
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    \n    // Your code here\n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    func TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp39vg6js4_test.go:283:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075396
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    interval1Start, interval1End := interval1[0].([]interface{})[0],\
    \ interval1[0].([]interface{})[1]\n    interval2Start, interval2End := interval2[0].([]interface{})[0],\
    \ interval2[0].([]interface{})[1]\n    if interval1Start > interval1End {\n  \
    \      interval1Start, interval1End = interval1End, interval1Start\n    }\n  \
    \  if interval2Start > interval2End {\n        interval2Start, interval2End =\
    \ interval2End, interval2Start\n    }\n    if interval1Start > interval2End {\n\
    \        return \"NO\"\n    }\n    if interval1Start < interval2Start {\n    \
    \    return \"NO\"\n    }\n    if interval1End > interval2End {\n        return\
    \ \"NO\"\n    }\n    if interval1Start <= interval2Start && interval1End >= interval2End\
    \ {\n        return \"YES\"\n    }\n    if interval1Start <= interval2End && interval1End\
    \ >= interval2Start {\n        return \"YES\"\n    }\n    if interval1Start >=\
    \ interval2Start && interval1End <= interval2End {\n        return \"YES\"\n \
    \   }\n    if interval1Start >= interval2Start && interval1End < interval2End\
    \ {\n        return \"NO\"\n    }\n    if interval1Start < interval2Start && interval1End\
    \ >= interval2End {\n        return \"NO\"\n    }\n    if interval1Start < interval2Start\
    \ && interval1End <= interval2End {\n        return \"NO\"\n    }\n    if interval1Start\
    \ >= interval2Start && interval1End < interval2End {\n        return \"NO\"\n\
    \    }\n    if interval1Start < interval2Start && interval1End <= interval2End\
    \ {\n        return \"NO\"\n    }\n    return \"NO\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp39cqet6n_test.go:30:8: invalid operation: interval1Start > interval1End
    (operator > not defined on interface)

    /tmp/tmp39cqet6n_test.go:33:8: invalid operation: interval2Start > interval2End
    (operator > not defined on interface)

    /tmp/tmp39cqet6n_test.go:36:8: invalid operation: interval1Start > interval2End
    (operator > not defined on interface)

    /tmp/tmp39cqet6n_test.go:39:8: invalid operation: interval1Start < interval2Start
    (operator < not defined on interface)

    /tmp/tmp39cqet6n_test.go:42:8: invalid operation: interval1End > interval2End
    (operator > not defined on interface)

    /tmp/tmp39cqet6n_test.go:45:8: invalid operation: interval1Start <= interval2Start
    (operator <= not defined on interface)

    /tmp/tmp39cqet6n_test.go:45:44: invalid operation: interval1End >= interval2End
    (operator >= not defined on interface)

    /tmp/tmp39cqet6n_test.go:48:8: invalid operation: interval1Start <= interval2End
    (operator <= not defined on interface)

    /tmp/tmp39cqet6n_test.go:48:42: invalid operation: interval1End >= interval2Start
    (operator >= not defined on interface)

    /tmp/tmp39cqet6n_test.go:51:8: invalid operation: interval1Start >= interval2Start
    (operator >= not defined on interface)

    /tmp/tmp39cqet6n_test.go:51:8: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075549
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpfypebohj_test.go:285:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075396
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    \n    interval1Start := interval1[0].(float64)\n    interval1End\
    \ := interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n  \
    \  interval2End := interval2[1].(float64)\n    \n    \n    if interval1Start >\
    \ interval1End {\n        fmt.Println(\"interval1Start > interval1End\")\n   \
    \     return \"NO\"\n    }\n    if interval2Start > interval2End {\n        fmt.Println(\"\
    interval2Start > interval2End\")\n        return \"NO\"\n    }\n    \n    \n \
    \   \n    if interval1Start < interval2Start {\n        fmt.Println(\"interval1Start\
    \ < interval2Start\")\n        return \"NO\"\n    }\n    if interval1End > interval2End\
    \ {\n        fmt.Println(\"interval1End > interval2End\")\n        return \"NO\"\
    \n    }\n    \n    \n    \n    if interval1Start <= interval2Start && interval1End\
    \ >= interval2End {\n        fmt.Println(\"interval1Start <= interval2Start &&\
    \ interval1End >= interval2End\")\n        return \"NO\"\n    }\n    \n    \n\
    \    \n    if interval1Start >= interval2Start && interval1End <= interval2End\
    \ {\n        fmt.Println(\"interval1Start >= interval2Start && interval1End <=\
    \ interval2End\")\n        return \"NO\"\n    }\n    \n    \n    \n    if interval1Start\
    \ <= interval2Start && interval1End >= interval2End {\n        fmt.Println(\"\
    interval1Start <= interval2Start && interval1End >= interval2End\")\n        return\
    \ \"NO\"\n    }\n    \n    \n    \n    if interval1Start >= interval2Start &&\
    \ interval1End <= interval2End {\n        fmt.Println(\"interval1Start >= interval2Start\
    \ && interval1End <= interval2End\")\n        return \"NO\"\n    }\n    \n   \
    \ \n    \n    if interval1Start <= interval2Start && interval1End >= interval2End\
    \ {\n        fmt.Println(\"interval1Start <= interval2Start && interval1End >=\
    \ interval2End\")\n        return \"NO\"\n    }\n    \n    \n    \n    if interval1Start\
    \ >= interval2Start && interval1End <= interval2End {\n        fmt.Println(\"\
    interval1Start >= interval2Start && interval1End <= interval2End\")\n        return\
    \ \"NO\"\n    }\n    \n    \n    \n    if interval1Start <= interval2Start &&\
    \ interval1End >= interval2End {\n        fmt.Println(\"interval1Start <= interval2\n\
    func TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpal34bgto_test.go:100:21: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075549
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1 := interval1\n    interval2 := interval2\n    \n \
    \   result := make([]interface{}, 0)\n    \n    for i := 0; i < len(interval1);\
    \ i++ {\n        if interval1[i] > interval2[i] {\n            interval1[i], interval2[i]\
    \ = interval2[i], interval1[i]\n        }\n    }\n    \n    for i := 0; i < len(interval1);\
    \ i++ {\n        if interval1[i] <= interval2[i] {\n            result = append(result,\
    \ interval1[i])\n        }\n    }\n    \n    if len(result) == 0 {\n        return\
    \ \"NO\"\n    }\n    \n    if len(result) == 1 {\n        return \"YES\"\n   \
    \ }\n    \n    if isPrime(len(result)) {\n        return \"YES\"\n    }\n    \n\
    \    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate :=\
    \ intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp74mw6kqq_test.go:32:15: no new variables on left side of :=

    /tmp/tmp74mw6kqq_test.go:33:15: no new variables on left side of :=

    /tmp/tmp74mw6kqq_test.go:38:12: invalid operation: interval1[i] > interval2[i]
    (operator > not defined on interface)

    /tmp/tmp74mw6kqq_test.go:44:12: invalid operation: interval1[i] <= interval2[i]
    (operator <= not defined on interface)

    /tmp/tmp74mw6kqq_test.go:57:8: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075549
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    var result string\n    \n    if len(interval1) != len(interval2)\
    \ {\n        return \"NO\"\n    }\n    \n    for i := 0; i < len(interval1); i++\
    \ {\n        if interval1[i].(int) < interval2[i].(int) {\n            result\
    \ = \"NO\"\n            break\n        }\n    }\n    \n    if result == \"NO\"\
    \ {\n        return \"NO\"\n    }\n    \n    for i := 0; i < len(interval1); i++\
    \ {\n        if interval1[i].(int) > interval2[i].(int) {\n            result\
    \ = \"NO\"\n            break\n        }\n    }\n    \n    if result == \"NO\"\
    \ {\n        return \"NO\"\n    }\n    \n    if result == \"YES\" {\n        return\
    \ \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T)\
    \ {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2\
    \ (0.00s)\n        tmprgki525f_test.go:83: expected 'YES', got 'NO'\n    --- FAIL:\
    \ TestIntersection/test_num__3 (0.00s)\n        tmprgki525f_test.go:83: expected\
    \ 'YES', got 'NO'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075550
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1 := make([]int, len(interval1))\n    interval2 := make([]int,\
    \ len(interval2))\n    \n    for i, v := range interval1 {\n        interval1[i]\
    \ = int(v.(float64))\n    }\n    for i, v := range interval2 {\n        interval2[i]\
    \ = int(v.(float64))\n    }\n    \n    result := make([]int, len(interval1))\n\
    \    \n    for i, v := range interval1 {\n        for j, w := range interval2\
    \ {\n            if v < w {\n                result[i] = v\n                break\n\
    \            }\n        }\n    }\n    \n    if len(result) == 0 {\n        return\
    \ \"NO\"\n    }\n    \n    length := len(result)\n    \n    if length == 1 {\n\
    \        return \"YES\"\n    }\n    \n    if length == 2 && result[0] == result[1]\
    \ {\n        return \"YES\"\n    }\n    \n    if length == 2 && result[0] == result[1]\
    \ {\n        return \"NO\"\n    }\n    \n    if length == 3 && result[0] == result[1]\
    \ && result[1] == result[2] {\n        return \"YES\"\n    }\n    \n    if length\
    \ == 3 && result[0] == result[1] && result[1] == result[2] {\n        return \"\
    NO\"\n    }\n    \n    if length == 4 && result[0] == result[1] && result[1] ==\
    \ result[2] && result[2] == result[3] {\n        return \"YES\"\n    }\n    \n\
    \    if length == 4 && result[0] == result[1] && result[1] == result[2] && result[2]\
    \ == result[3] {\n        return \"NO\"\n    }\n    \n    if length == 5 && result[0]\
    \ == result[1] && result[1] == result[2] && result[2] == result[3] && result[3]\
    \ == result[4] {\n        return \"YES\"\n    }\n    \n    if length == 5 && result[0]\
    \ == result[1] && result[1] == result[2] && result[2] == result[3] && result[3]\
    \ == result[4] {\n        return \"NO\"\n    }\n    \n    return \"NO\"\n}\n\n\
    func TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2bisryau_test.go:32:15:\
    \ no new variables on left side of :=\n/tmp/tmp2bisryau_test.go:32:18: cannot\
    \ use make([]int, len(interval1)) (value of type []int) as type []interface{}\
    \ in assignment\n/tmp/tmp2bisryau_test.go:33:15: no new variables on left side\
    \ of :=\n/tmp/tmp2bisryau_test.go:33:18: cannot use make([]int, len(interval2))\
    \ (value of type []int) as type []interface{} in assignment\n/tmp/tmp2bisryau_test.go:45:13:\
    \ j declared but not used\n/tmp/tmp2bisryau_test.go:46:16: invalid operation:\
    \ v < w (operator < not defined on interface)\n/tmp/tmp2bisryau_test.go:47:29:\
    \ cannot use v (variable of type interface{}) as type int in assignment:\n\tneed\
    \ type assertion\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075550
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    \n    interval1Start := interval1[0].(float64)\n    interval1End\
    \ := interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n  \
    \  interval2End := interval2[1].(float64)\n    \n    \n    if interval1Start >\
    \ interval1End {\n        fmt.Println(\"interval1Start > interval1End\")\n   \
    \     return \"NO\"\n    }\n    if interval2Start > interval2End {\n        fmt.Println(\"\
    interval2Start > interval2End\")\n        return \"NO\"\n    }\n    \n    \n \
    \   if interval1Start < interval2Start {\n        fmt.Println(\"interval1Start\
    \ < interval2Start\")\n        return \"NO\"\n    }\n    if interval1End > interval2End\
    \ {\n        fmt.Println(\"interval1End > interval2End\")\n        return \"NO\"\
    \n    }\n    \n    \n    if interval1Start <= interval2Start && interval1End >=\
    \ interval2End {\n        fmt.Println(\"interval1Start <= interval2Start && interval1End\
    \ >= interval2End\")\n        return \"YES\"\n    }\n    if interval1Start >=\
    \ interval2Start && interval1End <= interval2End {\n        fmt.Println(\"interval1Start\
    \ >= interval2Start && interval1End <= interval2End\")\n        return \"YES\"\
    \n    }\n    if interval1Start <= interval2Start && interval1End >= interval2End\
    \ {\n        fmt.Println(\"interval1Start <= interval2Start && interval1End >=\
    \ interval2End\")\n        return \"YES\"\n    }\n    if interval1Start >= interval2Start\
    \ && interval1End <= interval2End {\n        fmt.Println(\"interval1Start >= interval2Start\
    \ && interval1End <= interval2End\")\n        return \"YES\"\n    }\n    \n  \
    \  \n    if interval1Start <= interval2Start && interval1End >= interval2End {\n\
    \        fmt.Println(\"interval1Start <= interval2Start && interval1End >= interval2End\"\
    )\n        return \"YES\"\n    }\n    if interval1Start >= interval2Start && interval1End\
    \ <= interval2End {\n        fmt.Println(\"interval1Start >= interval2Start &&\
    \ interval1End <= interval2End\")\n        return \"YES\"\n    }\n    if interval1Start\
    \ <= interval2Start && interval1End >= interval2End {\n        fmt.Println(\"\
    interval1Start <= interval2Start && interval1End >= interval2End\")\n        return\
    \ \"YES\"\n    }\n    if interval1Start >= interval2Start && interval1End <= interval2End\
    \ {\n        f\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpqa0yw16u_test.go:87:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075549
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpfypebohj_test.go:285:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075396
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpfypebohj_test.go:285:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075396
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    intersectionStart := interval1Start <=\
    \ interval2Start && interval1End >= interval2End\n    intersectionEnd := interval1Start\
    \ <= interval2End && interval1End >= interval2Start\n    \n    if intersectionStart\
    \ && intersectionEnd {\n        intersectionLength := interval1End - interval1Start\n\
    \        if isPrime(intersectionLength) {\n            return \"YES\"\n      \
    \  }\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T)\
    \ {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpnq1s6ttu_test.go:42:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075407
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) < len(interval2) {\n        interval1, interval2\
    \ = interval2, interval1\n    }\n    \n    interval1Start := interval1[0].(int)\n\
    \    interval1End := interval1[1].(int)\n    interval2Start := interval2[0].(int)\n\
    \    interval2End := interval2[1].(int)\n\n    if interval1Start > interval2End\
    \ {\n        return \"NO\"\n    }\n    if interval1End < interval2Start {\n  \
    \      return \"NO\"\n    }\n    \n    interval1Len := interval1End - interval1Start\n\
    \    interval2Len := interval2End - interval2Start\n    \n    if interval1Len\
    \ > interval2Len {\n        return \"NO\"\n    }\n    \n    if interval1Len ==\
    \ interval2Len {\n        \n        if interval1Start <= interval2Start {\n  \
    \          return \"YES\"\n        }\n        if interval1End >= interval2End\
    \ {\n            return \"YES\"\n        }\n        \n        if interval1Start\
    \ <= interval2End {\n            return \"YES\"\n        }\n        if interval1End\
    \ >= interval2Start {\n            return \"YES\"\n        }\n        \n     \
    \   if interval1Start <= interval2Start {\n            return \"YES\"\n      \
    \  }\n        if interval1End >= interval2End {\n            return \"YES\"\n\
    \        }\n        \n        if interval1Start <= interval2Start {\n        \
    \    return \"YES\"\n        }\n        if interval1End >= interval2End {\n  \
    \          return \"YES\"\n        }\n        \n        if interval1Start <= interval2Start\
    \ {\n            return \"YES\"\n        }\n        if interval1End >= interval2End\
    \ {\n            return \"YES\"\n        }\n        \n        if interval1Start\
    \ <= interval2Start {\n            return \"YES\"\n        }\n        if interval1End\
    \ >= interval2End {\n            return \"YES\"\n        }\n        \n       \
    \ if interval1Start <= interval2Start {\n            return \"YES\"\n        }\n\
    \        if interval1End >= interval2End {\n            return \"YES\"\n     \
    \   }\n        \n        if interval1Start <= interval2Start {\n            return\
    \ \"YES\"\n        }\n        if interval1End >= interval2End {\n            return\
    \ \"YES\"\n        }\n        \n        if interval1Start <= interval2Start {\n\
    \            return \"YES\"\n        }\n        if interval1End >= interval2End\
    \ {\n            return \"YES\"\n        }\n        \n        if interval1Start\
    \ <= interval2Start {\n            return \"YES\"\n        }\n        if interval1End\
    \ >= interval2End {\n            return \"YES\"\n        }\n        \n       \
    \ if interval1Start <= interval2Start {\n            return \"YES\"\n        }\n\
    \        if interval\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpovy8ubcx_test.go:127:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075549
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    \n    if len(interval1) != len(interval2) {\n        return \"\
    NO\"\n    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End\
    \ := interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n  \
    \  interval2End := interval2[1].(float64)\n    \n    if interval1Start > interval2End\
    \ {\n        return \"NO\"\n    }\n    if interval1End < interval2Start {\n  \
    \      return \"NO\"\n    }\n    \n    intersection := interval1Start + interval1End\
    \ - interval2Start - interval2End\n    \n    if intersection <= 0 {\n        return\
    \ \"NO\"\n    }\n    \n    if isPrime(intersection) {\n        return \"YES\"\n\
    \    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n\
    \  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7so0_lpf_test.go:51:8: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075550
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    intersectionLength := interval1End - interval1Start\n\
    \    \n    if interval2Start <= interval1End && interval2End <= interval1End {\n\
    \        if interval2Start <= interval1Start && interval2End <= interval1Start\
    \ {\n            if interval2Start <= interval1End && interval2End <= interval1End\
    \ {\n                return \"YES\"\n            }\n        }\n    }\n    \n \
    \   if interval2Start <= interval1Start && interval2End <= interval1Start {\n\
    \        if interval2Start <= interval1End && interval2End <= interval1End {\n\
    \            if interval2Start <= interval1End && interval2End <= interval1End\
    \ {\n                return \"YES\"\n            }\n        }\n    }\n    \n \
    \   if interval2Start <= interval1Start && interval2End <= interval1Start {\n\
    \        if interval2Start <= interval1End && interval2End <= interval1End {\n\
    \            if interval2Start <= interval1End && interval2End <= interval1End\
    \ {\n                return \"YES\"\n            }\n        }\n    }\n    \n \
    \   if interval2Start <= interval1Start && interval2End <= interval1Start {\n\
    \        if interval2Start <= interval1End && interval2End <= interval1End {\n\
    \            if interval2Start <= interval1End && interval2End <= interval1End\
    \ {\n                return \"YES\"\n            }\n        }\n    }\n    \n \
    \   if interval2Start <= interval1Start && interval2End <= interval1Start {\n\
    \        if interval2Start <= interval1End && interval2End <= interval1End {\n\
    \            if interval2Start <= interval1End && interval2End <= interval1End\
    \ {\n                return \"YES\"\n            }\n        }\n    }\n    \n \
    \   if interval2Start <= interval1Start && interval2End <= interval1Start {\n\
    \        if interval2Start <= interval1End && interval2End <= interval1End {\n\
    \            if interval2Start <= interval1End && interval2End <= interval1End\
    \ {\n                return \"YES\"\n            }\n        }\n    }\n    \n \
    \   if interval2Start <= interval1Start && interval2End <= interval1Start {\n\
    \        if interval2Start <= interval1End && interval2End <= interval1\nfunc\
    \ TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp7ml2ojs4_test.go:89:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075549
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(int)\n    interval1End := interval1[1].(int)\n\
    \    interval2Start := interval2[0].(int)\n    interval2End := interval2[1].(int)\n\
    \    \n    if interval1Start > interval1End || interval2Start > interval2End {\n\
    \        return \"NO\"\n    }\n    \n    intersection := make([]interface{}, 0)\n\
    \    \n    for i := 0; i < len(interval1); i++ {\n        if interval1Start <=\
    \ interval2Start && interval1End >= interval2End {\n            intersection =\
    \ append(intersection, interval1[i])\n        }\n        if interval1Start <=\
    \ interval2End && interval1End >= interval2Start {\n            intersection =\
    \ append(intersection, interval1[i])\n        }\n        if interval1Start >=\
    \ interval2Start && interval1End <= interval2End {\n            intersection =\
    \ append(intersection, interval1[i])\n        }\n        if interval1Start >=\
    \ interval2End && interval1End <= interval2Start {\n            intersection =\
    \ append(intersection, interval1[i])\n        }\n    }\n    \n    if len(intersection)\
    \ == 0 {\n        return \"NO\"\n    }\n    \n    length := len(intersection)\n\
    \    \n    if length == 1 {\n        return \"YES\"\n    }\n    \n    if length\
    \ == 2 && interval1Start <= interval2Start && interval1End >= interval2End {\n\
    \        return \"YES\"\n    }\n    \n    if length == 2 && interval1Start <=\
    \ interval2End && interval1End >= interval2Start {\n        return \"YES\"\n \
    \   }\n    \n    if length == 2 && interval1Start >= interval2Start && interval1End\
    \ <= interval2End {\n        return \"YES\"\n    }\n    \n    if length == 2 &&\
    \ interval1Start >= interval2End && interval1End <= interval2Start {\n       \
    \ return \"YES\"\n    }\n    \n    if length == 3 && interval1Start <= interval2Start\
    \ && interval1End >= interval2End {\n        return \"YES\"\n    }\n    \n   \
    \ if length == 3 && interval1Start <= interval2End && interval1End >= interval2Start\
    \ {\n        return \"YES\"\n    }\n    \n    if length == 3 && interval1Start\
    \ >= interval2Start && interval1End <= interval2End {\n        return \"YES\"\n\
    \    }\n    \n    if length == 3 && interval1Start >= interval2End && interval1End\
    \ <= interval2Start {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n\
    }\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmppsra_5dd_test.go:123: expected 'NO', got 'YES'\n    ---\
    \ FAIL: TestIntersection/test_num__1 (0.00s)\n        tmppsra_5dd_test.go:123:\
    \ expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n\
    \        tmppsra_5dd_test.go:123: expected 'YES', got 'NO'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075551
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    var result string\n    \n    if len(interval1) != len(interval2)\
    \ {\n        return \"NO\"\n    }\n    \n    for i := 0; i < len(interval1); i++\
    \ {\n        if interval1[i].(float64) >= interval2[i].(float64) {\n         \
    \   result = \"NO\"\n            break\n        }\n    }\n    \n    if result\
    \ == \"NO\" {\n        return \"NO\"\n    }\n    \n    if result == \"YES\" {\n\
    \        for i := 0; i < len(interval1); i++ {\n            if interval1[i].(float64)\
    \ <= interval2[i].(float64) {\n                result = \"NO\"\n             \
    \   break\n            }\n        }\n    }\n    \n    if result == \"YES\" {\n\
    \        for i := 0; i < len(interval1); i++ {\n            if interval1[i].(float64)\
    \ <= interval2[i].(float64) {\n                result = \"YES\"\n            \
    \    break\n            }\n        }\n    }\n    \n    if result == \"YES\" {\n\
    \        for i := 0; i < len(interval1); i++ {\n            if interval1[i].(float64)\
    \ <= interval2[i].(float64) {\n                result = \"YES\"\n            \
    \    break\n            }\n        }\n    }\n    \n    if result == \"YES\" {\n\
    \        for i := 0; i < len(interval1); i++ {\n            if interval1[i].(float64)\
    \ <= interval2[i].(float64) {\n                result = \"YES\"\n            \
    \    break\n            }\n        }\n    }\n    \n    if result == \"YES\" {\n\
    \        for i := 0; i < len(interval1); i++ {\n            if interval1[i].(float64)\
    \ <= interval2[i].(float64) {\n                result = \"YES\"\n            \
    \    break\n            }\n        }\n    }\n    \n    if result == \"YES\" {\n\
    \        for i := 0; i < len(interval1); i++ {\n            if interval1[i].(float64)\
    \ <= interval2[i].(float64) {\n                result = \"YES\"\n            \
    \    break\n            }\n        }\n    }\n    \n    if result == \"YES\" {\n\
    \        for i := 0; i < len(interval1); i++ {\n            if interval1[i].(float64)\
    \ <= interval2[i].(float64) {\n                result = \"YES\"\n            \
    \    break\n            }\n        }\n    }\n    \n    if result == \"YES\" {\n\
    \        for i := 0; i < len(interval1); i++ {\n            if interval1[i].(float64)\
    \ <= interval2[i].(float64) {\n                result = \"YES\"\n            \
    \    break\n            }\n        }\n    }\n    \n    if result == \"YES\" {\n\
    \        for i := 0; i < len(interval1); i++ {\n            if interval1[i].(float64)\
    \ <= interval2[i].(float64) {\n                result = \"YES\"\n            \
    \    break\n            }\n        }\n    }\n    \n    if result == \"YES\nfunc\
    \ TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp9v8l8_jj_test.go:126:18: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075550
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    interval1Start, interval1End := interval1[0], interval1[1]\n \
    \   interval2Start, interval2End := interval2[0], interval2[1]\n\n    if interval1Start\
    \ > interval2End {\n        return fmt.Sprintf(\"NO\")\n    }\n\n    if interval1End\
    \ < interval2Start {\n        return fmt.Sprintf(\"NO\")\n    }\n\n    if interval1Start\
    \ >= interval2Start && interval1End <= interval2End {\n        return fmt.Sprintf(\"\
    YES\")\n    }\n\n    if interval1Start >= interval2Start {\n        return fmt.Sprintf(\"\
    YES\")\n    }\n\n    if interval1End <= interval2End {\n        return fmt.Sprintf(\"\
    YES\")\n    }\n\n    if interval1Start <= interval2Start {\n        return fmt.Sprintf(\"\
    YES\")\n    }\n\n    if interval1Start <= interval2Start && interval1End >= interval2End\
    \ {\n        return fmt.Sprintf(\"YES\")\n    }\n\n    if interval1Start >= interval2Start\
    \ && interval1End >= interval2End {\n        return fmt.Sprintf(\"YES\")\n   \
    \ }\n\n    return fmt.Sprintf(\"NO\")\n}\n\nfunc TestIntersection(t *testing.T)\
    \ {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpiie1cu2k_test.go:31:8: invalid operation: interval1Start > interval2End
    (operator > not defined on interface)

    /tmp/tmpiie1cu2k_test.go:35:8: invalid operation: interval1End < interval2Start
    (operator < not defined on interface)

    /tmp/tmpiie1cu2k_test.go:39:8: invalid operation: interval1Start >= interval2Start
    (operator >= not defined on interface)

    /tmp/tmpiie1cu2k_test.go:39:44: invalid operation: interval1End <= interval2End
    (operator <= not defined on interface)

    /tmp/tmpiie1cu2k_test.go:43:8: invalid operation: interval1Start >= interval2Start
    (operator >= not defined on interface)

    /tmp/tmpiie1cu2k_test.go:47:8: invalid operation: interval1End <= interval2End
    (operator <= not defined on interface)

    /tmp/tmpiie1cu2k_test.go:51:8: invalid operation: interval1Start <= interval2Start
    (operator <= not defined on interface)

    /tmp/tmpiie1cu2k_test.go:55:8: invalid operation: interval1Start <= interval2Start
    (operator <= not defined on interface)

    /tmp/tmpiie1cu2k_test.go:55:44: invalid operation: interval1End >= interval2End
    (operator >= not defined on interface)

    /tmp/tmpiie1cu2k_test.go:59:8: invalid operation: interval1Start >= interval2Start
    (operator >= not defined on interface)

    /tmp/tmpiie1cu2k_test.go:59:8: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075551
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    if interval1Start > interval2End {\n  \
    \      return \"NO\"\n    }\n    if interval1End < interval2Start {\n        return\
    \ \"NO\"\n    }\n    \n    intersection := interval1Start + interval1End - interval2Start\
    \ - interval2End\n    \n    if intersection <= 0 {\n        return \"NO\"\n  \
    \  }\n    \n    if isPrime(intersection) {\n        return \"YES\"\n    }\n  \
    \  \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate\
    \ := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2wl81vbj_test.go:50:8: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075397
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) < len(interval2) {\n        interval1, interval2\
    \ = interval2, interval1\n    }\n    \n    var result string\n    \n    interval1Start\
    \ := interval1[0].(int)\n    interval1End := interval1[1].(int)\n    interval2Start\
    \ := interval2[0].(int)\n    interval2End := interval2[1].(int)\n    \n    if\
    \ interval1Start <= interval2Start && interval1End >= interval2End {\n       \
    \ result = \"YES\"\n    } else {\n        result = \"NO\"\n    }\n    \n    return\
    \ result\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2\
    \ (0.00s)\n        tmpgibgyby9_test.go:68: expected 'YES', got 'NO'\n    --- FAIL:\
    \ TestIntersection/test_num__3 (0.00s)\n        tmpgibgyby9_test.go:68: expected\
    \ 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n      \
    \  tmpgibgyby9_test.go:68: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6\
    \ (0.00s)\n        tmpgibgyby9_test.go:68: expected 'NO', got 'YES'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075551
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    var interval1Start, interval1End int\n    var interval2Start,\
    \ interval2End int\n    \n    if len(interval1) != len(interval2) {\n        return\
    \ \"NO\"\n    }\n    \n    for i := 0; i < len(interval1); i++ {\n        interval1Start\
    \ = interval1[i].(int)\n        interval1End = interval1Start + interval1[i].(int)\n\
    \        \n        for j := 0; j < len(interval2); j++ {\n            interval2Start\
    \ = interval2[j].(int)\n            interval2End = interval2Start + interval2[j].(int)\n\
    \            \n            if interval1Start <= interval2Start && interval1End\
    \ >= interval2End {\n                return \"YES\"\n            }\n        }\n\
    \    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n\
    \  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpvzox_xmc_test.go:72: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__2 (0.00s)\n        tmpvzox_xmc_test.go:72: expected\
    \ 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n      \
    \  tmpvzox_xmc_test.go:72: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__6\
    \ (0.00s)\n        tmpvzox_xmc_test.go:72: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__7 (0.00s)\n        tmpvzox_xmc_test.go:72: expected\
    \ 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075551
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    \n    interval1Start := interval1[0].(float64)\n    interval1End\
    \ := interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n  \
    \  interval2End := interval2[1].(float64)\n    \n    \n    if interval1Start >\
    \ interval1End {\n        fmt.Println(\"interval1Start > interval1End\")\n   \
    \     return \"NO\"\n    }\n    if interval2Start > interval2End {\n        fmt.Println(\"\
    interval2Start > interval2End\")\n        return \"NO\"\n    }\n    \n    \n \
    \   if interval1Start < interval2Start {\n        fmt.Println(\"interval1Start\
    \ < interval2Start\")\n        return \"NO\"\n    }\n    if interval1End > interval2End\
    \ {\n        fmt.Println(\"interval1End > interval2End\")\n        return \"NO\"\
    \n    }\n    \n    \n    if interval1Start <= interval2Start {\n        fmt.Println(\"\
    interval1Start <= interval2Start\")\n        return \"NO\"\n    }\n    if interval1End\
    \ >= interval2End {\n        fmt.Println(\"interval1End >= interval2End\")\n \
    \       return \"NO\"\n    }\n    \n    \n    if interval1Start <= interval2Start\
    \ && interval1End >= interval2End {\n        fmt.Println(\"interval1Start <= interval2Start\
    \ && interval1End >= interval2End\")\n        return \"NO\"\n    }\n    \n   \
    \ \n    if interval1Start <= interval2Start && interval1End <= interval2End {\n\
    \        fmt.Println(\"interval1Start <= interval2Start && interval1End <= interval2End\"\
    )\n        return \"YES\"\n    }\n    \n    \n    if interval1Start >= interval2Start\
    \ && interval1End >= interval2End {\n        fmt.Println(\"interval1Start >= interval2Start\
    \ && interval1End >= interval2End\")\n        return \"YES\"\n    }\n    \n  \
    \  \n    if interval1Start >= interval2Start && interval1End <= interval2End {\n\
    \        fmt.Println(\"interval1Start >= interval2Start && interval1End <= interval2End\"\
    )\n        return \"YES\"\n    }\n    \n    \n    if interval1Start <= interval2Start\
    \ && interval1End <= interval2End {\n        fmt.Println(\"interval1Start <= interval2Start\
    \ && interval1End <= interval2End\")\n        return \"YES\"\n    }\n    \n  \
    \  \n    if interval1Start >= interval2Start && interval1End >= interval2End {\n\
    \        fmt.Println(\"interval1Start >= interval2Start && interval\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6i2ps4g6_test.go:96:21: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075550
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    var interval1Start, interval1End int\n    var interval2Start,\
    \ interval2End int\n    \n    if len(interval1) != len(interval2) {\n        return\
    \ \"NO\"\n    }\n    \n    for i := 0; i < len(interval1); i++ {\n        interval1Start\
    \ = interval1[i].(int)\n        interval1End = interval1Start + 1\n        interval2Start\
    \ = interval2[i].(int)\n        interval2End = interval2Start + 1\n        \n\
    \        if interval1Start <= interval2Start && interval1End >= interval2End {\n\
    \            continue\n        }\n        \n        if interval1Start <= interval2End\
    \ && interval1End >= interval2Start {\n            continue\n        }\n     \
    \   \n        if interval1Start >= interval2Start && interval1End <= interval2End\
    \ {\n            continue\n        }\n        \n        if interval1Start <= interval2Start\
    \ && interval1End >= interval2End {\n            continue\n        }\n       \
    \ \n        if interval1Start >= interval2Start && interval1End <= interval2End\
    \ {\n            continue\n        }\n        \n        if interval1Start <= interval2Start\
    \ && interval1End >= interval2End {\n            continue\n        }\n       \
    \ \n        if interval1Start >= interval2Start && interval1End <= interval2End\
    \ {\n            continue\n        }\n        \n        if interval1Start <= interval2Start\
    \ && interval1End >= interval2End {\n            continue\n        }\n       \
    \ \n        if interval1Start >= interval2Start && interval1End <= interval2End\
    \ {\n            continue\n        }\n        \n        if interval1Start <= interval2Start\
    \ && interval1End >= interval2End {\n            continue\n        }\n       \
    \ \n        if interval1Start >= interval2Start && interval1End <= interval2End\
    \ {\n            continue\n        }\n        \n        if interval1Start <= interval2Start\
    \ && interval1End >= interval2End {\n            continue\n        }\n       \
    \ \n        if interval1Start >= interval2Start && interval1End <= interval2End\
    \ {\n            continue\n        }\n        \n        if interval1Start <= interval2Start\
    \ && interval1End >= interval2End {\n            continue\n        }\n       \
    \ \n        if interval1Start >= interval2Start && interval1End <= interval2End\
    \ {\n            continue\n        }\n        \n        if interval1Start <= interval2Start\
    \ && interval1End >= interval2End {\n            continue\n        }\n       \
    \ \n        if interval1Start >= interval2Start && interval1End <= interval2End\
    \ {\n            continue\n        }\n        \n        if interval1Start <= interval2Start\
    \ && interval1End >= interval2End {\n\nfunc TestIntersection(t *testing.T) {\n\
    \  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp21obmj81_test.go:111:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075550
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    intersectionStart := interval1Start <=\
    \ interval2Start && interval2Start <= interval1End\n    intersectionEnd := interval1End\
    \ <= interval2End && interval2End <= interval1End\n    \n    if intersectionStart\
    \ && intersectionEnd {\n        intersectionLength := interval1End - interval1Start\n\
    \        if isPrime(intersectionLength) {\n            return \"YES\"\n      \
    \  }\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T)\
    \ {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpnyu3rpms_test.go:42:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075551
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(int)\n    interval1End := interval1[1].(int)\n\
    \    interval2Start := interval2[0].(int)\n    interval2End := interval2[1].(int)\n\
    \    \n    if interval1Start > interval1End {\n        return \"NO\"\n    }\n\
    \    if interval2Start > interval2End {\n        return \"NO\"\n    }\n    \n\
    \    intersection := interval1Start <= interval2Start && interval1End >= interval2End\n\
    \    if intersection {\n        intersection := interval1Start <= interval2End\
    \ && interval1End >= interval2Start\n        if intersection {\n            intersection\
    \ := interval1Start <= interval2Start && interval1End >= interval2End\n      \
    \      if intersection {\n                intersection := interval1Start <= interval2End\
    \ && interval1End >= interval2Start\n                if intersection {\n     \
    \               intersection := interval1Start <= interval2End && interval1End\
    \ >= interval2Start\n                    if intersection {\n                 \
    \       intersection := interval1Start <= interval2End && interval1End >= interval2Start\n\
    \                        if intersection {\n                            intersection\
    \ := interval1Start <= interval2End && interval1End >= interval2Start\n      \
    \                      if intersection {\n                                intersection\
    \ := interval1Start <= interval2End && interval1End >= interval2Start\n      \
    \                          if intersection {\n                               \
    \     intersection := interval1Start <= interval2End && interval1End >= interval2Start\n\
    \                                    if intersection {\n                     \
    \                   intersection := interval1Start <= interval2End && interval1End\
    \ >= interval2Start\n                                        if intersection {\n\
    \                                            intersection := interval1Start <=\
    \ interval2End && interval1End >= interval2Start\n                           \
    \                 if intersection {\n                                        \
    \        intersection := interval1Start <= interval2End && interval1End >= interval2Start\n\
    \                                                if intersection {\n         \
    \                                           intersection := interval1Start <=\
    \ interval2End && interval1End >= interval2Start\n                           \
    \                         if intersection {\n                                \
    \                        intersection := interval1Start <= interval2End && interval1End\
    \ >= interval2Start\n                                                        if\
    \ intersection {\n                                                           \
    \ intersection := interval1Start <= interval2End && interval1End >= interval2Start\n\
    \                                                            if intersection {\n\
    \                                                                intersection\
    \ := interval1Start <= interval2End && interval1End >= interval2Start\n      \
    \                                                          if intersection {\n\
    \                                                                    intersection\
    \ := interval1Start <= interval2End && interval1End >= interval2Start\n      \
    \                                                              if intersection\
    \ {\n                                \nfunc TestIntersection(t *testing.T) {\n\
    \  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpgozxn2eu_test.go:79:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075402
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    intersection := interval1Start <= interval2Start\
    \ && interval1End >= interval2End\n    \n    if intersection {\n        intersectionLength\
    \ := interval1End - interval1Start\n        \n        if isPrime(intersectionLength)\
    \ {\n            return \"YES\"\n        }\n    }\n    \n    return \"NO\"\n}\n\
    \nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3y4ih9wb_test.go:42:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075551
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    interval1Start, interval1End := interval1[0].(int), interval1[1].(int)\n\
    \    interval2Start, interval2End := interval2[0].(int), interval2[1].(int)\n\n\
    \    if interval1Start > interval2End {\n        return fmt.Sprintf(\"NO\")\n\
    \    }\n    if interval1End < interval2Start {\n        return fmt.Sprintf(\"\
    NO\")\n    }\n\n    intersection := interval1Start <= interval2End && interval1End\
    \ >= interval2Start\n\n    if intersection {\n        if interval1Start <= interval2Start\
    \ && interval1End >= interval2End {\n            return fmt.Sprintf(\"YES\")\n\
    \        }\n        if interval1Start <= interval2End && interval1End < interval2Start\
    \ {\n            return fmt.Sprintf(\"NO\")\n        }\n        if interval1Start\
    \ >= interval2Start && interval1End <= interval2End {\n            return fmt.Sprintf(\"\
    NO\")\n        }\n    }\n\n    return fmt.Sprintf(\"NO\")\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2\
    \ (0.00s)\n        tmpa_lfslwx_test.go:75: expected 'YES', got 'NO'\n    --- FAIL:\
    \ TestIntersection/test_num__3 (0.00s)\n        tmpa_lfslwx_test.go:75: expected\
    \ 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n      \
    \  tmpa_lfslwx_test.go:75: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6\
    \ (0.00s)\n        tmpa_lfslwx_test.go:75: expected 'NO', got 'YES'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075551
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    if interval1Start > interval1End {\n  \
    \      interval1Start, interval1End = interval1End, interval1Start\n    }\n  \
    \  if interval2Start > interval2End {\n        interval2Start, interval2End =\
    \ interval2End, interval2Start\n    }\n    \n    if interval1Start > interval2End\
    \ {\n        return \"NO\"\n    }\n    if interval1Start < interval2Start {\n\
    \        return \"NO\"\n    }\n    \n    if interval1End < interval2End {\n  \
    \      return \"NO\"\n    }\n    \n    intersection := interval1Start + interval2End\
    \ - interval1End - interval2Start\n    if isPrime(intersection) {\n        return\
    \ \"YES\"\n    }\n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T)\
    \ {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmqtpxuh3_test.go:56:8: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075551
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    var result string\n    \n    if len(interval1) != len(interval2)\
    \ {\n        return \"NO\"\n    }\n    \n    for i := 0; i < len(interval1); i++\
    \ {\n        if interval1[i] > interval2[i] {\n            result = \"NO\"\n \
    \           break\n        }\n    }\n    \n    if result == \"NO\" {\n       \
    \ return \"NO\"\n    }\n    \n    for i := 0; i < len(interval1); i++ {\n    \
    \    if interval1[i] < interval2[i] {\n            result = \"NO\"\n         \
    \   break\n        }\n    }\n    \n    if result == \"NO\" {\n        return \"\
    NO\"\n    }\n    \n    if result == \"YES\" {\n        return \"YES\"\n    }\n\
    \    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate\
    \ := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp79ua2rc4_test.go:35:12: invalid operation: interval1[i] > interval2[i]
    (operator > not defined on interface)

    /tmp/tmp79ua2rc4_test.go:46:12: invalid operation: interval1[i] < interval2[i]
    (operator < not defined on interface)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075399
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    \n    // Write your code here\n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpbz11ina1_test.go:283:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075396
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    var result string\n    \n    if len(interval1) != len(interval2)\
    \ {\n        return \"NO\"\n    }\n    \n    for i := 0; i < len(interval1); i++\
    \ {\n        if interval1[i] > interval2[i] {\n            result = \"NO\"\n \
    \           break\n        }\n    }\n    \n    if result == \"NO\" {\n       \
    \ return \"NO\"\n    }\n    \n    for i := 0; i < len(interval1); i++ {\n    \
    \    if interval1[i] < interval2[i] {\n            result = \"NO\"\n         \
    \   break\n        }\n    }\n    \n    if result == \"NO\" {\n        return \"\
    NO\"\n    }\n    \n    if result == \"YES\" {\n        return \"YES\"\n    }\n\
    \    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate\
    \ := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp79ua2rc4_test.go:35:12: invalid operation: interval1[i] > interval2[i]
    (operator > not defined on interface)

    /tmp/tmp79ua2rc4_test.go:46:12: invalid operation: interval1[i] < interval2[i]
    (operator < not defined on interface)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075399
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    if interval1Start > interval1End {\n  \
    \      interval1Start, interval1End = interval1End, interval1Start\n    }\n  \
    \  if interval2Start > interval2End {\n        interval2Start, interval2End =\
    \ interval2End, interval2Start\n    }\n    \n    if interval1Start <= interval2Start\
    \ && interval1End >= interval2End {\n        return \"YES\"\n    }\n    if interval1Start\
    \ <= interval2End && interval1End >= interval2Start {\n        return \"NO\"\n\
    \    }\n    \n    if interval1Start <= interval2Start {\n        return \"NO\"\
    \n    }\n    if interval1End >= interval2End {\n        return \"NO\"\n    }\n\
    \    \n    if interval1Start <= interval2End {\n        return \"YES\"\n    }\n\
    \    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate\
    \ := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface\
    \ {} is int, not float64\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x503ea0,\
    \ 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503ea0, 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection({0xc0000f5cc0?, 0x2?, 0x2?},\
    \ {0xc0000f5ca0?, 0x2?, 0x2?})\n\t/tmp/tmproz_4kus_test.go:32 +0x1d0\ncommand-line-arguments_test.TestIntersection(0x0?)\n\
    \t/tmp/tmproz_4kus_test.go:72 +0xe7\ntesting.tRunner(0xc0001a01a0, 0x528f48)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075548
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1 := make([]int, len(interval1))\n    interval2 := make([]int,\
    \ len(interval2))\n    \n    for i, v := range interval1 {\n        interval1[i]\
    \ = v.(int)\n    }\n    for i, v := range interval2 {\n        interval2[i] =\
    \ v.(int)\n    }\n    \n    result := make([]int, len(interval1))\n    \n    for\
    \ i, v := range interval1 {\n        for j, w := range interval2 {\n         \
    \   if v < w {\n                result[i] = v\n                break\n       \
    \     }\n        }\n    }\n    \n    if len(result) == 0 {\n        return \"\
    NO\"\n    }\n    \n    result := make([]int, len(result))\n    \n    for i, v\
    \ := range result {\n        if v == 1 {\n            return \"YES\"\n       \
    \ }\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T)\
    \ {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9fdqpxf0_test.go:32:15:\
    \ no new variables on left side of :=\n/tmp/tmp9fdqpxf0_test.go:32:18: cannot\
    \ use make([]int, len(interval1)) (value of type []int) as type []interface{}\
    \ in assignment\n/tmp/tmp9fdqpxf0_test.go:33:15: no new variables on left side\
    \ of :=\n/tmp/tmp9fdqpxf0_test.go:33:18: cannot use make([]int, len(interval2))\
    \ (value of type []int) as type []interface{} in assignment\n/tmp/tmp9fdqpxf0_test.go:45:13:\
    \ j declared but not used\n/tmp/tmp9fdqpxf0_test.go:46:16: invalid operation:\
    \ v < w (operator < not defined on interface)\n/tmp/tmp9fdqpxf0_test.go:47:29:\
    \ cannot use v (variable of type interface{}) as type int in assignment:\n\tneed\
    \ type assertion\n/tmp/tmp9fdqpxf0_test.go:57:12: no new variables on left side\
    \ of :=\n/tmp/tmp9fdqpxf0_test.go:59:9: i declared but not used\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075551
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    var interval1Start, interval1End int\n    var interval2Start,\
    \ interval2End int\n    \n    if len(interval1) != len(interval2) {\n        return\
    \ \"NO\"\n    }\n    \n    for i := 0; i < len(interval1); i++ {\n        interval1Start\
    \ = interval1[i].(int)\n        interval1End = interval1Start + interval1[i].(int)\n\
    \        \n        for j := 0; j < len(interval2); j++ {\n            interval2Start\
    \ = interval2[j].(int)\n            interval2End = interval2Start + interval2[j].(int)\n\
    \            \n            if interval1Start <= interval2Start && interval1End\
    \ >= interval2End {\n                fmt.Println(interval1Start, interval1End,\
    \ interval2Start, interval2End)\n                fmt.Println(interval1Start <=\
    \ interval2Start && interval1End >= interval2End)\n                fmt.Println(interval1Start\
    \ <= interval2Start && interval1End >= interval2End)\n                fmt.Println(interval1Start\
    \ <= interval2Start && interval1End >= interval2End)\n                fmt.Println(interval1Start\
    \ <= interval2Start && interval1End >= interval2End)\n                fmt.Println(interval1Start\
    \ <= interval2Start && interval1End >= interval2End)\n                fmt.Println(interval1Start\
    \ <= interval2Start && interval1End >= interval2End)\n                fmt.Println(interval1Start\
    \ <= interval2Start && interval1End >= interval2End)\n                fmt.Println(interval1Start\
    \ <= interval2Start && interval1End >= interval2End)\n                fmt.Println(interval1Start\
    \ <= interval2Start && interval1End >= interval2End)\n                fmt.Println(interval1Start\
    \ <= interval2Start && interval1End >= interval2End)\n                fmt.Println(interval1Start\
    \ <= interval2Start && interval1End >= interval2End)\n                fmt.Println(interval1Start\
    \ <= interval2Start && interval1End >= interval2End)\n                fmt.Println(interval1Start\
    \ <= interval2Start && interval1End >= interval2End)\n                fmt.Println(interval1Start\
    \ <= interval2Start && interval1End >= interval2End)\n                fmt.Println(interval1Start\
    \ <= interval2Start && interval1End >= interval2End)\n                fmt.Println(interval1Start\
    \ <= interval2Start && interval1End >= interval2End)\n                fmt.Println(interval1Start\
    \ <= interval2Start && interval1End >= interval2End)\n                fmt.Println(interval1Start\
    \ \nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpnr5mw_h8_test.go:62:44: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075550
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    intersectionStart := interval1Start <=\
    \ interval2Start && interval1End >= interval2End\n    intersectionEnd := interval1Start\
    \ <= interval2End && interval1End >= interval2Start\n    \n    if intersectionStart\
    \ && intersectionEnd {\n        intersectionLength := interval1End - interval1Start\n\
    \        if isPrime(intersectionLength) {\n            return \"YES\"\n      \
    \  }\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T)\
    \ {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpnq1s6ttu_test.go:42:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075407
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    if interval1Start > interval2End {\n  \
    \      return \"NO\"\n    }\n    if interval1End < interval2Start {\n        return\
    \ \"NO\"\n    }\n    \n    intersectionStart := interval1Start\n    intersectionEnd\
    \ := interval1End\n    \n    for i := 1; i < len(interval1); i++ {\n        interval1Start\
    \ := interval1[i].(float64)\n        interval1End := interval1[i+1].(float64)\n\
    \        \n        if interval1Start > interval1End {\n            return \"NO\"\
    \n        }\n        if interval1End < interval1Start {\n            return \"\
    NO\"\n        }\n        \n        if interval1Start <= intersectionEnd && interval1End\
    \ >= intersectionStart {\n            intersectionStart = interval1Start\n   \
    \         intersectionEnd = interval1End\n        }\n    }\n    \n    if intersectionStart\
    \ <= intersectionEnd && intersectionEnd >= interval2Start {\n        return \"\
    YES\"\n    }\n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n\
    \  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface\
    \ {} is int, not float64\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x503ea0,\
    \ 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503ea0, 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection({0xc0000f5cc0?, 0x2?, 0x2?},\
    \ {0xc0000f5ca0?, 0x2?, 0x2?})\n\t/tmp/tmp58eg65eb_test.go:32 +0x228\ncommand-line-arguments_test.TestIntersection(0x0?)\n\
    \t/tmp/tmp58eg65eb_test.go:77 +0xe7\ntesting.tRunner(0xc0001a01a0, 0x528f48)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075551
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(int)\n    interval1End := interval1[1].(int)\n\
    \    interval2Start := interval2[0].(int)\n    interval2End := interval2[1].(int)\n\
    \    \n    if interval1Start > interval2End {\n        return \"NO\"\n    }\n\
    \    if interval1End < interval2Start {\n        return \"NO\"\n    }\n    \n\
    \    intersectionLength := interval1End - interval1Start + 1\n    if interval1Start\
    \ <= interval2Start && interval1End >= interval2End {\n        if interval1Start\
    \ <= interval2Start {\n            intersectionLength++\n        }\n        if\
    \ interval1End >= interval2End {\n            intersectionLength++\n        }\n\
    \    }\n    if intersectionLength == 2 {\n        return \"YES\"\n    }\n    if\
    \ intersectionLength % 2 == 0 {\n        return \"NO\"\n    }\n    \n    primeLength\
    \ := 0\n    primeLength := intersectionLength / 2\n    if primeLength == 2 {\n\
    \        return \"YES\"\n    }\n    if primeLength % 2 == 0 {\n        return\
    \ \"NO\"\n    }\n    \n    if primeLength == 1 {\n        return \"YES\"\n   \
    \ }\n    \n    if primeLength > 1 {\n        return \"NO\"\n    }\n    \n    return\
    \ \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpncd272ut_test.go:61:17: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075551
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpfypebohj_test.go:285:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075396
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    interval1Start, interval1End := interval1[0], interval1[1]\n \
    \   interval2Start, interval2End := interval2[0], interval2[1]\n    if interval1Start\
    \ > interval2End {\n        return fmt.Sprintf(\"NO\")\n    }\n    if interval1End\
    \ < interval2Start {\n        return fmt.Sprintf(\"NO\")\n    }\n    if interval1Start\
    \ <= interval2Start && interval1End >= interval2End {\n        return fmt.Sprintf(\"\
    YES\")\n    }\n    if interval1Start <= interval2End && interval1End >= interval2Start\
    \ {\n        return fmt.Sprintf(\"YES\")\n    }\n    if interval1Start <= interval2Start\
    \ && interval1End <= interval2End {\n        return fmt.Sprintf(\"NO\")\n    }\n\
    \    if interval1Start >= interval2Start && interval1End <= interval2End {\n \
    \       return fmt.Sprintf(\"NO\")\n    }\n    if interval1Start >= interval2Start\
    \ && interval1End >= interval2End {\n        return fmt.Sprintf(\"NO\")\n    }\n\
    \    if interval1Start <= interval2Start && interval1End >= interval2Start {\n\
    \        return fmt.Sprintf(\"NO\")\n    }\n    if interval1Start >= interval2Start\
    \ && interval1End <= interval2End {\n        return fmt.Sprintf(\"NO\")\n    }\n\
    \    if interval1Start >= interval2Start && interval1End >= interval2Start {\n\
    \        return fmt.Sprintf(\"NO\")\n    }\n    if interval1Start <= interval2Start\
    \ && interval1End <= interval2End {\n        return fmt.Sprintf(\"NO\")\n    }\n\
    \    if interval1Start >= interval2Start && interval1End >= interval2Start {\n\
    \        return fmt.Sprintf(\"NO\")\n    }\n    if interval1Start <= interval2Start\
    \ && interval1End <= interval2End {\n        return fmt.Sprintf(\"NO\")\n    }\n\
    \    if interval1Start >= interval2Start && interval1End >= interval2Start {\n\
    \        return fmt.Sprintf(\"NO\")\n    }\n    if interval1Start <= interval2Start\
    \ && interval1End <= interval2End {\n        return fmt.Sprintf(\"NO\")\n    }\n\
    \    if interval1Start >= interval2Start && interval1End >= interval2Start {\n\
    \        return fmt.Sprintf(\"NO\")\n    }\n    if interval1Start <= interval2Start\
    \ && interval1End <= interval2End {\n        return fmt.Sprintf(\"NO\")\n    }\n\
    \    if interval1Start >= interval2Start && interval1End >= interval2Start {\n\
    \        return fmt.Sprintf(\"NO\")\n    }\n    if interval1Start <= interval2Start\
    \ && interval1End \nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpre77pzb1_test.go:85:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075551
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    var result string\n    \n    if len(interval1) != len(interval2)\
    \ {\n        return \"NO\"\n    }\n    \n    for i := 0; i < len(interval1); i++\
    \ {\n        if interval1[i].(float64) < interval2[i].(float64) {\n          \
    \  result = \"NO\"\n            break\n        }\n    }\n    \n    if result ==\
    \ \"NO\" {\n        return \"NO\"\n    }\n    \n    for i := 0; i < len(interval1);\
    \ i++ {\n        if interval1[i].(float64) >= interval2[i].(float64) {\n     \
    \       result = \"NO\"\n            break\n        }\n    }\n    \n    if result\
    \ == \"NO\" {\n        return \"NO\"\n    }\n    \n    if isPrime(interval1[0].(float64)\
    \ + interval1[1].(float64)) && isPrime(interval2[0].(float64) + interval2[1].(float64))\
    \ {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphdwkfn8h_test.go:56:8: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075551
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpfypebohj_test.go:285:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075396
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpfypebohj_test.go:285:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075396
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    var interval1Start, interval1End int\n    var interval2Start,\
    \ interval2End int\n    var lengthOfIntersection int\n\n    interval1Start, interval1End\
    \ = interval1[0].(int), interval1[1].(int)\n    interval2Start, interval2End =\
    \ interval2[0].(int), interval2[1].(int)\n\n    if interval1Start <= interval2End\
    \ && interval1End >= interval2Start {\n        lengthOfIntersection = interval1End\
    \ - interval1Start\n    } else {\n        return \"NO\"\n    }\n\n    if lengthOfIntersection\
    \ == 0 {\n        return \"NO\"\n    }\n\n    if lengthOfIntersection == 1 {\n\
    \        if isPrime(lengthOfIntersection) {\n            return \"YES\"\n    \
    \    } else {\n            return \"NO\"\n        }\n    }\n\n    if isPrime(lengthOfIntersection)\
    \ {\n        return \"YES\"\n    } else {\n        return \"NO\"\n    }\n}\n\n\
    func TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpg88ugjiu_test.go:46:12: undefined: isPrime

    /tmp/tmpg88ugjiu_test.go:53:8: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075552
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    if interval1Start > interval2End {\n  \
    \      return \"NO\"\n    }\n    if interval1End < interval2Start {\n        return\
    \ \"NO\"\n    }\n    \n    intersectionStart := interval1Start\n    intersectionEnd\
    \ := interval1End\n    \n    for i := 1; i < len(interval1); i++ {\n        interval1Start\
    \ := interval1[i].(float64)\n        interval1End := interval1[i+1].(float64)\n\
    \        \n        if interval1Start > interval2End {\n            return \"NO\"\
    \n        }\n        if interval1End < interval2Start {\n            return \"\
    NO\"\n        }\n        \n        if intersectionStart > interval1End {\n   \
    \         intersectionEnd = interval1End\n        }\n        if intersectionEnd\
    \ < interval1Start {\n            intersectionStart = interval1Start\n       \
    \ }\n    }\n    \n    if intersectionStart <= intersectionEnd {\n        return\
    \ \"YES\"\n    }\n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T)\
    \ {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface\
    \ {} is int, not float64\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x503ea0,\
    \ 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503ea0, 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection({0xc0000f5cc0?, 0x2?, 0x2?},\
    \ {0xc0000f5ca0?, 0x2?, 0x2?})\n\t/tmp/tmprburqq5n_test.go:32 +0x24f\ncommand-line-arguments_test.TestIntersection(0x0?)\n\
    \t/tmp/tmprburqq5n_test.go:79 +0xe7\ntesting.tRunner(0xc0001924e0, 0x528f48)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075552
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    \n    // Write your code here\n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpbz11ina1_test.go:283:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075396
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    var result string\n    \n    if len(interval1) != len(interval2)\
    \ {\n        return \"NO\"\n    }\n    \n    result := \"YES\"\n    \n    for\
    \ i := 0; i < len(interval1); i++ {\n        if interval1[i] < interval2[i] {\n\
    \            result += \"NO\"\n            break\n        }\n    }\n    \n   \
    \ return result\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpva_6kp9i_test.go:34:12: no new variables on left side of :=

    /tmp/tmpva_6kp9i_test.go:37:12: invalid operation: interval1[i] < interval2[i]
    (operator < not defined on interface)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075552
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    if interval1Start > interval2End {\n  \
    \      return \"NO\"\n    }\n    if interval1End < interval2Start {\n        return\
    \ \"NO\"\n    }\n    \n    interval1Len := interval1End - interval1Start\n   \
    \ interval2Len := interval2End - interval2Start\n    \n    if interval1Len < interval2Len\
    \ {\n        return \"NO\"\n    }\n    \n    if interval1Len == interval2Len {\n\
    \        if interval1Start <= interval2Start {\n            return \"YES\"\n \
    \       }\n        if interval1End >= interval2End {\n            return \"YES\"\
    \n        }\n    }\n    \n    if interval1Len > interval2Len {\n        return\
    \ \"NO\"\n    }\n    \n    if interval1Start <= interval2Start {\n        return\
    \ \"YES\"\n    }\n    if interval1End >= interval2End {\n        return \"YES\"\
    \n    }\n    \n    interval1Start += interval1Start\n    interval1End += interval1Start\n\
    \    interval2Start += interval2Start\n    interval2End += interval2Start\n  \
    \  \n    if interval1Start <= interval2Start {\n        return \"YES\"\n    }\n\
    \    if interval1End >= interval2End {\n        return \"YES\"\n    }\n    \n\
    \    if interval1Start <= interval2Start {\n        return \"YES\"\n    }\n  \
    \  if interval1End >= interval2End {\n        return \"YES\"\n    }\n    \n  \
    \  return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface\
    \ {} is int, not float64\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x503ea0,\
    \ 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503ea0, 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection({0xc0000f5cc0?, 0x2?, 0x2?},\
    \ {0xc0000f5ca0?, 0x2?, 0x2?})\n\t/tmp/tmpalegxo_e_test.go:32 +0x26a\ncommand-line-arguments_test.TestIntersection(0x0?)\n\
    \t/tmp/tmpalegxo_e_test.go:100 +0xe7\ntesting.tRunner(0xc0001a0340, 0x528f48)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075552
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return\
    \ \"NO\"\n    }\n    \n    interval1Start, interval1End := interval1[0], interval1[1]\n\
    \    interval2Start, interval2End := interval2[0], interval2[1]\n    \n    if\
    \ interval1Start > interval2End {\n        return fmt.Sprintf(\"NO\")\n    }\n\
    \    if interval1End < interval2Start {\n        return fmt.Sprintf(\"NO\")\n\
    \    }\n    \n    interval1Start += interval1Start\n    interval1End += interval1End\n\
    \    interval2Start += interval2Start\n    interval2End += interval2End\n    \n\
    \    if interval1Start > interval2End {\n        return fmt.Sprintf(\"NO\")\n\
    \    }\n    if interval1End < interval2Start {\n        return fmt.Sprintf(\"\
    NO\")\n    }\n    \n    if interval1Start <= interval2Start && interval1End >=\
    \ interval2End {\n        return fmt.Sprintf(\"YES\")\n    }\n    if interval1Start\
    \ <= interval2End && interval1End >= interval2Start {\n        return fmt.Sprintf(\"\
    YES\")\n    }\n    \n    if interval1Start <= interval2Start && interval1End <\
    \ interval2End {\n        return fmt.Sprintf(\"YES\")\n    }\n    if interval1Start\
    \ >= interval2Start && interval1End <= interval2End {\n        return fmt.Sprintf(\"\
    YES\")\n    }\n    \n    if interval1Start <= interval2Start && interval1End >=\
    \ interval2End {\n        return fmt.Sprintf(\"YES\")\n    }\n    if interval1Start\
    \ >= interval2Start && interval1End <= interval2End {\n        return fmt.Sprintf(\"\
    YES\")\n    }\n    \n    if interval1Start <= interval2Start && interval1End <\
    \ interval2End {\n        return fmt.Sprintf(\"YES\")\n    }\n    if interval1Start\
    \ >= interval2Start && interval1End >= interval2End {\n        return fmt.Sprintf(\"\
    YES\")\n    }\n    \n    if interval1Start <= interval2Start && interval1End >=\
    \ interval2End {\n        return fmt.Sprintf(\"YES\")\n    }\n    if interval1Start\
    \ >= interval2Start && interval1End <= interval2End {\n        return fmt.Sprintf(\"\
    YES\")\n    }\n    \n    if interval1Start <= interval2Start && interval1End <\
    \ interval2End {\n        return fmt.Sprintf(\"YES\")\n    }\n    if interval1Start\
    \ >= interval2Start && interval1End >= interval2End {\n        return fmt.Sprintf(\"\
    YES\")\n    }\n    \n    if interval1Start <= interval2Start \nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpo39c4uez_test.go:97:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075551
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    if interval1Start > interval1End {\n  \
    \      interval1Start, interval1End = interval1End, interval1Start\n    }\n  \
    \  if interval2Start > interval2End {\n        interval2Start, interval2End =\
    \ interval2End, interval2Start\n    }\n    \n    if interval1Start <= interval2Start\
    \ && interval1End >= interval2End {\n        return \"YES\"\n    }\n    if interval1Start\
    \ <= interval2End && interval1End >= interval2Start {\n        return \"NO\"\n\
    \    }\n    \n    if interval1Start <= interval2Start {\n        return \"NO\"\
    \n    }\n    if interval1End >= interval2End {\n        return \"NO\"\n    }\n\
    \    \n    if interval1Start <= interval2End {\n        return \"YES\"\n    }\n\
    \    \n    if interval1Start < interval2Start {\n        return \"YES\"\n    }\n\
    \    if interval1End > interval2End {\n        return \"NO\"\n    }\n    \n  \
    \  return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface\
    \ {} is int, not float64\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x503ea0,\
    \ 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503ea0, 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection({0xc0000f5cc0?, 0x2?, 0x2?},\
    \ {0xc0000f5ca0?, 0x2?, 0x2?})\n\t/tmp/tmp6qb7pw2s_test.go:32 +0x20c\ncommand-line-arguments_test.TestIntersection(0x0?)\n\
    \t/tmp/tmp6qb7pw2s_test.go:79 +0xe7\ntesting.tRunner(0xc0001a01a0, 0x528f48)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075552
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(int)\n    interval1End := interval1[1].(int)\n\
    \    interval2Start := interval2[0].(int)\n    interval2End := interval2[1].(int)\n\
    \    \n    if interval1Start > interval2End {\n        return \"NO\"\n    }\n\
    \    if interval1End < interval2Start {\n        return \"NO\"\n    }\n    \n\
    \    result := 0\n    \n    for i := 0; i < interval1Start; i++ {\n        result\
    \ += interval1End - i\n    }\n    \n    for i := 0; i < interval2Start; i++ {\n\
    \        result += interval2End - i\n    }\n    \n    if result % 2 == 0 {\n \
    \       return \"NO\"\n    }\n    \n    return \"YES\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpzs2e_ymo_test.go:81: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__2 (0.00s)\n        tmpzs2e_ymo_test.go:81: expected\
    \ 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n      \
    \  tmpzs2e_ymo_test.go:81: expected 'YES', got 'NO'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075552
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpfypebohj_test.go:285:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075396
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpfypebohj_test.go:285:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075396
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    var result string\n    var interval1_start, interval1_end int\n\
    \    var interval2_start, interval2_end int\n    interval1_start = interval1[0].(int)\n\
    \    interval1_end = interval1[1].(int)\n    interval2_start = interval2[0].(int)\n\
    \    interval2_end = interval2[1].(int)\n    if interval1_start > interval1_end\
    \ {\n        interval1_start, interval1_end = interval1_end, interval1_start\n\
    \    }\n    if interval2_start > interval2_end {\n        interval2_start, interval2_end\
    \ = interval2_end, interval2_start\n    }\n    if interval1_start < interval2_start\
    \ {\n        interval1_start, interval2_start = interval2_start, interval1_start\n\
    \    }\n    if interval1_end > interval2_end {\n        interval1_end, interval2_end\
    \ = interval2_end, interval1_end\n    }\n    if interval1_start > interval2_end\
    \ {\n        interval1_start, interval2_end = interval2_end, interval1_start\n\
    \    }\n    if interval1_end < interval2_start {\n        interval1_end, interval2_start\
    \ = interval2_start, interval1_end\n    }\n    if interval1_start == interval1_end\
    \ {\n        if interval2_start == interval2_end {\n            result = \"YES\"\
    \n        } else {\n            result = \"NO\"\n        }\n    } else {\n   \
    \     if interval2_start == interval2_end {\n            result = \"NO\"\n   \
    \     } else {\n            result = \"YES\"\n        }\n    }\n    return result\n\
    }\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__1\
    \ (0.00s)\n        tmp1z80kyxy_test.go:89: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp1z80kyxy_test.go:89: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n      \
    \  tmp1z80kyxy_test.go:89: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075552
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    interval1Start, interval1End := interval1[0], interval1[1]\n \
    \   interval2Start, interval2End := interval2[0], interval2[1]\n    if interval1Start\
    \ > interval1End {\n        interval1Start, interval1End = interval1End, interval1Start\n\
    \    }\n    if interval2Start > interval2End {\n        interval2Start, interval2End\
    \ = interval2End, interval2Start\n    }\n    if interval1Start >= interval2End\
    \ {\n        return \"NO\"\n    }\n    if interval1End <= interval2Start {\n \
    \       return \"NO\"\n    }\n    if interval1Start <= interval2Start && interval1End\
    \ >= interval2End {\n        return \"YES\"\n    }\n    if interval1Start <= interval2End\
    \ && interval1End >= interval2Start {\n        return \"YES\"\n    }\n    if interval1Start\
    \ >= interval2Start && interval1End <= interval2End {\n        return \"YES\"\n\
    \    }\n    if interval1Start >= interval2Start && interval1End >= interval2End\
    \ {\n        return \"YES\"\n    }\n    return \"NO\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpz0u5rz3q_test.go:30:8: invalid operation: interval1Start > interval1End
    (operator > not defined on interface)

    /tmp/tmpz0u5rz3q_test.go:33:8: invalid operation: interval2Start > interval2End
    (operator > not defined on interface)

    /tmp/tmpz0u5rz3q_test.go:36:8: invalid operation: interval1Start >= interval2End
    (operator >= not defined on interface)

    /tmp/tmpz0u5rz3q_test.go:39:8: invalid operation: interval1End <= interval2Start
    (operator <= not defined on interface)

    /tmp/tmpz0u5rz3q_test.go:42:8: invalid operation: interval1Start <= interval2Start
    (operator <= not defined on interface)

    /tmp/tmpz0u5rz3q_test.go:42:44: invalid operation: interval1End >= interval2End
    (operator >= not defined on interface)

    /tmp/tmpz0u5rz3q_test.go:45:8: invalid operation: interval1Start <= interval2End
    (operator <= not defined on interface)

    /tmp/tmpz0u5rz3q_test.go:45:42: invalid operation: interval1End >= interval2Start
    (operator >= not defined on interface)

    /tmp/tmpz0u5rz3q_test.go:48:8: invalid operation: interval1Start >= interval2Start
    (operator >= not defined on interface)

    /tmp/tmpz0u5rz3q_test.go:48:44: invalid operation: interval1End <= interval2End
    (operator <= not defined on interface)

    /tmp/tmpz0u5rz3q_test.go:48:44: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075552
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    var result string\n    \n    if len(interval1) != len(interval2)\
    \ {\n        return \"NO\"\n    }\n    \n    for i := 0; i < len(interval1); i++\
    \ {\n        if interval1[i].(float64) <= interval2[i].(float64) {\n         \
    \   result += \"YES\"\n        } else {\n            result += \"NO\"\n      \
    \  }\n    }\n    \n    return result\n}\n\nfunc TestIntersection(t *testing.T)\
    \ {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface\
    \ {} is int, not float64\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x503ea0,\
    \ 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503ea0, 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection(...)\n\t/tmp/tmpeua9bn8g_test.go:35\n\
    command-line-arguments_test.TestIntersection(0x0?)\n\t/tmp/tmpeua9bn8g_test.go:52\
    \ +0x1131\ntesting.tRunner(0xc000192680, 0x528f48)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075407
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpfypebohj_test.go:285:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075396
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    var result string\n    \n    if len(interval1) != len(interval2)\
    \ {\n        return \"NO\"\n    }\n    \n    for i := 0; i < len(interval1); i++\
    \ {\n        if interval1[i].(float64) < interval2[i].(float64) {\n          \
    \  result = \"NO\"\n            break\n        }\n    }\n    \n    if result ==\
    \ \"NO\" {\n        return \"NO\"\n    }\n    \n    for i := 0; i < len(interval1);\
    \ i++ {\n        if interval1[i].(float64) > interval2[i].(float64) {\n      \
    \      result = \"NO\"\n            break\n        }\n    }\n    \n    if result\
    \ == \"NO\" {\n        return \"NO\"\n    }\n    \n    if interval1[0].(float64)\
    \ <= interval2[0].(float64) {\n        result = \"YES\"\n    }\n    \n    return\
    \ result\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface\
    \ {} is int, not float64\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x503ea0,\
    \ 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503ea0, 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection({0xc0000f5cc0?, 0x2?, 0x2?},\
    \ {0xc0000f5ca0?, 0x2?, 0x2?})\n\t/tmp/tmpu3yvxktt_test.go:35 +0x205\ncommand-line-arguments_test.TestIntersection(0x0?)\n\
    \t/tmp/tmpu3yvxktt_test.go:70 +0xe7\ntesting.tRunner(0xc000192680, 0x528f48)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075553
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    if interval1Start > interval2End {\n  \
    \      return \"NO\"\n    }\n    \n    if interval1End < interval2Start {\n  \
    \      return \"NO\"\n    }\n    \n    interval1Length := interval1End - interval1Start\n\
    \    interval2Length := interval2End - interval2Start\n    \n    if interval1Length\
    \ == 0 || interval2Length == 0 {\n        return \"NO\"\n    }\n    \n    if interval1Length\
    \ == interval2Length {\n        if interval1Start <= interval2Start {\n      \
    \      return \"YES\"\n        }\n        return \"NO\"\n    }\n    \n    if interval1Length\
    \ < interval2Length {\n        interval1Start += interval1Length\n        interval1End\
    \ += interval1Length\n    }\n    \n    if interval1Start <= interval2Start {\n\
    \        interval2Start += interval2Length\n        interval2End += interval2Length\n\
    \    }\n    \n    if interval1Start <= interval2Start {\n        return \"YES\"\
    \n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n\
    \  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface\
    \ {} is int, not float64\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2({0x503ea0,\
    \ 0xc0001223c0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503ea0, 0xc0001223c0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection({0xc00011bcc0?, 0x2?, 0x2?},\
    \ {0xc00011bca0?, 0x2?, 0x2?})\n\t/tmp/tmprlf3li9x_test.go:32 +0x1f7\ncommand-line-arguments_test.TestIntersection(0x0?)\n\
    \t/tmp/tmprlf3li9x_test.go:83 +0xe7\ntesting.tRunner(0xc0001036c0, 0x528f48)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075553
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    var interval1Start, interval1End int\n    var interval2Start,\
    \ interval2End int\n    var lengthOfIntersection int\n    \n    interval1Start\
    \ = interval1[0].(int)\n    interval1End = interval1[1].(int)\n    interval2Start\
    \ = interval2[0].(int)\n    interval2End = interval2[1].(int)\n    \n    if interval1Start\
    \ > interval1End {\n        interval1Start, interval1End = interval1End, interval1Start\n\
    \    }\n    if interval2Start > interval2End {\n        interval2Start, interval2End\
    \ = interval2End, interval2Start\n    }\n    \n    if interval1Start <= interval2Start\
    \ && interval1End >= interval2End {\n        lengthOfIntersection = interval1End\
    \ - interval1Start\n    }\n    if interval2Start <= interval1Start && interval2End\
    \ >= interval1End {\n        lengthOfIntersection = interval2End - interval2Start\n\
    \    }\n    \n    if lengthOfIntersection == 0 {\n        return \"NO\"\n    }\n\
    \    \n    if lengthOfIntersection == 1 {\n        return \"YES\"\n    }\n   \
    \ \n    if lengthOfIntersection == 2 && interval1Start <= interval2Start && interval2End\
    \ >= interval1End {\n        return \"YES\"\n    }\n    \n    if lengthOfIntersection\
    \ == 2 && interval2Start <= interval1Start && interval1End >= interval2End {\n\
    \        return \"YES\"\n    }\n    \n    if lengthOfIntersection == 2 && interval1Start\
    \ <= interval2Start && interval2End >= interval1End {\n        return \"YES\"\n\
    \    }\n    \n    if lengthOfIntersection == 2 && interval2Start <= interval1Start\
    \ && interval1End >= interval2End {\n        return \"YES\"\n    }\n    \n   \
    \ if lengthOfIntersection == 3 && interval1Start <= interval2Start && interval2End\
    \ >= interval1End {\n        return \"YES\"\n    }\n    \n    if lengthOfIntersection\
    \ == 3 && interval2Start <= interval1Start && interval1End >= interval2End {\n\
    \        return \"YES\"\n    }\n    \n    if lengthOfIntersection == 3 && interval1Start\
    \ <= interval2Start && interval2End >= interval1End {\n        return \"YES\"\n\
    \    }\n    \n    if lengthOfIntersection == 3 && interval2Start <= interval1Start\
    \ && interval1End >= interval2End {\n        return \"YES\"\n    }\n    \n   \
    \ if lengthOfIntersection == 3 && interval1Start <= interval2Start && interval2End\
    \ >= interval1End {\n        return \"YES\"\n    }\n    \n    if lengthOf\nfunc\
    \ TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpn67dmse4_test.go:96:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075552
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    \n    if interval1Start > interval1End\
    \ {\n        return \"NO\"\n    }\n    if interval2Start > interval2End {\n  \
    \      return \"NO\"\n    }\n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n\nfunc TestIntersection(t *testing.T) {\n  candidate\
    \ := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpi7ah4anu_test.go:253:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075552
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n\n    if interval1Start > interval1End {\n      \
    \  fmt.Println(\"interval1Start > interval1End\")\n        return \"NO\"\n   \
    \ }\n    if interval2Start > interval2End {\n        fmt.Println(\"interval2Start\
    \ > interval2End\")\n        return \"NO\"\n    }\n\n    if interval1Start < interval2Start\
    \ {\n        fmt.Println(\"interval1Start < interval2Start\")\n        return\
    \ \"NO\"\n    }\n    if interval1End > interval2End {\n        fmt.Println(\"\
    interval1End > interval2End\")\n        return \"NO\"\n    }\n\n    if interval1Start\
    \ >= interval1End {\n        fmt.Println(\"interval1Start >= interval1End\")\n\
    \        return \"NO\"\n    }\n    if interval2Start >= interval2End {\n     \
    \   fmt.Println(\"interval2Start >= interval2End\")\n        return \"NO\"\n \
    \   }\n\n    if interval1Start <= interval2Start {\n        fmt.Println(\"interval1Start\
    \ <= interval2Start\")\n        return \"NO\"\n    }\n    if interval1End <= interval2End\
    \ {\n        fmt.Println(\"interval1End <= interval2End\")\n        return \"\
    NO\"\n    }\n\n    if interval1Start <= interval2Start && interval1End >= interval2End\
    \ {\n        fmt.Println(\"interval1Start <= interval2Start && interval1End >=\
    \ interval2End\")\n        return \"NO\"\n    }\n\n    if interval1Start >= interval1End\
    \ && interval2Start >= interval2End {\n        fmt.Println(\"interval1Start >=\
    \ interval1End && interval2Start >= interval2End\")\n        return \"NO\"\n \
    \   }\n\n    if interval1Start <= interval2Start && interval1End <= interval2End\
    \ {\n        fmt.Println(\"interval1Start <= interval2Start && interval1End <=\
    \ interval2End\")\n        return \"NO\"\n    }\n\n    if interval1Start >= interval1End\
    \ && interval2Start <= interval2End {\n        fmt.Println(\"interval1Start >=\
    \ interval1End && interval2Start <= interval2End\")\n        return \"NO\"\n \
    \   }\n\n    if interval1Start <= interval2Start && interval1End >= interval2End\
    \ {\n        fmt.Println(\"interval1Start <= interval2Start && interval1End >=\
    \ interval2End\")\n        return \"NO\"\n    }\n\n    if interval1Start >= interval1End\
    \ && interval2\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpt2uua0rg_test.go:95:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075552
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(int)\n    interval1End := interval1[1].(int)\n\
    \    interval2Start := interval2[0].(int)\n    interval2End := interval2[1].(int)\n\
    \    \n    if interval1Start > interval2End {\n        return \"NO\"\n    }\n\
    \    if interval1End < interval2Start {\n        return \"NO\"\n    }\n    \n\
    \    interval1Length := interval1End - interval1Start\n    interval2Length :=\
    \ interval2End - interval2Start\n    \n    if interval1Length == 0 || interval2Length\
    \ == 0 {\n        return \"NO\"\n    }\n    \n    interval1PrimeLength := interval1Length\
    \ / 2\n    interval2PrimeLength := interval2Length / 2\n    \n    if interval1PrimeLength\
    \ == 0 || interval2PrimeLength == 0 {\n        return \"NO\"\n    }\n    \n  \
    \  if interval1PrimeLength == interval2PrimeLength {\n        interval1PrimeLength\
    \ += 1\n    }\n    \n    if interval1PrimeLength == 2 {\n        return \"YES\"\
    \n    }\n    \n    if interval1PrimeLength == 3 {\n        return \"YES\"\n  \
    \  }\n    \n    if interval1PrimeLength == 4 {\n        return \"YES\"\n    }\n\
    \    \n    if interval1PrimeLength == 5 {\n        return \"YES\"\n    }\n   \
    \ \n    if interval1PrimeLength == 6 {\n        return \"YES\"\n    }\n    \n\
    \    if interval1PrimeLength == 7 {\n        return \"YES\"\n    }\n    \n   \
    \ if interval1PrimeLength == 8 {\n        return \"YES\"\n    }\n    \n    if\
    \ interval1PrimeLength == 9 {\n        return \"YES\"\n    }\n    \n    if interval1PrimeLength\
    \ == 10 {\n        return \"YES\"\n    }\n    \n    if interval1PrimeLength ==\
    \ 11 {\n        return \"YES\"\n    }\n    \n    if interval1PrimeLength == 12\
    \ {\n        return \"YES\"\n    }\n    \n    if interval1PrimeLength == 13 {\n\
    \        return \"YES\"\n    }\n    \n    if interval1PrimeLength == 14 {\n  \
    \      return \"YES\"\n    }\n    \n    if interval1PrimeLength == 15 {\n    \
    \    return \"YES\"\n    }\n    \n    if interval1PrimeLength == 16 {\n      \
    \  return \"YES\"\n    }\n    \n    if interval1PrimeLength == 17 {\n        return\
    \ \"YES\"\n    }\n    \n    if interval1PrimeLength == 18 {\n        return \"\
    YES\"\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmprpoih6ts_test.go:128:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075552
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    if interval1Start > interval1End {\n  \
    \      fmt.Println(\"interval1Start > interval1End\")\n        return \"NO\"\n\
    \    }\n    if interval2Start > interval2End {\n        fmt.Println(\"interval2Start\
    \ > interval2End\")\n        return \"NO\"\n    }\n    \n    \n    if interval1Start\
    \ <= interval2Start && interval1End >= interval2End {\n        fmt.Println(\"\
    interval1Start <= interval2Start && interval1End >= interval2End\")\n        return\
    \ \"NO\"\n    }\n    if interval1Start <= interval2Start && interval1End <= interval2End\
    \ {\n        fmt.Println(\"interval1Start <= interval2Start && interval1End <=\
    \ interval2End\")\n        return \"YES\"\n    }\n    if interval1Start >= interval2Start\
    \ && interval1End >= interval2End {\n        fmt.Println(\"interval1Start >= interval2Start\
    \ && interval1End >= interval2End\")\n        return \"YES\"\n    }\n    \n  \
    \  if interval1Start <= interval2Start && interval1End >= interval2End {\n   \
    \     fmt.Println(\"interval1Start <= interval2Start && interval1End >= interval2End\"\
    )\n        return \"YES\"\n    }\n    \n    if interval1Start >= interval2Start\
    \ && interval1End <= interval2End {\n        fmt.Println(\"interval1Start >= interval2Start\
    \ && interval1End <= interval2End\")\n        return \"YES\"\n    }\n    \n  \
    \  if interval1Start <= interval2Start && interval1End <= interval2End {\n   \
    \     fmt.Println(\"interval1Start <= interval2Start && interval1End <= interval2End\"\
    )\n        return \"YES\"\n    }\n    \n    if interval1Start >= interval2Start\
    \ && interval1End >= interval2End {\n        fmt.Println(\"interval1Start >= interval2Start\
    \ && interval1End >= interval2End\")\n        return \"YES\"\n    }\n    \n  \
    \  return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface\
    \ {} is int, not float64\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x503ea0,\
    \ 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503ea0, 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection({0xc0000f5cc0?, 0x2?, 0x2?},\
    \ {0xc0000f5ca0?, 0x2?, 0x2?})\n\t/tmp/tmpbox0b1e8_test.go:28 +0x527\ncommand-line-arguments_test.TestIntersection(0x0?)\n\
    \t/tmp/tmpbox0b1e8_test.go:86 +0xe7\ntesting.tRunner(0xc0001924e0, 0x529080)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075553
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    interval1Start, interval1End := interval1[0].([]interface{})[0],\
    \ interval1[0].([]interface{})[1]\n    interval2Start, interval2End := interval2[0].([]interface{})[0],\
    \ interval2[0].([]interface{})[1]\n    if interval1Start > interval1End {\n  \
    \      interval1Start, interval1End = interval1End, interval1Start\n    }\n  \
    \  if interval2Start > interval2End {\n        interval2Start, interval2End =\
    \ interval2End, interval2Start\n    }\n    if interval1Start > interval2End {\n\
    \        return \"NO\"\n    }\n    if interval1End < interval2Start {\n      \
    \  return \"NO\"\n    }\n    if interval1Start <= interval2Start && interval1End\
    \ >= interval2End {\n        return \"YES\"\n    }\n    if interval1Start <= interval2End\
    \ && interval1End >= interval2Start {\n        return \"YES\"\n    }\n    if interval1Start\
    \ >= interval2Start && interval1End <= interval2End {\n        return \"YES\"\n\
    \    }\n    if interval1Start >= interval2End && interval1End <= interval2Start\
    \ {\n        return \"YES\"\n    }\n    return \"NO\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfpwt8iyx_test.go:30:8: invalid operation: interval1Start > interval1End
    (operator > not defined on interface)

    /tmp/tmpfpwt8iyx_test.go:33:8: invalid operation: interval2Start > interval2End
    (operator > not defined on interface)

    /tmp/tmpfpwt8iyx_test.go:36:8: invalid operation: interval1Start > interval2End
    (operator > not defined on interface)

    /tmp/tmpfpwt8iyx_test.go:39:8: invalid operation: interval1End < interval2Start
    (operator < not defined on interface)

    /tmp/tmpfpwt8iyx_test.go:42:8: invalid operation: interval1Start <= interval2Start
    (operator <= not defined on interface)

    /tmp/tmpfpwt8iyx_test.go:42:44: invalid operation: interval1End >= interval2End
    (operator >= not defined on interface)

    /tmp/tmpfpwt8iyx_test.go:45:8: invalid operation: interval1Start <= interval2End
    (operator <= not defined on interface)

    /tmp/tmpfpwt8iyx_test.go:45:42: invalid operation: interval1End >= interval2Start
    (operator >= not defined on interface)

    /tmp/tmpfpwt8iyx_test.go:48:8: invalid operation: interval1Start >= interval2Start
    (operator >= not defined on interface)

    /tmp/tmpfpwt8iyx_test.go:48:44: invalid operation: interval1End <= interval2End
    (operator <= not defined on interface)

    /tmp/tmpfpwt8iyx_test.go:48:44: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075553
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return\
    \ \"NO\"\n    }\n    \n    interval1Start := interval1[0].(int)\n    interval1End\
    \ := interval1[1].(int)\n    interval2Start := interval2[0].(int)\n    interval2End\
    \ := interval2[1].(int)\n    \n    if interval1Start > interval2End {\n      \
    \  return \"NO\"\n    }\n    \n    if interval1End < interval2Start {\n      \
    \  return \"NO\"\n    }\n    \n    if interval1Start > interval2Start {\n    \
    \    interval1Start := interval1Start\n        interval1End := interval1End\n\
    \    }\n    \n    if interval1Start > interval2End {\n        interval1End :=\
    \ interval1End\n        interval1Start := interval1Start\n    }\n    \n    if\
    \ interval1Start > interval2End {\n        return \"NO\"\n    }\n    \n    if\
    \ interval1Start < interval2End {\n        interval1End := interval1End\n    \
    \    interval1Start := interval1Start\n    }\n    \n    if interval1Start < interval2End\
    \ {\n        return \"NO\"\n    }\n    \n    if interval1Start < interval2Start\
    \ {\n        interval1Start := interval1Start\n        interval1End := interval1End\n\
    \    }\n    \n    if interval1Start < interval2Start {\n        interval1End :=\
    \ interval1End\n        interval1Start := interval1Start\n    }\n    \n    if\
    \ interval1Start < interval2Start {\n        return \"NO\"\n    }\n    \n    if\
    \ interval1Start < interval2End {\n        return \"NO\"\n    }\n    \n    if\
    \ interval1Start < interval2End {\n        return \"NO\"\n    }\n    \n    if\
    \ interval1Start < interval2Start {\n        interval1Start := interval1Start\n\
    \        interval1End := interval1End\n    }\n    \n    if interval1Start < interval2Start\
    \ {\n        interval1End := interval1End\n        interval1Start := interval1Start\n\
    \    }\n    \n    if interval1Start < interval2Start {\n        return \"NO\"\n\
    \    }\n    \n    if interval1Start < interval2End {\n        return \"NO\"\n\
    \    }\n    \n    if interval1Start < interval2End {\n        return \"NO\"\n\
    \    }\n    \n    if interval1Start < interval2Start {\n        interval1Start\
    \ := interval1Start\n        interval1End := interval1End\n    }\n    \n    if\
    \ interval1Start < interval2Start {\n        interval1End := interval\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpyu9fatv__test.go:119:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075552
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1 := make([]int, len(interval1))\n    interval2 := make([]int,\
    \ len(interval2))\n    \n    for i := 0; i < len(interval1); i++ {\n        interval1[i]\
    \ = int(interval1[i])\n    }\n    for i := 0; i < len(interval2); i++ {\n    \
    \    interval2[i] = int(interval2[i])\n    }\n    \n    result := make([]int,\
    \ len(interval1))\n    \n    for i := 0; i < len(interval1); i++ {\n        for\
    \ j := 0; j < len(interval2); j++ {\n            if interval1[i] >= interval2[j]\
    \ {\n                break\n            }\n            if interval1[i] <= interval2[j]\
    \ {\n                result[i] = interval1[i]\n                break\n       \
    \     }\n        }\n    }\n    \n    if result == nil {\n        return \"NO\"\
    \n    }\n    \n    result := make([]int, len(result))\n    \n    for i := 0; i\
    \ < len(result); i++ {\n        if result[i] == 0 {\n            result[i] = 1\n\
    \        }\n    }\n    \n    if result == nil {\n        return \"NO\"\n    }\n\
    \    \n    result := make([]int, len(result))\n    \n    for i := 0; i < len(result);\
    \ i++ {\n        if result[i] == 1 {\n            result[i] = 0\n        }\n \
    \   }\n    \n    if result == nil {\n        return \"NO\"\n    }\n    \n    result\
    \ := make([]int, len(result))\n    \n    for i := 0; i < len(result); i++ {\n\
    \        if result[i] == 0 {\n            result[i] = 1\n        }\n    }\n  \
    \  \n    if result == nil {\n        return \"NO\"\n    }\n    \n    result :=\
    \ make([]int, len(result))\n    \n    for i := 0; i < len(result); i++ {\n   \
    \     if result[i] == 1 {\n            result[i] = 0\n        }\n    }\n    \n\
    \    if result == nil {\n        return \"NO\"\n    }\n    \n    result := make([]int,\
    \ len(result))\n    \n    for i := 0; i < len(result); i++ {\n        if result[i]\
    \ == 0 {\n            result[i] = 1\n        }\n    }\n    \n    if result ==\
    \ nil {\n        return \"NO\"\n    }\n    \n    result := make([]int, len(result))\n\
    \    \n    for i := 0; i < len(result); i++ {\n        if result[i] == 1 {\n \
    \           result[i] = 0\n        }\n    }\n    \n    if result == nil {\n  \
    \      return \"NO\"\n    }\n    \n    result := make([]int, len(result))\n  \
    \  \n    for i := 0; i < len(result); i++ {\n        if result\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpbh_5m1ng_test.go:136:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075553
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpfypebohj_test.go:285:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075396
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    var interval1Start, interval1End int\n    var interval2Start,\
    \ interval2End int\n    var isIntersecting bool\n\n    if len(interval1) != len(interval2)\
    \ {\n        return \"NO\"\n    }\n\n    for i := 0; i < len(interval1); i++ {\n\
    \        interval1Start = interval1[i].(int)\n        interval1End = interval1Start\
    \ + interval1[i].(int)\n        interval2Start = interval2[i].(int)\n        interval2End\
    \ = interval2Start + interval2[i].(int)\n\n        if interval1Start <= interval2Start\
    \ && interval1End >= interval2End {\n            isIntersecting = true\n     \
    \       break\n        }\n    }\n\n    if !isIntersecting {\n        return \"\
    NO\"\n    }\n\n    if isPrime(interval1Start, interval1End, interval2Start, interval2End)\
    \ {\n        return \"YES\"\n    }\n\n    return \"NO\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjdq1rcx3_test.go:52:8: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075553
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    if interval1Start > interval1End {\n  \
    \      interval1Start, interval1End = interval1End, interval1Start\n    }\n  \
    \  if interval2Start > interval2End {\n        interval2Start, interval2End =\
    \ interval2End, interval2Start\n    }\n    \n    if interval1Start <= interval2Start\
    \ && interval1End >= interval2End {\n        if interval1Start <= interval2End\
    \ {\n            interval1Start, interval1End = interval2Start, interval2End\n\
    \        }\n        if interval1End >= interval2Start {\n            interval1End,\
    \ interval1Start = interval2End, interval2Start\n        }\n        \n       \
    \ if interval1Start <= interval1End {\n            interval1Start += interval1End\
    \ - interval1Start\n            interval1End -= interval1End - interval1Start\n\
    \        }\n        \n        if interval1Start > interval1End {\n           \
    \ return \"NO\"\n        }\n        \n        if interval1Start <= interval2Start\
    \ {\n            interval1Start += interval2End - interval2Start\n           \
    \ interval1End -= interval2End - interval2Start\n        }\n        \n       \
    \ if interval1Start > interval1End {\n            return \"NO\"\n        }\n \
    \       \n        if interval1Start <= interval2Start {\n            interval1Start\
    \ += interval1End - interval1Start\n            interval1End -= interval1End -\
    \ interval1Start\n        }\n        \n        if interval1Start > interval1End\
    \ {\n            return \"NO\"\n        }\n        \n        if interval1Start\
    \ <= interval2Start {\n            interval1Start += interval2End - interval2Start\n\
    \            interval1End -= interval2End - interval2Start\n        }\n      \
    \  \n        if interval1Start > interval1End {\n            return \"NO\"\n \
    \       }\n        \n        if interval1Start <= interval2Start {\n         \
    \   interval1Start += interval1End - interval1Start\n            interval1End\
    \ -= interval1End - interval1Start\n        }\n        \n        if interval1Start\
    \ > interval1End {\n            return \"NO\"\n        }\n        \n        if\
    \ interval1Start <= interval2Start {\n            interval1Start += interval2End\
    \ - interval2Start\n            interval1End -= interval2\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpn5btzs5i_test.go:100:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075553
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(int)\n    interval1End := interval1[1].(int)\n\
    \    interval2Start := interval2[0].(int)\n    interval2End := interval2[1].(int)\n\
    \    \n    if interval1Start > interval2End {\n        return \"NO\"\n    }\n\
    \    if interval1End < interval2Start {\n        return \"NO\"\n    }\n    \n\
    \    intersection := interval1Start <= interval2Start && interval1End >= interval2End\n\
    \    if intersection {\n        return \"YES\"\n    }\n    \n    intersection\
    \ := interval1Start <= interval2End && interval1End >= interval2Start\n    if\
    \ intersection {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\n\
    func TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp652nw9uo_test.go:49:18: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075399
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1 := make([]int, len(interval1))\n    interval2 := make([]int,\
    \ len(interval2))\n    \n    for i := 0; i < len(interval1); i++ {\n        interval1[i]\
    \ = int(interval1[i])\n    }\n    for i := 0; i < len(interval2); i++ {\n    \
    \    interval2[i] = int(interval2[i])\n    }\n    \n    result := make([]int,\
    \ len(interval1))\n    \n    for i := 0; i < len(interval1); i++ {\n        if\
    \ interval1[i] > interval2[i] {\n            result[i] = interval1[i]\n      \
    \  } else {\n            result[i] = interval2[i]\n        }\n    }\n    \n  \
    \  result := make([]int, len(result))\n    \n    for i := 0; i < len(result);\
    \ i++ {\n        if result[i] == 0 {\n            result[i] = 1\n        }\n \
    \   }\n    \n    result := make([]int, len(result))\n    \n    for i := 0; i <\
    \ len(result); i++ {\n        if result[i] == 1 {\n            result[i] = 0\n\
    \        }\n    }\n    \n    result := make([]int, len(result))\n    \n    for\
    \ i := 0; i < len(result); i++ {\n        if result[i] == 1 {\n            return\
    \ \"YES\"\n        }\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2_pboopk_test.go:32:15:\
    \ no new variables on left side of :=\n/tmp/tmp2_pboopk_test.go:32:18: cannot\
    \ use make([]int, len(interval1)) (value of type []int) as type []interface{}\
    \ in assignment\n/tmp/tmp2_pboopk_test.go:33:15: no new variables on left side\
    \ of :=\n/tmp/tmp2_pboopk_test.go:33:18: cannot use make([]int, len(interval2))\
    \ (value of type []int) as type []interface{} in assignment\n/tmp/tmp2_pboopk_test.go:36:28:\
    \ cannot convert interval1[i] (variable of type interface{}) to type int:\n\t\
    need type assertion\n/tmp/tmp2_pboopk_test.go:39:28: cannot convert interval2[i]\
    \ (variable of type interface{}) to type int:\n\tneed type assertion\n/tmp/tmp2_pboopk_test.go:45:12:\
    \ invalid operation: interval1[i] > interval2[i] (operator > not defined on interface)\n\
    /tmp/tmp2_pboopk_test.go:46:25: cannot use interval1[i] (variable of type interface{})\
    \ as type int in assignment:\n\tneed type assertion\n/tmp/tmp2_pboopk_test.go:48:25:\
    \ cannot use interval2[i] (variable of type interface{}) as type int in assignment:\n\
    \tneed type assertion\n/tmp/tmp2_pboopk_test.go:52:12: no new variables on left\
    \ side of :=\n/tmp/tmp2_pboopk_test.go:52:12: too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075553
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpfypebohj_test.go:285:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075396
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return\
    \ \"NO\"\n    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End\
    \ := interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n  \
    \  interval2End := interval2[1].(float64)\n    \n    if interval1Start > interval2End\
    \ {\n        return \"NO\"\n    }\n    if interval1End < interval2Start {\n  \
    \      return \"NO\"\n    }\n    \n    intersection := interval1Start + interval2End\
    \ - interval1End - interval2Start\n    \n    if isPrime(intersection) {\n    \
    \    return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpszti235m_test.go:46:8: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075553
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) < len(interval2) {\n        interval1, interval2\
    \ = interval2, interval1\n    }\n    \n    interval1 := interval1[:len(interval2)]\n\
    \    interval2 := interval2[:len(interval1)]\n    \n    result := make([]interface{},\
    \ len(interval1))\n    \n    for i := 0; i < len(interval1); i++ {\n        result[i]\
    \ = interval1[i] >= interval2[i] ? interval1[i] : interval2[i]\n    }\n    \n\
    \    result := result[:len(interval1)]\n    \n    result := append(result, interval1[len(interval1):])\n\
    \    result := append(result, interval2[len(interval2):])\n    \n    result :=\
    \ result[:len(result)/2]\n    \n    result := append(result, interval1[len(interval1)/2:])\n\
    \    result := append(result, interval2[len(interval2)/2:])\n    \n    result\
    \ := result[:len(result)/2]\n    \n    result := append(result, interval1[len(interval1)/2:])\n\
    \    result := append(result, interval2[len(interval2)/2:])\n    \n    result\
    \ := result[:len(result)/2]\n    \n    result := append(result, interval1[len(interval1)/2:])\n\
    \    result := append(result, interval2[len(interval2)/2:])\n    \n    result\
    \ := result[:len(result)/2]\n    \n    result := append(result, interval1[len(interval1)/2:])\n\
    \    result := append(result, interval2[len(interval2)/2:])\n    \n    result\
    \ := result[:len(result)/2]\n    \n    result := append(result, interval1[len(interval1)/2:])\n\
    \    result := append(result, interval2[len(interval2)/2:])\n    \n    result\
    \ := result[:len(result)/2]\n    \n    result := append(result, interval1[len(interval1)/2:])\n\
    \    result := append(result, interval2[len(interval2)/2:])\n    \n    result\
    \ := result[:len(result)/2]\n    \n    result := append(result, interval1[len(interval1)/2:])\n\
    \    result := append(result, interval2[len(interval2)/2:])\n    \n    result\
    \ := result[:len(result)/2]\n    \n    result := append(result, interval1[len(interval1)/2:])\n\
    \    result := append(result, interval2[len(interval2)/2:])\n    \n    result\
    \ := result[:len(result)/2]\n    \n    result := append(result, interval1[len(interval1)/2:])\n\
    \    result := append(result, interval2[len(interval2)/2:])\n    \n    result\
    \ := \nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_qpfbnqn_test.go:38:50: illegal character U+003F ''?''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075553
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    if interval1Start > interval2End {\n  \
    \      return \"NO\"\n    }\n    if interval1End < interval2Start {\n        return\
    \ \"NO\"\n    }\n    \n    intersectionLength := interval1End - interval1Start\n\
    \    \n    if intersectionLength == 0 {\n        return \"NO\"\n    }\n    \n\
    \    if interval1Start <= interval2Start && interval1End >= interval2End {\n \
    \       return \"YES\"\n    }\n    if interval1Start <= interval2End && interval1End\
    \ >= interval2Start {\n        return \"YES\"\n    }\n    if interval1Start >=\
    \ interval2Start && interval1End <= interval2End {\n        return \"YES\"\n \
    \   }\n    if interval1Start >= interval2End && interval1End <= interval2Start\
    \ {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface\
    \ {} is int, not float64\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2({0x503ea0,\
    \ 0xc0001223c0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503ea0, 0xc0001223c0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection({0xc00011bcc0?, 0x2?, 0x2?},\
    \ {0xc00011bca0?, 0x2?, 0x2?})\n\t/tmp/tmprt_2lep5_test.go:32 +0x217\ncommand-line-arguments_test.TestIntersection(0x0?)\n\
    \t/tmp/tmprt_2lep5_test.go:73 +0xe7\ntesting.tRunner(0xc000103520, 0x528f48)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075399
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    if interval1Start > interval2End {\n  \
    \      return \"NO\"\n    }\n    if interval1End < interval2Start {\n        return\
    \ \"NO\"\n    }\n    \n    interval1Length := interval1End - interval1Start\n\
    \    interval2Length := interval2End - interval2Start\n    \n    if interval1Length\
    \ == 0 || interval2Length == 0 {\n        return \"NO\"\n    }\n    \n    if interval1Length\
    \ == interval2Length {\n        \n        if interval1Start <= interval2Start\
    \ {\n            return \"NO\"\n        }\n        \n        if interval1End >=\
    \ interval2End {\n            return \"NO\"\n        }\n        \n        if interval1Start\
    \ <= interval2Start && interval1End >= interval2End {\n            return \"YES\"\
    \n        }\n        \n        if interval1Start <= interval2End && interval1End\
    \ >= interval2Start {\n            return \"YES\"\n        }\n        \n     \
    \   if interval1Start >= interval2Start && interval1End <= interval2End {\n  \
    \          return \"YES\"\n        }\n        \n        if interval1Start >= interval2Start\
    \ && interval1End >= interval2End {\n            return \"YES\"\n        }\n \
    \       \n        if interval1Start <= interval2Start && interval1End <= interval2End\
    \ {\n            return \"YES\"\n        }\n        \n        if interval1Start\
    \ <= interval2Start && interval1End >= interval2End {\n            return \"YES\"\
    \n        }\n        \n        if interval1Start >= interval2Start && interval1End\
    \ <= interval2End {\n            return \"YES\"\n        }\n        \n       \
    \ if interval1Start >= interval2Start && interval1End >= interval2End {\n    \
    \        return \"YES\"\n        }\n        \n        if interval1Start <= interval2Start\
    \ && interval1End <= interval2End {\n            return \"YES\"\n        }\n \
    \       \n        if interval1Start <= interval2Start && interval1End >= interval2End\
    \ {\n            return \"YES\"\n        }\n        \n        if interval1Start\
    \ >= interval2Start && interval1End <= interval2End {\n            return \"YES\"\
    \n        }\n        \n        if interval1Start >= interval2Start && interval1End\
    \ >= interval2End {\n            return \"YES\"\n        }\n        \n       \
    \ if interval1Start <= interval\nfunc TestIntersection(t *testing.T) {\n  candidate\
    \ := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpemv1i1bb_test.go:110:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075553
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    if interval1Start > interval2End {\n  \
    \      return \"NO\"\n    }\n    if interval1End < interval2Start {\n        return\
    \ \"NO\"\n    }\n    \n    intersection := interval1Start + interval1End - interval2Start\
    \ - interval2End\n    if intersection <= 0 {\n        return \"NO\"\n    }\n \
    \   \n    if isPrime(intersection) {\n        return \"YES\"\n    }\n    \n  \
    \  return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0l__isva_test.go:49:8: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075400
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    if interval1Start > interval2End {\n  \
    \      return \"NO\"\n    }\n    if interval1End < interval2Start {\n        return\
    \ \"NO\"\n    }\n    \n    intersection := interval1Start + interval1End - interval2Start\
    \ - interval2End\n    \n    if intersection <= 0 {\n        return \"NO\"\n  \
    \  }\n    \n    if isPrime(intersection) {\n        return \"YES\"\n    }\n  \
    \  \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate\
    \ := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2wl81vbj_test.go:50:8: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075397
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpfypebohj_test.go:285:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075396
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpfypebohj_test.go:285:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075396
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    if interval1Start > interval2End {\n  \
    \      return \"NO\"\n    }\n    if interval1End < interval2Start {\n        return\
    \ \"NO\"\n    }\n    \n    intersectionStart := interval1Start\n    intersectionEnd\
    \ := interval1End\n    \n    for i := 1; i < len(interval1); i++ {\n        interval1Start\
    \ := interval1[i].(float64)\n        interval1End := interval1[i+1].(float64)\n\
    \        \n        if interval1Start > interval1End {\n            return \"NO\"\
    \n        }\n        if interval1End < interval1Start {\n            return \"\
    NO\"\n        }\n        \n        if intersectionStart > interval1End {\n   \
    \         return \"NO\"\n        }\n        if intersectionEnd < interval1Start\
    \ {\n            return \"NO\"\n        }\n        \n        if intersectionStart\
    \ > intersectionEnd {\n            intersectionStart = interval1Start\n      \
    \      intersectionEnd = interval1End\n        }\n    }\n    \n    if intersectionStart\
    \ > intersectionEnd {\n        return \"NO\"\n    }\n    \n    if intersectionStart\
    \ <= interval1Start && intersectionEnd >= interval1End {\n        return \"YES\"\
    \n    }\n    \n    if intersectionStart >= interval1Start && intersectionEnd <=\
    \ interval1End {\n        return \"YES\"\n    }\n    \n    if intersectionStart\
    \ <= interval2Start && intersectionEnd >= interval2End {\n        return \"YES\"\
    \n    }\n    \n    if intersectionStart >= interval2Start && intersectionEnd <=\
    \ interval2End {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\n\
    func TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface\
    \ {} is int, not float64\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x503ea0,\
    \ 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503ea0, 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection({0xc0000f5cc0?, 0x2?, 0x2?},\
    \ {0xc0000f5ca0?, 0x2?, 0x2?})\n\t/tmp/tmpge6mfqxz_test.go:32 +0x2fe\ncommand-line-arguments_test.TestIntersection(0x0?)\n\
    \t/tmp/tmpge6mfqxz_test.go:101 +0xe7\ntesting.tRunner(0xc0001924e0, 0x528f48)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075555
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    if interval1Start > interval1End {\n  \
    \      interval1Start, interval1End = interval1End, interval1Start\n    }\n  \
    \  if interval2Start > interval2End {\n        interval2Start, interval2End =\
    \ interval2End, interval2Start\n    }\n    \n    intersectionLength := interval1End\
    \ - interval1Start\n    \n    if interval2Start <= interval2End {\n        if\
    \ interval1Start <= interval1End {\n            if interval2Start <= interval2End\
    \ {\n                if interval1Start <= interval2Start && interval1End >= interval2End\
    \ {\n                    if interval1Start <= interval2End {\n               \
    \         intersectionLength += 1\n                    }\n                   \
    \ if interval1Start >= interval2Start {\n                        intersectionLength\
    \ += 1\n                    }\n                }\n                if interval1Start\
    \ >= interval2Start {\n                    intersectionLength += 1\n         \
    \       }\n            }\n            if interval1Start >= interval2Start {\n\
    \                intersectionLength += 1\n            }\n        }\n        if\
    \ interval1Start >= interval2Start {\n            intersectionLength += 1\n  \
    \      }\n    }\n    if interval1Start <= interval1End {\n        if interval2Start\
    \ <= interval2End {\n            if interval1Start <= interval2Start && interval1End\
    \ >= interval2End {\n                if interval1Start <= interval2End {\n   \
    \                 intersectionLength += 1\n                }\n               \
    \ if interval1Start >= interval2Start {\n                    intersectionLength\
    \ += 1\n                }\n            }\n            if interval1Start >= interval2Start\
    \ {\n                intersectionLength += 1\n            }\n        }\n     \
    \   if interval1Start >= interval2Start {\n            intersectionLength += 1\n\
    \        }\n    }\n    \n    if intersectionLength == 2 {\n        return \"YES\"\
    \n    }\n    if intersectionLength > 2 {\n        return \"NO\"\n    }\n    return\
    \ \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface\
    \ {} is int, not float64\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x503ea0,\
    \ 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503ea0, 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection({0xc0000f5cc0?, 0x2?, 0x2?},\
    \ {0xc0000f5ca0?, 0x2?, 0x2?})\n\t/tmp/tmpugayxuh8_test.go:32 +0x22d\ncommand-line-arguments_test.TestIntersection(0x0?)\n\
    \t/tmp/tmpugayxuh8_test.go:104 +0xe7\ntesting.tRunner(0xc0001a0340, 0x528f48)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075555
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    \n    interval1_start := interval1[0].(int)\n    interval1_end\
    \ := interval1[1].(int)\n    interval2_start := interval2[0].(int)\n    interval2_end\
    \ := interval2[1].(int)\n    \n    if interval1_start > interval1_end {\n    \
    \    fmt.Println(\"interval1 start is bigger than interval1 end\")\n        return\
    \ \"NO\"\n    }\n    if interval2_start > interval2_end {\n        fmt.Println(\"\
    interval2 start is bigger than interval2 end\")\n        return \"NO\"\n    }\n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n\nfunc TestIntersection(t *testing.T)\
    \ {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp5o5ta5li_test.go:245:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075553
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    var interval1Start, interval1End int\n    var interval2Start,\
    \ interval2End int\n    var lengthOfIntersection int\n\n    interval1Start, interval1End\
    \ = interval1[0].(int), interval1[1].(int)\n    interval2Start, interval2End =\
    \ interval2[0].(int), interval2[1].(int)\n\n    lengthOfIntersection = interval1End\
    \ - interval1Start + 1\n    if interval2Start > interval2End {\n        interval2Start,\
    \ interval2End = interval2End, interval2Start\n    }\n\n    if lengthOfIntersection\
    \ == 0 {\n        return \"NO\"\n    }\n\n    if lengthOfIntersection == 1 {\n\
    \        if interval1Start <= interval1End && interval2Start <= interval2End {\n\
    \            if interval1Start <= interval2Start && interval1End <= interval2End\
    \ {\n                return \"YES\"\n            }\n        }\n        return\
    \ \"NO\"\n    }\n\n    if lengthOfIntersection == 2 {\n        if interval1Start\
    \ <= interval1End && interval2Start <= interval2End {\n            if interval1Start\
    \ <= interval2Start && interval1End <= interval2End {\n                if interval1Start\
    \ <= interval2Start {\n                    return \"YES\"\n                }\n\
    \                if interval1End <= interval2End {\n                    return\
    \ \"YES\"\n                }\n            }\n        }\n        return \"NO\"\n\
    \    }\n\n    if lengthOfIntersection == 3 {\n        if interval1Start <= interval1End\
    \ && interval2Start <= interval2End {\n            if interval1Start <= interval2Start\
    \ && interval1End <= interval2End {\n                if interval1Start <= interval2Start\
    \ {\n                    if interval1End <= interval2End {\n                 \
    \       return \"YES\"\n                    }\n                }\n           \
    \     if interval1End <= interval2End {\n                    if interval1Start\
    \ <= interval2Start {\n                        return \"YES\"\n              \
    \      }\n                }\n            }\n        }\n        return \"NO\"\n\
    \    }\n\n    if lengthOfIntersection == 4 {\n        if interval1Start <= interval1End\
    \ && interval2Start <= interval2End {\n            if interval1Start <= interval2Start\
    \ && interval1End <= interval2End {\n                if interval1Start <= interval2Start\
    \ {\n                    if interval1End <= interval2End {\n                 \
    \       if interval2Start <= interval2End {\n                            if interval1Start\
    \ <= interval2Start {\n                                if interval1End <= interval2End\
    \ {\n                                    if interval2Start <= interval2End {\n\
    \                                        return \"YES\"\n                    \
    \                }\n                                }\n                      \
    \      }\n                        }\n                    }\n                }\n\
    \                if interval1End <= interval2End {\n                    if interval1Start\
    \ \nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpscy0rzrn_test.go:103:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075554
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) < len(interval2) {\n        interval1, interval2\
    \ = interval2, interval1\n    }\n    \n    var result string\n    \n    for i\
    \ := 0; i < len(interval1); i++ {\n        if interval1[i] > interval2[i] {\n\
    \            break\n        }\n    }\n    \n    for i := 0; i < len(interval1);\
    \ i++ {\n        if interval1[i] < interval2[i] {\n            break\n       \
    \ }\n    }\n    \n    if i == len(interval1) {\n        result = \"NO\"\n    }\
    \ else if i == len(interval2) {\n        result = \"NO\"\n    } else {\n     \
    \   result = \"YES\"\n    }\n    \n    return result\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9yc24cg1_test.go:35:12: invalid operation: interval1[i] > interval2[i]
    (operator > not defined on interface)

    /tmp/tmp9yc24cg1_test.go:41:12: invalid operation: interval1[i] < interval2[i]
    (operator < not defined on interface)

    /tmp/tmp9yc24cg1_test.go:46:8: undefined: i

    /tmp/tmp9yc24cg1_test.go:48:15: undefined: i

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075554
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    intersectionStart := interval1Start\n \
    \   intersectionEnd := interval1End\n    \n    for i := 1; i < len(interval1);\
    \ i++ {\n        interval1Start := interval1[i].(float64)\n        interval1End\
    \ := interval1[i+1].(float64)\n        \n        if interval1Start > interval1End\
    \ {\n            intersectionStart = interval1Start\n            intersectionEnd\
    \ = interval1End\n            continue\n        }\n        \n        if interval2Start\
    \ > interval2End {\n            intersectionStart = interval2Start\n         \
    \   intersectionEnd = interval2End\n            continue\n        }\n        \n\
    \        if interval1Start <= interval2Start && interval1End >= interval2End {\n\
    \            intersectionStart = interval1Start\n            intersectionEnd =\
    \ interval1End\n            continue\n        }\n        \n        if interval1Start\
    \ <= interval2End && interval1End >= interval2Start {\n            intersectionStart\
    \ = interval1Start\n            intersectionEnd = interval1End\n            continue\n\
    \        }\n        \n        if interval1Start <= interval2Start && interval1End\
    \ <= interval2End {\n            intersectionStart = interval1Start\n        \
    \    intersectionEnd = interval1End\n            continue\n        }\n       \
    \ \n        if interval1Start >= interval2Start && interval1End >= interval2End\
    \ {\n            intersectionStart = interval1Start\n            intersectionEnd\
    \ = interval1End\n            continue\n        }\n        \n        if interval1Start\
    \ >= interval2Start && interval1End <= interval2End {\n            intersectionStart\
    \ = interval1Start\n            intersectionEnd = interval1End\n            continue\n\
    \        }\n        \n        if interval1Start <= interval2Start && interval1End\
    \ >= interval2Start {\n            intersectionStart = interval1Start\n      \
    \      intersectionEnd = interval1End\n            continue\n        }\n     \
    \   \n        if interval1Start >= interval2Start && interval1End <= interval2End\
    \ {\n            intersectionStart = interval1Start\n            intersectionEnd\
    \ = interval1End\n            continue\n        }\n        \n        if interval1Start\
    \ <= interval2Start && interval1End >= interval2Start {\n            intersectionStart\
    \ = interval1Start\n            intersectionEnd = interval1End\n            continue\n\
    \        }\n        \n        if interval1Start >= interval2Start && interval1End\
    \ <= interval2End {\n            intersectionStart = interval1Start\n        \
    \    intersectionEnd = interval1End\nfunc TestIntersection(t *testing.T) {\n \
    \ candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpbevomfsu_test.go:107:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075554
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpfypebohj_test.go:285:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075396
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(int)\n    interval1End := interval1[1].(int)\n\
    \    interval2Start := interval2[0].(int)\n    interval2End := interval2[1].(int)\n\
    \    \n    if interval1Start > interval2End {\n        return \"NO\"\n    }\n\
    \    if interval1End < interval2Start {\n        return \"NO\"\n    }\n    \n\
    \    intersectionLength := interval1End - interval1Start\n    \n    if interval1Start\
    \ <= interval2Start && interval1End >= interval2End {\n        return \"YES\"\n\
    \    }\n    if interval1Start <= interval2Start && interval1End <= interval2End\
    \ {\n        return \"NO\"\n    }\n    if interval1Start >= interval2Start &&\
    \ interval1End >= interval2End {\n        return \"NO\"\n    }\n    if interval1Start\
    \ >= interval2Start && interval1End <= interval2End {\n        return \"YES\"\n\
    \    }\n    if interval1Start <= interval2Start && interval1End >= interval2End\
    \ {\n        return \"YES\"\n    }\n    if interval1Start <= interval2Start &&\
    \ interval1End <= interval2End {\n        return \"NO\"\n    }\n    if interval1Start\
    \ >= interval2Start && interval1End >= interval2End {\n        return \"YES\"\n\
    \    }\n    if interval1Start >= interval2Start && interval1End <= interval2End\
    \ {\n        return \"NO\"\n    }\n    if interval1Start >= interval2Start &&\
    \ interval1End >= interval2End {\n        return \"NO\"\n    }\n    if interval1Start\
    \ <= interval2Start && interval1End <= interval2End {\n        return \"YES\"\n\
    \    }\n    if interval1Start <= interval2Start && interval1End >= interval2End\
    \ {\n        return \"NO\"\n    }\n    if interval1Start >= interval2Start &&\
    \ interval1End <= interval2End {\n        return \"NO\"\n    }\n    if interval1Start\
    \ >= interval2Start && interval1End >= interval2End {\n        return \"YES\"\n\
    \    }\n    if interval1Start <= interval2Start && interval1End <= interval2End\
    \ {\n        return \"YES\"\n    }\n    if interval1Start <= interval2Start &&\
    \ interval1End >= interval2End {\n        return \"NO\"\n    }\n    if interval1Start\
    \ >= interval2Start && interval1End <= interval2End {\n        return \"YES\"\n\
    \    }\n    if interval1Start >= interval2Start && interval1End >= interval2End\
    \ {\n        return \"NO\"\nfunc TestIntersection(t *testing.T) {\n  candidate\
    \ := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpfbjnukh8_test.go:96:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075554
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    \n    if interval1Start > interval2End\
    \ {\n        return \"NO\"\n    }\n    if interval1End < interval2Start {\n  \
    \      return \"NO\"\n    }\n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n\nfunc TestIntersection(t *testing.T) {\n  candidate\
    \ := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpd6v3ef9__test.go:253:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075554
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(int)\n    interval1End := interval1[1].(int)\n\
    \    interval2Start := interval2[0].(int)\n    interval2End := interval2[1].(int)\n\
    \    \n    if interval1Start > interval1End {\n        return \"NO\"\n    }\n\
    \    if interval2Start > interval2End {\n        return \"NO\"\n    }\n    \n\
    \    if interval1Start <= interval2Start && interval1End >= interval2End {\n \
    \       return \"YES\"\n    }\n    if interval1Start <= interval2End && interval1End\
    \ >= interval2Start {\n        return \"YES\"\n    }\n    \n    if interval1Start\
    \ <= interval2Start && interval1End <= interval2End {\n        return \"NO\"\n\
    \    }\n    if interval1Start >= interval2Start && interval1End >= interval2End\
    \ {\n        return \"NO\"\n    }\n    \n    if interval1Start <= interval2Start\
    \ && interval1End >= interval2End {\n        return \"NO\"\n    }\n    if interval1Start\
    \ >= interval2Start && interval1End <= interval2End {\n        return \"NO\"\n\
    \    }\n    \n    if interval1Start <= interval2Start && interval1End <= interval2End\
    \ {\n        return \"NO\"\n    }\n    if interval1Start >= interval2Start &&\
    \ interval1End >= interval2End {\n        return \"NO\"\n    }\n    \n    if interval1Start\
    \ <= interval2Start && interval1End <= interval2End {\n        return \"NO\"\n\
    \    }\n    if interval1Start >= interval2Start && interval1End >= interval2End\
    \ {\n        return \"NO\"\n    }\n    \n    if interval1Start <= interval2Start\
    \ && interval1End <= interval2End {\n        return \"NO\"\n    }\n    if interval1Start\
    \ >= interval2Start && interval1End >= interval2End {\n        return \"NO\"\n\
    \    }\n    \n    if interval1Start <= interval2Start && interval1End <= interval2End\
    \ {\n        return \"NO\"\n    }\n    if interval1Start >= interval2Start &&\
    \ interval1End >= interval2End {\n        return \"NO\"\n    }\n    \n    if interval1Start\
    \ <= interval2Start && interval1End <= interval2End {\n        return \"NO\"\n\
    \    }\n    if interval1Start >= interval2Start && interval1End >= interval2End\
    \ {\n        return \"NO\"\n    }\n    \n    if interval1Start <= interval2Start\
    \ && interval1End <= interval2End {\n        return \"NO\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpzqi5jwrx_test.go:101:16: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075554
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) < len(interval2) {\n        return intersection(interval2,\
    \ interval1)\n    }\n    \n    interval1Start := interval1[0]\n    interval1End\
    \ := interval1[1]\n    interval2Start := interval2[0]\n    interval2End := interval2[1]\n\
    \    \n    if interval1Start > interval2End {\n        return intersection(interval2,\
    \ interval1)\n    }\n    \n    if interval1End < interval2Start {\n        return\
    \ intersection(interval1, interval2)\n    }\n    \n    interval1Length := interval1End\
    \ - interval1Start\n    interval2Length := interval2End - interval2Start\n   \
    \ \n    if interval1Length == 0 || interval2Length == 0 {\n        return \"NO\"\
    \n    }\n    \n    if interval1Length == interval2Length {\n        if interval1Start\
    \ <= interval2Start {\n            return \"NO\"\n        }\n        return \"\
    YES\"\n    }\n    \n    if interval1Length > interval2Length {\n        return\
    \ intersection(interval1, interval2)\n    }\n    \n    if interval1Start <= interval2Start\
    \ {\n        if interval1Length == 1 {\n            return \"YES\"\n        }\n\
    \        return \"NO\"\n    }\n    \n    if interval1Start <= interval2End {\n\
    \        if interval1Length == 1 {\n            return \"NO\"\n        }\n   \
    \     return \"YES\"\n    }\n    \n    if interval1End <= interval2Start {\n \
    \       if interval1Length == 1 {\n            return \"NO\"\n        }\n    \
    \    return \"YES\"\n    }\n    \n    if interval1End <= interval2End {\n    \
    \    if interval1Length == 1 {\n            return \"YES\"\n        }\n      \
    \  return \"NO\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpl6k3aat3_test.go:37:8: invalid operation: interval1Start > interval2End
    (operator > not defined on interface)

    /tmp/tmpl6k3aat3_test.go:41:8: invalid operation: interval1End < interval2Start
    (operator < not defined on interface)

    /tmp/tmpl6k3aat3_test.go:45:24: invalid operation: operator - not defined on interval1End
    (variable of type interface{})

    /tmp/tmpl6k3aat3_test.go:46:24: invalid operation: operator - not defined on interval2End
    (variable of type interface{})

    /tmp/tmpl6k3aat3_test.go:53:12: invalid operation: interval1Start <= interval2Start
    (operator <= not defined on interface)

    /tmp/tmpl6k3aat3_test.go:63:8: invalid operation: interval1Start <= interval2Start
    (operator <= not defined on interface)

    /tmp/tmpl6k3aat3_test.go:70:8: invalid operation: interval1Start <= interval2End
    (operator <= not defined on interface)

    /tmp/tmpl6k3aat3_test.go:77:8: invalid operation: interval1End <= interval2Start
    (operator <= not defined on interface)

    /tmp/tmpl6k3aat3_test.go:84:8: invalid operation: interval1End <= interval2End
    (operator <= not defined on interface)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075554
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    if interval1Start > interval2End {\n  \
    \      return \"NO\"\n    }\n    if interval1End < interval2Start {\n        return\
    \ \"NO\"\n    }\n    \n    intersectionStart := interval1Start\n    intersectionEnd\
    \ := interval1End\n    \n    for interval2Start < interval2End {\n        if interval2Start\
    \ < intersectionEnd {\n            intersectionEnd = interval2Start\n        }\n\
    \        \n        if interval2End < intersectionStart {\n            intersectionStart\
    \ = interval2End\n        }\n    }\n    \n    if intersectionStart <= intersectionEnd\
    \ {\n        return \"YES\"\n    }\n    return \"NO\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface\
    \ {} is int, not float64\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x503ea0,\
    \ 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503ea0, 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection({0xc0000f5cc0?, 0x2?, 0x2?},\
    \ {0xc0000f5ca0?, 0x2?, 0x2?})\n\t/tmp/tmp7is3fqqx_test.go:32 +0x1a8\ncommand-line-arguments_test.TestIntersection(0x0?)\n\
    \t/tmp/tmp7is3fqqx_test.go:70 +0xe7\ntesting.tRunner(0xc0001a0340, 0x528f48)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075555
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    if interval1Start > interval1End {\n  \
    \      interval1Start, interval1End = interval1End, interval1Start\n    }\n  \
    \  if interval2Start > interval2End {\n        interval2Start, interval2End =\
    \ interval2End, interval2Start\n    }\n    \n    if interval1Start < interval2Start\
    \ {\n        return \"NO\"\n    }\n    if interval1End > interval2End {\n    \
    \    return \"NO\"\n    }\n    \n    intersection := interval1Start + interval2End\
    \ - interval1End - interval2Start\n    if intersection <= 0 {\n        return\
    \ \"NO\"\n    }\n    if isPrime(intersection) {\n        return \"YES\"\n    }\n\
    \    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate :=\
    \ intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmps8q1ko_0_test.go:55:8: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075555
- exit_code: null
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(int)\n    interval1End := interval1[1].(int)\n\
    \    interval2Start := interval2[0].(int)\n    interval2End := interval2[1].(int)\n\
    \    \n    if interval1Start > interval1End {\n        return \"NO\"\n    }\n\
    \    if interval2Start > interval2End {\n        return \"NO\"\n    }\n    \n\
    \    intersectionStart := interval1Start\n    intersectionEnd := interval1End\n\
    \    \n    for intersectionStart <= interval2End {\n        if interval2Start\
    \ <= intersectionEnd {\n            intersectionEnd = intersectionEnd+1\n    \
    \    } else {\n            intersectionEnd = intersectionEnd+1\n            intersectionStart\
    \ = intersectionStart+1\n        }\n    }\n    \n    if intersectionStart <= interval2End\
    \ {\n        return \"YES\"\n    } else {\n        return \"NO\"\n    }\n}\n\n\
    func TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660075568
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    var result string\n    var interval1Start int\n    var interval1End\
    \ int\n    var interval2Start int\n    var interval2End int\n\n    if len(interval1)\
    \ != len(interval2) {\n        return \"NO\"\n    }\n\n    for i := 0; i < len(interval1);\
    \ i++ {\n        interval1Start = interval1[i].(float64)\n        interval1End\
    \ = interval1[i].(float64)\n        interval2Start = interval2[i].(float64)\n\
    \        interval2End = interval2[i].(float64)\n\n        if interval1Start <=\
    \ interval2Start && interval1End >= interval2End {\n            result += fmt.Sprintf(\"\
    %v-%v\", interval1Start, interval1End)\n        }\n    }\n\n    if result == \"\
    NO\" {\n        return \"NO\"\n    }\n\n    if result == \"YES\" {\n        return\
    \ \"YES\"\n    }\n\n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T)\
    \ {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpiq8pchz5_test.go:39:26: cannot use interval1[i].(float64) (comma, ok expression
    of type float64) as type int in assignment

    /tmp/tmpiq8pchz5_test.go:40:24: cannot use interval1[i].(float64) (comma, ok expression
    of type float64) as type int in assignment

    /tmp/tmpiq8pchz5_test.go:41:26: cannot use interval2[i].(float64) (comma, ok expression
    of type float64) as type int in assignment

    /tmp/tmpiq8pchz5_test.go:42:24: cannot use interval2[i].(float64) (comma, ok expression
    of type float64) as type int in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075555
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    if interval1Start > interval1End {\n  \
    \      interval1Start, interval1End = interval1End, interval1Start\n    }\n  \
    \  if interval2Start > interval2End {\n        interval2Start, interval2End =\
    \ interval2End, interval2Start\n    }\n    \n    if interval1Start <= interval2Start\
    \ && interval1End >= interval2End {\n        return \"NO\"\n    }\n    \n    if\
    \ interval1Start <= interval2End && interval1End >= interval2Start {\n       \
    \ return \"NO\"\n    }\n    \n    if interval1Start <= interval2Start && interval1End\
    \ <= interval2End {\n        return \"YES\"\n    }\n    \n    if interval1Start\
    \ >= interval2Start && interval1End >= interval2End {\n        return \"YES\"\n\
    \    }\n    \n    if interval1Start >= interval2Start && interval1End <= interval2End\
    \ {\n        return \"YES\"\n    }\n    \n    if interval1Start <= interval2Start\
    \ && interval1End <= interval2End {\n        return \"YES\"\n    }\n    \n   \
    \ return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface\
    \ {} is int, not float64\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x503ea0,\
    \ 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503ea0, 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection({0xc0000f5cc0?, 0x2?, 0x2?},\
    \ {0xc0000f5ca0?, 0x2?, 0x2?})\n\t/tmp/tmpp_0oyid2_test.go:32 +0x217\ncommand-line-arguments_test.TestIntersection(0x0?)\n\
    \t/tmp/tmpp_0oyid2_test.go:78 +0xe7\ntesting.tRunner(0xc0001924e0, 0x528f48)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075555
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    \n    // Your code here\n    \n    \n    return \"\"\n}\n\nfunc\
    \ TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmplwb4t2rf_test.go:55: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmplwb4t2rf_test.go:55: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmplwb4t2rf_test.go:55:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmplwb4t2rf_test.go:55: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmplwb4t2rf_test.go:55: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmplwb4t2rf_test.go:55: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmplwb4t2rf_test.go:55:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmplwb4t2rf_test.go:55: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075404
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    if interval1Start > interval1End {\n  \
    \      interval1Start, interval1End = interval1End, interval1Start\n    }\n  \
    \  if interval2Start > interval2End {\n        interval2Start, interval2End =\
    \ interval2End, interval2Start\n    }\n    \n    intersectionStart := interval1Start\n\
    \    intersectionEnd := interval1End\n    \n    for interval1End <= interval2End\
    \ {\n        if interval1End < intersectionEnd {\n            intersectionEnd\
    \ = interval1End\n        }\n        \n        if interval1Start < intersectionStart\
    \ {\n            intersectionStart = interval1Start\n        }\n    }\n    \n\
    \    if intersectionStart <= intersectionEnd {\n        if intersectionEnd < interval2End\
    \ {\n            intersectionEnd = interval2End\n        }\n        \n       \
    \ if intersectionStart < interval2Start {\n            intersectionStart = interval2Start\n\
    \        }\n    }\n    \n    if intersectionStart <= intersectionEnd {\n     \
    \   if intersectionEnd < interval2End {\n            intersectionEnd = interval2End\n\
    \        }\n        \n        if intersectionStart < interval2Start {\n      \
    \      intersectionStart = interval2Start\n        }\n    }\n    \n    if intersectionStart\
    \ <= intersectionEnd {\n        if intersectionEnd < interval2End {\n        \
    \    intersectionEnd = interval2End\n        }\n        \n        if intersectionStart\
    \ < interval2Start {\n            intersectionStart = interval2Start\n       \
    \ }\n    }\n    \n    if intersectionStart <= intersectionEnd {\n        if intersectionEnd\
    \ < interval2End {\n            intersectionEnd = interval2End\n        }\n  \
    \      \n        if intersectionStart < interval2Start {\n            intersectionStart\
    \ = interval2Start\n        }\n    }\n    \n    if intersectionStart <= intersectionEnd\
    \ {\n        if intersectionEnd < interval2End {\n            intersectionEnd\
    \ = interval2End\n        }\n        \n        if intersectionStart < interval2Start\
    \ {\n            intersectionStart = interval2Start\n        }\n    }\n    \n\
    \    if intersectionStart <= intersectionEnd {\n        if intersectionEnd < interval2End\
    \ {\n            intersectionEnd = interval2End\n        }\n        \n       \
    \ if intersectionStart < interval2Start {\n            intersectionStart = interval2Start\n\
    \        }\n    }\n    \n    if intersectionStart <= intersectionEnd {\n     \
    \   if intersectionEnd < interval2End {\n            intersectionEnd = interval2End\n\
    \nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp39zzym8g_test.go:121:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075554
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    var result string\n    \n    if len(interval1) != len(interval2)\
    \ {\n        return \"NO\"\n    }\n    \n    for i := 0; i < len(interval1); i++\
    \ {\n        if interval1[i].(float64) < interval2[i].(float64) {\n          \
    \  result = \"NO\"\n            break\n        }\n    }\n    \n    if result ==\
    \ \"NO\" {\n        return \"NO\"\n    }\n    \n    for i := 0; i < len(interval1);\
    \ i++ {\n        if interval1[i].(float64) > interval2[i].(float64) {\n      \
    \      result = \"NO\"\n            break\n        }\n    }\n    \n    if result\
    \ == \"NO\" {\n        return \"NO\"\n    }\n    \n    if result == \"YES\" {\n\
    \        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface\
    \ {} is int, not float64\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x503ea0,\
    \ 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503ea0, 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection({0xc0000f5cc0?, 0x2?, 0x2?},\
    \ {0xc0000f5ca0?, 0x2?, 0x2?})\n\t/tmp/tmplv0j_k_8_test.go:35 +0x1ca\ncommand-line-arguments_test.TestIntersection(0x0?)\n\
    \t/tmp/tmplv0j_k_8_test.go:70 +0xe7\ntesting.tRunner(0xc0001a01a0, 0x528f48)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075555
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    if interval1Start > interval2End {\n  \
    \      return \"NO\"\n    }\n    if interval1End < interval2Start {\n        return\
    \ \"NO\"\n    }\n    \n    intersectionStart := interval1Start\n    intersectionEnd\
    \ := interval1End\n    \n    for i := 1; i < len(interval1); i++ {\n        interval1Start\
    \ := interval1[i].(float64)\n        interval1End := interval1[i+1].(float64)\n\
    \        \n        if interval1Start > interval1End {\n            return \"NO\"\
    \n        }\n        if interval1End < interval1Start {\n            return \"\
    NO\"\n        }\n        \n        if intersectionStart > interval1End {\n   \
    \         return \"NO\"\n        }\n        if intersectionEnd < interval1Start\
    \ {\n            return \"NO\"\n        }\n        \n        intersectionStart\
    \ = intersectionEnd\n        intersectionEnd = interval1End\n    }\n    \n   \
    \ if intersectionStart > intersectionEnd {\n        return \"NO\"\n    }\n   \
    \ if intersectionEnd < intersectionStart {\n        return \"NO\"\n    }\n   \
    \ \n    if intersectionStart <= intersectionEnd {\n        intersectionStart +=\
    \ interval1Start\n        intersectionEnd += interval1End\n    }\n    \n    if\
    \ intersectionStart % 2 == 0 {\n        return \"YES\"\n    }\n    \n    if intersectionEnd\
    \ % 2 == 0 {\n        return \"YES\"\n    }\n    \n    if intersectionStart %\
    \ 3 == 0 {\n        return \"YES\"\n    }\n    \n    if intersectionEnd % 3 ==\
    \ 0 {\n        return \"YES\"\n    }\n    \n    if intersectionStart % 5 == 0\
    \ {\n        return \"YES\"\n    }\n    \n    if intersectionEnd % 5 == 0 {\n\
    \        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpuq5x4o85_test.go:81:8: invalid operation: operator % not defined on intersectionStart
    (variable of type float64)

    /tmp/tmpuq5x4o85_test.go:85:8: invalid operation: operator % not defined on intersectionEnd
    (variable of type float64)

    /tmp/tmpuq5x4o85_test.go:89:8: invalid operation: operator % not defined on intersectionStart
    (variable of type float64)

    /tmp/tmpuq5x4o85_test.go:93:8: invalid operation: operator % not defined on intersectionEnd
    (variable of type float64)

    /tmp/tmpuq5x4o85_test.go:97:8: invalid operation: operator % not defined on intersectionStart
    (variable of type float64)

    /tmp/tmpuq5x4o85_test.go:101:8: invalid operation: operator % not defined on intersectionEnd
    (variable of type float64)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075555
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    intersection := interval1Start <= interval2End\
    \ && interval2Start <= interval1End\n    \n    if intersection {\n        intersectionLength\
    \ := interval1End - interval1Start\n        \n        if isPrime(intersectionLength)\
    \ {\n            return \"YES\"\n        }\n    }\n    \n    return \"NO\"\n}\n\
    \nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4sco3gx9_test.go:42:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075548
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    if interval1Start > interval2End {\n  \
    \      return \"NO\"\n    }\n    if interval1End < interval2Start {\n        return\
    \ \"NO\"\n    }\n    \n    intersection := interval1Start + interval1End - interval2Start\
    \ - interval2End\n    \n    if intersection <= 0 {\n        return \"NO\"\n  \
    \  }\n    \n    if isPrime(intersection) {\n        return \"YES\"\n    }\n  \
    \  \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate\
    \ := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2wl81vbj_test.go:50:8: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075397
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    \n    // Your code here\n    \n    \n    \n    return \"\"\n}\n\
    \nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpruh8rfck_test.go:56: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmpruh8rfck_test.go:56: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmpruh8rfck_test.go:56:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmpruh8rfck_test.go:56: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmpruh8rfck_test.go:56: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmpruh8rfck_test.go:56: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmpruh8rfck_test.go:56:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmpruh8rfck_test.go:56: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075556
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpfypebohj_test.go:285:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075396
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpfypebohj_test.go:285:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075396
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    if interval1Start > interval1End {\n  \
    \      interval1Start, interval1End = interval1End, interval1Start\n    }\n  \
    \  if interval2Start > interval2End {\n        interval2Start, interval2End =\
    \ interval2End, interval2Start\n    }\n    \n    intersectionStart := interval1Start\n\
    \    intersectionEnd := interval1End\n    \n    for interval1End <= interval2End\
    \ {\n        if interval1End < intersectionStart {\n            intersectionStart\
    \ = interval1End\n        }\n        if interval1End > intersectionEnd {\n   \
    \         intersectionEnd = interval1End\n        }\n    }\n    \n    if intersectionStart\
    \ <= intersectionEnd {\n        intersectionLength := intersectionEnd - intersectionStart\n\
    \        if isPrime(intersectionLength) {\n            return \"YES\"\n      \
    \  }\n    }\n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n \
    \ candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp827u_kc1_test.go:58:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075555
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    if interval1Start > interval2End {\n  \
    \      return \"NO\"\n    }\n    if interval1End < interval2Start {\n        return\
    \ \"NO\"\n    }\n    \n    intersectionStart := interval1Start\n    intersectionEnd\
    \ := interval1End\n    \n    for i := 1; i < len(interval1); i++ {\n        interval1Start\
    \ := interval1[i].(float64)\n        interval1End := interval1[i+1].(float64)\n\
    \        \n        if interval1Start > interval2End {\n            return \"NO\"\
    \n        }\n        if interval1End < interval2Start {\n            return \"\
    NO\"\n        }\n        \n        if interval1Start <= intersectionEnd && interval1End\
    \ >= intersectionStart {\n            intersectionStart = interval1Start\n   \
    \         intersectionEnd = interval1End\n        }\n    }\n    \n    if intersectionStart\
    \ <= intersectionEnd && intersectionEnd <= interval2End {\n        return \"YES\"\
    \n    }\n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate\
    \ := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface\
    \ {} is int, not float64\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x503ea0,\
    \ 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503ea0, 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection({0xc0000f5cc0?, 0x2?, 0x2?},\
    \ {0xc0000f5ca0?, 0x2?, 0x2?})\n\t/tmp/tmpaonoikge_test.go:32 +0x25a\ncommand-line-arguments_test.TestIntersection(0x0?)\n\
    \t/tmp/tmpaonoikge_test.go:77 +0xe7\ntesting.tRunner(0xc0001a0340, 0x528f48)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075556
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    if interval1Start > interval2End {\n  \
    \      return \"NO\"\n    }\n    if interval1End < interval2Start {\n        return\
    \ \"NO\"\n    }\n    \n    intersection := interval1Start + interval1End - interval2Start\
    \ - interval2End\n    if intersection <= 0 {\n        return \"NO\"\n    }\n \
    \   \n    if isPrime(intersection) {\n        return \"YES\"\n    }\n    return\
    \ \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpf6mk4jeo_test.go:49:8: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075398
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpfypebohj_test.go:285:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075396
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpfypebohj_test.go:285:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075396
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    interval1Start, interval1End := interval1[0], interval1[1]\n \
    \   interval2Start, interval2End := interval2[0], interval2[1]\n    if interval1Start\
    \ > interval2End {\n        return fmt.Sprintf(\"NO\")\n    }\n    if interval2Start\
    \ > interval1End {\n        return fmt.Sprintf(\"NO\")\n    }\n    if interval1Start\
    \ < interval2Start {\n        return fmt.Sprintf(\"NO\")\n    }\n    if interval1End\
    \ < interval2End {\n        return fmt.Sprintf(\"NO\")\n    }\n    if interval1Start\
    \ <= interval2Start && interval1End >= interval2End {\n        return fmt.Sprintf(\"\
    YES\")\n    }\n    if interval1Start <= interval2End && interval1End >= interval2Start\
    \ {\n        return fmt.Sprintf(\"YES\")\n    }\n    if interval1Start >= interval2Start\
    \ && interval1End <= interval2End {\n        return fmt.Sprintf(\"YES\")\n   \
    \ }\n    if interval1Start >= interval2End && interval1End <= interval2Start {\n\
    \        return fmt.Sprintf(\"YES\")\n    }\n    if interval1Start <= interval2Start\
    \ && interval1End >= interval2End {\n        return fmt.Sprintf(\"YES\")\n   \
    \ }\n    if interval1Start >= interval2Start && interval1End <= interval2End {\n\
    \        return fmt.Sprintf(\"YES\")\n    }\n    if interval1Start <= interval2Start\
    \ && interval1End >= interval2End {\n        return fmt.Sprintf(\"YES\")\n   \
    \ }\n    if interval1Start >= interval2Start && interval1End <= interval2End {\n\
    \        return fmt.Sprintf(\"YES\")\n    }\n    if interval1Start <= interval2Start\
    \ && interval1End >= interval2End {\n        return fmt.Sprintf(\"YES\")\n   \
    \ }\n    if interval1Start >= interval2Start && interval1End <= interval2End {\n\
    \        return fmt.Sprintf(\"YES\")\n    }\n    if interval1Start <= interval2Start\
    \ && interval1End >= interval2End {\n        return fmt.Sprintf(\"YES\")\n   \
    \ }\n    if interval1Start >= interval2Start && interval1End <= interval2End {\n\
    \        return fmt.Sprintf(\"YES\")\n    }\n    if interval1Start <= interval2Start\
    \ && interval1End >= interval2End {\n        return fmt.Sprintf(\"YES\")\n   \
    \ }\n    if interval1Start >= interval2Start && interval1End <= interval2End {\n\
    \        return fmt.Sprintf(\"YES\")\n    }\n    if interval1Start <= interval2Start\
    \ && interval1End >= interval2End {\n        return fmt.Sprintf(\"YES\")\n   \
    \ }\n    if \nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpf8xyza9t_test.go:88:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075555
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1 := make([]int, len(interval1))\n    interval2 := make([]int,\
    \ len(interval2))\n    \n    for i := 0; i < len(interval1); i++ {\n        interval1[i]\
    \ = int(interval1[i])\n    }\n    for i := 0; i < len(interval2); i++ {\n    \
    \    interval2[i] = int(interval2[i])\n    }\n    \n    result := make([]int,\
    \ len(interval1))\n    \n    for i := 0; i < len(interval1); i++ {\n        if\
    \ interval1[i] > interval2[i] {\n            result[i] = interval1[i] - interval2[i]\n\
    \        } else {\n            result[i] = interval2[i] - interval1[i]\n     \
    \   }\n    }\n    \n    for i := 0; i < len(result); i++ {\n        if result[i]\
    \ == 0 {\n            return \"NO\"\n        }\n    }\n    \n    if isPrime(result.Len())\
    \ {\n        return \"YES\"\n    }\n    return \"NO\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpzruwi2ar_test.go:32:15:\
    \ no new variables on left side of :=\n/tmp/tmpzruwi2ar_test.go:32:18: cannot\
    \ use make([]int, len(interval1)) (value of type []int) as type []interface{}\
    \ in assignment\n/tmp/tmpzruwi2ar_test.go:33:15: no new variables on left side\
    \ of :=\n/tmp/tmpzruwi2ar_test.go:33:18: cannot use make([]int, len(interval2))\
    \ (value of type []int) as type []interface{} in assignment\n/tmp/tmpzruwi2ar_test.go:36:28:\
    \ cannot convert interval1[i] (variable of type interface{}) to type int:\n\t\
    need type assertion\n/tmp/tmpzruwi2ar_test.go:39:28: cannot convert interval2[i]\
    \ (variable of type interface{}) to type int:\n\tneed type assertion\n/tmp/tmpzruwi2ar_test.go:45:12:\
    \ invalid operation: interval1[i] > interval2[i] (operator > not defined on interface)\n\
    /tmp/tmpzruwi2ar_test.go:46:25: invalid operation: operator - not defined on interval1[i]\
    \ (variable of type interface{})\n/tmp/tmpzruwi2ar_test.go:48:25: invalid operation:\
    \ operator - not defined on interval2[i] (variable of type interface{})\n/tmp/tmpzruwi2ar_test.go:58:8:\
    \ undefined: isPrime\n/tmp/tmpzruwi2ar_test.go:58:8: too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075555
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(int)\n    interval1End := interval1[1].(int)\n\
    \    interval2Start := interval2[0].(int)\n    interval2End := interval2[1].(int)\n\
    \    \n    if interval1Start > interval2End {\n        return \"NO\"\n    }\n\
    \    if interval1End < interval2Start {\n        return \"NO\"\n    }\n    \n\
    \    interval1Length := interval1End - interval1Start + 1\n    interval2Length\
    \ := interval2End - interval2Start + 1\n    \n    if interval1Length == 0 || interval2Length\
    \ == 0 {\n        return \"NO\"\n    }\n    \n    if interval1Length == interval2Length\
    \ {\n        interval1Start += interval1Length\n        interval1End += interval1Length\n\
    \        interval2Start += interval2Length\n        interval2End += interval2Length\n\
    \    }\n    \n    if interval1Start > interval2End {\n        return \"NO\"\n\
    \    }\n    if interval1End < interval2Start {\n        return \"NO\"\n    }\n\
    \    \n    if interval1Start <= interval2Start && interval1End >= interval2End\
    \ {\n        return \"YES\"\n    }\n    \n    if interval1Start <= interval2End\
    \ && interval1End >= interval2Start {\n        return \"YES\"\n    }\n    \n \
    \   if interval1Start >= interval2Start && interval1End <= interval2End {\n  \
    \      return \"YES\"\n    }\n    \n    if interval1Start >= interval2End && interval1End\
    \ <= interval2Start {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n\
    }\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpzsychz2j_test.go:104: expected 'NO', got 'YES'\n    ---\
    \ FAIL: TestIntersection/test_num__1 (0.00s)\n        tmpzsychz2j_test.go:104:\
    \ expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n\
    \        tmpzsychz2j_test.go:104: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6\
    \ (0.00s)\n        tmpzsychz2j_test.go:104: expected 'NO', got 'YES'\n    ---\
    \ FAIL: TestIntersection/test_num__7 (0.00s)\n        tmpzsychz2j_test.go:104:\
    \ expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075556
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(int)\n    interval1End := interval1[1].(int)\n\
    \    interval2Start := interval2[0].(int)\n    interval2End := interval2[1].(int)\n\
    \    \n    if interval1Start > interval2End {\n        return \"NO\"\n    }\n\
    \    if interval1End < interval2Start {\n        return \"NO\"\n    }\n    \n\
    \    interval1Length := interval1End - interval1Start\n    interval2Length :=\
    \ interval2End - interval2Start\n    \n    if interval1Length == 0 || interval2Length\
    \ == 0 {\n        return \"NO\"\n    }\n    \n    if interval1Length == interval2Length\
    \ {\n        if interval1Start <= interval2Start {\n            return \"YES\"\
    \n        }\n        if interval1End >= interval2End {\n            return \"\
    YES\"\n        }\n    }\n    \n    if interval1Length > interval2Length {\n  \
    \      interval1Length -= interval2Length\n    }\n    \n    if interval1Length\
    \ == 0 {\n        return \"NO\"\n    }\n    \n    if interval2Length == 0 {\n\
    \        return \"NO\"\n    }\n    \n    if interval1Start <= interval2Start {\n\
    \        interval1Start += interval2Length\n        interval1End -= interval2Length\n\
    \    }\n    \n    if interval1End >= interval2End {\n        interval1End -= interval2Length\n\
    \        interval1Start += interval2Length\n    }\n    \n    if interval1Start\
    \ > interval2End {\n        return \"NO\"\n    }\n    if interval1End < interval2Start\
    \ {\n        return \"NO\"\n    }\n    \n    if interval1Start <= interval2Start\
    \ {\n        interval1Start += interval2Length\n        interval1End -= interval2Length\n\
    \    }\n    \n    if interval1End >= interval2End {\n        interval1End -= interval2Length\n\
    \        interval1Start += interval2Length\n    }\n    \n    if interval1Start\
    \ > interval2End {\n        return \"NO\"\n    }\n    if interval1End < interval2Start\
    \ {\n        return \"NO\"\n    }\n    \n    if interval1Start <= interval2Start\
    \ {\n        interval1Start += interval2Length\n        interval1End -= interval2Length\n\
    \    }\n    \n    if interval1End >= interval2End {\n        interval1End -= interval2Length\n\
    \        interval1Start += interval2Length\n    }\n    \n    if interval1Start\
    \ > interval2End {\n        return \"\nfunc TestIntersection(t *testing.T) {\n\
    \  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp4s5eb9kz_test.go:117:16: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075555
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    var result string\n    \n    if len(interval1) != len(interval2)\
    \ {\n        return \"NO\"\n    }\n    \n    for i := 0; i < len(interval1); i++\
    \ {\n        if interval1[i].(float64) < interval2[i].(float64) {\n          \
    \  result = \"NO\"\n            break\n        }\n    }\n    \n    if result ==\
    \ \"NO\" {\n        return \"NO\"\n    }\n    \n    for i := 0; i < len(interval1);\
    \ i++ {\n        if interval1[i].(float64) > interval2[i].(float64) {\n      \
    \      result = \"NO\"\n            break\n        }\n    }\n    \n    if result\
    \ == \"NO\" {\n        return \"NO\"\n    }\n    \n    if interval1[0].(float64)\
    \ <= interval2[0].(float64) {\n        result = \"YES\"\n    }\n    \n    return\
    \ result\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface\
    \ {} is int, not float64\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x503ea0,\
    \ 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503ea0, 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection({0xc0000f5cc0?, 0x2?, 0x2?},\
    \ {0xc0000f5ca0?, 0x2?, 0x2?})\n\t/tmp/tmpu3yvxktt_test.go:35 +0x205\ncommand-line-arguments_test.TestIntersection(0x0?)\n\
    \t/tmp/tmpu3yvxktt_test.go:70 +0xe7\ntesting.tRunner(0xc000192680, 0x528f48)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075553
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    var interval1Start, interval1End int\n    var interval2Start,\
    \ interval2End int\n    var interval1Length, interval2Length int\n\n    interval1Start\
    \ = interval1[0].(int)\n    interval1End = interval1[1].(int)\n    interval2Start\
    \ = interval2[0].(int)\n    interval2End = interval2[1].(int)\n\n    interval1Length\
    \ = interval1End - interval1Start\n    interval2Length = interval2End - interval2Start\n\
    \n    if interval1Length == 0 || interval2Length == 0 {\n        return \"NO\"\
    \n    }\n\n    if interval1Start <= interval2Start && interval1End >= interval2End\
    \ {\n        return \"YES\"\n    }\n\n    if interval1Start <= interval2End &&\
    \ interval1End >= interval2Start {\n        return \"NO\"\n    }\n\n    if interval1Start\
    \ <= interval2Start && interval1End <= interval2End {\n        if interval1Length\
    \ == interval2Length {\n            if interval1Start <= interval2Start {\n  \
    \              return \"YES\"\n            }\n            if interval1End >= interval2End\
    \ {\n                return \"NO\"\n            }\n        }\n    }\n\n    if\
    \ interval1Start <= interval2End {\n        return \"NO\"\n    }\n\n    return\
    \ \"YES\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2\
    \ (0.00s)\n        tmpj3lo0ydr_test.go:90: expected 'YES', got 'NO'\n    --- FAIL:\
    \ TestIntersection/test_num__3 (0.00s)\n        tmpj3lo0ydr_test.go:90: expected\
    \ 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n      \
    \  tmpj3lo0ydr_test.go:90: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075556
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    var result string\n    \n    if len(interval1) > len(interval2)\
    \ {\n        interval1, interval2 = interval2, interval1\n    }\n    \n    for\
    \ i := 0; i < len(interval1); i++ {\n        if interval1[i] < interval2[i] {\n\
    \            result += fmt.Sprintf(\"NO\")\n            break\n        }\n   \
    \ }\n    \n    if result == \"NO\" {\n        for i := 0; i < len(interval2);\
    \ i++ {\n            if interval1[i] < interval2[i] {\n                result\
    \ += fmt.Sprintf(\"NO\")\n                break\n            }\n        }\n  \
    \  }\n    \n    if result == \"NO\" {\n        result = \"NO\"\n    }\n    \n\
    \    return result\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate :=\
    \ intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_d86qons_test.go:35:12: invalid operation: interval1[i] < interval2[i]
    (operator < not defined on interface)

    /tmp/tmp_d86qons_test.go:43:16: invalid operation: interval1[i] < interval2[i]
    (operator < not defined on interface)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075555
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpfypebohj_test.go:285:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075396
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1 := interval1.([]interface{})\n    interval2 := interval2.([]interface{})\n\
    \    \n    result := make([]interface{}, len(interval1))\n    \n    for i, v :=\
    \ range interval1 {\n        if v > interval2[1] {\n            result[i] = v\n\
    \        } else {\n            result[i] = interval2[1]\n        }\n    }\n  \
    \  \n    result := result.([]interface{})\n    \n    if len(result) == 0 {\n \
    \       return \"NO\"\n    }\n    \n    result := result.([]interface{})\n   \
    \ \n    if len(result) == 1 {\n        return \"YES\"\n    }\n    \n    result\
    \ := result.([]interface{})\n    \n    if len(result) == 2 {\n        return \"\
    YES\"\n    }\n    \n    result := result.([]interface{})\n    \n    if len(result)\
    \ == 3 {\n        return \"YES\"\n    }\n    \n    result := result.([]interface{})\n\
    \    \n    if len(result) == 4 {\n        return \"YES\"\n    }\n    \n    result\
    \ := result.([]interface{})\n    \n    if len(result) == 5 {\n        return \"\
    YES\"\n    }\n    \n    result := result.([]interface{})\n    \n    if len(result)\
    \ == 6 {\n        return \"YES\"\n    }\n    \n    result := result.([]interface{})\n\
    \    \n    if len(result) == 7 {\n        return \"YES\"\n    }\n    \n    result\
    \ := result.([]interface{})\n    \n    if len(result) == 8 {\n        return \"\
    YES\"\n    }\n    \n    result := result.([]interface{})\n    \n    if len(result)\
    \ == 9 {\n        return \"YES\"\n    }\n    \n    result := result.([]interface{})\n\
    \    \n    if len(result) == 10 {\n        return \"YES\"\n    }\n    \n    result\
    \ := result.([]interface{})\n    \n    if len(result) == 11 {\n        return\
    \ \"YES\"\n    }\n    \n    result := result.([]interface{})\n    \n    if len(result)\
    \ == 12 {\n        return \"YES\"\n    }\n    \n    result := result.([]interface{})\n\
    \    \n    if len(result) == 13 {\n        return \"YES\"\n    }\n    \n    result\
    \ := result.([]interface{})\n    \n    if len(result) == 14 {\n        return\
    \ \"YES\"\n    }\n    \n    result := result.([]interface{})\n    \n    if len(result)\
    \ == 15 {\n        return \"YES\"\n    }\n    \n    result := result.([]interface{})\n\
    \    \n    if len(result) == 16 {\n        return \"YES\"\n    }\n    \n    result\
    \ := result.(\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpbo0ngmso_test.go:148:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075555
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start, interval1End := interval1[0], interval1[1]\n\
    \    interval2Start, interval2End := interval2[0], interval2[1]\n    \n    if\
    \ interval1Start > interval2End {\n        return \"NO\"\n    }\n    if interval1End\
    \ < interval2Start {\n        return \"NO\"\n    }\n    \n    intersectionLength\
    \ := interval1End - interval1Start\n    \n    if interval1Start <= interval2Start\
    \ && interval1End >= interval2End {\n        return \"YES\"\n    }\n    if interval1Start\
    \ <= interval2End && interval1End >= interval2Start {\n        return \"YES\"\n\
    \    }\n    if interval1Start >= interval2Start && interval1End <= interval2End\
    \ {\n        return \"YES\"\n    }\n    \n    if interval1Start <= interval2Start\
    \ {\n        return \"NO\"\n    }\n    if interval1Start >= interval2Start {\n\
    \        return \"NO\"\n    }\n    if interval1End <= interval2End {\n       \
    \ return \"NO\"\n    }\n    if interval1End >= interval2End {\n        return\
    \ \"NO\"\n    }\n    \n    if interval1Start <= interval2Start {\n        return\
    \ \"YES\"\n    }\n    if interval1Start >= interval2Start {\n        return \"\
    YES\"\n    }\n    if interval1End <= interval2End {\n        return \"YES\"\n\
    \    }\n    if interval1End >= interval2End {\n        return \"YES\"\n    }\n\
    \    \n    if interval1Start <= interval2Start {\n        return \"YES\"\n   \
    \ }\n    if interval1Start >= interval2Start {\n        return \"YES\"\n    }\n\
    \    if interval1End <= interval2End {\n        return \"YES\"\n    }\n    if\
    \ interval1End >= interval2End {\n        return \"YES\"\n    }\n    \n    if\
    \ interval1Start <= interval2Start {\n        return \"YES\"\n    }\n    if interval1Start\
    \ >= interval2Start {\n        return \"YES\"\n    }\n    if interval1End <= interval2End\
    \ {\n        return \"YES\"\n    }\n    if interval1End >= interval2End {\n  \
    \      return \"YES\"\n    }\n    \n    if interval1Start <= interval2Start {\n\
    \        return \"YES\"\n    }\n    if interval1Start >= interval2Start {\n  \
    \      return \"YES\"\n    }\n    if interval1End <= interval2End {\n        return\
    \ \"YES\"\n    }\n    if interval1End >= interval2End {\n        return \"YES\"\
    \n    }\n    \n    if interval1Start <= interval2Start {\n        return \"\n\
    func TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_7t0uv87_test.go:120:16: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075555
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    if interval1Start > interval2End {\n  \
    \      return \"NO\"\n    }\n    if interval1End < interval2Start {\n        return\
    \ \"NO\"\n    }\n    \n    intersectionStart := interval1Start\n    intersectionEnd\
    \ := interval1End\n    \n    for i := 1; i < len(interval1); i++ {\n        interval1Start\
    \ := interval1[i].(float64)\n        interval1End := interval1[i+1].(float64)\n\
    \        \n        if interval1Start > interval1End {\n            return \"NO\"\
    \n        }\n        if interval1End < interval1Start {\n            return \"\
    NO\"\n        }\n        \n        if intersectionStart > interval1Start {\n \
    \           intersectionStart = interval1Start\n        }\n        if intersectionEnd\
    \ < interval1End {\n            intersectionEnd = interval1End\n        }\n  \
    \  }\n    \n    if intersectionStart > intersectionEnd {\n        return \"NO\"\
    \n    }\n    \n    if intersectionEnd < interval2Start {\n        return \"NO\"\
    \n    }\n    \n    if intersectionEnd > interval2End {\n        return \"NO\"\n\
    \    }\n    \n    if intersectionStart <= intersectionEnd {\n        if interval1Start\
    \ <= interval2Start && interval1End >= interval2End {\n            return \"YES\"\
    \n        }\n        if interval1Start <= interval2End && interval1End >= interval2Start\
    \ {\n            return \"YES\"\n        }\n        if interval1Start >= interval2Start\
    \ && interval1End <= interval2End {\n            return \"YES\"\n        }\n \
    \       if interval1Start >= interval2End && interval1End <= interval2Start {\n\
    \            return \"YES\"\n        }\n    }\n    \n    return \"NO\"\n}\n\n\
    func TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface\
    \ {} is int, not float64\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x503ea0,\
    \ 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503ea0, 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection({0xc0000f5cc0?, 0x2?, 0x2?},\
    \ {0xc0000f5ca0?, 0x2?, 0x2?})\n\t/tmp/tmpps549v2e_test.go:32 +0x317\ncommand-line-arguments_test.TestIntersection(0x0?)\n\
    \t/tmp/tmpps549v2e_test.go:103 +0xe7\ntesting.tRunner(0xc000192680, 0x528f48)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075556
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    var result string\n    if len(interval1) > len(interval2) {\n\
    \        interval1, interval2 = interval2, interval1\n    }\n    for _, interval1Element\
    \ := range interval1 {\n        for _, interval2Element := range interval2 {\n\
    \            if interval1Element > interval2Element {\n                break\n\
    \            }\n        }\n        if interval1Element == interval2Element {\n\
    \            result = \"YES\"\n            break\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpm4rbzh0m_test.go:34:16: invalid operation: interval1Element > interval2Element
    (operator > not defined on interface)

    /tmp/tmpm4rbzh0m_test.go:38:32: undefined: interval2Element

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075556
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    if interval1Start > interval2End {\n  \
    \      return \"NO\"\n    }\n    if interval1End < interval2Start {\n        return\
    \ \"NO\"\n    }\n    \n    intersectionStart := interval1Start\n    intersectionEnd\
    \ := interval1End\n    \n    for i := 1; i < len(interval1); i++ {\n        interval1Start\
    \ := interval1[i].(float64)\n        interval1End := interval1[i+1].(float64)\n\
    \        \n        if interval1Start > interval1End {\n            return \"NO\"\
    \n        }\n        if interval1End < interval1Start {\n            return \"\
    NO\"\n        }\n        \n        if interval1Start > intersectionEnd {\n   \
    \         intersectionEnd = interval1End\n        }\n        if interval1End <\
    \ intersectionStart {\n            intersectionStart = interval1End\n        }\n\
    \    }\n    \n    if intersectionStart <= intersectionEnd && intersectionStart\
    \ < interval2End {\n        return \"YES\"\n    }\n    if intersectionStart <=\
    \ intersectionEnd && intersectionEnd < interval2Start {\n        return \"YES\"\
    \n    }\n    if intersectionStart > intersectionEnd {\n        return \"NO\"\n\
    \    }\n    if intersectionEnd > interval2Start {\n        return \"NO\"\n   \
    \ }\n    if intersectionEnd > interval2End {\n        return \"NO\"\n    }\n \
    \   return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate :=\
    \ intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface\
    \ {} is int, not float64\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x503ea0,\
    \ 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503ea0, 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection({0xc0000f5cc0?, 0x2?, 0x2?},\
    \ {0xc0000f5ca0?, 0x2?, 0x2?})\n\t/tmp/tmpl5k9dqzd_test.go:32 +0x2be\ncommand-line-arguments_test.TestIntersection(0x0?)\n\
    \t/tmp/tmpl5k9dqzd_test.go:91 +0xe7\ntesting.tRunner(0xc0001a0340, 0x528f48)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075556
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    var interval1Start, interval1End int\n    var interval2Start,\
    \ interval2End int\n    var intersectionLength int\n    var isPrime bool\n\n \
    \   if len(interval1) != len(interval2) {\n        return \"NO\"\n    }\n\n  \
    \  for i := 0; i < len(interval1); i++ {\n        interval1Start = interval1[i].(int)\n\
    \        interval1End = interval1Start + interval1[i].(int)\n        interval2Start\
    \ = interval2[i].(int)\n        interval2End = interval2Start + interval2[i].(int)\n\
    \n        if interval1Start <= interval2Start && interval1End >= interval2End\
    \ {\n            intersectionLength = interval1End - interval1Start\n        \
    \    if isPrime = checkIfPrime(intersectionLength) {\n                return \"\
    YES\"\n            }\n        }\n    }\n\n    return \"NO\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpyj1fi4r__test.go:45:16: expected boolean expression, found assignment
    (missing parentheses around composite literal?)

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075556
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    var interval1Start, interval1End int\n    var interval2Start,\
    \ interval2End int\n\n    interval1Start = interval1[0].(int)\n    interval1End\
    \ = interval1[1].(int)\n    interval2Start = interval2[0].(int)\n    interval2End\
    \ = interval2[1].(int)\n\n    if interval1Start <= interval2Start && interval1End\
    \ >= interval2End {\n        if interval1Start <= interval2End {\n           \
    \ if interval1End <= interval2Start {\n                return \"YES\"\n      \
    \      } else {\n                return \"NO\"\n            }\n        } else\
    \ {\n            return \"NO\"\n        }\n    } else {\n        return \"NO\"\
    \n    }\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2\
    \ (0.00s)\n        tmpyc6ewben_test.go:71: expected 'YES', got 'NO'\n    --- FAIL:\
    \ TestIntersection/test_num__3 (0.00s)\n        tmpyc6ewben_test.go:71: expected\
    \ 'YES', got 'NO'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075556
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    \n    // Write your code here\n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpbz11ina1_test.go:283:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075396
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpfypebohj_test.go:285:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075396
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    var interval1Start, interval1End int\n    var interval2Start,\
    \ interval2End int\n    \n    if len(interval1) != len(interval2) {\n        return\
    \ \"NO\"\n    }\n    \n    for i := 0; i < len(interval1); i++ {\n        interval1Start\
    \ = interval1[i].(int)\n        interval1End = interval1Start + interval1[i].(int)\n\
    \        \n        for j := 0; j < len(interval2); j++ {\n            interval2Start\
    \ = interval2[j].(int)\n            interval2End = interval2Start + interval2[j].(int)\n\
    \            \n            if interval1Start <= interval2Start && interval1End\
    \ >= interval2End {\n                return \"YES\"\n            }\n        }\n\
    \    }\n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate\
    \ := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp9q1wwsm3_test.go:71: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__2 (0.00s)\n        tmp9q1wwsm3_test.go:71: expected\
    \ 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n      \
    \  tmp9q1wwsm3_test.go:71: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__6\
    \ (0.00s)\n        tmp9q1wwsm3_test.go:71: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__7 (0.00s)\n        tmp9q1wwsm3_test.go:71: expected\
    \ 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075556
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1 := interval1.([]interface{})\n    interval2 := interval2.([]interface{})\n\
    \    \n    result := make([]interface{}, len(interval1))\n    \n    for i := 0;\
    \ i < len(interval1); i++ {\n        if interval1[i] > interval2[i] {\n      \
    \      result[i] = interval1[i]\n        } else {\n            result[i] = interval2[i]\n\
    \        }\n    }\n    \n    result := result.([]interface{})\n    \n    if len(result)\
    \ == 0 {\n        return \"NO\"\n    }\n    \n    result := result.([]interface{})\n\
    \    \n    if len(result) == 1 {\n        if result[0] == result[1] {\n      \
    \      return \"YES\"\n        }\n        return \"NO\"\n    }\n    \n    result\
    \ := result.([]interface{})\n    \n    if len(result) == 2 {\n        if result[0]\
    \ == result[1] {\n            return \"YES\"\n        }\n        return \"NO\"\
    \n    }\n    \n    result := result.([]interface{})\n    \n    if len(result)\
    \ == 3 {\n        if result[0] == result[1] && result[1] == result[2] {\n    \
    \        return \"YES\"\n        }\n        return \"NO\"\n    }\n    \n    result\
    \ := result.([]interface{})\n    \n    if len(result) == 4 {\n        if result[0]\
    \ == result[1] && result[1] == result[2] && result[2] == result[3] {\n       \
    \     return \"YES\"\n        }\n        return \"NO\"\n    }\n    \n    result\
    \ := result.([]interface{})\n    \n    if len(result) == 5 {\n        if result[0]\
    \ == result[1] && result[1] == result[2] && result[2] == result[3] && result[3]\
    \ == result[4] {\n            return \"YES\"\n        }\n        return \"NO\"\
    \n    }\n    \n    result := result.([]interface{})\n    \n    if len(result)\
    \ == 6 {\n        if result[0] == result[1] && result[1] == result[2] && result[2]\
    \ == result[3] && result[3] == result[4] && result[4] == result[5] {\n       \
    \     return \"YES\"\n        }\n        return \"NO\"\n    }\n    \n    result\
    \ := result.([]interface{})\n    \n    if len(result) == 7 {\n        if result[0]\
    \ == result[1] && result[1] == result[2] && result[2] == result[3] && result[3]\
    \ == result[4] && result[4] == result[5] && result[5] == result[6] {\n       \
    \     return \"YES\"\n        }\n        return \"NO\"\n    }\n    \n    result\
    \ := result.([]interface{})\n    \n    if len(result) == 8 {\n        if result[0]\
    \ == result[1] && result[1] == result[2] && result[2] == result[3] && result[3]\
    \ == result[4] && result[4] == result[5\nfunc TestIntersection(t *testing.T) {\n\
    \  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpmcneqkve_test.go:117:137: expected '']'', found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075556
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return\
    \ \"NO\"\n    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End\
    \ := interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n  \
    \  interval2End := interval2[1].(float64)\n    \n    if interval1Start > interval1End\
    \ {\n        interval1Start, interval1End = interval1End, interval1Start\n   \
    \ }\n    if interval2Start > interval2End {\n        interval2Start, interval2End\
    \ = interval2End, interval2Start\n    }\n    \n    interval1Length := interval1End\
    \ - interval1Start\n    interval2Length := interval2End - interval2Start\n   \
    \ \n    if interval1Length == 0 || interval2Length == 0 {\n        return \"NO\"\
    \n    }\n    \n    intersectionLength := interval1Length * interval2Length\n \
    \   \n    if intersectionLength == 0 {\n        return \"NO\"\n    }\n    \n \
    \   if interval1Length == interval2Length {\n        \n        if interval1Start\
    \ <= interval2Start && interval1End >= interval2End {\n            return \"YES\"\
    \n        }\n        \n        if interval1Start <= interval2End && interval1End\
    \ >= interval2Start {\n            return \"YES\"\n        }\n        \n     \
    \   if interval1Start >= interval2Start && interval1End <= interval2End {\n  \
    \          return \"YES\"\n        }\n        \n        if interval1Start >= interval2End\
    \ && interval1End <= interval2Start {\n            return \"YES\"\n        }\n\
    \        \n        return \"NO\"\n    }\n    \n    if interval1Length == 1 {\n\
    \        \n        if interval1Start <= interval2Start && interval1End >= interval2End\
    \ {\n            return \"YES\"\n        }\n        \n        if interval1Start\
    \ <= interval2End && interval1End >= interval2Start {\n            return \"YES\"\
    \n        }\n        \n        if interval1Start >= interval2Start && interval1End\
    \ <= interval2End {\n            return \"YES\"\n        }\n        \n       \
    \ if interval1Start >= interval2End && interval1End <= interval2Start {\n    \
    \        return \"YES\"\n        }\n        \n        return \"NO\"\n    }\n \
    \   \n    if interval2Length == 1 {\n        \n        if interval1Start <= interval2Start\
    \ && interval1End >= interval2End {\n            return \"YES\"\n        }\n \
    \       \n        if interval1Start <= interval2End && interval1End >= interval2Start\
    \ {\n            return \"YES\"\n        }\n        \n        if interval1Start\
    \ >= interval2\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmptj3d4ma7_test.go:110:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075556
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    if interval1Start > interval1End {\n  \
    \      interval1Start, interval1End = interval1End, interval1Start\n    }\n  \
    \  if interval2Start > interval2End {\n        interval2Start, interval2End =\
    \ interval2End, interval2Start\n    }\n    \n    if interval1Start > interval2End\
    \ {\n        return \"NO\"\n    }\n    if interval1End < interval2Start {\n  \
    \      return \"NO\"\n    }\n    \n    interval1Length := interval1End - interval1Start\n\
    \    interval2Length := interval2End - interval2Start\n    \n    if interval1Length\
    \ == 0 || interval2Length == 0 {\n        return \"NO\"\n    }\n    \n    if interval1Length\
    \ == interval2Length {\n        \n        if interval1Start <= interval2Start\
    \ {\n            return \"NO\"\n        }\n        if interval1End >= interval2End\
    \ {\n            return \"NO\"\n        }\n        \n        if interval1Start\
    \ <= interval2Start {\n            return \"NO\"\n        }\n        if interval1End\
    \ >= interval2End {\n            return \"NO\"\n        }\n        \n        if\
    \ interval1Start <= interval2Start {\n            return \"NO\"\n        }\n \
    \       if interval1End >= interval2End {\n            return \"NO\"\n       \
    \ }\n        \n        if interval1Start <= interval2Start {\n            return\
    \ \"NO\"\n        }\n        if interval1End >= interval2End {\n            return\
    \ \"NO\"\n        }\n        \n        if interval1Start <= interval2Start {\n\
    \            return \"NO\"\n        }\n        if interval1End >= interval2End\
    \ {\n            return \"NO\"\n        }\n        \n        if interval1Start\
    \ <= interval2Start {\n            return \"NO\"\n        }\n        if interval1End\
    \ >= interval2End {\n            return \"NO\"\n        }\n        \n        if\
    \ interval1Start <= interval2Start {\n            return \"NO\"\n        }\n \
    \       if interval1End >= interval2End {\n            return \"NO\"\n       \
    \ }\n        \n        if interval1Start <= interval2Start {\n            return\
    \ \"NO\"\n        }\n        if interval1End >= interval2End {\n            return\
    \ \"NO\"\n        }\n        \n        if interval1Start <= interval2Start {\n\
    \            return \"NO\"\n        }\n        if interval1End >= interval2End\
    \ {\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpjk3v5xo7_test.go:121:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075556
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start, interval1End := interval1[0], interval1[1]\n\
    \    interval2Start, interval2End := interval2[0], interval2[1]\n    \n    if\
    \ interval1Start > interval2End {\n        return \"NO\"\n    }\n    if interval1End\
    \ < interval2Start {\n        return \"NO\"\n    }\n    \n    interval1Length\
    \ := interval1End - interval1Start\n    interval2Length := interval2End - interval2Start\n\
    \    \n    if interval1Length == 0 || interval2Length == 0 {\n        return \"\
    NO\"\n    }\n    \n    if interval1Length == interval2Length {\n        return\
    \ fmt.Sprintf(\"YES\")\n    }\n    \n    if interval1Length < interval2Length\
    \ {\n        interval1Length += 1\n    }\n    \n    primeLength := interval1Length\n\
    \    \n    for i := 2; i <= primeLength; i++ {\n        if interval1Start % i\
    \ == 0 && interval2Start % i == 0 {\n            primeLength += 1\n        }\n\
    \    }\n    \n    if primeLength == interval1Length {\n        return fmt.Sprintf(\"\
    YES\")\n    }\n    \n    if primeLength > interval1Length {\n        primeLength\
    \ -= 1\n    }\n    \n    if interval1Start % primeLength == 0 && interval2Start\
    \ % primeLength == 0 {\n        return fmt.Sprintf(\"YES\")\n    }\n    \n   \
    \ if interval1Start % primeLength == 0 && interval2Start % primeLength != 0 {\n\
    \        return fmt.Sprintf(\"NO\")\n    }\n    \n    if interval1Start % primeLength\
    \ != 0 && interval2Start % primeLength == 0 {\n        return fmt.Sprintf(\"NO\"\
    )\n    }\n    \n    if interval1Start % primeLength != 0 && interval2Start % primeLength\
    \ != 0 {\n        return fmt.Sprintf(\"NO\")\n    }\n    \n    return \"NO\"\n\
    }\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmmnfrd7l_test.go:35:8: invalid operation: interval1Start > interval2End
    (operator > not defined on interface)

    /tmp/tmpmmnfrd7l_test.go:38:8: invalid operation: interval1End < interval2Start
    (operator < not defined on interface)

    /tmp/tmpmmnfrd7l_test.go:42:24: invalid operation: operator - not defined on interval1End
    (variable of type interface{})

    /tmp/tmpmmnfrd7l_test.go:43:24: invalid operation: operator - not defined on interval2End
    (variable of type interface{})

    /tmp/tmpmmnfrd7l_test.go:60:12: invalid operation: interval1Start % i (mismatched
    types interface{} and int)

    /tmp/tmpmmnfrd7l_test.go:60:39: invalid operation: interval2Start % i (mismatched
    types interface{} and int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075556
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    if interval1Start > interval2End {\n  \
    \      return \"NO\"\n    }\n    if interval1End < interval2Start {\n        return\
    \ \"NO\"\n    }\n    \n    intersectionStart := interval1Start\n    intersectionEnd\
    \ := interval1End\n    \n    for i := 1; i < len(interval1); i++ {\n        interval1Start\
    \ := interval1[i].(float64)\n        interval1End := interval1[i+1].(float64)\n\
    \        \n        if interval1Start > interval1End {\n            return \"NO\"\
    \n        }\n        if interval1End < interval1Start {\n            return \"\
    NO\"\n        }\n        \n        if interval1Start <= intersectionEnd && interval1End\
    \ >= intersectionStart {\n            intersectionStart = interval1Start\n   \
    \         intersectionEnd = interval1End\n        }\n    }\n    \n    if intersectionStart\
    \ <= intersectionEnd && intersectionEnd <= interval2End {\n        return \"YES\"\
    \n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n\
    \  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface\
    \ {} is int, not float64\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x503ea0,\
    \ 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503ea0, 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection({0xc0000f4cc0?, 0x2?, 0x2?},\
    \ {0xc0000f4ca0?, 0x2?, 0x2?})\n\t/tmp/tmps2fg8duv_test.go:32 +0x228\ncommand-line-arguments_test.TestIntersection(0x0?)\n\
    \t/tmp/tmps2fg8duv_test.go:78 +0xe7\ntesting.tRunner(0xc0001a0340, 0x528f48)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075405
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(int)\n    interval1End := interval1[1].(int)\n\
    \    interval2Start := interval2[0].(int)\n    interval2End := interval2[1].(int)\n\
    \    \n    if interval1Start > interval2End {\n        return \"NO\"\n    }\n\
    \    if interval1End < interval2Start {\n        return \"NO\"\n    }\n    \n\
    \    intersection := interval1Start <= interval2Start && interval1End >= interval2End\n\
    \    if intersection {\n        return \"YES\"\n    }\n    \n    return \"NO\"\
    \n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2\
    \ (0.00s)\n        tmp8l5w614j_test.go:72: expected 'YES', got 'NO'\n    --- FAIL:\
    \ TestIntersection/test_num__3 (0.00s)\n        tmp8l5w614j_test.go:72: expected\
    \ 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n      \
    \  tmp8l5w614j_test.go:72: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6\
    \ (0.00s)\n        tmp8l5w614j_test.go:72: expected 'NO', got 'YES'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075556
