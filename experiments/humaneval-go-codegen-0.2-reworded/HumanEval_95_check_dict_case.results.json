{
  "name": "HumanEval_95_check_dict_case",
  "language": "go_test.go",
  "prompt": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n",
  "tests": "func TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "results": [
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__6 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    if len(dict) == 0 {\n        return false\n    }\n    for k, v := range dict {\n        if k[0] >= 'A' && k[0] <= 'Z' {\n            return false\n        }\n        if k[0] >= 'a' && k[0] <= 'z' {\n            return true\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0oqrkbcn_test.go:26:12: v declared but not used\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__6 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__6 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    if len(dict) == 0 {\n        return false\n    }\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmp7o3vn_po_test.go:53: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmp7o3vn_po_test.go:53: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    if len(dict) == 0 {\n        return false\n    }\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmp7o3vn_po_test.go:53: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmp7o3vn_po_test.go:53: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    if len(dict) == 0 {\n        return false\n    }\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmp7o3vn_po_test.go:53: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmp7o3vn_po_test.go:53: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    if len(dict) == 0 {\n        return false\n    }\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmp7o3vn_po_test.go:53: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmp7o3vn_po_test.go:53: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    if len(dict) == 0 {\n        return false\n    }\n    for k, v := range dict {\n        if k[0] >= 'A' && k[0] <= 'Z' {\n            return false\n        }\n        if k[0] >= 'a' && k[0] <= 'z' {\n            return true\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0oqrkbcn_test.go:26:12: v declared but not used\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    if len(dict) == 0 {\n        return false\n    }\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmp7o3vn_po_test.go:53: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmp7o3vn_po_test.go:53: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__6 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    if len(dict) == 0 {\n        return false\n    }\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmp7o3vn_po_test.go:53: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmp7o3vn_po_test.go:53: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    if len(dict) == 0 {\n        return false\n    }\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmp7o3vn_po_test.go:53: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmp7o3vn_po_test.go:53: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    if len(dict) == 0 {\n        return false\n    }\n    for key, value := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n        if key[0] >= 'a' && key[0] <= 'z' {\n            continue\n        }\n        return false\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5mwdpykr_test.go:26:14: value declared but not used\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    if len(dict) == 0 {\n        return false\n    }\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmp7o3vn_po_test.go:53: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmp7o3vn_po_test.go:53: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__6 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    if len(dict) == 0 {\n        return false\n    }\n    for k, v := range dict {\n        if k[0] >= 'A' && k[0] <= 'Z' {\n            return false\n        }\n        if k[0] >= 'a' && k[0] <= 'z' {\n            continue\n        }\n        if v[0] >= 'A' && v[0] <= 'Z' {\n            return false\n        }\n        if v[0] >= 'a' && v[0] <= 'z' {\n            continue\n        }\n        return false\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmp8yhfyj70_test.go:63: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmp8yhfyj70_test.go:63: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    if len(dict) == 0 {\n        return false\n    }\n    for key, value := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n        if key[0] >= 'a' && key[0] <= 'z' {\n            continue\n        }\n        return false\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5mwdpykr_test.go:26:14: value declared but not used\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, value := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            if key != key.ToLower() {\n                return false\n            }\n        } else if key[0] >= 'a' && key[0] <= 'z' {\n            if key != key.ToUpper() {\n                return false\n            }\n        } else {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpwxyuo99e_test.go:25:26: key.ToLower undefined (type string has no field or method ToLower)\n/tmp/tmpwxyuo99e_test.go:29:26: key.ToUpper undefined (type string has no field or method ToUpper)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, value := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            if key != key.ToLower() {\n                return false\n            }\n        } else if key[0] >= 'a' && key[0] <= 'z' {\n            if key != key.ToUpper() {\n                return false\n            }\n        } else {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpwxyuo99e_test.go:25:26: key.ToLower undefined (type string has no field or method ToLower)\n/tmp/tmpwxyuo99e_test.go:29:26: key.ToUpper undefined (type string has no field or method ToUpper)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__6 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, value := range dict {\n        if key == \"\" {\n            return false\n        }\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            if key != key.ToLower() {\n                return false\n            }\n        } else if key[0] >= 'a' && key[0] <= 'z' {\n            if key != key.ToUpper() {\n                return false\n            }\n        } else {\n            return false\n        }\n        if value == \"\" {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpzix6sq1t_test.go:28:26: key.ToLower undefined (type string has no field or method ToLower)\n/tmp/tmpzix6sq1t_test.go:32:26: key.ToUpper undefined (type string has no field or method ToUpper)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    if len(dict) == 0 {\n        return false\n    }\n    for k, v := range dict {\n        if k[0] >= 'A' && k[0] <= 'Z' {\n            return false\n        }\n        if k[0] >= 'a' && k[0] <= 'z' {\n            return true\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0oqrkbcn_test.go:26:12: v declared but not used\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__6 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    if len(dict) == 0 {\n        return false\n    }\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmp7o3vn_po_test.go:53: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmp7o3vn_po_test.go:53: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    if len(dict) == 0 {\n        return false\n    }\n    for key, _ := range dict {\n        if key == key.ToLower() || key == key.ToUpper() {\n            continue\n        } else {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmph_yaxm1t_test.go:27:22: key.ToLower undefined (type string has no field or method ToLower)\n/tmp/tmph_yaxm1t_test.go:27:46: key.ToUpper undefined (type string has no field or method ToUpper)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        } else if key[0] >= 'a' && key[0] <= 'z' {\n            continue\n        } else {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmphf4hmykm_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__6 (0.00s)\n        tmphf4hmykm_test.go:54: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, value := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n        if key[0] >= 'a' && key[0] <= 'z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpevuubkg2_test.go:23:14: value declared but not used\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, value := range dict {\n        if key == \"\" {\n            return false\n        }\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            if key != key.ToLower() {\n                return false\n            }\n        } else if key[0] >= 'a' && key[0] <= 'z' {\n            if key != key.ToUpper() {\n                return false\n            }\n        } else {\n            return false\n        }\n        if value == \"\" {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpzix6sq1t_test.go:28:26: key.ToLower undefined (type string has no field or method ToLower)\n/tmp/tmpzix6sq1t_test.go:32:26: key.ToUpper undefined (type string has no field or method ToUpper)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, value := range dict {\n        if key == \"\" {\n            return false\n        }\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            if key != key.ToLower() {\n                return false\n            }\n        } else if key[0] >= 'a' && key[0] <= 'z' {\n            if key != key.ToUpper() {\n                return false\n            }\n        } else {\n            return false\n        }\n        if value == \"\" {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpzix6sq1t_test.go:28:26: key.ToLower undefined (type string has no field or method ToLower)\n/tmp/tmpzix6sq1t_test.go:32:26: key.ToUpper undefined (type string has no field or method ToUpper)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        } else if key[0] >= 'a' && key[0] <= 'z' {\n            continue\n        } else {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmphf4hmykm_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__6 (0.00s)\n        tmphf4hmykm_test.go:54: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    if len(dict) == 0 {\n        return false\n    }\n    for k, v := range dict {\n        if k[0] >= 'A' && k[0] <= 'Z' {\n            return false\n        }\n        if k[0] >= 'a' && k[0] <= 'z' {\n            continue\n        }\n        if v[0] >= 'A' && v[0] <= 'Z' {\n            return false\n        }\n        if v[0] >= 'a' && v[0] <= 'z' {\n            continue\n        }\n        return false\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmp8yhfyj70_test.go:63: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmp8yhfyj70_test.go:63: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    if len(dict) == 0 {\n        return false\n    }\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmp7o3vn_po_test.go:53: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmp7o3vn_po_test.go:53: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__6 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__6 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, value := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n        if key[0] >= 'a' && key[0] <= 'z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpevuubkg2_test.go:23:14: value declared but not used\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n        if key[0] >= 'a' && key[0] <= 'z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__0 (0.00s)\n        tmp8x3ozxb5_test.go:53: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmp8x3ozxb5_test.go:53: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__5 (0.00s)\n        tmp8x3ozxb5_test.go:53: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__6 (0.00s)\n        tmp8x3ozxb5_test.go:53: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.008s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    if len(dict) == 0 {\n        return false\n    }\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmp7o3vn_po_test.go:53: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmp7o3vn_po_test.go:53: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, value := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            if key != key.ToLower() {\n                return false\n            }\n        } else if key[0] >= 'a' && key[0] <= 'z' {\n            if key != key.ToUpper() {\n                return false\n            }\n        } else {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpwxyuo99e_test.go:25:26: key.ToLower undefined (type string has no field or method ToLower)\n/tmp/tmpwxyuo99e_test.go:29:26: key.ToUpper undefined (type string has no field or method ToUpper)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__6 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for k, v := range dict {\n        if k[0] >= 'A' && k[0] <= 'Z' {\n            return false\n        }\n        if k[0] >= 'a' && k[0] <= 'z' {\n            return false\n        }\n        if v[0] >= 'A' && v[0] <= 'Z' {\n            return false\n        }\n        if v[0] >= 'a' && v[0] <= 'z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__0 (0.00s)\n        tmpcfy9j9hq_test.go:59: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmpcfy9j9hq_test.go:59: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__5 (0.00s)\n        tmpcfy9j9hq_test.go:59: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__6 (0.00s)\n        tmpcfy9j9hq_test.go:59: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        } else if key[0] >= 'a' && key[0] <= 'z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__0 (0.00s)\n        tmpx3u92qjg_test.go:52: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmpx3u92qjg_test.go:52: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__5 (0.00s)\n        tmpx3u92qjg_test.go:52: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__6 (0.00s)\n        tmpx3u92qjg_test.go:52: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    if len(dict) == 0 {\n        return false\n    }\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmp7o3vn_po_test.go:53: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmp7o3vn_po_test.go:53: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    if len(dict) == 0 {\n        return false\n    }\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n        if key[0] >= 'a' && key[0] <= 'z' {\n            return true\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__1 (0.00s)\n        tmpwmuh3t9s_test.go:56: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmpwmuh3t9s_test.go:56: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmpwmuh3t9s_test.go:56: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    if len(dict) == 0 {\n        return false\n    }\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmp7o3vn_po_test.go:53: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmp7o3vn_po_test.go:53: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    if len(dict) == 0 {\n        return false\n    }\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmp7o3vn_po_test.go:53: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmp7o3vn_po_test.go:53: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    if len(dict) == 0 {\n        return false\n    }\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmp7o3vn_po_test.go:53: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmp7o3vn_po_test.go:53: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    if len(dict) == 0 {\n        return false\n    }\n    for key, value := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n        if key[0] >= 'a' && key[0] <= 'z' {\n            continue\n        }\n        return false\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5mwdpykr_test.go:26:14: value declared but not used\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    if len(dict) == 0 {\n        return false\n    }\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmp7o3vn_po_test.go:53: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmp7o3vn_po_test.go:53: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    if len(dict) == 0 {\n        return false\n    }\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmp7o3vn_po_test.go:53: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmp7o3vn_po_test.go:53: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    if len(dict) == 0 {\n        return false\n    }\n    for key, value := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n        if key[0] >= 'a' && key[0] <= 'z' {\n            continue\n        }\n        if value[0] >= 'A' && value[0] <= 'Z' {\n            return false\n        }\n        if value[0] >= 'a' && value[0] <= 'z' {\n            continue\n        }\n        return false\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmpcs3gwghg_test.go:63: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmpcs3gwghg_test.go:63: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, value := range dict {\n        if key == \"\" {\n            return false\n        }\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            if key != key.ToLower() {\n                return false\n            }\n        } else if key[0] >= 'a' && key[0] <= 'z' {\n            if key != key.ToUpper() {\n                return false\n            }\n        } else {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpg92ylt2y_test.go:28:26: key.ToLower undefined (type string has no field or method ToLower)\n/tmp/tmpg92ylt2y_test.go:32:26: key.ToUpper undefined (type string has no field or method ToUpper)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    if len(dict) == 0 {\n        return false\n    }\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmp7o3vn_po_test.go:53: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmp7o3vn_po_test.go:53: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        } else if key[0] >= 'a' && key[0] <= 'z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__0 (0.00s)\n        tmpx3u92qjg_test.go:52: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmpx3u92qjg_test.go:52: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__5 (0.00s)\n        tmpx3u92qjg_test.go:52: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__6 (0.00s)\n        tmpx3u92qjg_test.go:52: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    if len(dict) == 0 {\n        return false\n    }\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmp7o3vn_po_test.go:53: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmp7o3vn_po_test.go:53: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__6 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    if len(dict) == 0 {\n        return false\n    }\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmp7o3vn_po_test.go:53: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmp7o3vn_po_test.go:53: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, value := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        } else if key[0] >= 'a' && key[0] <= 'z' {\n            continue\n        } else {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp1o598o6w_test.go:23:14: value declared but not used\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__6 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, value := range dict {\n        if key == \"\" {\n            return false\n        }\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            if key != key.ToLower() {\n                return false\n            }\n        } else if key[0] >= 'a' && key[0] <= 'z' {\n            if key != key.ToUpper() {\n                return false\n            }\n        } else {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpg92ylt2y_test.go:28:26: key.ToLower undefined (type string has no field or method ToLower)\n/tmp/tmpg92ylt2y_test.go:32:26: key.ToUpper undefined (type string has no field or method ToUpper)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    if len(dict) == 0 {\n        return false\n    }\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmp7o3vn_po_test.go:53: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmp7o3vn_po_test.go:53: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__6 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__6 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    if len(dict) == 0 {\n        return false\n    }\n    for key, value := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n        if key[0] >= 'a' && key[0] <= 'z' {\n            continue\n        }\n        return false\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5mwdpykr_test.go:26:14: value declared but not used\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, value := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            if key != key.ToLower() {\n                return false\n            }\n        } else if key[0] >= 'a' && key[0] <= 'z' {\n            if key != key.ToUpper() {\n                return false\n            }\n        } else {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpwxyuo99e_test.go:25:26: key.ToLower undefined (type string has no field or method ToLower)\n/tmp/tmpwxyuo99e_test.go:29:26: key.ToUpper undefined (type string has no field or method ToUpper)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    if len(dict) == 0 {\n        return false\n    }\n    for key, value := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n        if key[0] >= 'a' && key[0] <= 'z' {\n            continue\n        }\n        return false\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5mwdpykr_test.go:26:14: value declared but not used\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, value := range dict {\n        if key == \"\" {\n            return false\n        }\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            if key != key.ToLower() {\n                return false\n            }\n        } else if key[0] >= 'a' && key[0] <= 'z' {\n            if key != key.ToUpper() {\n                return false\n            }\n        } else {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpg92ylt2y_test.go:28:26: key.ToLower undefined (type string has no field or method ToLower)\n/tmp/tmpg92ylt2y_test.go:32:26: key.ToUpper undefined (type string has no field or method ToUpper)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    if len(dict) == 0 {\n        return false\n    }\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmp7o3vn_po_test.go:53: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmp7o3vn_po_test.go:53: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, value := range dict {\n        if key == \"\" {\n            return false\n        }\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            if key != key.ToLower() {\n                return false\n            }\n        } else if key[0] >= 'a' && key[0] <= 'z' {\n            if key != key.ToUpper() {\n                return false\n            }\n        } else {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpg92ylt2y_test.go:28:26: key.ToLower undefined (type string has no field or method ToLower)\n/tmp/tmpg92ylt2y_test.go:32:26: key.ToUpper undefined (type string has no field or method ToUpper)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__6 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    if len(dict) == 0 {\n        return false\n    }\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmp7o3vn_po_test.go:53: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmp7o3vn_po_test.go:53: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__6 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, value := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n        if key[0] >= 'a' && key[0] <= 'z' {\n            continue\n        }\n        return false\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpimfl2oyz_test.go:23:14: value declared but not used\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    if len(dict) == 0 {\n        return false\n    }\n    for key, value := range dict {\n        if key == \"\" {\n            return false\n        }\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            if key != key.ToLower() {\n                return false\n            }\n        } else if key[0] >= 'a' && key[0] <= 'z' {\n            if key != key.ToUpper() {\n                return false\n            }\n        } else {\n            return false\n        }\n        if value == \"\" {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp1z4fwuy5_test.go:31:26: key.ToLower undefined (type string has no field or method ToLower)\n/tmp/tmp1z4fwuy5_test.go:35:26: key.ToUpper undefined (type string has no field or method ToUpper)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        } else if key[0] >= 'a' && key[0] <= 'z' {\n            continue\n        } else {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmphf4hmykm_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__6 (0.00s)\n        tmphf4hmykm_test.go:54: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    if len(dict) == 0 {\n        return false\n    }\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmp7o3vn_po_test.go:53: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmp7o3vn_po_test.go:53: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, value := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        } else if key[0] >= 'a' && key[0] <= 'z' {\n            continue\n        } else {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp1o598o6w_test.go:23:14: value declared but not used\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    if len(dict) == 0 {\n        return false\n    }\n    for k, v := range dict {\n        if k[0] >= 'A' && k[0] <= 'Z' {\n            return false\n        }\n        if k[0] >= 'a' && k[0] <= 'z' {\n            continue\n        }\n        if v[0] >= 'A' && v[0] <= 'Z' {\n            return false\n        }\n        if v[0] >= 'a' && v[0] <= 'z' {\n            continue\n        }\n        return false\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmp8yhfyj70_test.go:63: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmp8yhfyj70_test.go:63: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        } else if key[0] >= 'a' && key[0] <= 'z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__0 (0.00s)\n        tmpx3u92qjg_test.go:52: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmpx3u92qjg_test.go:52: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__5 (0.00s)\n        tmpx3u92qjg_test.go:52: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__6 (0.00s)\n        tmpx3u92qjg_test.go:52: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    if len(dict) == 0 {\n        return false\n    }\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n        if key[0] >= 'a' && key[0] <= 'z' {\n            return true\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__1 (0.00s)\n        tmpwmuh3t9s_test.go:56: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmpwmuh3t9s_test.go:56: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmpwmuh3t9s_test.go:56: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, value := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n        if key[0] >= 'a' && key[0] <= 'z' {\n            continue\n        }\n        return false\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpimfl2oyz_test.go:23:14: value declared but not used\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, value := range dict {\n        if key == \"\" {\n            return false\n        }\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            if key != key.ToLower() {\n                return false\n            }\n        } else if key[0] >= 'a' && key[0] <= 'z' {\n            if key != key.ToUpper() {\n                return false\n            }\n        } else {\n            return false\n        }\n        if value == \"\" {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpzix6sq1t_test.go:28:26: key.ToLower undefined (type string has no field or method ToLower)\n/tmp/tmpzix6sq1t_test.go:32:26: key.ToUpper undefined (type string has no field or method ToUpper)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__6 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    if len(dict) == 0 {\n        return false\n    }\n    for key, value := range dict {\n        if key == \"\" {\n            return false\n        }\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            if key != key.ToLower() {\n                return false\n            }\n        } else if key[0] >= 'a' && key[0] <= 'z' {\n            if key != key.ToUpper() {\n                return false\n            }\n        } else {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpt_fszihm_test.go:31:26: key.ToLower undefined (type string has no field or method ToLower)\n/tmp/tmpt_fszihm_test.go:35:26: key.ToUpper undefined (type string has no field or method ToUpper)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__6 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    if len(dict) == 0 {\n        return false\n    }\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmp7o3vn_po_test.go:53: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmp7o3vn_po_test.go:53: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__6 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, value := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            if key != key.ToLower() {\n                return false\n            }\n        } else if key[0] >= 'a' && key[0] <= 'z' {\n            if key != key.ToUpper() {\n                return false\n            }\n        } else {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpwxyuo99e_test.go:25:26: key.ToLower undefined (type string has no field or method ToLower)\n/tmp/tmpwxyuo99e_test.go:29:26: key.ToUpper undefined (type string has no field or method ToUpper)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, value := range dict {\n        if key == \"\" {\n            return false\n        }\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            if key != key.ToLower() {\n                return false\n            }\n        } else if key[0] >= 'a' && key[0] <= 'z' {\n            if key != key.ToUpper() {\n                return false\n            }\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpcazmooq2_test.go:28:26: key.ToLower undefined (type string has no field or method ToLower)\n/tmp/tmpcazmooq2_test.go:32:26: key.ToUpper undefined (type string has no field or method ToUpper)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__6 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__6 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__6 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__6 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__6 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, value := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n        if key[0] >= 'a' && key[0] <= 'z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpevuubkg2_test.go:23:14: value declared but not used\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, value := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n        if key[0] >= 'a' && key[0] <= 'z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpevuubkg2_test.go:23:14: value declared but not used\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    if len(dict) == 0 {\n        return false\n    }\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmp7o3vn_po_test.go:53: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmp7o3vn_po_test.go:53: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    if len(dict) == 0 {\n        return false\n    }\n    for k, v := range dict {\n        if k[0] >= 'A' && k[0] <= 'Z' {\n            return false\n        }\n        if k[0] >= 'a' && k[0] <= 'z' {\n            continue\n        }\n        if v[0] >= 'A' && v[0] <= 'Z' {\n            return false\n        }\n        if v[0] >= 'a' && v[0] <= 'z' {\n            continue\n        }\n        return false\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmp8yhfyj70_test.go:63: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmp8yhfyj70_test.go:63: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, value := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            if key != key.ToLower() {\n                return false\n            }\n        } else if key[0] >= 'a' && key[0] <= 'z' {\n            if key != key.ToUpper() {\n                return false\n            }\n        } else {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpwxyuo99e_test.go:25:26: key.ToLower undefined (type string has no field or method ToLower)\n/tmp/tmpwxyuo99e_test.go:29:26: key.ToUpper undefined (type string has no field or method ToUpper)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__6 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    if len(dict) == 0 {\n        return false\n    }\n    for key, value := range dict {\n        if key == \"\" {\n            return false\n        }\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            if key != key.ToLower() {\n                return false\n            }\n        } else if key[0] >= 'a' && key[0] <= 'z' {\n            if key != key.ToUpper() {\n                return false\n            }\n        } else {\n            return false\n        }\n        if value == \"\" {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp1z4fwuy5_test.go:31:26: key.ToLower undefined (type string has no field or method ToLower)\n/tmp/tmp1z4fwuy5_test.go:35:26: key.ToUpper undefined (type string has no field or method ToUpper)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    if len(dict) == 0 {\n        return false\n    }\n    for key, value := range dict {\n        if key == \"\" {\n            return false\n        }\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            if key != key.ToLower() {\n                return false\n            }\n        } else if key[0] >= 'a' && key[0] <= 'z' {\n            if key != key.ToUpper() {\n                return false\n            }\n        } else {\n            return false\n        }\n        if value == \"\" {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp1z4fwuy5_test.go:31:26: key.ToLower undefined (type string has no field or method ToLower)\n/tmp/tmp1z4fwuy5_test.go:35:26: key.ToUpper undefined (type string has no field or method ToUpper)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    if len(dict) == 0 {\n        return false\n    }\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmp7o3vn_po_test.go:53: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmp7o3vn_po_test.go:53: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for k, v := range dict {\n        if k[0] >= 'A' && k[0] <= 'Z' {\n            if v != k {\n                return false\n            }\n        } else if k[0] >= 'a' && k[0] <= 'z' {\n            if v != string(k[0] - 32) + k[1:] {\n                return false\n            }\n        } else {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__0 (0.00s)\n        tmp1g1q3cg2_test.go:58: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmp1g1q3cg2_test.go:58: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__5 (0.00s)\n        tmp1g1q3cg2_test.go:58: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__6 (0.00s)\n        tmp1g1q3cg2_test.go:58: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.008s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, value := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n        if key[0] >= 'a' && key[0] <= 'z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpevuubkg2_test.go:23:14: value declared but not used\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__6 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, value := range dict {\n        if key == \"\" {\n            return false\n        }\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            if key != key.ToLower() {\n                return false\n            }\n        } else if key[0] >= 'a' && key[0] <= 'z' {\n            if key != key.ToUpper() {\n                return false\n            }\n        } else {\n            return false\n        }\n        if value == \"\" {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpzix6sq1t_test.go:28:26: key.ToLower undefined (type string has no field or method ToLower)\n/tmp/tmpzix6sq1t_test.go:32:26: key.ToUpper undefined (type string has no field or method ToUpper)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__6 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n        if key[0] >= 'a' && key[0] <= 'z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__0 (0.00s)\n        tmp8x3ozxb5_test.go:53: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmp8x3ozxb5_test.go:53: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__5 (0.00s)\n        tmp8x3ozxb5_test.go:53: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__6 (0.00s)\n        tmp8x3ozxb5_test.go:53: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.008s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    if len(dict) == 0 {\n        return false\n    }\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmp7o3vn_po_test.go:53: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmp7o3vn_po_test.go:53: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, value := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n        if key[0] >= 'a' && key[0] <= 'z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpevuubkg2_test.go:23:14: value declared but not used\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__6 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        } else if key[0] >= 'a' && key[0] <= 'z' {\n            continue\n        } else {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmphf4hmykm_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__6 (0.00s)\n        tmphf4hmykm_test.go:54: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__6 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, value := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n        if key[0] >= 'a' && key[0] <= 'z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpevuubkg2_test.go:23:14: value declared but not used\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__6 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, value := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n        if key[0] >= 'a' && key[0] <= 'z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpevuubkg2_test.go:23:14: value declared but not used\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    if len(dict) == 0 {\n        return false\n    }\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmp7o3vn_po_test.go:53: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmp7o3vn_po_test.go:53: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        } else if key[0] >= 'a' && key[0] <= 'z' {\n            continue\n        } else {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmphf4hmykm_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__6 (0.00s)\n        tmphf4hmykm_test.go:54: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, value := range dict {\n        if key == \"\" {\n            return false\n        }\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            if key != key.ToLower() {\n                return false\n            }\n        } else if key[0] >= 'a' && key[0] <= 'z' {\n            if key != key.ToUpper() {\n                return false\n            }\n        } else {\n            return false\n        }\n        if value == \"\" {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpzix6sq1t_test.go:28:26: key.ToLower undefined (type string has no field or method ToLower)\n/tmp/tmpzix6sq1t_test.go:32:26: key.ToUpper undefined (type string has no field or method ToUpper)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__6 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    if len(dict) == 0 {\n        return false\n    }\n    for key, value := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n        if key[0] >= 'a' && key[0] <= 'z' {\n            continue\n        }\n        return false\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5mwdpykr_test.go:26:14: value declared but not used\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    if len(dict) == 0 {\n        return false\n    }\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmp7o3vn_po_test.go:53: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmp7o3vn_po_test.go:53: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, _ := range dict {\n        if key == key {\n            return true\n        }\n    }\n    return false\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__1 (0.00s)\n        tmp2czckcko_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmp2czckcko_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__3 (0.00s)\n        tmp2czckcko_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        } else if key[0] >= 'a' && key[0] <= 'z' {\n            continue\n        } else {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmphf4hmykm_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__6 (0.00s)\n        tmphf4hmykm_test.go:54: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    if len(dict) == 0 {\n        return false\n    }\n    for key, _ := range dict {\n        if key == key.ToLower() {\n            continue\n        }\n        if key == key.ToUpper() {\n            continue\n        }\n        return false\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpu5282scv_test.go:27:22: key.ToLower undefined (type string has no field or method ToLower)\n/tmp/tmpu5282scv_test.go:30:22: key.ToUpper undefined (type string has no field or method ToUpper)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    if len(dict) == 0 {\n        return false\n    }\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n        if key[0] >= 'a' && key[0] <= 'z' {\n            return true\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__1 (0.00s)\n        tmpwmuh3t9s_test.go:56: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmpwmuh3t9s_test.go:56: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmpwmuh3t9s_test.go:56: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    if len(dict) == 0 {\n        return false\n    }\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmp7o3vn_po_test.go:53: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmp7o3vn_po_test.go:53: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, value := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            if key != key.ToLower() {\n                return false\n            }\n        } else if key[0] >= 'a' && key[0] <= 'z' {\n            if key != key.ToUpper() {\n                return false\n            }\n        } else {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpwxyuo99e_test.go:25:26: key.ToLower undefined (type string has no field or method ToLower)\n/tmp/tmpwxyuo99e_test.go:29:26: key.ToUpper undefined (type string has no field or method ToUpper)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    if len(dict) == 0 {\n        return false\n    }\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmp7o3vn_po_test.go:53: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmp7o3vn_po_test.go:53: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    if len(dict) == 0 {\n        return false\n    }\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmp7o3vn_po_test.go:53: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmp7o3vn_po_test.go:53: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    if len(dict) == 0 {\n        return false\n    }\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmp7o3vn_po_test.go:53: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmp7o3vn_po_test.go:53: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__6 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    if len(dict) == 0 {\n        return false\n    }\n    for key, value := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n        if key[0] >= 'a' && key[0] <= 'z' {\n            continue\n        }\n        return false\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5mwdpykr_test.go:26:14: value declared but not used\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    if len(dict) == 0 {\n        return false\n    }\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmp7o3vn_po_test.go:53: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmp7o3vn_po_test.go:53: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, _ := range dict {\n        if key == key {\n            return true\n        }\n    }\n    return false\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__1 (0.00s)\n        tmp2czckcko_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmp2czckcko_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__3 (0.00s)\n        tmp2czckcko_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, value := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            if key != key.ToLower() {\n                return false\n            }\n        } else if key[0] >= 'a' && key[0] <= 'z' {\n            if key != key.ToUpper() {\n                return false\n            }\n        } else {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpwxyuo99e_test.go:25:26: key.ToLower undefined (type string has no field or method ToLower)\n/tmp/tmpwxyuo99e_test.go:29:26: key.ToUpper undefined (type string has no field or method ToUpper)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    if len(dict) == 0 {\n        return false\n    }\n    for key, value := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n        if key[0] >= 'a' && key[0] <= 'z' {\n            return true\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0aw03hch_test.go:26:14: value declared but not used\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, _ := range dict {\n        if key == \"\" {\n            return false\n        }\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmpi1wf7s6__test.go:53: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmpi1wf7s6__test.go:53: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__6 (0.00s)\n        tmpi1wf7s6__test.go:53: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__6 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__6 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__6 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, value := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            if key != key.ToLower() {\n                return false\n            }\n        } else if key[0] >= 'a' && key[0] <= 'z' {\n            if key != key.ToUpper() {\n                return false\n            }\n        } else {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpwxyuo99e_test.go:25:26: key.ToLower undefined (type string has no field or method ToLower)\n/tmp/tmpwxyuo99e_test.go:29:26: key.ToUpper undefined (type string has no field or method ToUpper)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, _ := range dict {\n        if key == key {\n            return true\n        }\n    }\n    return false\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__1 (0.00s)\n        tmp2czckcko_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmp2czckcko_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__3 (0.00s)\n        tmp2czckcko_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__6 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        } else if key[0] >= 'a' && key[0] <= 'z' {\n            continue\n        } else {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmphf4hmykm_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__6 (0.00s)\n        tmphf4hmykm_test.go:54: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__6 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    if len(dict) == 0 {\n        return false\n    }\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n        if key[0] >= 'a' && key[0] <= 'z' {\n            continue\n        }\n        return false\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmp8lxl4kkb_test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for k, v := range dict {\n        if k[0] >= 'A' && k[0] <= 'Z' {\n            if k != k.ToLower() {\n                return false\n            }\n        } else if k[0] >= 'a' && k[0] <= 'z' {\n            if k != k.ToUpper() {\n                return false\n            }\n        } else {\n            return false\n        }\n        if v != v.ToLower() {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjifioapa_test.go:25:22: k.ToLower undefined (type string has no field or method ToLower)\n/tmp/tmpjifioapa_test.go:29:22: k.ToUpper undefined (type string has no field or method ToUpper)\n/tmp/tmpjifioapa_test.go:35:18: v.ToLower undefined (type string has no field or method ToLower)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__6 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        } else if key[0] >= 'a' && key[0] <= 'z' {\n            continue\n        } else {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmphf4hmykm_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__6 (0.00s)\n        tmphf4hmykm_test.go:54: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    if len(dict) == 0 {\n        return false\n    }\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmp7o3vn_po_test.go:53: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmp7o3vn_po_test.go:53: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, value := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        } else if key[0] >= 'a' && key[0] <= 'z' {\n            continue\n        } else {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp1o598o6w_test.go:23:14: value declared but not used\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    if len(dict) == 0 {\n        return false\n    }\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmp7o3vn_po_test.go:53: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmp7o3vn_po_test.go:53: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__6 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    if len(dict) == 0 {\n        return false\n    }\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmp7o3vn_po_test.go:53: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmp7o3vn_po_test.go:53: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    if len(dict) == 0 {\n        return false\n    }\n    for key, value := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n        if key[0] >= 'a' && key[0] <= 'z' {\n            continue\n        }\n        return false\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5mwdpykr_test.go:26:14: value declared but not used\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    if len(dict) == 0 {\n        return false\n    }\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n        if key[0] >= 'a' && key[0] <= 'z' {\n            return true\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__1 (0.00s)\n        tmpwmuh3t9s_test.go:56: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmpwmuh3t9s_test.go:56: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmpwmuh3t9s_test.go:56: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, value := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n        if key[0] >= 'a' && key[0] <= 'z' {\n            continue\n        }\n        return false\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpimfl2oyz_test.go:23:14: value declared but not used\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__6 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__6 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    if len(dict) == 0 {\n        return false\n    }\n    for key, value := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n        if key[0] >= 'a' && key[0] <= 'z' {\n            continue\n        }\n        return false\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5mwdpykr_test.go:26:14: value declared but not used\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, value := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n        if key[0] >= 'a' && key[0] <= 'z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpevuubkg2_test.go:23:14: value declared but not used\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    if len(dict) == 0 {\n        return false\n    }\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmp7o3vn_po_test.go:53: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmp7o3vn_po_test.go:53: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__6 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, value := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n        if key[0] >= 'a' && key[0] <= 'z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpevuubkg2_test.go:23:14: value declared but not used\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, value := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n        if key[0] >= 'a' && key[0] <= 'z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpevuubkg2_test.go:23:14: value declared but not used\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__6 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, value := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n        if key[0] >= 'a' && key[0] <= 'z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpevuubkg2_test.go:23:14: value declared but not used\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for k, v := range dict {\n        if k[0] >= 'A' && k[0] <= 'Z' {\n            if k[0] != v[0] {\n                return false\n            }\n        } else if k[0] >= 'a' && k[0] <= 'z' {\n            if k[0] != v[0] {\n                return false\n            }\n        } else {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmpozslbcs5_test.go:58: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__5 (0.00s)\n        tmpozslbcs5_test.go:58: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__6 (0.00s)\n        tmpozslbcs5_test.go:58: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, value := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            if key != key.ToLower() {\n                return false\n            }\n        } else if key[0] >= 'a' && key[0] <= 'z' {\n            if key != key.ToUpper() {\n                return false\n            }\n        } else {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpwxyuo99e_test.go:25:26: key.ToLower undefined (type string has no field or method ToLower)\n/tmp/tmpwxyuo99e_test.go:29:26: key.ToUpper undefined (type string has no field or method ToUpper)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for k, v := range dict {\n        if k[0] >= 'A' && k[0] <= 'Z' {\n            return false\n        }\n        if k[0] >= 'a' && k[0] <= 'z' {\n            continue\n        }\n        if v[0] >= 'A' && v[0] <= 'Z' {\n            return false\n        }\n        if v[0] >= 'a' && v[0] <= 'z' {\n            continue\n        }\n        return false\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmp9mksjkfa_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmp9mksjkfa_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__6 (0.00s)\n        tmp9mksjkfa_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__6 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, _ := range dict {\n        if key == key {\n            return true\n        }\n    }\n    return false\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__1 (0.00s)\n        tmp2czckcko_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmp2czckcko_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__3 (0.00s)\n        tmp2czckcko_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n        if key[0] >= 'a' && key[0] <= 'z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__0 (0.00s)\n        tmp8x3ozxb5_test.go:53: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmp8x3ozxb5_test.go:53: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__5 (0.00s)\n        tmp8x3ozxb5_test.go:53: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__6 (0.00s)\n        tmp8x3ozxb5_test.go:53: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.008s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, value := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            if key != key.ToLower() {\n                return false\n            }\n        } else if key[0] >= 'a' && key[0] <= 'z' {\n            if key != key.ToUpper() {\n                return false\n            }\n        } else {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpwxyuo99e_test.go:25:26: key.ToLower undefined (type string has no field or method ToLower)\n/tmp/tmpwxyuo99e_test.go:29:26: key.ToUpper undefined (type string has no field or method ToUpper)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    if len(dict) == 0 {\n        return false\n    }\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmp7o3vn_po_test.go:53: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmp7o3vn_po_test.go:53: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    if len(dict) == 0 {\n        return false\n    }\n    for key, value := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n        if key[0] >= 'a' && key[0] <= 'z' {\n            return true\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0aw03hch_test.go:26:14: value declared but not used\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    if len(dict) == 0 {\n        return false\n    }\n    for k, v := range dict {\n        if k[0] >= 'A' && k[0] <= 'Z' {\n            return false\n        }\n        if k[0] >= 'a' && k[0] <= 'z' {\n            return true\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0oqrkbcn_test.go:26:12: v declared but not used\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__6 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, value := range dict {\n        if key == \"\" {\n            return false\n        }\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            if key != key.ToLower() {\n                return false\n            }\n        } else if key[0] >= 'a' && key[0] <= 'z' {\n            if key != key.ToUpper() {\n                return false\n            }\n        } else {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpg92ylt2y_test.go:28:26: key.ToLower undefined (type string has no field or method ToLower)\n/tmp/tmpg92ylt2y_test.go:32:26: key.ToUpper undefined (type string has no field or method ToUpper)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__6 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    if len(dict) == 0 {\n        return false\n    }\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmp7o3vn_po_test.go:53: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmp7o3vn_po_test.go:53: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    if len(dict) == 0 {\n        return false\n    }\n    for key, value := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n        if key[0] >= 'a' && key[0] <= 'z' {\n            continue\n        }\n        return false\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5mwdpykr_test.go:26:14: value declared but not used\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    if len(dict) == 0 {\n        return false\n    }\n    for key, value := range dict {\n        if key == \"\" {\n            return false\n        }\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            if key != key.ToLower() {\n                return false\n            }\n        } else if key[0] >= 'a' && key[0] <= 'z' {\n            if key != key.ToUpper() {\n                return false\n            }\n        } else {\n            return false\n        }\n        if value == \"\" {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp1z4fwuy5_test.go:31:26: key.ToLower undefined (type string has no field or method ToLower)\n/tmp/tmp1z4fwuy5_test.go:35:26: key.ToUpper undefined (type string has no field or method ToUpper)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, value := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            if key != key.ToLower() {\n                return false\n            }\n        } else if key[0] >= 'a' && key[0] <= 'z' {\n            if key != key.ToUpper() {\n                return false\n            }\n        } else {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpwxyuo99e_test.go:25:26: key.ToLower undefined (type string has no field or method ToLower)\n/tmp/tmpwxyuo99e_test.go:29:26: key.ToUpper undefined (type string has no field or method ToUpper)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__6 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, value := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n        if key[0] >= 'a' && key[0] <= 'z' {\n            continue\n        }\n        return false\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpimfl2oyz_test.go:23:14: value declared but not used\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__6 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    if len(dict) == 0 {\n        return false\n    }\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n        if key[0] >= 'a' && key[0] <= 'z' {\n            return true\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__1 (0.00s)\n        tmpwmuh3t9s_test.go:56: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmpwmuh3t9s_test.go:56: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmpwmuh3t9s_test.go:56: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        } else if key[0] >= 'a' && key[0] <= 'z' {\n            continue\n        } else {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmphf4hmykm_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__6 (0.00s)\n        tmphf4hmykm_test.go:54: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    if len(dict) == 0 {\n        return false\n    }\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmp7o3vn_po_test.go:53: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmp7o3vn_po_test.go:53: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__6 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    if len(dict) == 0 {\n        return false\n    }\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmp7o3vn_po_test.go:53: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmp7o3vn_po_test.go:53: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__6 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    if len(dict) == 0 {\n        return false\n    }\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmp7o3vn_po_test.go:53: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmp7o3vn_po_test.go:53: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    if len(dict) == 0 {\n        return false\n    }\n    for k, v := range dict {\n        if k[0] >= 'A' && k[0] <= 'Z' {\n            return false\n        }\n        if k[0] >= 'a' && k[0] <= 'z' {\n            continue\n        }\n        if v[0] >= 'A' && v[0] <= 'Z' {\n            return false\n        }\n        if v[0] >= 'a' && v[0] <= 'z' {\n            continue\n        }\n        return false\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmp8yhfyj70_test.go:63: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmp8yhfyj70_test.go:63: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, value := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n        if key[0] >= 'a' && key[0] <= 'z' {\n            continue\n        }\n        return false\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpimfl2oyz_test.go:23:14: value declared but not used\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__6 (0.00s)\n        tmpckb2g4yo_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string) bool {\n    for key, value := range dict {\n        if key == \"\" {\n            return false\n        }\n        if key[0] >= 'A' && key[0] <= 'Z' {\n            if key != key.ToLower() {\n                return false\n            }\n        } else if key[0] >= 'a' && key[0] <= 'z' {\n            if key != key.ToUpper() {\n                return false\n            }\n        } else {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpg92ylt2y_test.go:28:26: key.ToLower undefined (type string has no field or method ToLower)\n/tmp/tmpg92ylt2y_test.go:32:26: key.ToUpper undefined (type string has no field or method ToUpper)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    }
  ]
}